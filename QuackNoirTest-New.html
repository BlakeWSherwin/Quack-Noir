<!DOCTYPE html>
<!-- Write-access verification marker (safe to remove). Timestamp: 2025-10-02T12:34Z (write access re-confirmed) -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Urban Roguelike</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            font-family: 'Courier New', monospace;
            color: white;
            display: flex;
            gap: 20px;
            min-height: 100vh;
        }
    /* Prestart state: fully hide game section so nothing shows under title even if overlay changes */
    body.prestart #gameSection { display: none !important; }
    body.prestart #resetProgressBtn { display: none !important; }
    body.title-active #resetProgressBtn { display: none !important; }
            body.title-active #resetProgressBtn { display: none !important; }
        /* Landscape enforcement helper: in narrow portrait we will overlay a rotate message */
        @media (orientation: portrait) and (max-width: 899px) {
            body.enforce-landscape #gameSection { filter: blur(3px) brightness(0.3); pointer-events: none; }
        }
        #orientationOverlay {
            position: fixed; left:0; top:0; width:100%; height:100%;
            background: rgba(0,0,0,0.92); display:none; z-index:30000;
            align-items:center; justify-content:center; flex-direction:column;
            font-family:'Courier New', monospace; text-align:center; padding:30px; box-sizing:border-box;
        }
        #orientationOverlay h1 { font-size: 26px; margin:0 0 14px; color:#00ff88; }
        #orientationOverlay p { font-size:14px; color:#ccc; line-height:1.5; max-width:480px; }
        #gameSection {
            flex-shrink: 0;
            position: relative;
        }
        #statsSection {
            width: 280px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            height: fit-content;
            backdrop-filter: blur(10px);
        }
        .ability-item {
            font-size: 10px;
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
        }
        .permanent {
            color: #ffd700 !important;
            background: rgba(255,215,0,0.2) !important;
            border: 1px solid #ffd700;
        }
        .controls {
            margin-top: 10px;
            color: #aaa;
            font-size: 11px;
            line-height: 1.4;
        }
        .tooltip {
            position: absolute;
            left: 50%;
            bottom: 18px;
            transform: translateX(-50%);
            background: rgba(60,60,60,0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            border: 2px solid #666;
            font-size: 14px;
            text-align: center;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .tooltip.show {
            opacity: 1;
        }
        .tooltip .ability-name {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .tooltip .ability-desc {
            color: #ccc;
        }
        #pauseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        #pauseMenu {
            background: rgba(20,20,20,0.95);
            border: 3px solid #666;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
        }
        .ability-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }
        .ability-card {
            background: rgba(40,40,40,0.8);
            border: 2px solid #555;
            border-radius: 6px;
            padding: 12px;
            text-align: left;
        }
        .ability-card.tier1 { border-color: #888; }
        .ability-card.tier2 { border-color: #4488ff; }
        .ability-card.tier3 { border-color: #ff44ff; }
        .ability-card.permanent { 
            border-color: #ffd700; 
            background: rgba(255,215,0,0.1);
        }
        .ability-card-name {
            font-weight: bold;
            margin-bottom: 6px;
        }
        .ability-card.tier1 .ability-card-name { color: #ffffff; }
        .ability-card.tier2 .ability-card-name { color: #4488ff; }
        .ability-card.tier3 .ability-card-name { color: #ff44ff; }
        .ability-card.permanent .ability-card-name { color: #ffd700; }
        .ability-card-desc {
            color: #ccc;
            font-size: 12px;
        }
        .minimap {
            width: 100px;
            height: 75px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            border-radius: 4px;
            margin-top: 15px;
            position: relative;
        }
        /* Stats panel rows */
        .stat-row { display:flex; justify-content:space-between; align-items:center; margin:6px 0 4px; padding:2px 0 4px; border-bottom:1px solid #333; }
        .stat-label { color:#ccc; font-size:11px; letter-spacing:0.5px; }
        .stat-value { color:#00ff88; font-weight:bold; font-size:12px; text-shadow:0 0 4px #004422; }
        #abilities > div:first-child { font-weight:bold; margin-bottom:4px; color:#ffdd55; text-shadow:0 0 6px #664400; }
        #abilities { font-family:'Courier New', monospace; }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00aa66);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        html, body { margin:0; padding:0; overflow-y:hidden; }
        /* Tighten spacing under minimap/sound buttons */
        #gameSection { margin-bottom:0; }
        /* Reduce top margin on minimap to reclaim vertical space */
        .minimap { margin-top: 4px; }
    </style>
</head>
<body>
    <div id="launchCurtain"></div>
                        <div id="gameSection" style="display: flex; flex-direction: row; align-items: flex-start; gap: 0; margin:0; padding:0;">
                            <div style="display: flex; flex-direction: column; align-items: flex-start;">
                                <div id="gameContainer" style="position: relative;">
                                    <canvas id="gameCanvas" width="640" height="480"></canvas>
                                    <div id="abilityTooltip" class="tooltip">
                                        <div id="tooltipName" class="ability-name"></div>
                                        <div id="tooltipDesc" class="ability-desc"></div>
                                    </div>
                                </div>
                                <div style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 8px;">
                                    <div id="ui" style="background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; min-width: 180px;">
                                        <div>Health: <span id="health"></span> / <span id="maxHealth"></span></div>
                                        <div>District: <span id="dungeon"></span> | Street: <span id="room"></span></div>
                                        <div>Score: <span id="score"></span></div>
                                        <div class="progress-bar"><div id="healthBar" class="progress-fill" style="width:100%"></div></div>
                                        <div id="chestLegend" style="margin-top:8px;font-size:11px;color:#ffdd55;letter-spacing:0.5px;">Chests: <span id="statChests" style="color:#ffd700"></span></div>
                                    </div>
                                </div>
                            </div>
                                                    <div style="display: flex; flex-direction: row; align-items: flex-start; margin-left: 0; width: 220px; justify-content: flex-start;">
                                                        <div id="abilities" style="width: 210px;">
                                                            <div>Stats:</div>
                                                            <div class="stat-row"><span class="stat-label">Damage</span><span id="statDamage" class="stat-value"></span></div>
                                                            <div class="stat-row"><span class="stat-label">Projectiles</span><span id="statProjectiles" class="stat-value"></span></div>
                                                            <div class="stat-row"><span class="stat-label">Attack Speed</span><span id="statAttackSpeed" class="stat-value"></span></div>
                                                            <div class="stat-row"><span class="stat-label">Pierce</span><span id="statPierce" class="stat-value"></span></div>
                                                            <div class="stat-row"><span class="stat-label">Crit</span><span id="statCrit" class="stat-value"></span></div>
                                                            <div class="stat-row"><span class="stat-label">Block</span><span id="statBlock" class="stat-value"></span></div>
                                                            <div class="stat-row"><span class="stat-label">Kills</span><span id="statKills" class="stat-value"></span></div>
                                                            <div class="stat-row"><span class="stat-label">Rooms</span><span id="statRooms" class="stat-value"></span></div>
                                                        </div>
                            </div>
                        </div>
                        <!-- Pause overlay with tabbed submenus -->
                        <div id="pauseOverlay" style="display:none;">
                            <div id="pauseMenu">
                                <h2 style="margin-top:0;color:#00ff88;">Paused</h2>
                                <div style="display:flex; gap:12px; margin-bottom:14px;">
                                    <button id="tabAbilities" data-tab="abilities" style="flex:1;padding:8px 10px;background:#111;border:2px solid #00ff88;color:#00ff88;border-radius:6px;cursor:pointer;font-family:'Courier New', monospace;">Abilities</button>
                                    <button id="tabOptions" data-tab="options" style="flex:1;padding:8px 10px;background:#111;border:2px solid #444;color:#aaa;border-radius:6px;cursor:pointer;font-family:'Courier New', monospace;">Options</button>
                                </div>
                                <div id="pauseTabContent" style="width:100%; min-height:260px;">
                                    <div id="pauseAbilities" class="ability-grid" style="text-align:left; width:100%;"></div>
                                    <div id="pauseOptions" style="display:none; text-align:left; width:100%;">
                                        <div style="display:flex; flex-direction:column; gap:10px;">
                                            <button id="optToggleSfx" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle SFX</button>
                                            <button id="optToggleMusic" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle Music</button>
                                            <button id="optToggleCosmetic" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle Cosmetic FX</button>
                                            <button id="optResetProgress" style="padding:8px 12px;background:#330000;border:2px solid #aa4444;color:#ff8080;font-family:'Courier New', monospace;cursor:pointer;">Reset Progress</button>
                                        </div>
                                    </div>
                                </div>
                                <div style="margin-top:14px;color:#ccc;font-size:12px;">Press P to resume</div>
                            </div>
                        </div>
        <!-- ...existing HTML for game UI, canvas, etc... -->
        <script>
        // Ensure canvas visible early.
        document.addEventListener('DOMContentLoaded', ()=> {
            const cv = document.getElementById('gameCanvas');
            if (cv) { cv.style.display='block'; cv.style.visibility='visible'; }
        });
    let canvas, ctx;
    const TILE_SIZE = 20;
    const ROOM_WIDTH = 32;
    const ROOM_HEIGHT = 24;
        
    const game = {
            player: {
                x: 320, y: 240, health: 100, maxHealth: 100,
                abilities: [], permanentAbilities: [],
                // Initial facing is down; align lastDirection so first shot matches sprite
                facing: 'down',
                lastDirection: { x: 0, y: 1 },
                invulnerable: false, invulnTime: 0,
                speed: 2.5
            },
            dungeon: 1, room: 1, score: 0,
            enemies: [], chests: [], projectiles: [], walls: [], particles: [],
            duckFlocks: [], // active duck swoop entities (Duck Dynasty)
            // Active reality-distortion fields (used by Reality Break)
            activeRealityFields: [],
            keys: {}, lastAttack: 0, roomCleared: false,
            shotCounter: 0, totalKills: 0, roomsCleared: 0, chestsOpened: 0,
            screenShake: 0, screenShakeIntensity: 0, paused: false,
            sfxEnabled: true,
            musicEnabled: true,
            disableCosmeticParticles: false, // user-configurable performance toggle
            _roomSpawnedEnemies: 0,
            _restartGraceFrames: 0,
            nextDuckFlockFrame: 0 // scheduling for Duck Dynasty flocks
        };
    // Expose globally so external debug or delayed handlers can access before start
    window.game = game;

    // Unified guarded start to prevent double init / double RAF loops.
    game._started = false;
    game._loopStarted = false;
    function safeStartGame(source='manual') {
        if (game._started) return; // already started
        game._started = true;
        document.body.classList.remove('title-active');
        // Defensive: remove title overlay if still present (e.g., alternate start trigger)
        const to = document.getElementById('titleOverlay');
        if (to && to.parentElement) try { to.parentElement.removeChild(to); } catch(e) {}
        if (typeof init === 'function') init();
        // Attempt music start (safe if already playing)
        ensureBackgroundMusic();
        // Title overlay removal (if still present)
        const existingTitle = document.getElementById('titleOverlay');
        if (existingTitle) existingTitle.parentElement.removeChild(existingTitle);
        console.info('[Game Start] source=' + source);
    }
    // Removed auto-start watchdog so title screen persists until fire (space) pressed.

// Load stored audio prefs immediately so title screen & auto-start reflect choices
loadAudioPreferences();

// --- Permanent Ability System ---
function loadPermanentAbilities() {
    const saved = localStorage.getItem('permanentAbilities');
    if (saved) {
        try {
            const arr = JSON.parse(saved);
            if (Array.isArray(arr)) {
                game.player.permanentAbilities = arr;
            }
        } catch (e) {}
    }
}

function grantPermanentAbilities() {
    if (game.player.permanentAbilities && Array.isArray(game.player.permanentAbilities)) {
        game.player.permanentAbilities.forEach(ability => {
            if (!game.player.abilities.includes(ability)) {
                game.player.abilities.push(ability);
            }
        });
    }
}

// ===== Audio Preference Persistence =====
function loadAudioPreferences() {
    try {
        const sfx = localStorage.getItem('pref_sfx');
        const music = localStorage.getItem('pref_music');
        const cosmeticOff = localStorage.getItem('pref_disable_cosmetic');
        if (sfx !== null) game.sfxEnabled = sfx === '1';
        if (music !== null) game.musicEnabled = music === '1';
        if (cosmeticOff !== null) game.disableCosmeticParticles = cosmeticOff === '1';
    } catch(e) {}
}
function saveAudioPreferences() {
    try {
        localStorage.setItem('pref_sfx', game.sfxEnabled ? '1' : '0');
        localStorage.setItem('pref_music', game.musicEnabled ? '1' : '0');
        localStorage.setItem('pref_disable_cosmetic', game.disableCosmeticParticles ? '1' : '0');
    } catch(e) {}
    applyMusicPreference(false);
}

// Idempotent background music starter
function ensureBackgroundMusic() {
    if (!game.musicEnabled) return; // respect preference
    try {
        if (!game.bgMusic) {
            const m = new Audio('assets/audio/QuackshotChronicles.mp3');
            m.loop = true; m.volume = 0.55; game.bgMusic = m;
        }
        if (game.bgMusic.paused) {
            game.bgMusic.play().catch(()=>{});
        }
    } catch(e) {}
}

function toggleCosmeticParticles() {
    game.disableCosmeticParticles = !game.disableCosmeticParticles;
    saveAudioPreferences();
    updateAudioButtons();
}

// ================= Simplified Title Screen =================
function showTitleScreen() {
    if (document.getElementById('titleOverlay') || game._started) return;
    document.body.classList.add('title-active');
    const overlay = document.createElement('div');
    overlay.id = 'titleOverlay';
    Object.assign(overlay.style, {
        position:'fixed', inset:'0', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center',
        background:'radial-gradient(circle at center,#111 0%,#000 70%)', zIndex:9999, gap:'32px',
        fontFamily:'Courier New,monospace', transition:'opacity 380ms ease', opacity:'1'
    });
    overlay.innerHTML = `
        <img id="titleLogo" src="assets/title.png" alt="Quack Noir" style="width:clamp(300px,60vw,780px);max-height:70vh;object-fit:contain;image-rendering:pixelated;filter:drop-shadow(0 0 12px #400060);" />
        <div id="pressStartPrompt" style="color:#bbb;font-size:22px;letter-spacing:2px;animation:pulsePrompt 2.8s ease-in-out infinite;">PRESS SPACE / CLICK TO START</div>
        <div style="position:absolute;bottom:12px;right:16px;font-size:11px;color:#444;">Build: Simplified Title v4</div>`;
    if (!document.getElementById('pulsePromptStyle')) {
        const st = document.createElement('style'); st.id='pulsePromptStyle';
        st.textContent='@keyframes pulsePrompt{0%{opacity:.35}50%{opacity:1}100%{opacity:.35}}';
        document.head.appendChild(st);
    }
    document.body.appendChild(overlay);
    // Try autoplay (may be blocked; we'll retry on input)
    ensureBackgroundMusic();
    let started = false;
    function begin(source){
        if (started) return; started = true;
        overlay.style.opacity='0';
        // Kick music again explicitly on gesture for browsers that require it
        ensureBackgroundMusic();
        setTimeout(()=> safeStartGame(source), 360);
    }
    function keyHandler(ev){
        if (ev.code==='Space') { ev.preventDefault(); cleanup(); begin('title-space'); }
    }
    function clickHandler(){ cleanup(); begin('title-click'); }
    function cleanup(){
        window.removeEventListener('keydown', keyHandler);
        overlay.removeEventListener('click', clickHandler);
        overlay.removeEventListener('touchstart', clickHandler);
    }
    window.addEventListener('keydown', keyHandler);
    overlay.addEventListener('click', clickHandler, { passive:true });
    overlay.addEventListener('touchstart', clickHandler, { passive:true });
}
window.addEventListener('load', showTitleScreen);

// ================= Touch Controls (Adaptive) =================
// Provide an on-screen joystick + fire button if the user is on a touch-capable device
// and no keyboard / mouse input has been detected yet. Hides automatically on first
// hardware keyboard/mouse interaction to avoid clutter for desktop users.
(() => {
    game._hardwareInputDetected = false;
    game._touchControlsInitialized = false;
    game._touchFireInterval = null; // legacy (no longer used)
    // Removed game.touchFireActive flag; touch fire now directly toggles the spacebar key state for unified cooldown logic.
    const hwHandler = () => {
        game._hardwareInputDetected = true;
        // If touch controls are visible, hide them (user clearly has hardware input)
        const tc = document.getElementById('touchControlsContainer');
        if (tc) tc.style.display = 'none';
        window.removeEventListener('keydown', hwHandler, { passive: true });
    };
    // Only key presses count as hardware (keyboard) input now; mouse movement/clicks no longer disable touch controls.
    // This prevents normal screen taps (which some engines surface as synthetic mouse events) from hiding the overlay.
    window.addEventListener('keydown', hwHandler, { passive: true });

    function shouldUseTouchControls() {
        const touchCapable = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
        return touchCapable && !game._hardwareInputDetected;
    }

    // Removed ensureTouchFireLoop & per-frame touchFireActive polling; we now just set game.keys[' '] on press/release.

    function setDirectionalKeys(dx, dy) {
        // Reset movement keys
        const k = game.keys;
        k['w'] = k['a'] = k['s'] = k['d'] = false;
        if (Math.abs(dy) > 0.25) { if (dy < 0) k['w'] = true; else k['s'] = true; }
        if (Math.abs(dx) > 0.25) { if (dx < 0) k['a'] = true; else k['d'] = true; }
    }

    function initTouchControls() {
        if (game._touchControlsInitialized) return;
        game._touchControlsInitialized = true;
        const container = document.createElement('div');
        container.id = 'touchControlsContainer';
        container.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:12000;';

        // Joystick base
        const joyBase = document.createElement('div');
        joyBase.id = 'touchJoyBase';
        joyBase.style.cssText = 'position:absolute;left:24px;bottom:24px;width:110px;height:110px;border:2px solid #444;background:rgba(0,0,0,0.35);border-radius:50%;pointer-events:auto;touch-action:none;';
        const joyStick = document.createElement('div');
        joyStick.id = 'touchJoyStick';
        joyStick.style.cssText = 'position:absolute;left:50%;top:50%;width:48px;height:48px;transform:translate(-50%,-50%);background:rgba(0,255,136,0.55);border:2px solid #0f8;border-radius:50%;box-shadow:0 0 6px #0f8;';
        joyBase.appendChild(joyStick);

        // Fire button
        const fireBtn = document.createElement('div');
        fireBtn.id = 'touchFireBtn';
        fireBtn.textContent = 'FIRE';
        fireBtn.style.cssText = 'position:absolute;right:34px;bottom:40px;width:100px;height:100px;border:2px solid #aa2222;border-radius:50%;background:rgba(255,40,40,0.4);display:flex;align-items:center;justify-content:center;font:700 16px Courier New,monospace;color:#fff;box-shadow:0 0 8px #f33;pointer-events:auto;touch-action:none;user-select:none;';

        container.appendChild(joyBase);
        container.appendChild(fireBtn);
        document.body.appendChild(container);

        let activeJoyId = null;
        let joyCenter = { x: 0, y: 0 };

        function handleJoyStart(e) {
            const touch = (e.changedTouches ? e.changedTouches[0] : e);
            activeJoyId = touch.identifier !== undefined ? touch.identifier : 'mouse';
            const rect = joyBase.getBoundingClientRect();
            joyCenter.x = rect.left + rect.width/2;
            joyCenter.y = rect.top + rect.height/2;
            updateJoy(touch);
            e.preventDefault();
        }
        function updateJoy(touch) {
            const dx = touch.clientX - joyCenter.x;
            const dy = touch.clientY - joyCenter.y;
            const maxR = 44; // radius limit for stick movement
            let dist = Math.sqrt(dx*dx + dy*dy);
            let nx = 0, ny = 0;
            if (dist > 0) {
                nx = dx / dist; ny = dy / dist;
                if (dist > maxR) dist = maxR;
            }
            joyStick.style.left = (50 + (dist * nx) / maxR * 50) + '%';
            joyStick.style.top  = (50 + (dist * ny) / maxR * 50) + '%';
            setDirectionalKeys(nx, ny);
        }
        function handleJoyMove(e) {
            if (activeJoyId === null) return;
            const touches = e.changedTouches ? Array.from(e.changedTouches) : [e];
            for (const t of touches) {
                const id = t.identifier !== undefined ? t.identifier : 'mouse';
                if (id === activeJoyId) { updateJoy(t); break; }
            }
            e.preventDefault();
        }
        function handleJoyEnd(e) {
            const touches = e.changedTouches ? Array.from(e.changedTouches) : [e];
            for (const t of touches) {
                const id = t.identifier !== undefined ? t.identifier : 'mouse';
                if (id === activeJoyId) {
                    activeJoyId = null;
                    joyStick.style.left = '50%';
                    joyStick.style.top = '50%';
                    setDirectionalKeys(0,0);
                    break;
                }
            }
        }

        // Attach joystick listeners
        joyBase.addEventListener('touchstart', handleJoyStart, { passive: false });
        joyBase.addEventListener('touchmove', handleJoyMove, { passive: false });
        joyBase.addEventListener('touchend', handleJoyEnd, { passive: false });
        joyBase.addEventListener('touchcancel', handleJoyEnd, { passive: false });
        // (Optional mouse support for debugging on desktop)
        joyBase.addEventListener('mousedown', handleJoyStart);
        window.addEventListener('mousemove', handleJoyMove);
        window.addEventListener('mouseup', handleJoyEnd);

    function fireStart(e) { game.keys[' '] = true; e.preventDefault(); }
    function fireEnd(e) { game.keys[' '] = false; e.preventDefault(); }
        fireBtn.addEventListener('touchstart', fireStart, { passive: false });
        fireBtn.addEventListener('touchend', fireEnd, { passive: false });
        fireBtn.addEventListener('touchcancel', fireEnd, { passive: false });
        fireBtn.addEventListener('mousedown', fireStart);
        window.addEventListener('mouseup', fireEnd);
    }

    // Defer initialization slightly so hardware inputs can register first.
    document.addEventListener('DOMContentLoaded', () => {
           const cv = document.getElementById('gameCanvas');
           if (cv) { cv.style.display='block'; cv.style.visibility='visible'; }
    });

    // Public hook if we ever need to re-evaluate after a reset
    window.__maybeInitTouch = () => { if (shouldUseTouchControls()) initTouchControls(); };
})();
// =============================================================

// Apply current preference to an existing or newly created bgMusic element without flipping state
function applyMusicPreference(autoPlayIfEnabled=true) {
    if (!game.bgMusic) return;
    game.bgMusic.muted = !game.musicEnabled;
    if (game.musicEnabled && autoPlayIfEnabled) {
        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
    } else if (!game.musicEnabled) {
        try { game.bgMusic.pause(); } catch(e) {}
    }
}

function showAbilityChoiceUI(options) {
    const overlay = document.createElement('div');
    overlay.id = 'abilityChoiceOverlay';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center;
        z-index: 1001; font-family: 'Courier New', monospace;
    `;

    const container = document.createElement('div');
    container.style.cssText = `
        display: flex; gap: 20px; background: #222; padding: 20px; border-radius: 10px;
        border: 2px solid #666;
    `;

    const tierStyles = {
        1: { border:'#5aa84d', glow:'#5aa84d88', bg:'#0d2a0d', label:'Tier I' },
        2: { border:'#3d7dd9', glow:'#3d7dd988', bg:'#0a1d33', label:'Tier II' },
        3: { border:'#c68b1a', glow:'#c68b1acc', bg:'#2a1d05', label:'Tier III' }
    };
    // Inject one-time keyframe styles if not present
    if (!document.getElementById('permAbilityFXStyles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'permAbilityFXStyles';
        styleEl.textContent = `@keyframes badgePop {0%{transform:scale(.4) translateY(-8px);opacity:0}60%{transform:scale(1.08) translateY(0);opacity:1}100%{transform:scale(1) translateY(0);opacity:1}}
        @keyframes flairFloat {0%{transform:translateY(0) scale(.6);opacity:0}20%{opacity:1}80%{opacity:1}100%{transform:translateY(-38px) scale(1.1);opacity:0}}
        .synergy-tip {position:absolute;left:50%;top:100%;transform:translate(-50%,12px);background:#111;padding:8px 10px;border:1px solid #555;border-radius:6px;color:#eee;font:11px/1.3 'Courier New',monospace;width:220px;pointer-events:none;opacity:0;transition:opacity .18s;z-index:40;box-shadow:0 0 6px #000}
        .ability-card.permanent:hover .synergy-tip {opacity:1}
        `;
        document.head.appendChild(styleEl);
    }
    // Simple synergy hint generator (lightweight heuristic)
    function buildSynergyHint(ab){
        const meta = ABILITIES[ab]; if(!meta||!meta.effect) return 'Passive enhancement.';
        const eff = meta.effect; const tips = [];
        if (eff.damageType) tips.push(`Combines with other ${eff.damageType} sources for amplified status.`);
        if (eff.projectileCount) tips.push('Stacks with multi-shot to flood patterns.');
        if (eff.spiralPattern || eff.sineWave || eff.wackyZigzag || eff.ekgWave) tips.push('Motion pattern contributes to resonance combos.');
        if (eff.explosive || eff.chainExplosion || eff.novaBlast) tips.push('Explosion effects can trigger combust synergies.');
        if (eff.dimensional) tips.push('Rifts manipulate and duplicate passing projectiles.');
        if (eff.timeWarp) tips.push('Time Warp can extend airborne telegraphs (meteors / bombs).');
        if (!tips.length) return 'General utility ability.';
        return tips.slice(0,3).join(' ');
    }
    const flairIntervals = [];
    options.forEach((ability, idx) => {
        const meta = ABILITIES[ability];
        const tier = meta && meta.tier || 1;
        const style = tierStyles[tier] || tierStyles[1];
        const card = document.createElement('div');
        card.className = 'ability-card permanent';
        card.style.cssText = `min-width:200px;max-width:240px;padding:14px 16px;background:${style.bg};`+
            `border:3px solid ${style.border};border-radius:10px;position:relative;`+
            `box-shadow:0 0 10px ${style.glow}, inset 0 0 8px #000;display:flex;flex-direction:column;gap:8px;`+
            `transition:transform .15s, box-shadow .2s;`;
        card.onmouseenter = ()=>{ card.style.transform='translateY(-4px)'; card.style.boxShadow=`0 0 16px ${style.glow}, 0 0 4px ${style.border}`; };
        card.onmouseleave = ()=>{ card.style.transform='none'; card.style.boxShadow=`0 0 10px ${style.glow}, inset 0 0 8px #000`; };

        const badge = document.createElement('div');
        badge.textContent = style.label;
        badge.style.cssText = `position:absolute;top:-12px;left:12px;padding:2px 8px;`+
            `background:${style.border};color:#fff;font:600 11px 'Courier New',monospace;`+
            `border-radius:4px;text-shadow:0 0 4px #000;letter-spacing:1px;`+
            `animation:badgePop .42s cubic-bezier(.25,1.4,.45,1) ${idx*0.08}s both;`;
        card.appendChild(badge);

        const nameDiv = document.createElement('div');
        nameDiv.className = 'ability-card-name';
        nameDiv.textContent = ability;
        nameDiv.style.cssText = 'font:700 18px Courier New,monospace;color:#fff;text-shadow:0 0 6px '+style.glow+';';
        const descDiv = document.createElement('div');
        descDiv.className = 'ability-card-desc';
        descDiv.textContent = meta ? meta.desc : '';
        descDiv.style.cssText = 'font:13px/1.3 Courier New,monospace;color:#ddd;min-height:48px;';

        card.appendChild(nameDiv);
        card.appendChild(descDiv);
        // Synergy tooltip
        const tip = document.createElement('div');
        tip.className = 'synergy-tip';
        tip.textContent = buildSynergyHint(ability);
        card.appendChild(tip);
        // Tier III flair particles (ambient floating sparks)
        if (tier === 3) {
            const flairLayer = document.createElement('div');
            flairLayer.style.cssText = 'position:absolute;inset:0;overflow:visible;pointer-events:none;';
            card.appendChild(flairLayer);
            const spawnFlair = () => {
                if (!document.body.contains(card)) return; // stop if overlay gone
                const f = document.createElement('div');
                const size = 4 + Math.random()*4;
                f.style.cssText = `position:absolute;bottom:4px;left:${6+Math.random()* (card.clientWidth-14)}px;`+
                    `width:${size}px;height:${size}px;border-radius:50%;background:radial-gradient(circle,#ffd37a,#c68b1a);`+
                    `opacity:0;animation:flairFloat ${2.6+Math.random()*1.4}s linear forwards;box-shadow:0 0 6px #c68b1a,0 0 2px #fff inset;`;
                flairLayer.appendChild(f);
                // Auto remove after animation
                setTimeout(()=>{ if(f.parentElement) f.parentElement.removeChild(f); }, 4000);
            };
            // Initial burst
            for (let i=0;i<3;i++) setTimeout(spawnFlair, i*160 + Math.random()*120);
            const intId = setInterval(spawnFlair, 650 + Math.random()*400);
            flairIntervals.push(intId);
        }
        card.style.cursor = 'pointer';
        card.onclick = () => {
            if (!game.player.permanentAbilities.includes(ability)) {
                game.player.permanentAbilities.push(ability);
                localStorage.setItem('permanentAbilities', JSON.stringify(game.player.permanentAbilities));
            }
            document.body.removeChild(overlay);
            // Clear intervals
            flairIntervals.forEach(id=>clearInterval(id));
            if (game && game._bigQuackDefeated) {
                if (!document.getElementById('postFinalPlayAgain')) {
                    const btn = document.createElement('button');
                    btn.id = 'postFinalPlayAgain';
                    btn.textContent = 'Play Again';
                    btn.style.cssText = 'position:fixed;bottom:40px;left:50%;transform:translateX(-50%);padding:12px 28px;font-size:18px;background:#222;color:#fff;border:2px solid #666;border-radius:6px;z-index:30010;cursor:pointer;';
                    btn.onclick = () => { btn.remove(); resetGame(); };
                    document.body.appendChild(btn);
                }
            }
        };
        container.appendChild(card);
    });

    overlay.appendChild(container);
    document.body.appendChild(overlay);
    // Ensure flair intervals are cleared if overlay removed externally
    const obs = new MutationObserver(()=>{ if(!document.body.contains(overlay)) { flairIntervals.forEach(id=>clearInterval(id)); obs.disconnect(); }});
    obs.observe(document.body,{childList:true});
}

function offerPermanentAbilityChoice() {
    if (!game || !game.player) return;
    let pool = game.player.abilities.filter(a => !game.player.permanentAbilities.includes(a));
    // If fewer than 3 unique non-permanent, fallback to include permanent ones (still avoid duplicates in display)
    if (pool.length < 3) {
        const extras = game.player.abilities.filter(a => !pool.includes(a));
        pool = pool.concat(extras);
    }
    // Still not enough? Show whatever exists (1–3). If none, show informational overlay.
    if (pool.length === 0) {
        console.info('[Permanent Ability Choice] No abilities available to offer.');
        const msg = document.createElement('div');
        msg.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:18px 26px;color:#fff;font:14px Courier New;border:2px solid #555;z-index:35000;';
        msg.textContent = 'No abilities to make permanent. Press Play Again to restart.';
        document.body.appendChild(msg);
        return;
    }
    const shuffled = [...pool].sort(() => Math.random() - 0.5);
    const options = shuffled.slice(0, Math.min(3, shuffled.length));
    console.info('[Permanent Ability Choice] Offering options:', options);
    showAbilityChoiceUI(options);
}

        const ABILITIES = {
            /*
             * Synergy Notes (pattern stacking system):
             *  - Projectile motion patterns (sineWave, wackyZigzag, ekgWave, spiralPattern, teleporting, orbital, growing, homing/weakHoming, bouncing/ricochet, omni/radial, crossPattern, boomerang) now coexist. (Split Shot removed)
             *  - updateProjectiles aggregates lateral deltas from sine + wacky + ekg instead of making them mutually exclusive.
             *  - Dampening rules: when multiple patterns active, each pattern's amplitude is slightly reduced to prevent runaway speed inflation.
             *  - Spiral still applies its own loop motion; if also sine/wacky/ekg, their offsets add on top.
             *  - Orbitals inherit pattern flags on spawn and animate with radial/tangential modulation.
             *  - Split projectiles propagate pattern flags so child fragments maintain complex motion.
             *  - Teleport Shot synergy: additional portal particle styles appear based on which pattern flags the projectile has (spiral / sine / wacky / ekg).
             *  - Speed capping & normalization keeps composite velocity within ~1.85x original forward speed.
             *  - Resonance Combos: 2+ core motion patterns (sine, wacky, ekg, spiral) grant escalating damage multiplier (8%/15%/22%) and at 3+ patterns periodic resonance pulses (AoE % base damage) emanate; all 4 patterns trigger occasional hypersurge speed burst.
             *  - Elemental Amplifiers: Fire+Wind (burn tick +15%, burn duration +40f), Ice+Lightning (12% shatter proc for bonus burst), Poison+Void (poison tick +25%, duration +90f), Fire+Poison (magma combustion: +10% burn tick, +12% poison tick), Ice+Wind (slow duration +60f).
             *  - Beam Pattern Blending: Laser/Particle beams inherit pattern flags for visual modulation (oscillation, jitter, spikes, mini-spiral); movement unaffected for fairness; particles tint by dominant pattern.
             *  - DOT Scaling: Elemental amplifiers modify per-tick burn/poison damage dynamically based on active ability sets.
             *  - Elemental Infusions: Temporary stacked overlays (up to 3 via Elemental Conduit) add bonus partial damage + status effects; strongest infusion selects primary damageType if projectile neutral; diminishing returns on multi stack.
             */
            // Shooting Abilities
            'Fire Shot': { desc: 'Fire damage + burning DoT', effect: { damageBonus: 8, damageType: 'fire' }, tier: 1 },
            'Ice Shot': { desc: 'Slows enemies by 60%', effect: { damageType: 'ice' }, tier: 1 },
            'Lightning Shot': { desc: 'Chains to 3 enemies', effect: { damageType: 'lightning' }, tier: 1 },
            'Poison Shot': { desc: 'Poison damage over time', effect: { damageType: 'poison' }, tier: 1 },
            'Explosive Shot': { desc: 'Explodes dealing area damage', effect: { explosive: true }, tier: 2 },
            'Double Shot': { desc: 'Fire 2 projectiles', effect: { projectileCount: 2 }, tier: 1 },
            'Triple Shot': { desc: 'Fire 3 projectiles', effect: { projectileCount: 3 }, tier: 2 },
            'Quad Shot': { desc: 'Fire 4 projectiles', effect: { projectileCount: 4 }, tier: 2 }, // Rebalanced: was tier 3
            'Machine Gun': { desc: 'Fire rate +100%', effect: { attackSpeedMultiplier: 2.0 }, tier: 2 },
            'Laser Cannon': { desc: 'Fire rate +200%', effect: { attackSpeedMultiplier: 3.0 }, tier: 2 }, // Rebalanced: was tier 3
            'Pierce Shot': { desc: 'Pierce through 3 enemies', effect: { piercing: true, pierceCount: 3 }, tier: 2 },
            'Multi-Pierce': { desc: 'Pierce unlimited enemies', effect: { piercing: true, pierceCount: 999 }, tier: 3 },
            'Homing Shot': { desc: 'Auto-target nearest enemy', effect: { homing: true }, tier: 1 }, // Rebalanced: was tier 2
            'Bouncing Shot': { desc: 'Bounce off walls 3 times', effect: { bouncing: true }, tier: 1 }, // Rebalanced: was tier 2
            'Growing Shot': { desc: 'Size increases over time', effect: { growing: true }, tier: 1 },
            'Shotgun Blast': { desc: '5 wide spread shots', effect: { shotgunBlast: true }, tier: 2 },
            'Sniper Shot': { desc: '3x larger, faster shots', effect: { projectileSize: 3, projectileSpeed: 2 }, tier: 2 },
            // Advanced Projectile Abilities
            'Plasma Cannon': { desc: 'Super heated plasma bolts', effect: { damageBonus: 15, damageType: 'plasma' }, tier: 2 },
            'Acid Shot': { desc: 'Melts through armor', effect: { damageType: 'acid', armorPiercing: true }, tier: 2 },
            'Shadow Bolt': { desc: 'Dark energy projectiles that deal bonus shadow damage and slightly ignore ambient light—pairs well with armor shredding and void/poison synergies', effect: { damageBonus: 12, damageType: 'shadow' }, tier: 2 },
            'Solar Flare': { desc: 'Blinding solar energy', effect: { damageType: 'solar', blinds: true }, tier: 2 },
            'Frost Shard': { desc: 'Freezing ice projectiles', effect: { damageType: 'frost', freezes: true }, tier: 2 },
            'Wind Blade': { desc: 'Razor sharp air currents — massively pushes enemies back', effect: { damageBonus: 10, damageType: 'wind', knockback: true, knockbackDistance: 120 }, tier: 1 }, // Added strong knockback
            // Newly re-added base Earth element so Earth combos (e.g., Magma) have a source ability when combo card not yet offered.
            'Earth Spike': { desc: 'Stone spikes with impact shock (minor stun & knockback)', effect: { damageType: 'earth', knockback: true, knockbackDistance: 48 }, tier: 1 },
            'Void Shot': { desc: 'Reality-tearing projectiles', effect: { damageBonus: 25, damageType: 'void' }, tier: 3 },
            'Crystal Shot': { desc: 'Prismatic energy bolts', effect: { damageBonus: 18, damageType: 'crystal' }, tier: 2 },
            // Multi-Shot Abilities
            'Penta Shot': { desc: 'Fire 5 projectiles', effect: { projectileCount: 5 }, tier: 2 }, // Rebalanced: was tier 3
            'Hexa Shot': { desc: 'Fire 6 projectiles', effect: { projectileCount: 6 }, tier: 3 },
            'Octa Shot': { desc: 'Fire 8 projectiles', effect: { projectileCount: 8 }, tier: 3 },
            'Deca Shot': { desc: 'Fire 10 projectiles', effect: { projectileCount: 10 }, tier: 3 },
            'Storm Barrage': { desc: 'Fire 15 random projectiles', effect: { projectileCount: 15, randomSpread: true }, tier: 3 },
            'Bullet Hell': { desc: 'Fire 20 chaotic shots', effect: { projectileCount: 20, randomSpread: true }, tier: 3 },
            'Omni Shot': { desc: 'Fire in all 8 directions', effect: { omniDirectional: true }, tier: 3 },
            'Radial Burst': { desc: 'Fire 16 shots in circle', effect: { radialBurst: true }, tier: 3 },
            'Spiral Shot': { desc: 'Spinning projectile pattern — shots curve in local swirling loops for a tight spiral motion', effect: { spiralPattern: true }, tier: 2 },
            'Uzumaki': { desc: 'Expanding outward swirl — shots emit in a continuously rotating spiral stream from you (global spiral path)', effect: { uzumaki: true }, tier: 2 },
            'Sine Wave': { desc: 'Shots follow a sine wave pattern', effect: { sineWave: true }, tier: 2 },
            'Wacky Shot': { desc: 'Bullets zigzag unpredictably with rapid direction changes', effect: { wackyZigzag: true }, tier: 2 },
            'EKG': { desc: 'Shots follow an erratic cardiogram spike pattern (flatline pulses then sharp vertical spikes)', effect: { ekgWave: true }, tier: 2 },
            'Cross Shot': { desc: 'Fire in + pattern', effect: { crossPattern: true }, tier: 2 },
            // Rate of Fire Abilities
            'Rapid Fire': { desc: 'Fire rate +50%', effect: { attackSpeedMultiplier: 1.5 }, tier: 1 },
            'Burst Fire': { desc: 'Fire rate +75%', effect: { attackSpeedMultiplier: 1.75 }, tier: 2 },
            'Auto Cannon': { desc: 'Fire rate +150%', effect: { attackSpeedMultiplier: 2.5 }, tier: 2 },
            'Gatling Gun': { desc: 'Fire rate +250%', effect: { attackSpeedMultiplier: 3.5 }, tier: 3 },
            'Chain Gun': { desc: 'Fire rate +300%', effect: { attackSpeedMultiplier: 4.0 }, tier: 3 },
            'Minigun': { desc: 'Fire rate +400%', effect: { attackSpeedMultiplier: 5.0 }, tier: 3 },
            'Vulcan Cannon': { desc: 'Fire rate +500%', effect: { attackSpeedMultiplier: 6.0 }, tier: 3 },
            // Damage Boost Abilities
            'Power Shot': { desc: 'Damage +10', effect: { damageBonus: 10 }, tier: 1 },
            'Heavy Shot': { desc: 'Damage +15', effect: { damageBonus: 15 }, tier: 1 },
            'Mega Damage': { desc: 'Damage +20', effect: { damageBonus: 20 }, tier: 2 },
            'Ultra Damage': { desc: 'Damage +40', effect: { damageBonus: 40 }, tier: 2 }, // Rebalanced: was tier 3
            'Supreme Damage': { desc: 'Damage +60', effect: { damageBonus: 60 }, tier: 3 },
            'Divine Power': { desc: 'Damage +80', effect: { damageBonus: 80 }, tier: 3 },
            'Apocalypse': { desc: 'Damage +100', effect: { damageBonus: 100 }, tier: 3 },
            // Projectile Behavior Abilities
            'Seeking Shot': { desc: 'Weak homing behavior', effect: { weakHoming: true }, tier: 1 },
            'Smart Bomb': { desc: 'Explodes near enemies', effect: { smartExplosive: true }, tier: 2 },
            'Ricochet': { desc: 'Bounce between enemies', effect: { ricochet: true }, tier: 2 },
            'Boomerang': { desc: 'Returns to player', effect: { boomerang: true }, tier: 1 }, // Rebalanced: was tier 2
            'Orbital': { desc: 'Orbits around player', effect: { orbital: true }, tier: 2 },
            'Drill Shot': { desc: 'Spins while moving', effect: { drilling: true }, tier: 1 }, // Rebalanced: was tier 2
            'Phasing Shot': { desc: 'Passes through walls', effect: { phasing: true }, tier: 2 },
            'Teleport Shot': { desc: 'Each fired projectile instantly teleports to a random nearby location around you (within ~140px) before flying forward', effect: { teleporting: true }, tier: 2 }, // Rebalanced: was tier 3
            // Area Effect Abilities
            'Nova Blast': { desc: 'Explosion on impact', effect: { novaBlast: true }, tier: 2 },
            'Chain Explosion': { desc: 'Explosions spread', effect: { chainExplosion: true }, tier: 2 }, // Rebalanced: was tier 3
            'Shockwave': { desc: 'Ground-traveling wave', effect: { shockwave: true }, tier: 2 },
            'Meteor': { desc: 'Falls from sky', effect: { meteor: true }, tier: 3 },
            'Black Hole': { desc: 'Pulls enemies inward', effect: { blackHole: true }, tier: 3 },
            'Vortex': { desc: 'Creates a lingering void spiral that pulls enemies inward, deals periodic damage, and ignites them', effect: { vortex: true }, tier: 3 },
            'Time Bomb': { desc: 'Delayed massive explosion', effect: { timeBomb: true }, tier: 3 },
            // Status Effect Abilities
            'Stun Shot': { desc: 'Paralyzes enemies briefly', effect: { damageType: 'stun' }, tier: 2 },
            // Removed status shots (blind, silence, curse, weakness, doom) per design trim
            'Fear Shot': { desc: 'Makes enemies flee', effect: { damageType: 'fear' }, tier: 2 },
            'Charm Shot': { desc: 'Turns enemies friendly', effect: { damageType: 'charm' }, tier: 3 },
            // Elemental Combinations
            'Steam Shot': { desc: 'Fire + Ice combo damage', effect: { damageType: 'steam', damageBonus: 20 }, tier: 2 },
            'Magma Shot': { desc: 'Fire + Earth combo', effect: { damageType: 'magma', damageBonus: 25 }, tier: 2 }, // Rebalanced: was tier 3
            'Storm Shot': { desc: 'Lightning + Wind combo', effect: { damageType: 'storm', damageBonus: 22 }, tier: 2 },
            'Toxic Cloud': { desc: 'Poison gas area', effect: { damageType: 'toxic', areaEffect: true }, tier: 2 }, // Rebalanced: was tier 3
            'Blizzard': { desc: 'Ice + Wind storm', effect: { damageType: 'blizzard', areaEffect: true }, tier: 3 },
            'Inferno': { desc: 'Spreading fire damage', effect: { damageType: 'inferno', spreading: true }, tier: 3 },
            // Weapon Types
            'Sword Throw': { desc: 'Spinning blade projectile', effect: { weaponType: 'sword', spinning: true }, tier: 1 }, // Rebalanced: was tier 2
            'Axe Hurl': { desc: 'Heavy axe projectile — slow, large axe that deals high impact damage and knocks enemies back on hit', effect: { weaponType: 'axe', damageBonus: 30 }, tier: 2 },
            'Spear Thrust': { desc: 'Long-range piercing — fast spear that pierces multiple enemies for extended reach', effect: { weaponType: 'spear', piercing: true }, tier: 2 },
            'Hammer Slam': { desc: 'Crushing blunt damage — heavy hammer shot that stuns or briefly incapacitates enemies on impact', effect: { weaponType: 'hammer', crushDamage: true }, tier: 2 },
            'Dagger Rain': { desc: 'Multiple small blades', effect: { weaponType: 'dagger', projectileCount: 8 }, tier: 3 },
            // Energy Weapons
            'Laser Beam': { desc: 'Continuous energy beam (adds persistent beam ticks while you fire; does NOT block normal shots)', effect: { energyType: 'laser', continuous: true }, tier: 3 },
            'Particle Beam': { desc: 'High-energy particles — thick beam segments with AoE ticks; hold to deal sustained area damage along the beam', effect: { energyType: 'particle', damageBonus: 35 }, tier: 3 },
            'Ion Cannon': { desc: 'Charged ion blast — hold to charge and release a massive piercing blast; charge increases size and damage', effect: { energyType: 'ion', chargeShot: true }, tier: 3 },
            'Pulse Rifle': { desc: 'Energy pulse bursts — fires short 3-round bursts (micro-projectiles) for rapid close damage', effect: { energyType: 'pulse', burstFire: true }, tier: 2 },
            'Photon Torpedo': { desc: 'Light-speed projectile — instantly strikes the nearest enemy when fired (instant-travel strike)', effect: { energyType: 'photon', instantTravel: true }, tier: 3 },
            // Exotic Abilities
            'Quantum Shot': { desc: 'Exists in multiple states', effect: { quantum: true, hitMultipleTimes: true }, tier: 3 },
            'Dimensional Rift': { desc: 'Tears through space — creates a rift field that manipulates projectiles and can teleport or refract shots; ignores armor', effect: { dimensional: true, ignoresArmor: true }, tier: 3 },
            'Time Warp': { desc: 'Slows time around impact', effect: { timeWarp: true }, tier: 3 },
            'Reality Break': { desc: 'Breaks physics rules — spawns an unstable field that disrupts projectile paths and weakens enemy resistances', effect: { realityBreak: true, ignoresEverything: true }, tier: 3 },
            'Antimatter': { desc: 'Pure destruction', effect: { antimatter: true, massiveExplosion: true }, tier: 3 },
            // Core / Meta Abilities (previously system placeholders)
            'Auto-Aim': { desc: 'Automatically targets the nearest enemy when firing (no manual aim needed).', effect: { autoAim: true }, tier: 1 },
            'Treasure Hunter': { desc: 'Higher chance for rooms to spawn a chest (+30%) and health bread drops are 50% more likely.', effect: { chestChanceBonus: 0.3, breadDropBonus: 0.5 }, tier: 1 },
            'Rage Mode': { desc: 'Gain +3 damage for every enemy you have slain this run (scales endlessly).', effect: { rageScaling: true }, tier: 2 },
            'Berserker': { desc: 'Damage increases up to +50% as your health gets lower (scales with missing HP).', effect: { berserker: true }, tier: 2 },
            // Removed Death Touch per design trim
            'Terrifying Aura': { desc: 'Every 25 kills create a purple aura; enemies touching it are Feared for 3s and flee.', effect: { terrifyingAura: true }, tier: 2 },
            'Diarrhea': { desc: 'Oh God!', effect: { diarrhea: true }, tier: 2 },
            'Carb it up!': { desc: 'Bread drops magnetize and glide to you for instant pickup.', effect: { breadMagnet: true }, tier: 1 },
            'Beartrap': { desc: 'Every 5s drop a beartrap; first enemy to step on it takes heavy damage and is immobilized for 5s.', effect: { beartrap: true }, tier: 2 },
            'Punji Pit': { desc: 'Every 5s leave a poison spike pit; enemies touching it take damage and are poisoned.', effect: { punjiPit: true }, tier: 2 },
            'Oppemheimer': { desc: 'Every 10s a massive nuke strikes a random area — huge blast radius dealing catastrophic damage.', effect: { nukeStrike: true }, tier: 3 },
            'Silent But Deadly': { desc: 'Cropdust your enemies!', effect: { poisonTrail: true }, tier: 2 },
            'Spontaneous Combustion': { desc: 'Enemies you kill erupt into an omni blast of burning shards', effect: { combustOnKill: true }, tier: 2 },
            // Infusion / Overlay Systems
            'Elemental Conduit': { desc: 'Periodically channels random elemental infusions (can stack up to 3 simultaneous; each adds partial damage + status to shots).', effect: { elementalConduit: true }, tier: 3 },
            
            // --- New Bullet Pattern / Behavior Abilities ---
            'Lissajous Shot': { desc: 'Figure-8 oscillation path (compound wave)', effect: { lissajousPattern: true }, tier: 2 },
            'Helix Pair': { desc: 'Fires twin helix-winding partners', effect: { helixPair: true }, tier: 2 },
            'Slalom Shot': { desc: 'Sharp alternating lateral gates', effect: { slalomPattern: true }, tier: 1 },
            'Bloom Ring': { desc: 'Periodically emits expanding pellet ring', effect: { bloomRing: true }, tier: 3 },
            'Cascade Burst': { desc: 'Pulsing forward micro-bursts', effect: { cascadeBurst: true }, tier: 2 },
            'Pendulum Shot': { desc: 'Swinging arc that settles', effect: { pendulumPattern: true }, tier: 1 },
            'Sawtooth Wave': { desc: 'Jagged saw lateral motion', effect: { sawWave: true }, tier: 2 },
            'Phase Echo': { desc: 'Afterimage echoes re-impact', effect: { phaseEcho: true }, tier: 3 },
            'Resonant Pulse Core': { desc: 'Periodic buff pulse for nearby shots', effect: { resonantPulseCore: true }, tier: 3 },
            'Vector Pivot': { desc: 'Quarter-turn pivot arcs', effect: { pivotPattern: true }, tier: 2 },
            'Converging Twins': { desc: 'Diverge then fuse for burst', effect: { convergePair: true }, tier: 2 },
            'Fragment Wake': { desc: 'Leaves a lingering trail of flickering sparks that rapidly ping nearby enemies (stacking contact DPS).', effect: { fragmentWake: true }, tier: 1 },
            'Spiral Bloom': { desc: 'Tightens then blooms outward', effect: { spiralBloom: true }, tier: 3 },
            'Harmonic Split': { desc: 'Splits twice at set life points', effect: { harmonicSplit: true }, tier: 3 },
            'Gyro Stabilizer': { desc: 'Dampens chaotic lateral drift', effect: { gyroStabilizer: true }, tier: 1 },
            'Temporal Drift': { desc: 'Cycles slow stretch & surge', effect: { temporalDrift: true }, tier: 3 },
            'Veering Fan': { desc: 'Fans into arc mid-flight', effect: { veeringFan: true }, tier: 2 },
            'Echo Bloom': { desc: 'Echo catches up & bursts', effect: { echoBloom: true }, tier: 2 },
            'Toenail Clibbins': { desc: 'Thats a biggin', effect: { toenailClibbins: true }, tier: 2 },
            'Popcorn': { desc: 'Fires a kernel that pops into 2 flying puffs', effect: { popcornKernel: true }, tier: 1 },
            'Umbrella Shot': { desc: 'Primary shot splits forward into two arcing halves that curve overhead then return past you', effect: { umbrellaShot: true }, tier: 2 },
            'Duck Dynasty': { desc: 'Summon your ancestors', effect: { duckDynasty: true }, tier: 2 },
            // Crowd Control / Utility
            'Rizz': { desc: 'Every 5s magnetically gathers enemies near you then Fears them for 3s', effect: { rizzAbility: true }, tier: 3 },
            'SHOOTING INTENSIFIES': { desc: 'Amplifies ALL projectile motion patterns (waves, spirals, zigzags, helix, etc.) for +40% pattern amplitude & special speed; stacks after normal dampening.', effect: { patternAmplify: true }, tier: 3 },
        };
        // (Removed placeholder system ability injection; all core meta abilities now have proper entries.)

    // Enemy type definitions (restored after recent update)
        const ENEMY_TYPES = {
            'Thug':      { health: 60,  speed: 1.2, damage: 10, color: '#FF8888', size: 22, xp: 10,  ranged: false, armor: 0 },
            'Street Dog':{ health: 40,  speed: 1.1, damage: 8,  color: '#AA6644', size: 18, xp: 8,   ranged: false, armor: 0 },
            'Punk':      { health: 55,  speed: 1.05, damage: 12, color: '#FF44FF', size: 20, xp: 12,  ranged: false, armor: 1 },
            'Gangster':  { health: 90,  speed: 0.9, damage: 18, color: '#8888FF', size: 28, xp: 20,  ranged: true, rangedCooldown: 2500, armor: 2 },
            'Dealer':    { health: 70,  speed: 1.0, damage: 14, color: '#FFFF00', size: 24, xp: 15,  ranged: true, armor: 1 },
            'Enforcer':  { health: 130, speed: 0.7, damage: 25, color: '#FF4444', size: 32, xp: 35,  ranged: false, armor: 3 },
            'Boss Thug': { health: 350, speed: 0.6, damage: 40, color: '#FFD700', size: 48, xp: 200, ranged: false, armor: 5 },
            'Boss Gangster': { health: 520, speed: 0.65, damage: 50, color: '#4444FF', size: 52, xp: 260, ranged: true, rangedCooldown: 2000, armor: 6 },
            'The Big Quack': { health: 10000, speed: 0.55, damage: 50, color: '#111111', size: 96, xp: 4000, ranged: true, rangedCooldown: 1600, armor: 10, bossFinal: true }
        };

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

                    // Floating damage numbers storage
                        game.damageNumbers = []; // Initialize damage numbers array

                        // Initialize reality break distortion state for rendering
                        game.realityBreakDistort = { time: 0, intensity: 0.5 };

            // World pickups (health bread, etc.)
            game.pickups = [];
            // Beartraps (ability-based deployables)
            game.traps = [];
            game._lastTrapDrop = 0;
            // Punji pits (poison spike fields)
            game.pits = [];
            game._lastPitDrop = 0;
            // Nuke strike markers (Oppemheimer ability)
            game.nukes = [];
            game._lastNuke = 0;
            // Poison cloud trail (Silent But Deadly ability)
            game.poisonClouds = [];
            // Fragment Wake sparks (lingering damaging embers)
            game.fragmentSparks = [];
            game._lastPoisonCloud = 0;
            // Photon strike visual records
            game.photonStrikes = [];
            // Traveling shockwaves (Shockwave ability)
            game.shockwaves = [];

            // Small util: darken/lighten hex color (amount negative to darken)
            window.shadeColor = function(col, amt) {
                try {
                    if (!col || col[0] !== '#') return col;
                    let num = parseInt(col.slice(1), 16);
                    let r = (num >> 16) & 255;
                    let g = (num >> 8) & 255;
                    let b = num & 255;
                    r = Math.min(255, Math.max(0, r + amt));
                    g = Math.min(255, Math.max(0, g + amt));
                    b = Math.min(255, Math.max(0, b + amt));
                    return '#' + (r.toString(16).padStart(2,'0')) + (g.toString(16).padStart(2,'0')) + (b.toString(16).padStart(2,'0'));
                } catch(e) { return col; }
            };

            // Background music now created in title screen start() to ensure autoplay eligibility.
            // (Previously created here, causing some browsers to require a second click to play.)
            if (!game.bgMusic) {
                // placeholder reference; real Audio object assigned on start
                game.bgMusic = null;
            }

            // Prevent spacebar from scrolling the page
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    // Prevent page scroll AND suppress normal firing when ending overlay is active
                    e.preventDefault();
                    if (game && game._bigQuackDefeated && !game._finalAbilityOffered) {
                        const overlay = document.getElementById('endingOverlay');
                        if (overlay) overlay.remove();
                        offerPermanentAbilityChoice();
                        game._finalAbilityOffered = true;
                        return; // stop propagation to any firing logic
                    }
                }
                // Dev: toggle sprite bounds with F3
                if (e.code === 'F3') {
                    game._debugSpriteBounds = !game._debugSpriteBounds;
                    console.info('[Debug] Sprite bounds:', game._debugSpriteBounds ? 'ON' : 'OFF');
                }
                if (e.code === 'F2') {
                    console.info('[Sprite Debug]', {
                        meta: game.player && game.player.spriteMeta,
                        scale: game.player && game.player.spriteScale,
                        loaded: game.player && game.player.spriteLoaded,
                        directionalFrames: game.player && game.player.directionalFrames,
                        facing: game.player && game.player.facing
                    });
                }
                if (e.code === 'F4') {
                    console.info('[ThugSprite Debug]', game.enemySprites && game.enemySprites.thug);
                }
                if (e.code === 'F5') {
                    console.info('[StreetDogSprite Debug]', game.enemySprites && game.enemySprites.streetDog);
                }
                if (e.code === 'F6') {
                    console.info('[PunkSprite Debug]', game.enemySprites && game.enemySprites.punk);
                }
                if (e.code === 'F7') {
                    console.info('[DealerSprite Debug]', game.enemySprites && game.enemySprites.dealer);
                }
                if (e.code === 'F8') {
                    console.info('[EnforcerSprite Debug]', game.enemySprites && game.enemySprites.enforcer);
                }
                if (e.code === 'F9') {
                    console.info('[BossThugSprite Debug]', game.enemySprites && game.enemySprites.bossThug);
                }
                if (e.code === 'F10') {
                    console.info('[BossGangsterSprite Debug]', game.enemySprites && game.enemySprites.bossGangster);
                }
                if (e.code === 'F11') {
                    console.info('[BigQuackSprite Debug]', game.enemySprites && game.enemySprites.bigQuack);
                }
                if (e.code === 'F12') {
                    console.info('[GangsterSprite Debug]', game.enemySprites && game.enemySprites.gangster);
                }
            });
            // Also allow mouse primary click on ending overlay to proceed (mobile / desktop convenience)
            window.addEventListener('mousedown', (e) => {
                if (game && game._bigQuackDefeated && !game._finalAbilityOffered) {
                    const overlay = document.getElementById('endingOverlay');
                    if (overlay) {
                        overlay.remove();
                        offerPermanentAbilityChoice();
                        game._finalAbilityOffered = true;
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            // Removed pointer fallback to match original spec (FIRE key only)

            // --- Permanent Ability Integration ---
            loadPermanentAbilities();
            grantPermanentAbilities();
            // Cleanup removed abilities post-reset
            if (game.player && Array.isArray(game.player.abilities)) {
                game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
            }
            if (game.player && Array.isArray(game.player.permanentAbilities)) {
                game.player.permanentAbilities = game.player.permanentAbilities.filter(a => ABILITIES[a]);
            }
            // Clean up any abilities that were removed from the design set
            if (game.player && Array.isArray(game.player.abilities)) {
                game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
            }
            if (game.player && Array.isArray(game.player.permanentAbilities)) {
                game.player.permanentAbilities = game.player.permanentAbilities.filter(a => ABILITIES[a]);
            }

            // Player sprite sheet (replaces separate SVG sprites). Assumes a 4x4 grid: rows = facing (down,left,right,up), cols = animation frames.
            // Adjust frame size or mapping if your sheet differs.
            game.player = game.player || {};
            game.player.spriteSheet = new Image();
            game.player.spriteSheet.src = 'assets/player.png';
            game.player.spriteMeta = { rows: 4, cols: 4, frameWidth: 48, frameHeight: 48, order: ['down','left','right','up'] };
            game.player.facing = game.player.facing || 'down';
            game.player.animFrame = 0;
            game.player.animTimer = 0;
            game.player.animSpeed = 7; // lower = faster animation
            game.player.moving = false;

            // Legacy sprite flags kept for fallback detection
            game.sprites = game.sprites || {};
            game.spritesLoaded = { front:false, rear:false, side:false };

            // Game Over assets & state
            game.gameOverImage = new Image();
            game.gameOverImage.src = 'assets/gameover.png';
            game.gameOver = false;
            game._gameOverSound = null;

            // Track when sheet loads
            game.player.spriteSheet.onload = () => {
                game.player.spriteLoaded = true;
                const iw = game.player.spriteSheet.naturalWidth || game.player.spriteSheet.width;
                const ih = game.player.spriteSheet.naturalHeight || game.player.spriteSheet.height;
                const meta = game.player.spriteMeta;
                // Provide manual override hook before inference (user can call window.configurePlayerSheet prior to sheet load).
                if (typeof window.configurePlayerSheet === 'function') {
                    try { window.configurePlayerSheet(meta, iw, ih); } catch(e) { console.warn('configurePlayerSheet error', e); }
                }
                // Heuristic: attempt to find a reasonable frame size if current values consume whole sheet.
                // If default frame equals entire sheet OR cols/rows come out as 1x1, try factoring.
                function factors(n) { const out=[]; for (let i=1;i*i<=n;i++){ if(n%i===0){ out.push(i); if(i!==n/i) out.push(n/i);} } return out.sort((a,b)=>a-b); }
                if (meta) {
                    // If the assumed size is the whole sheet, attempt to split into up to 4 columns.
                    if ((meta.frameWidth === iw && meta.frameHeight === ih) || (meta.cols===1 && meta.rows===1)) {
                        // Try to pick a frame width close to 48 or 32.
                        const candW = factors(iw).filter(f=>f>=24 && f<=128);
                        const targetPref = [48,32,64];
                        let chosenW = iw;
                        for (const pref of targetPref) { const m = candW.find(c=>c===pref); if (m){ chosenW = m; break; } }
                        if (chosenW === iw && candW.length>1) chosenW = candW[Math.floor(candW.length/2)];
                        const candH = factors(ih).filter(f=>f>=24 && f<=128);
                        let chosenH = ih;
                        for (const pref of targetPref) { const m = candH.find(c=>c===pref); if (m){ chosenH = m; break; } }
                        if (chosenH === ih && candH.length>1) chosenH = candH[Math.floor(candH.length/2)];
                        meta.frameWidth = chosenW;
                        meta.frameHeight = chosenH;
                    }
                    // Recompute cols/rows with new size (guard against division by zero)
                    if (meta.frameWidth > 0 && meta.frameHeight > 0) {
                        meta.cols = Math.max(1, Math.floor(iw / meta.frameWidth));
                        meta.rows = Math.max(1, Math.floor(ih / meta.frameHeight));
                    } else {
                        meta.cols = 1; meta.rows = 1; meta.frameWidth = iw; meta.frameHeight = ih;
                    }
                    // Build facing order based on rows count
                    if (meta.rows === 1) meta.order = ['down'];
                    else if (meta.rows === 2) meta.order = ['down','up'];
                    else if (meta.rows === 3) meta.order = ['down','left','right'];
                    else meta.order = ['down','left','right','up'];
                }
                // Apply a render scale so on-screen size approximates 48px tall unless otherwise specified.
                if (!game.player.spriteScale) {
                    const targetHeight = 48;
                    game.player.spriteScale = targetHeight / (meta ? meta.frameHeight : ih);
                    if (!isFinite(game.player.spriteScale) || game.player.spriteScale <= 0) game.player.spriteScale = 1;
                }
                console.info('[SpriteSheet] Loaded', { iw, ih, meta, scale: game.player.spriteScale });

                // Explicit single-frame directional bounding boxes (static images)
                // Provided bounds (inclusive start, end). We'll compute width/height.
                // Front (down): 95,113 -> 508,883
                // Back (up):   567,106 -> 964,877
                // Side (right):1022,115 -> 1534,879
                // We'll store as {x,y,w,h}. Assume coordinates are top-left (x1,y1) and bottom-right (x2,y2).
                function makeBox(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                game.player.directionalFrames = {
                    down: makeBox(95,113,508,883),
                    up: makeBox(567,106,964,877),
                    right: makeBox(1022,115,1534,879)
                    // left will mirror right
                };
                // Compute scale to fit target on-screen height ~48
                const targetH = 48;
                const ref = game.player.directionalFrames.down;
                if (ref) {
                    game.player.spriteScale = targetH / ref.h;
                }
                console.info('[SpriteSheet] Directional static frames set', game.player.directionalFrames, 'scale', game.player.spriteScale);
            };

            // Helper: rebuild player directional frames if lost or on reset
            function rebuildPlayerSprite() {
                try {
                    if (!game || !game.player) return;
                    // If we lost the spriteSheet reference (e.g. after reset) but it previously existed, abort quietly
                    if (!game.player.spriteSheet) return;
                    // If the sheet already finished loading but spriteLoaded got lost, restore it
                    if (game.player.spriteSheet.complete && !game.player.spriteLoaded) {
                        game.player.spriteLoaded = true;
                    }
                    function makeBox(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.player.directionalFrames = {
                        down: makeBox(95,113,508,883),
                        up: makeBox(567,106,964,877),
                        right: makeBox(1022,115,1534,879)
                    };
                    const ref = game.player.directionalFrames.down;
                    const targetH = 48;
                    if (ref) game.player.spriteScale = targetH / ref.h;
                    // Reset blink/visibility timers when rebuilding explicitly
                    game.player.blinkTimer = 0;
                    game.player.wasHitTimer = 0;
                    // Ensure visibility and loaded flags so render path draws immediately
                    game.player.spriteLoaded = true;
                    if (!game.player.forceVisibleFrames || game.player.forceVisibleFrames < 30) {
                        game.player.forceVisibleFrames = 45; // extend a bit after rebuild
                    }
                } catch(e) { console.warn('rebuildPlayerSprite failed', e); }
            }
            // Expose globally in case resetGame fires in a scope where local function not yet hoisted
            if (typeof window !== 'undefined') window.rebuildPlayerSprite = rebuildPlayerSprite;

            // === Thug enemy sprite sheet (static directional frames) ===
            game.enemySprites = game.enemySprites || {};
            if (!game.enemySprites.thug) {
                const thugImg = new Image();
                thugImg.src = 'assets/KnifeDuck1.png';
                game.enemySprites.thug = { image: thugImg, loaded: false };
                thugImg.onload = () => {
                    game.enemySprites.thug.loaded = true;
                    // Provided bounding boxes (front=down, back=up, side=right) one frame each
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.thug.frames = {
                        down: box(130,200,477,857),
                        up: box(574,203,943,859),
                        right: box(1090,214,1425,859)
                        // left mirrored from right
                    };
                    // Derive scale so on-screen matches original circle size (~ enemy.size*2 tall). We'll aim height ~= enemy.size*2 baseline (size is radius). Use reference: down frame height.
                    const refH = game.enemySprites.thug.frames.down.h;
                    game.enemySprites.thug.baseScaleForSize = (enemySize)=> ( (enemySize*2) / refH );
                    // Provide a hitbox derivation function: returns {w,h,ox,oy} relative to center.
                    game.enemySprites.thug.computeHitbox = (enemy)=> {
                        const size = enemy.size;
                        const scale = game.enemySprites.thug.baseScaleForSize(size);
                        const f = game.enemySprites.thug.frames.down; // use front frame as baseline
                        const w = f.w * scale;
                        const h = f.h * scale;
                        // Slight trimming to tighten collision vs visual edges
                        const hitW = w * 0.55; // narrower to ignore wings/empty space
                        const hitH = h * 0.60; // focus on torso area
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.10 };
                    };
                    console.info('[ThugSprite] Loaded KnifeDuck1.png', game.enemySprites.thug.frames);
                };
            }
            // === Enforcer enemy sprite sheet ===
            if (!game.enemySprites.enforcer) {
                const enfImg = new Image();
                enfImg.src = 'assets/Enforcer.png';
                game.enemySprites.enforcer = { image: enfImg, loaded: false };
                enfImg.onload = () => {
                    game.enemySprites.enforcer.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    // Provided bounding boxes (front=down, back=up, side=right)
                    // Front (down): 78,119 -> 529,858
                    // Back (up):   541,120 -> 957,863
                    // Side (right):1074,120 -> 1459,858
                    game.enemySprites.enforcer.frames = {
                        down: box(78,119,529,858),
                        up: box(541,120,957,863),
                        right: box(1074,120,1459,858)
                    };
                    const refH = game.enemySprites.enforcer.frames.down.h;
                    game.enemySprites.enforcer.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.enforcer.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.enforcer.baseScaleForSize(size);
                        const f = game.enemySprites.enforcer.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        // Armor bulk: a bit wider but still trimmed
                        const hitW = w * 0.58;
                        const hitH = h * 0.60;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.11 };
                    };
                    console.info('[EnforcerSprite] Loaded Enforcer.png', game.enemySprites.enforcer.frames);
                };
            }

            // === Street Dog enemy sprite sheet ===
            if (!game.enemySprites.streetDog) {
                const dogImg = new Image();
                dogImg.src = 'assets/KnifeDuck2.png';
                game.enemySprites.streetDog = { image: dogImg, loaded: false };
                dogImg.onload = () => {
                    game.enemySprites.streetDog.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.streetDog.frames = {
                        down: box(49,141,557,917),
                        up: box(565,141,978,921),
                        right: box(1041,141,1515,922)
                    };
                    const refH = game.enemySprites.streetDog.frames.down.h;
                    game.enemySprites.streetDog.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.streetDog.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.streetDog.baseScaleForSize(size);
                        const f = game.enemySprites.streetDog.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.58; // slight different trim
                        const hitH = h * 0.62;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.12 };
                    };
                    console.info('[StreetDogSprite] Loaded KnifeDuck2.png', game.enemySprites.streetDog.frames);
                };
            }

            // === Punk enemy sprite sheet ===
            if (!game.enemySprites.punk) {
                const punkImg = new Image();
                punkImg.src = 'assets/KnifeDuck3.png';
                game.enemySprites.punk = { image: punkImg, loaded: false };
                punkImg.onload = () => {
                    game.enemySprites.punk.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.punk.frames = {
                        down: box(0,164,411,887),
                        up: box(510,166,873,883),
                        right: box(1011,164,1467,883)
                    };
                    const refH = game.enemySprites.punk.frames.down.h;
                    game.enemySprites.punk.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.punk.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.punk.baseScaleForSize(size);
                        const f = game.enemySprites.punk.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.56;
                        const hitH = h * 0.60;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.11 };
                    };
                    console.info('[PunkSprite] Loaded KnifeDuck3.png', game.enemySprites.punk.frames);
                };
            }

            // === Gangster enemy sprite sheet ===
            if (!game.enemySprites.gangster) {
                const gangsterImg = new Image();
                gangsterImg.src = 'assets/GunDuck1.png';
                game.enemySprites.gangster = { image: gangsterImg, loaded: false };
                gangsterImg.onload = () => {
                    game.enemySprites.gangster.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    // Provided bounding boxes
                    // Front (down): 131,209 -> 482,861
                    // Back (up):   588,203 -> 941,861
                    // Side (right):1056,215 -> 1428,854
                    game.enemySprites.gangster.frames = {
                        down: box(131,209,482,861),
                        up: box(588,203,941,861),
                        right: box(1056,215,1428,854)
                    };
                    const refH = game.enemySprites.gangster.frames.down.h;
                    game.enemySprites.gangster.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.gangster.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.gangster.baseScaleForSize(size);
                        const f = game.enemySprites.gangster.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        // Trim similar to other humanoids; adjust if gameplay feel off
                        const hitW = w * 0.55;
                        const hitH = h * 0.60;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.10 };
                    };
                    console.info('[GangsterSprite] Loaded GunDuck1.png', game.enemySprites.gangster.frames);
                };
            }

            // === Dealer enemy sprite sheet ===
            if (!game.enemySprites.dealer) {
                const dealerImg = new Image();
                dealerImg.src = 'assets/Dealer.png';
                game.enemySprites.dealer = { image: dealerImg, loaded: false };
                dealerImg.onload = () => {
                    game.enemySprites.dealer.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.dealer.frames = {
                        down: box(76,120,514,867),
                        up: box(555,122,982,864),
                        right: box(1045,120,1513,866)
                    };
                    const refH = game.enemySprites.dealer.frames.down.h;
                    game.enemySprites.dealer.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.dealer.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.dealer.baseScaleForSize(size);
                        const f = game.enemySprites.dealer.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.54; // dealer slimmer torso
                        const hitH = h * 0.58;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.10 };
                    };
                    console.info('[DealerSprite] Loaded Dealer.png', game.enemySprites.dealer.frames);
                };
            }

            // === Boss Thug enemy sprite sheet ===
            if (!game.enemySprites.bossThug) {
                const bossImg = new Image();
                bossImg.src = 'assets/KnifeBoss.png';
                game.enemySprites.bossThug = { image: bossImg, loaded: false };
                bossImg.onload = () => {
                    game.enemySprites.bossThug.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.bossThug.frames = {
                        down: box(0,146,520,880),
                        up: box(523,152,963,872),
                        right: box(965,150,1533,873)
                    };
                    const refH = game.enemySprites.bossThug.frames.down.h;
                    game.enemySprites.bossThug.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.bossThug.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.bossThug.baseScaleForSize(size);
                        const f = game.enemySprites.bossThug.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.57; // a bit wider torso for boss
                        const hitH = h * 0.62; // slightly taller hit core
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.09 };
                    };
                    console.info('[BossThugSprite] Loaded KnifeBoss.png', game.enemySprites.bossThug.frames);
                };
            }

            // === Boss Gangster enemy sprite sheet ===
            if (!game.enemySprites.bossGangster) {
                const bossGImg = new Image();
                // NOTE: Asset filename contains a space before .png (GunBoss.png); match exact to load correctly
                bossGImg.src = 'assets/GunBoss.png';
                game.enemySprites.bossGangster = { image: bossGImg, loaded: false };
                bossGImg.onload = () => {
                    game.enemySprites.bossGangster.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.bossGangster.frames = {
                        down: box(0,150,503,874),
                        up: box(508,154,960,867),
                        right: box(966,150,1534,870)
                    };
                    const refH = game.enemySprites.bossGangster.frames.down.h;
                    game.enemySprites.bossGangster.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.bossGangster.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.bossGangster.baseScaleForSize(size);
                        const f = game.enemySprites.bossGangster.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.56; // moderate torso width
                        const hitH = h * 0.60; // similar to other bosses
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.10 };
                    };
                    console.info('[BossGangsterSprite] Loaded GunBoss .png', game.enemySprites.bossGangster.frames);
                };
            }

            // === The Big Quack final boss sprite sheet ===
            if (!game.enemySprites.bigQuack) {
                const bqImg = new Image();
                bqImg.src = 'assets/BigQuack.png';
                game.enemySprites.bigQuack = { image: bqImg, loaded: false };
                bqImg.onload = () => {
                    game.enemySprites.bigQuack.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.bigQuack.frames = {
                        down: box(0,161,539,866),
                        up: box(541,159,1004,869),
                        right: box(1011,161,1535,875)
                    };
                    const refH = game.enemySprites.bigQuack.frames.down.h;
                    game.enemySprites.bigQuack.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.bigQuack.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.bigQuack.baseScaleForSize(size);
                        const f = game.enemySprites.bigQuack.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.60; // large core but trimmed from full sprite width
                        const hitH = h * 0.65; // taller torso hit area
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.08 };
                    };
                    console.info('[BigQuackSprite] Loaded BigQuack.png', game.enemySprites.bigQuack.frames);
                };
            }

            // (Rolled back) Removed procedural enemy & wall sprite generation.

            generateRoom();
            setupControls();
            updateUI();
            gameLoop();
            // Add particle effects
            setInterval(addAmbientParticles, 2000);
            // Track guaranteed chest logic per district cycle (rooms 1-5)
            game.chestsThisCycle = 0;

            // Initialize audio buttons & listeners
            updateAudioButtons();
            const bs = document.getElementById('btnToggleSfx');
            const bm = document.getElementById('btnToggleMusic');
            if (bs) bs.addEventListener('click', toggleSfx);
            if (bm) bm.addEventListener('click', toggleMusic);
            // Apply initial music mute state if bgMusic already created
            if (game.bgMusic) {
                game.bgMusic.muted = !game.musicEnabled;
                if (game.musicEnabled) { try { game.bgMusic.play().catch(()=>{}); } catch(e) {} }
            }
        }

        // ================= Elemental Infusion System =================
        // Supports multiple concurrent temporary elemental overlays that augment outgoing projectiles.
        // Each infusion tracked as { type, remaining, potency }. potency: scalar applied to bonus damage (% of base) and status strength.
        function ensureInfusionState() {
            if (!game.player) return;
            if (!game.player.infusions) {
                game.player.infusions = []; // array of active infusions
                game.player.maxInfusions = 3;
            }
        }

        // Add (or refresh/stack) an infusion. duration in frames. If same type exists, refresh to max of existing/added and slightly increase potency (capped).
        function addElementalInfusion(type, duration = 600, potency = 0.25) {
            ensureInfusionState();
            if (!game.player) return;
            const existing = game.player.infusions.find(i => i.type === type);
            if (existing) {
                existing.remaining = Math.max(existing.remaining, duration);
                existing.potency = Math.min(0.6, existing.potency + potency * 0.5); // soft cap
            } else {
                if (game.player.infusions.length >= game.player.maxInfusions) {
                    // Replace the one with least remaining time to keep system from silently failing
                    let worstIndex = 0; let worst = Infinity;
                    game.player.infusions.forEach((i, idx) => { if (i.remaining < worst) { worst = i.remaining; worstIndex = idx; } });
                    game.player.infusions.splice(worstIndex, 1);
                }
                game.player.infusions.push({ type, remaining: duration, potency });
            }
        }

        // Randomly roll an element not already active (or refresh one if all taken)
        function rollRandomInfusion() {
            ensureInfusionState();
            if (!game.player) return;
            const pool = ['fire','ice','lightning','poison','void','wind'];
            const inactive = pool.filter(t => !game.player.infusions.some(i => i.type === t));
            const pick = inactive.length ? inactive[Math.floor(Math.random()*inactive.length)] : pool[Math.floor(Math.random()*pool.length)];
            addElementalInfusion(pick, 600, 0.25);
        }

        // Update infusion timers; remove expired.
        function updateInfusions() {
            if (!game.player || !game.player.infusions) return;
            for (let i = game.player.infusions.length - 1; i >= 0; i--) {
                const inf = game.player.infusions[i];
                inf.remaining--;
                if (inf.remaining <= 0) game.player.infusions.splice(i,1);
            }
        }

        // Visual helper: blend colors for infusion overlay (simple average)
        function getInfusionColorBlend() {
            if (!game.player || !game.player.infusions || game.player.infusions.length === 0) return null;
            const colors = { fire:'#ff6a00', ice:'#55ccff', lightning:'#ffee55', poison:'#55ff55', void:'#aa55ff', wind:'#aaffdd' };
            let r=0,g=0,b=0,n=0;
            game.player.infusions.forEach(i => { const c = colors[i.type]; if (!c) return; const v=parseInt(c.slice(1),16); r+=(v>>16)&255; g+=(v>>8)&255; b+=v&255; n++; });
            if (!n) return '#ffffff';
            r=Math.min(255,Math.round(r/n)); g=Math.min(255,Math.round(g/n)); b=Math.min(255,Math.round(b/n));
            return '#'+r.toString(16).padStart(2,'0')+g.toString(16).padStart(2,'0')+b.toString(16).padStart(2,'0');
        }
        // =================================================================

        // Add a floating damage number at world position (x,y). Options can include
        // {crit:true, type:'fire'|'ice'|..., armor:true, heal:true}
        function addDamageNumber(amount, x, y, opts={}) {
            if (amount == null) return;
            // Avoid flooding: cap active numbers
            if (game.damageNumbers.length > 120) game.damageNumbers.splice(0, game.damageNumbers.length - 120);
            const typeColors = {
                fire:'#ff7933', ice:'#66ccff', lightning:'#ffee55', poison:'#66ff55', void:'#aa66ff',
                shadow:'#8855ff', earth:'#c2934b', wind:'#aaffdd', plasma:'#ff4455', crystal:'#88e6ff',
                solar:'#ffd966', // bright golden hue for Solar Flare
                storm:'#d7f542', magma:'#ff5522', blizzard:'#d0f0ff', inferno:'#ff2200', toxic:'#99ff66',
                bleed:'#ff3355', doom:'#ffffff', weakness:'#cccccc', stun:'#ffee88'
            };
            let color = '#ffffff';
            if (opts.heal) color = '#66ff88';
            else if (opts.crit) color = '#ffdd55';
            else if (opts.type && typeColors[opts.type]) color = typeColors[opts.type];
            if (opts.armor) color = '#888888';
            const floatAngle = (Math.random()*0.8) - 0.4;
            game.damageNumbers.push({
                value: amount,
                x, y,
                vx: Math.sin(floatAngle) * 0.4,
                vy: -1.4 - Math.random()*0.4,
                life: 60, // frames
                color,
                scale: opts.crit ? 1.4 : 1.0,
                crit: !!opts.crit,
                heal: !!opts.heal
            });
        }

        function generateRoom() {
            game.walls = [];
            game.enemies = [];
            game.chests = [];
            game.projectiles = [];
            game.particles = [];
            game.pickups = [];
            game.traps = [];
            game.pits = [];
            game.nukes = [];
            game.poisonClouds = [];
            game.shockwaves = [];
            // Active vortex fields (persistent spinning damage zones)
            game.vortexFields = [];
            // Active transient lightning arcs for visual chain effects
            game.lightningArcs = [];
            // Mark the start time of the room for gating early ranged attacks
            game.roomStartTime = Date.now();
            game.roomCleared = false;
            
            // Create perimeter walls
            for (let x = 0; x < ROOM_WIDTH; x++) {
                game.walls.push({ x: x * TILE_SIZE, y: 0, type: 'building' });
                game.walls.push({ x: x * TILE_SIZE, y: (ROOM_HEIGHT - 1) * TILE_SIZE, type: 'building' });
            }
            for (let y = 1; y < ROOM_HEIGHT - 1; y++) {
                game.walls.push({ x: 0, y: y * TILE_SIZE, type: 'building' });
                game.walls.push({ x: (ROOM_WIDTH - 1) * TILE_SIZE, y: y * TILE_SIZE, type: 'building' });
            }
            
            // Add varied obstacles
            const obstacleTypes = ['car', 'dumpster', 'streetlight', 'barrier'];
            const obstacleCount = 5 + Math.floor(game.dungeon / 2);
            
            for (let i = 0; i < obstacleCount; i++) {
                let x, y, attempts = 0;
                do {
                    x = (2 + Math.floor(Math.random() * (ROOM_WIDTH - 4))) * TILE_SIZE;
                    y = (2 + Math.floor(Math.random() * (ROOM_HEIGHT - 4))) * TILE_SIZE;
                    attempts++;
                } while ((Math.abs(x - 320) < 100 && Math.abs(y - 240) < 100) && attempts < 50);
                
                if (attempts < 50) {
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    game.walls.push({ x, y, type });
                }
            }
            
            // Spawn enemies with scaling difficulty
            const baseEnemyCount = 4;
            const enemyCount = baseEnemyCount + Math.floor(game.dungeon / 2) + Math.floor(game.room / 2);
            console.info('[RoomGen] Begin', { dungeon: game.dungeon, room: game.room, enemyCount });
            const enemyTypes = Object.keys(ENEMY_TYPES);
            
            // Add boss enemy every 5th room. Final boss only appears in district 10 room 5.
            const hasBoss = game.room === 5;
            
            for (let i = 0; i < enemyCount; i++) {
                let x, y, attempts = 0;
                do {
                    x = 60 + Math.random() * (canvas.width - 120);
                    y = 60 + Math.random() * (canvas.height - 120);
                    attempts++;
                } while ((Math.abs(x - 320) < 120 || Math.abs(y - 240) < 120 || isWall(x, y)) && attempts < 50);
                
                if (attempts < 50) {
                    let typeName;
                    if (hasBoss && i === 0) {
                        if (game.dungeon === 10) {
                            typeName = 'The Big Quack';
                        } else if (game.dungeon >= 5) {
                            typeName = 'Boss Gangster';
                        } else {
                            typeName = 'Boss Thug';
                        }
                    } else {
                        // Weight enemy selection based on dungeon level
                        const weights = {
                            'Thug': Math.max(1, 4 - game.dungeon),
                            'Street Dog': Math.max(1, 4 - game.dungeon),
                            'Punk': Math.max(1, 3 - game.dungeon + 2),
                            'Gangster': Math.max(0, game.dungeon - 1),
                            'Dealer': Math.max(0, game.dungeon - 3),
                            'Enforcer': Math.max(0, game.dungeon - 6)
                        };
                        
                        const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
                        let random = Math.random() * totalWeight;
                        
                        for (const [type, weight] of Object.entries(weights)) {
                            random -= weight;
                            if (random <= 0) {
                                typeName = type;
                                break;
                            }
                        }
                    }
                    
                    const baseType = ENEMY_TYPES[typeName];
                    // Compounding 35% health increase per completed district: multiplier = 1.35^(dungeon-1)
                    const healthMult = Math.pow(1.35, (game.dungeon - 1));
                    
                    const enemyObj = {
                        x, y, type: typeName,
                        health: Math.floor(baseType.health * healthMult),
                        maxHealth: Math.floor(baseType.health * healthMult),
                        speed: baseType.speed,
                        baseSpeed: baseType.speed, // store unmodified original for later recovery
                        // Damage no longer scales per district; only health scales to avoid late-game one-shots.
                        damage: baseType.damage,
                        color: baseType.color,
                        size: baseType.size,
                        xp: baseType.xp,
                        ranged: baseType.ranged || false,
                        lastAttack: 0,
                        poisoned: false, poisonTime: 0,
                        slowed: false, slowTime: 0,
                        burning: false, burnTime: 0
                    };
                    if (typeName === 'The Big Quack') {
                        enemyObj.finalBoss = true;
                        // Music swap to boss theme
                        try {
                            if (!game._bossMusicPlaying) {
                                if (game.bgMusic) { game._prevMusicSrc = game.bgMusic.src; try { game.bgMusic.pause(); } catch(e) {} }
                                game.bgMusic = new Audio('assets/audio/PixelShowdown.mp3');
                                game.bgMusic.loop = true;
                                applyMusicPreference();
                                updateAudioButtons();
                                game._bossMusicPlaying = true;
                            }
                        } catch(e) {}
                    }
                    game.enemies.push(enemyObj);
                    if (typeof game._roomSpawnedEnemies === 'number') game._roomSpawnedEnemies++;
                    if (i === 0) console.info('[RoomGen] First enemy', { type: typeName, x: +enemyObj.x.toFixed(1), y: +enemyObj.y.toFixed(1) });
                }
            }
            if (game.enemies.length === 0) {
                console.warn('[RoomGen] No enemies spawned; injecting fallback.');
                const fallback = { x: 320+(Math.random()*160-80), y: 240+(Math.random()*160-80), type:'Thug', health:40, maxHealth:40, speed:1.1, baseSpeed:1.1, damage:5, color:'#884400', size:20, xp:5, ranged:false, lastAttack:0, poisoned:false, slowed:false, burning:false };
                game.enemies.push(fallback);
                if (typeof game._roomSpawnedEnemies === 'number') game._roomSpawnedEnemies++;
            }
            console.info('[RoomGen] Done', { spawned: game.enemies.length, counter: game._roomSpawnedEnemies });
            
            // Spawn chests
            let chestSpawnChance = 0.5;
            if (game.player.abilities.includes('Treasure Hunter')) chestSpawnChance = 0.8;
            // Guaranteed minimum chest logic: ensure at least 2 chests every district (rooms 1-5)
            // Strategy: If still below quota and nearing end of cycle, force spawn.
            const roomsPerDistrict = 5;
            const minChestsPerDistrict = 2;
            const roomIndexInCycle = game.room; // 1..5
            let forceChest = false;
            if (typeof game.chestsThisCycle !== 'number') game.chestsThisCycle = 0;
            const remainingRooms = roomsPerDistrict - roomIndexInCycle + 1;
            const needed = minChestsPerDistrict - game.chestsThisCycle;
            if (needed > 0) {
                // If number of remaining rooms equals needed, we must force spawn now.
                if (needed >= remainingRooms) {
                    forceChest = true;
                } else {
                    // Soft pity: slightly boost chance proportional to deficit
                    chestSpawnChance += 0.15 * needed; // each missing chest adds 15% chance
                }
            }
            if (forceChest || Math.random() < chestSpawnChance) {
                let x, y, attempts = 0;
                const startX = 320, startY = 240; // player spawn center
                const startExclusionR = 90; // radius within which chests may not spawn
                const startExclusionR2 = startExclusionR * startExclusionR;
                do {
                    x = 60 + Math.random() * (canvas.width - 120);
                    y = 60 + Math.random() * (canvas.height - 120);
                    attempts++;
                    const dxs = x - startX; const dys = y - startY;
                    var tooCloseToStart = (dxs*dxs + dys*dys) < startExclusionR2;
                } while ((tooCloseToStart || game.enemies.some(e => Math.abs(e.x - x) < 60) || isWall(x, y)) && attempts < 50);
                
                if (attempts < 50) {
                    // Preselect an ability for this chest now so variant can reflect rarity.
                    // Choose from abilities the player does NOT yet have.
                    const pool = Object.keys(ABILITIES).filter(a => !game.player.abilities.includes(a));
                    let chosenAbility = null;
                    if (pool.length > 0) {
                        // Weight by inverse tier (common more likely) but with slight bias for variety.
                        const weighted = [];
                        pool.forEach(a => {
                            const tier = ABILITIES[a].tier || 1;
                            const base = Math.max(1, 4 - tier); // 3 for T1,2 for T2,1 for T3
                            for (let i=0;i<base;i++) weighted.push(a);
                        });
                        chosenAbility = weighted[Math.floor(Math.random()*weighted.length)];
                    }
                    // Map tier to can variant: tier1 -> platinum (common / white), tier2 -> gold (rare / blue), tier3 -> irradiated (epic / purple)
                    let variant = 'gold';
                    if (chosenAbility) {
                        const tier = ABILITIES[chosenAbility].tier || 1;
                        if (tier === 1) variant = 'platinum';
                        else if (tier === 2) variant = 'gold';
                        else if (tier >= 3) variant = 'irradiated';
                    } else {
                        // No ability available (player owns everything) keep neutral gold appearance
                        variant = 'gold';
                    }
                    game.chests.push({ x, y, opened: false, variant, jigglePhase: 0, ability: chosenAbility });
                    game.chestsThisCycle = (game.chestsThisCycle || 0) + 1;
                }
            }
            
            game.player.x = 320;
            game.player.y = 240;
        }

        function isWall(x, y, size = 25) {
            return game.walls.some(wall => 
                x > wall.x - size && x < wall.x + TILE_SIZE + size &&
                y > wall.y - size && y < wall.y + TILE_SIZE + size
            );
        }

        // Move an enemy along a vector in small steps, stopping before hitting walls.
        // dx,dy is the normalized direction vector; distance is how far to attempt to push.
        function pushEnemy(enemy, dx, dy, distance, step = 4) {
            const steps = Math.max(1, Math.ceil(distance / step));
            let moved = 0;
            for (let i = 0; i < steps; i++) {
                const nx = enemy.x + dx * step;
                const ny = enemy.y + dy * step;
                // If the next step would be inside a wall, stop early
                if (isWall(nx, ny, enemy.size/2)) break;
                enemy.x = nx;
                enemy.y = ny;
                moved += step;
            }
            // Failsafe clamp so enemies never leave playable bounds
            const margin = 40;
            enemy.x = Math.max(margin, Math.min(enemy.x, canvas.width - margin));
            enemy.y = Math.max(margin, Math.min(enemy.y, canvas.height - margin));
            return moved;
        }

        // Unified knockback impulse application (velocity-based) replacing instantaneous pushEnemy usage for knockback effects.
        // forceDist approximates desired travel distance; direction provided via normalized (dx,dy) or computed from sx,sy vector.
        function applyKnockback(enemy, forceDist, sx, sy) {
            if (!enemy) return;
            // Derive direction from sx,sy
            const mag = Math.hypot(sx, sy) || 1;
            const dx = sx / mag; const dy = sy / mag;
            // Parameters: decay & initial velocity mapping (reuse smooth knockback math but allow independent tuning)
            const decay = 0.9; // slightly higher decay (slower) vs applySmoothKnockback for layered pushes
            const v0 = Math.min(30, forceDist * (1 - decay));
            enemy._kbDecay = decay;
            enemy.kbVX = (enemy.kbVX || 0) + dx * v0;
            enemy.kbVY = (enemy.kbVY || 0) + dy * v0;
            // Extend kbFrames proportionally; layering multiple impulses increases duration modestly
            const addFrames = Math.min(40, Math.floor(forceDist * 0.4));
            enemy.kbFrames = Math.max(enemy.kbFrames || 0, addFrames);
            enemy._knockbacking = true;
        }

        // Smooth knockback: apply an initial velocity and let updateEnemies integrate it over several frames.
        // distance roughly correlates with the total displacement we want. We translate that into an initial
        // speed and decay factor. This avoids the "teleport" look of large instantaneous pushes (e.g., Wind Blade 120px).
        function applySmoothKnockback(enemy, dx, dy, distance) {
            // Normalize direction (defensive)
            const mag = Math.hypot(dx, dy) || 1;
            const ndx = dx / mag; const ndy = dy / mag;
            // If enemy already has knockback velocity, blend (add) the new impulse.
            const decay = 0.88; // stored for reference if we later want per-enemy tuning
            enemy._kbDecay = decay;
            // Convert desired travel distance into initial speed; geometric series sum S = v0 / (1-decay)
            // => v0 ≈ distance * (1 - decay). We clamp to avoid absurd speeds on gigantic values.
            const baseV0 = distance * (1 - decay); // e.g. distance 120, decay .88 -> ~14.4
            const v0 = Math.min(28, baseV0);
            enemy.kbVX = (enemy.kbVX || 0) + ndx * v0;
            enemy.kbVY = (enemy.kbVY || 0) + ndy * v0;
            // Duration in frames: allow enough frames for displacement. Use log threshold: v * decay^n < 0.25 => n ≈ log(0.25/v)/log(decay)
            // Approximate with linear scale for simplicity.
            enemy.kbFrames = Math.max(enemy.kbFrames || 0, Math.min(50, Math.floor(distance * 0.5))); // 120 -> 60 (capped 50)
            // Flag so other movement AI can skip while sliding.
            enemy._knockbacking = true;
        }

        function setupControls() {
            document.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                game.keys[key] = true;
                
                // Handle pause
                if (key === 'p') {
                    togglePause();
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', e => {
                game.keys[e.key.toLowerCase()] = false;
            });
        }

        function gameLoop() {
            if (!game._loopStarted) game._loopStarted = true; // mark loop engaged once
            // Defensive: if multiple RAF chains somehow created, abort duplicates
            if (game._cancelExtraLoop) return;
            if (!game.paused && !game.gameOver) {
                update();
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            game.paused = !game.paused;
            const overlay = document.getElementById('pauseOverlay');
            
            if (game.paused) {
                overlay.style.display = 'flex';
                initPauseTabs();
                switchPauseTab('abilities');
                updatePauseMenu();
            } else {
                overlay.style.display = 'none';
            }
        }

        // Update pause menu to show ability descriptions
        function updatePauseMenu() {
            const pauseAbilities = document.getElementById('pauseAbilities');
            if (game.player.abilities.length === 0) {
                pauseAbilities.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #666; font-style: italic;">No abilities acquired yet</div>';
                return;
            }
            let html = '';
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                const tier = abilityData ? abilityData.tier || 1 : 1;
                const isPermanent = game.player.permanentAbilities.includes(ability);
                let cardClass = `ability-card tier${tier}`;
                if (isPermanent) cardClass += ' permanent';
                let color = '#ffffff';
                if (tier === 2) color = '#4488ff';
                else if (tier >= 3) color = '#c855ff';
                html += `<div class="${cardClass}" style="margin-bottom:8px;">
                    <div class="ability-card-name" style="color:${color}">${ability}</div>
                    <div class="ability-card-desc">${abilityData ? abilityData.desc : 'Unknown ability'}</div>
                </div>`;
            });
            pauseAbilities.innerHTML = html;
        }

        function initPauseTabs() {
            const btnA = document.getElementById('tabAbilities');
            const btnO = document.getElementById('tabOptions');
            if (!btnA || !btnO) return;
            btnA.onclick = () => { switchPauseTab('abilities'); };
            btnO.onclick = () => { switchPauseTab('options'); };
            // Option buttons
            const sfxBtn = document.getElementById('optToggleSfx');
            const musicBtn = document.getElementById('optToggleMusic');
            const cosBtn = document.getElementById('optToggleCosmetic');
            const resetBtn = document.getElementById('optResetProgress');
            if (sfxBtn) sfxBtn.onclick = () => { toggleSfx(); reflectOptionStates(); };
            if (musicBtn) musicBtn.onclick = () => { toggleMusic(); reflectOptionStates(); };
            if (cosBtn) cosBtn.onclick = () => { game.disableCosmeticParticles = !game.disableCosmeticParticles; saveAudioPreferences(); reflectOptionStates(); };
            if (resetBtn) resetBtn.onclick = () => {
                if (confirm('Reset progress and clear permanent abilities?')) {
                    localStorage.removeItem('permanentAbilities');
                    location.reload();
                }
            };
            reflectOptionStates();
        }

        function reflectOptionStates() {
            const sfxBtn = document.getElementById('optToggleSfx');
            const musicBtn = document.getElementById('optToggleMusic');
            const cosBtn = document.getElementById('optToggleCosmetic');
            if (sfxBtn) sfxBtn.textContent = 'SFX: ' + (game.sfxEnabled ? 'ON' : 'OFF');
            if (musicBtn) musicBtn.textContent = 'Music: ' + (game.musicEnabled ? 'ON' : 'OFF');
            if (cosBtn) cosBtn.textContent = 'Cosmetic FX: ' + (game.disableCosmeticParticles ? 'OFF' : 'ON');
        }

        function switchPauseTab(which) {
            const tabA = document.getElementById('tabAbilities');
            const tabO = document.getElementById('tabOptions');
            const contentA = document.getElementById('pauseAbilities');
            const contentO = document.getElementById('pauseOptions');
            if (!tabA || !tabO || !contentA || !contentO) return;
            const activeStyles = { borderColor:'#00ff88', color:'#00ff88' };
            const idleStyles = { borderColor:'#444', color:'#aaa' };
            function applyStyles(btn, styles) { Object.assign(btn.style, styles); }
            if (which === 'abilities') {
                contentA.style.display = 'grid';
                contentO.style.display = 'none';
                applyStyles(tabA, activeStyles); applyStyles(tabO, idleStyles);
            } else {
                contentA.style.display = 'none';
                contentO.style.display = 'block';
                applyStyles(tabO, activeStyles); applyStyles(tabA, idleStyles);
            }
        }

        function showAbilityTooltip(abilityName) {
            const tooltip = document.getElementById('abilityTooltip');
            const nameEl = document.getElementById('tooltipName');
            const descEl = document.getElementById('tooltipDesc');
            const abilityData = ABILITIES[abilityName];
            
            if (!abilityData) return;
            
            nameEl.textContent = abilityName;
            descEl.textContent = abilityData.desc;
            
            // Apply tier coloring
            const tier = abilityData.tier || 1;
            switch (tier) {
                case 1:
                    nameEl.style.color = '#ffffff';
                    break;
                case 2:
                    nameEl.style.color = '#4488ff';
                    break;
                case 3:
                    nameEl.style.color = '#ff44ff';
                    break;
            }
            
            tooltip.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(() => {
                tooltip.classList.remove('show');
            }, 3000);
        }

        // ================= Rizz Ability (Animated Pull) =================
        // Replaces previous teleport version: enemies are smoothly pulled into a ring.
        const RIZZ_INTERVAL_MS = 5000;       // Trigger cadence
        const RIZZ_PULL_DURATION = 900;      // ms for interpolation
        const RIZZ_RING_RADIUS = 90;         // Distance from player center
        const RIZZ_FEAR_FRAMES = 180;        // 3s fear after arrival

        function triggerRizzPull() {
            if (!game.player || !game.player.abilities || !game.player.abilities.includes('Rizz')) return;
            const now = performance.now();
            if (!game._lastRizz) game._lastRizz = now;
            if (now - game._lastRizz < RIZZ_INTERVAL_MS) return; // not time yet
            if (!Array.isArray(game.enemies) || game.enemies.length === 0) return;
            game._lastRizz = now;
            const px = game.player.x, py = game.player.y;
            const angleStep = (Math.PI * 2) / Math.max(1, game.enemies.length);
            let idx = 0;
            // Center pulse
            for (let p=0;p<28;p++) addParticle(px + (Math.random()-0.5)*30, py + (Math.random()-0.5)*30, '#B066FF', 'spark');
            addScreenShake(3);
            game.enemies.forEach(enemy => {
                if (!enemy || enemy.health <= 0) return;
                const ang = angleStep * idx + Math.random()*0.18;
                const tx = px + Math.cos(ang) * RIZZ_RING_RADIUS;
                const ty = py + Math.sin(ang) * RIZZ_RING_RADIUS;
                enemy._rizzPull = {
                    active: true,
                    startX: enemy.x,
                    startY: enemy.y,
                    targetX: tx,
                    targetY: ty,
                    startTime: now,
                    duration: RIZZ_PULL_DURATION,
                    appliedFear: false
                };
                if (Math.random() < 0.9) addParticle(enemy.x, enemy.y - (enemy.size||20)/2, '#D080FF', 'spark');
                idx++;
            });
        }

        function advanceRizzPull() {
            if (!game.enemies || game.enemies.length === 0) return;
            const now = performance.now();
            game.enemies.forEach(enemy => {
                const st = enemy && enemy._rizzPull;
                if (!st || !st.active) return;
                if (enemy.health <= 0) { st.active = false; return; }
                const tRaw = (now - st.startTime) / st.duration;
                const t = Math.min(1, Math.max(0, tRaw));
                const ease = 1 - Math.pow(1 - t, 3); // cubic out
                enemy.x = st.startX + (st.targetX - st.startX) * ease;
                enemy.y = st.startY + (st.targetY - st.startY) * ease;
                if (Math.random() < (0.25 * (1 - t) + 0.05)) {
                    addParticle(enemy.x, enemy.y - (enemy.size||20)/2, '#C070FF', 'spark');
                }
                if (t >= 1) {
                    st.active = false;
                    if (!st.appliedFear) {
                        enemy.fearTime = Math.max(enemy.fearTime || 0, RIZZ_FEAR_FRAMES);
                        enemy.feared = true;
                        st.appliedFear = true;
                        if (Math.random() < 0.85) addParticle(enemy.x, enemy.y, '#EEAAFF', 'spark');
                    }
                }
            });
        }

        function updateRizz() {
            triggerRizzPull();
            advanceRizzPull();
        }

        function update() {
            // Global frame counter (needed for timed mechanics like meteor detonation)
            if (typeof game.frame !== 'number') game.frame = 0;
            game.frame++;
            updatePlayer();
            updateEnemies();
            // Spawn/adjust orbitals BEFORE projectile update so they get a fresh position tick this frame
            if (typeof ensureOrbitals === 'function') ensureOrbitals();
            updateProjectiles();
            if (typeof updateShockwaves === 'function') updateShockwaves();
            if (typeof updateVortexFields === 'function') updateVortexFields();
            if (typeof updateEchoBloomFields === 'function') updateEchoBloomFields();
            if (typeof updateBloomRings === 'function') updateBloomRings();
            // Failsafe: re-anchor any orbitals to current player position in case other logic modified them after projectile update
            if (game && game.projectiles && game.player) {
                for (const proj of game.projectiles) {
                    if (proj && proj._orbital && !proj.enemy && proj._orbitRadius != null && proj._orbitAngle != null) {
                        // Only adjust if the projectile appears to have drifted far from expected anchor (> 8px difference from radial distance)
                        const dx = proj.x - game.player.x;
                        const dy = proj.y - game.player.y;
                        const dist = Math.hypot(dx, dy);
                        if (Math.abs(dist - proj._orbitRadius) > 8) {
                            proj.x = game.player.x + Math.cos(proj._orbitAngle) * proj._orbitRadius;
                            proj.y = game.player.y + Math.sin(proj._orbitAngle) * proj._orbitRadius;
                        }
                    }
                }
            }
            // Dimensional rifts update
            if (typeof updateDimensionalRifts === 'function') updateDimensionalRifts();
            // Elemental infusion timers & periodic conduit proc
            if (typeof updateInfusions === 'function') updateInfusions();
            if (typeof updateTimeWarpFields === 'function') updateTimeWarpFields();
            if (typeof updateBlackHoles === 'function') updateBlackHoles();
            if (typeof updateRizz === 'function') updateRizz();
            // Touch fire now routed through standard spacebar key handling; no separate per-frame polling needed.
            // Terrifying Aura room-based expiration (in addition to level)
            if (game.player && game.player.auraActive) {
                if (game.player.auraExpireRoom && game.room >= game.player.auraExpireRoom) {
                    game.player.auraActive = false;
                }
            }
            if (game.player && game.player.abilities && game.player.abilities.includes('Elemental Conduit')) {
                const nowC = Date.now();
                if (!game._lastConduitRoll) game._lastConduitRoll = nowC;
                const conduitInterval = 4500; // ms between new infusions
                if (nowC - game._lastConduitRoll >= conduitInterval) {
                    rollRandomInfusion();
                    game._lastConduitRoll = nowC;
                    // Small visual pulse at player
                    for (let p=0;p<14;p++) addParticle(game.player.x + (Math.random()-0.5)*40, game.player.y + (Math.random()-0.5)*40, getInfusionColorBlend() || '#FFFFFF', 'spark');
                }
            }
            updateParticles();
            updateDamageNumbers();
            if (typeof updateTraps === 'function') updateTraps();
            if (typeof updatePits === 'function') updatePits();
            if (typeof updateNukes === 'function') updateNukes();
            if (typeof updatePoisonClouds === 'function') updatePoisonClouds();
            if (typeof updateFragmentSparks === 'function') updateFragmentSparks();
            checkCollisions();
            checkRoomComplete();

            // Animate toenail crescents (rotate phase)
            if (game.projectiles && game.projectiles.length) {
                for (const proj of game.projectiles) {
                    if (proj.toenail) {
                        proj._crescentPhase += 0.22 * proj._crescentDir; // spin direction
                    }
                    if (proj.popcornPuff) {
                        proj._puffSpin += 0.18 * (proj._puffDir||1);
                    }
                    if (proj.isPopcornKernel) {
                        // slight wobble before popping
                        proj._kernelWobble = (proj._kernelWobble||0) + 0.4;
                    }
                }
            }

            // Pickup collection (bread health)
            if (game.pickups && game.pickups.length) {
                for (let i = game.pickups.length - 1; i >= 0; i--) {
                    const p = game.pickups[i];
                    if (p.collected) { game.pickups.splice(i,1); continue; }
                    let dx = p.x - game.player.x;
                    let dy = p.y - game.player.y;
                    // Bread magnetization (Carb it up!) – gently pull bread toward player
                    if (p.type === 'bread' && game.player.abilities.includes('Carb it up!')) {
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        // If outside auto-pick radius, move it closer
                        if (dist > 8) {
                            const speed = Math.min(6, 1.5 + dist * 0.05); // faster if farther, capped
                            const nx = p.x - (dx / dist) * speed;
                            const ny = p.y - (dy / dist) * speed;
                            p.x = nx;
                            p.y = ny;
                            // Recompute delta after movement for pickup radius test
                            dx = p.x - game.player.x;
                            dy = p.y - game.player.y;
                        }
                    }
                    if (dx*dx + dy*dy < 34*34) { // collection radius ~34px
                        // Only heal if not already full
                        if (game.player.health < game.player.maxHealth) {
                            const before = game.player.health;
                            game.player.health = Math.min(game.player.maxHealth, game.player.health + 25);
                            const healed = game.player.health - before;
                            if (healed > 0) {
                                addDamageNumber(healed, game.player.x, game.player.y - 28, { heal:true });
                                addParticle(game.player.x, game.player.y - 18, '#66FF88', 'heal');
                                updateUI();
                            }
                        }
                        p.collected = true;
                        game.pickups.splice(i,1);
                    }
                }
            }
            
            if (game.screenShake > 0) {
                game.screenShake--;
            }
            // Enforce hard boundary for all enemies after every frame of motion/effects
            clampEnemiesToBounds();
            // Terrifying Aura: removed level-based expiry; room-based handled elsewhere.
            // Beartrap periodic deployment
            if (game.player && game.player.abilities && game.player.abilities.includes('Beartrap')) {
                const now = Date.now();
                if (!game._lastTrapDrop) game._lastTrapDrop = now;
                const interval = 5000; // 5 seconds
                if (now - game._lastTrapDrop >= interval) {
                    dropBeartrap();
                    game._lastTrapDrop = now;
                }
            }
            // Punji Pit periodic deployment
            if (game.player && game.player.abilities && game.player.abilities.includes('Punji Pit')) {
                const now2 = Date.now();
                if (!game._lastPitDrop) game._lastPitDrop = now2;
                const interval2 = 5000;
                if (now2 - game._lastPitDrop >= interval2) {
                    dropPunjiPit();
                    game._lastPitDrop = now2;
                }
            }
            // Oppemheimer periodic nuke strike spawner
            if (game.player && game.player.abilities && game.player.abilities.includes('Oppemheimer')) {
                const nowN = Date.now();
                if (!game._lastNuke) game._lastNuke = nowN;
                const nukeInterval = 10000; // 10 seconds
                if (nowN - game._lastNuke >= nukeInterval) {
                    if (!Array.isArray(game.nukes)) game.nukes = [];
                    // Cap active pending nukes to prevent stacking abuse
                    const pending = game.nukes.filter(n => !n.exploded);
                    if (pending.length < 3) {
                        const margin = 80;
                        const nx = margin + Math.random() * (canvas.width - margin*2);
                        const ny = margin + Math.random() * (canvas.height - margin*2);
                        const radius = Math.min(canvas.width, canvas.height) / 4; // quarter screen radius
                        game.nukes.push({
                            x: nx,
                            y: ny,
                            radius,
                            spawnAt: nowN,
                            impactAt: nowN + 1500, // warning duration 1.5s
                            exploded: false,
                            flashTime: 0
                        });
                        game._lastNuke = nowN;
                    } else {
                        // Delay slightly if too many pending so it retries soon
                        game._lastNuke = nowN - (nukeInterval - 1500);
                    }
                }
            }

            // Silent But Deadly poison trail spawning
            if (game.player && game.player.abilities && game.player.abilities.includes('Silent But Deadly')) {
                const nowP = Date.now();
                if (!game._lastPoisonCloud) game._lastPoisonCloud = nowP;
                const interval = 120; // ms between trail puffs
                if (nowP - game._lastPoisonCloud >= interval) {
                    if (!Array.isArray(game.poisonClouds)) game.poisonClouds = [];
                    game.poisonClouds.push({
                        x: game.player.x + (Math.random()*14-7),
                        y: game.player.y + (Math.random()*14-7),
                        radius: 34 + Math.random()*10,
                        life: 180, // frames (~3s at 60fps)
                        maxLife: 180,
                        tickTimer: 0
                    });
                    // Trim excessive lingering (cap to ~120 clouds = 6s trail worst case)
                    if (game.poisonClouds.length > 120) game.poisonClouds.splice(0, game.poisonClouds.length - 120);
                    game._lastPoisonCloud = nowP;
                }
            }

            // Duck Dynasty: periodic flock swoop (every ~2s) -- redesigned to spawn from top and arc downward in a swoop
            if (game.player && game.player.abilities && game.player.abilities.includes('Duck Dynasty')) {
                if (!Array.isArray(game.duckFlocks)) game.duckFlocks = [];
                const frameNow = game.frame||0;
                const intervalFrames = 120; // 2 seconds at 60fps
                if (frameNow >= (game.nextDuckFlockFrame||0)) {
                    game.nextDuckFlockFrame = frameNow + intervalFrames;
                    // Spawn a flock entering slightly above the top edge, choosing a horizontal band entry span
                    const flockSize = 6 + Math.floor(Math.random()*4); // 6-9 ducks
                    const baseDamage = calculateDamage();
                    const entryY = -40 - Math.random()*60; // start above screen
                    const exitY = canvas.height + 80; // allow overshoot before cleanup
                    const bandLeft = 80 + Math.random()*120;
                    const bandRight = canvas.width - (80 + Math.random()*120);
                    const duration = 120 + Math.floor(Math.random()*40); // frames of flight
                    const midCurveY = canvas.height * (0.30 + Math.random()*0.15); // apex of downward curve
                    const lateralDrift = (Math.random()<0.5?-1:1) * (60 + Math.random()*90);
                    for (let i=0;i<flockSize;i++) {
                        const laneFrac = (i / Math.max(1, flockSize-1));
                        const startX = bandLeft + (bandRight - bandLeft) * laneFrac + (Math.random()-0.5)*30;
                        const sway = (Math.random()*0.4 + 0.6); // amplitude multiplier
                        game.duckFlocks.push({
                            mode:'swoop',
                            t:0, tMax: duration,
                            startX, startY: entryY,
                            midX: startX + lateralDrift*0.4 + (Math.random()-0.5)*40,
                            midY: midCurveY + (Math.random()-0.5)*30,
                            endX: startX + lateralDrift + (Math.random()-0.5)*60,
                            endY: exitY,
                            progress:0, // compatibility
                            speed:1,
                            damage: Math.max(2, Math.floor(baseDamage * 0.60)),
                            size: 18 + Math.random()*6,
                            hitIds: new Set(),
                            color: (Math.random()<0.5?'#FFD74A':'#FFECA0'),
                            wingPhase: Math.random()*Math.PI*2,
                            swayAmp: sway * (20 + Math.random()*14)
                        });
                    }
                    // Telegraph: falling feathers / sparks near top
                    for (let p=0;p<18;p++) addParticle((bandLeft+bandRight)/2 + (Math.random()-0.5)*260, entryY + 20 + Math.random()*40, '#FFF2AA','spark');
                }
                // Update active ducks
                for (let i=game.duckFlocks.length-1;i>=0;i--) {
                    const d = game.duckFlocks[i];
                    if (d.mode === 'swoop') {
                        d.t++;
                        const u = d.t / d.tMax; // 0->1
                        if (u >= 1) { game.duckFlocks.splice(i,1); continue; }
                        // Ease curve progress (accelerate in, glide out)
                        const e = u<0.5 ? 2*u*u : -1 + (4 - 2*u)*u; // smooth-ish ease
                        // Quadratic Bezier for arc (start->mid->end)
                        const x1 = d.startX, y1 = d.startY;
                        const x2 = d.midX,   y2 = d.midY;
                        const x3 = d.endX,   y3 = d.endY;
                        d.x = (1-e)*(1-e)*x1 + 2*(1-e)*e*x2 + e*e*x3;
                        d.y = (1-e)*(1-e)*y1 + 2*(1-e)*e*y2 + e*e*y3;
                        // Add lateral sinusoidal sway for individual variation
                        d.wingPhase += 0.28 + Math.random()*0.02;
                        d.x += Math.sin(d.wingPhase*0.5 + d.startX*0.01) * (d.swayAmp*0.15);
                    } else {
                        // legacy arc mode (if any old objects remain)
                        d.progress += d.speed;
                        if (d.progress >= 1) { game.duckFlocks.splice(i,1); continue; }
                    }
                    // Collision with enemies (single hit per enemy per duck)
                    if (game.enemies && game.enemies.length) {
                        for (const en of game.enemies) {
                            if (en._dead) continue;
                            const dx = en.x - d.x; const dy = en.y - d.y;
                            const wingSpan = d.size * 1.6; // larger because wings out
                            const hitR = (wingSpan*0.5 + (en.size||20)*0.5);
                            if (dx*dx + dy*dy <= hitR*hitR && !d.hitIds.has(en._guid || en._hitMarker)) {
                                // assign a temp marker id if none
                                if (!en._guid) en._guid = 'e'+Math.random().toString(36).slice(2,9);
                                d.hitIds.add(en._guid);
                                en.health -= d.damage;
                                addDamageNumber(d.damage, en.x, en.y - en.size/2, { type:'wind'});
                                addParticle(en.x, en.y, '#FFECAA','impact');
                                if (en.health <= 0) en._dead = true;
                            }
                        }
                    }
                    // Occasional feather motes
                    if (Math.random()<0.25) addParticle(d.x + (Math.random()-0.5)*10, d.y + (Math.random()-0.5)*10, '#FFF5CC','spark');
                }
                // Cap flocks stored to avoid runaway if lag (should be small anyway)
                if (game.duckFlocks.length > 120) game.duckFlocks.splice(0, game.duckFlocks.length - 120);
            }

            // Process scheduled delayed combustion rings (Spontaneous Combustion synergies)
            if (game._pendingCombustionRings && game._pendingCombustionRings.length) {
                for (let i = game._pendingCombustionRings.length - 1; i >= 0; i--) {
                    const ring = game._pendingCombustionRings[i];
                    if (!ring) { game._pendingCombustionRings.splice(i,1); continue; }
                    if ((game.frame||0) >= ring.spawnFrame) {
                        const baseDmg = calculateDamage();
                        const count = ring.count || 10;
                        const speed = ring.speed || 6;
                        const dmgFrac = ring.dmgFrac != null ? ring.dmgFrac : 0.4;
                        for (let s=0; s<count; s++) {
                            const ang = (s / count) * Math.PI * 2; // even spread
                            game.projectiles.push({
                                x: ring.x,
                                y: ring.y,
                                vx: Math.cos(ang) * speed,
                                vy: Math.sin(ang) * speed,
                                life: 64,
                                size: 5,
                                enemy: false,
                                baseDamage: Math.max(1, Math.floor(baseDmg * dmgFrac)),
                                damageType: 'fire',
                                burningShard: true,
                                piercing: false
                            });
                        }
                        // Visual feedback: modest particle ring & scaled screen shake
                        for (let p=0; p<Math.min(24, count*1.2); p++) {
                            const pang = Math.random()*Math.PI*2;
                            const pr = Math.random()*26;
                            addParticle(ring.x + Math.cos(pang)*pr, ring.y + Math.sin(pang)*pr, (Math.random()<0.35?'#FFDD66':'#FF7722'), 'explosion');
                        }
                        addScreenShake( (ring.tier || 1) * 2 );
                        game._pendingCombustionRings.splice(i,1);
                    }
                }
                // Prevent unbounded growth if something failed to spawn far in the future (> 10s worth of frames)
                if (game._pendingCombustionRings.length > 100) {
                    const nowF = game.frame||0;
                    game._pendingCombustionRings = game._pendingCombustionRings.filter(r => r && r.spawnFrame > nowF - 600);
                }
            }
        }

        function clampEnemiesToBounds() {
            if (!game.enemies) return;
            const w = canvas.width;
            const h = canvas.height;
            game.enemies.forEach(enemy => {
                // Determine basic facing for sprite use (horizontal priority when significant, else vertical)
                if (!enemy.facing) enemy.facing = 'down';
                const vx = enemy.vx || (game.player.x - enemy.x); // fallback to vector toward player if vx undefined
                const vy = enemy.vy || (game.player.y - enemy.y);
                if (Math.abs(vx) > Math.abs(vy)) {
                    enemy.facing = vx < 0 ? 'left' : 'right';
                } else {
                    enemy.facing = vy < 0 ? 'up' : 'down';
                }
                if (!enemy) return;
                const r = enemy.size || 16;
                // Hard OOB kill: if an enemy somehow gets fully beyond a tolerance outside the canvas, kill it.
                // Tolerance allows minor float drift without triggering death.
                const tol = r * 1.2; // 120% of radius outside view before death
                if (enemy.x < -tol || enemy.x > w + tol || enemy.y < -tol || enemy.y > h + tol) {
                    enemy.health = 0; // will be removed during enemy cleanup
                    return;
                }
                const minX = r;
                const maxX = w - r;
                const minY = r;
                const maxY = h - r;
                let clamped = false;
                if (enemy.x < minX) { enemy.x = minX; if (enemy.kbVX < 0) enemy.kbVX = 0; clamped = true; }
                if (enemy.x > maxX) { enemy.x = maxX; if (enemy.kbVX > 0) enemy.kbVX = 0; clamped = true; }
                if (enemy.y < minY) { enemy.y = minY; if (enemy.kbVY < 0) enemy.kbVY = 0; clamped = true; }
                if (enemy.y > maxY) { enemy.y = maxY; if (enemy.kbVY > 0) enemy.kbVY = 0; clamped = true; }
                // If knockback velocity would push them further outside next frame, damp further
                if (clamped && (enemy.kbVX || enemy.kbVY)) {
                    enemy.kbVX *= 0.4; enemy.kbVY *= 0.4;
                }
            });
        }

        function updatePoisonClouds() {
            if (!Array.isArray(game.poisonClouds) || game.poisonClouds.length === 0) return;
            for (let i = game.poisonClouds.length - 1; i >= 0; i--) {
                const c = game.poisonClouds[i];
                c.life--;
                c.tickTimer++;
                // Every 30 frames (0.5s) apply damage + poison to enemies inside
                if (c.tickTimer >= 30) {
                    c.tickTimer = 0;
                    const r2 = c.radius * c.radius;
                    game.enemies.forEach(e => {
                        const dx = e.x - c.x; const dy = e.y - c.y;
                        if (dx*dx + dy*dy <= r2) {
                            // Apply light damage & poison status
                            const dmg = Math.max(3, Math.round(c.life / c.maxLife * 6)); // scales down as cloud fades
                            e.health -= dmg;
                            addDamageNumber(dmg, e.x, e.y - e.size/2 - 4, { type:'toxic' });
                            // Poison effect augment
                            e.poisoned = true;
                            e.poisonTime = Math.max(e.poisonTime || 0, 120); // 2s poison refresh
                            addParticle(e.x + (Math.random()*10-5), e.y + (Math.random()*10-5), '#55FF88', 'damage');
                        }
                    });
                }
                if (c.life <= 0) {
                    game.poisonClouds.splice(i,1);
                }
            }
        }

        // Fragment Wake spark updater
        function updateFragmentSparks() {
            if (!Array.isArray(game.fragmentSparks) || game.fragmentSparks.length === 0) return;
            for (let i = game.fragmentSparks.length - 1; i >= 0; i--) {
                const s = game.fragmentSparks[i];
                s.ttl--;
                s.pulse += 0.32 + Math.random()*0.05;
                // Light jitter for lively flicker
                s.x += (Math.random()-0.5)*0.6;
                s.y += (Math.random()-0.5)*0.6;
                // Damage tick (every 12 frames baseline)
                s.dpsTick = (s.dpsTick||0)+1;
                if (s.dpsTick >= 12) {
                    s.dpsTick = 0;
                    if (game.enemies && game.enemies.length) {
                        for (const enemy of game.enemies) {
                            const dx = enemy.x - s.x; const dy = enemy.y - s.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist <= s.r + enemy.size*0.5) {
                                const key = enemy._id || (enemy._id = Symbol());
                                if (!s.hitMap.has(key)) {
                                    s.hitMap.add(key);
                                    const dmg = s.damage;
                                    enemy.health -= dmg;
                                    addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type:'fire' });
                                    if (Math.random()<0.25) addParticle(enemy.x, enemy.y, '#FFC977','spark');
                                }
                            }
                        }
                    }
                }
                if (s.ttl <= 0) {
                    game.fragmentSparks.splice(i,1);
                }
            }
        }

        // Periodic nuke strike update handler (Oppemheimer ability)
        function updateNukes() {
            if (!Array.isArray(game.nukes) || game.nukes.length === 0) return;
            const now = Date.now();
            for (let i = game.nukes.length - 1; i >= 0; i--) {
                const n = game.nukes[i];
                if (!n) { game.nukes.splice(i,1); continue; }
                // Trigger explosion when warning time elapses
                if (!n.exploded && now >= n.impactAt) {
                    n.exploded = true;
                    n.flashTime = 34; // frames of flash
                    n._flashMax = n.flashTime;
                    addScreenShake(40);
                    // Damage enemies in radius with falloff (40% edge -> 100% center)
                    const baseDamage = calculateDamage() * 6 + 80;
                    const r = n.radius;
                    game.enemies.forEach(e => {
                        const dx = e.x - n.x; const dy = e.y - n.y; const dist = Math.hypot(dx,dy);
                        if (dist <= r) {
                            const falloff = 1 - 0.6 * (dist / r); // dist=0 =>1, dist=r => 0.4
                            const dmg = Math.round(baseDamage * falloff);
                            e.health -= dmg;
                            addDamageNumber(dmg, e.x, e.y - e.size/2 - 6, { color:'#ffdd55', big:true });
                            // Splash particles per enemy hit
                            for (let p=0;p<8;p++) {
                                const ang = Math.random()*Math.PI*2;
                                const spd = 2 + Math.random()*4;
                                addParticle(e.x, e.y, '#ffbb33', 'explosion');
                            }
                        }
                    });
                    // Central explosion particle bloom
                    for (let p=0;p<150;p++) {
                        const ang = Math.random()*Math.PI*2;
                        const dist = Math.random()*n.radius;
                        const px = n.x + Math.cos(ang)*dist*0.4; // concentrate a bit
                        const py = n.y + Math.sin(ang)*dist*0.4;
                        addParticle(px, py, (Math.random()<0.15?'#ffffff':(Math.random()<0.5?'#ffcc55':'#ff8822')), 'explosion');
                    }
                }
                // Decay flash
                if (n.exploded) {
                    n.flashTime -= 1;
                    if (n.flashTime <= 0) {
                        // Remove once flash over
                        game.nukes.splice(i,1);
                    }
                }
            }
        }

        function updateDamageNumbers() {
            if (!game.damageNumbers) return;
            for (let i = game.damageNumbers.length - 1; i >= 0; i--) {
                const dn = game.damageNumbers[i];
                dn.x += dn.vx;
                dn.y += dn.vy;
                dn.vy += 0.04; // slight gravity to curve path
                dn.life--;
                dn.scale *= 0.991; // gentle shrink
                if (dn.life <= 0) game.damageNumbers.splice(i,1);
            }
        }

        function updatePlayer() {
            let dx = 0, dy = 0;
            let speed = game.player.speed;
            
            // Apply speed multipliers
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.speedMultiplier) {
                    speed *= abilityData.effect.speedMultiplier;
                }
            });
            
            if (game.keys['w']) { dy -= speed; game.player.lastDirection = { x: 0, y: -1 }; game.player.facing = 'up'; }
            if (game.keys['s']) { dy += speed; game.player.lastDirection = { x: 0, y: 1 }; game.player.facing = 'down'; }
            if (game.keys['a']) { dx -= speed; game.player.lastDirection = { x: -1, y: 0 }; game.player.facing = 'left'; }
            if (game.keys['d']) { dx += speed; game.player.lastDirection = { x: 1, y: 0 }; game.player.facing = 'right'; }
            
            const newX = game.player.x + dx;
            const newY = game.player.y + dy;
            
            if (!isWall(newX, newY)) {
                game.player.x = Math.max(25, Math.min(newX, canvas.width - 25));
                game.player.y = Math.max(25, Math.min(newY, canvas.height - 25));
            }

            // Movement & animation state
            game.player.moving = (dx !== 0 || dy !== 0);
            if (game.player.spriteLoaded) {
                if (game.player.moving) {
                    game.player.animTimer++;
                    if (game.player.animTimer >= game.player.animSpeed) {
                        game.player.animTimer = 0;
                        game.player.animFrame = (game.player.animFrame + 1) % game.player.spriteMeta.cols;
                    }
                } else {
                    // Idle: frame 0 (could later add separate idle row or subtle bob)
                    game.player.animFrame = 0;
                    game.player.animTimer = 0;
                }
            }
            
            // Attack handling
            // Base cooldown in ms. Previous model multiplied divisively (compounded) which blew up with many sources.
            // New model: treat (attackSpeedMultiplier - 1) as additive bonuses.
            // Example: +100% (2.0) and +150% (2.5) => total bonus = (1.0 + 1.5)=2.5 => effective multiplier = 1 + 2.5 = 3.5.
            // Effective cooldown = base / (1 + sumBonuses).
            let baseAttackCooldown = 300;
            let attackSpeedBonusSum = 0; // sum of (multiplier - 1)
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.attackSpeedMultiplier) {
                    attackSpeedBonusSum += (abilityData.effect.attackSpeedMultiplier - 1);
                }
            });
            const effectiveAttackSpeedMult = 1 + attackSpeedBonusSum;
            let attackCooldown = baseAttackCooldown / effectiveAttackSpeedMult;
            
            if (game.keys[' '] && Date.now() - game.lastAttack > attackCooldown) {
                attack();
                game.lastAttack = Date.now();
            }

            // Continuous beam weapons: while holding space, spawn short beam segments at a high rate
            if (game.keys[' '] && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'laser' && ABILITIES[a].effect.continuous)) {
                // spawn extra mini-attacks without resetting lastAttack to allow continuous fire
                // create a rapid beam segment every 50ms
                if (!game._lastBeamSpawn || Date.now() - game._lastBeamSpawn > 50) {
                    // mimic a single projectile spawn in the direction of lastDirection
                    const dir = game.player.lastDirection;
                    const angle = Math.atan2(dir.y, dir.x);
                    const speed = 12;
                    const proj = {
                        x: game.player.x + Math.cos(angle) * 28,
                        y: game.player.y + Math.sin(angle) * 28,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 18,
                        size: 8,
                        beam: true,
                        beamOwner: 'player',
                        damage: calculateDamage(),
                        enemy: false
                    };
                    game.projectiles.push(proj);
                    game._lastBeamSpawn = Date.now();
                    addParticle(proj.x, proj.y, '#99EEFF', 'spark');
                }
            }

            // Ion Cannon: charge while holding space, release a single heavy blast on release
            if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'ion' && ABILITIES[a].effect.chargeShot)) {
                // increment charge while holding
                if (game.keys[' ']) {
                    game._ionChargeTime = (game._ionChargeTime || 0) + 1;
                    if (game._ionChargeTime > 100) game._ionChargeTime = 100; // cap
                    if (Math.random() < 0.08) addParticle(game.player.x + (Math.random()-0.5)*24, game.player.y + (Math.random()-0.5)*24, '#99FFEE', 'spark');
                } else if (game._ionChargeTime && game._ionChargeTime > 0) {
                    // on release, fire charged ion blast (one big projectile)
                    if (!game._lastIonFire || Date.now() - game._lastIonFire > 120) {
                        const angle = Math.atan2(game.player.lastDirection.y, game.player.lastDirection.x);
                        const charge = Math.min(1.0, game._ionChargeTime / 80);
                        const speed = 10 + Math.floor(charge * 18);
                        const proj = {
                            x: game.player.x + Math.cos(angle) * 28,
                            y: game.player.y + Math.sin(angle) * 28,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 160,
                            size: 14 + Math.floor(charge * 12),
                            energyType: 'ion',
                            enemy: false,
                            ionCharge: charge,
                            damage: Math.floor(calculateDamage() * (1.4 + charge * 2.2)),
                            pierceCount: 6,
                            piercing: true
                        };
                        game.projectiles.push(proj);
                        for (let p=0;p<8;p++) addParticle(proj.x + (Math.random()-0.5)*24, proj.y + (Math.random()-0.5)*24, '#AAEEFF', 'explosion');
                        addScreenShake(6 + Math.floor(charge*6));
                        game._lastIonFire = Date.now();
                    }
                    game._ionChargeTime = 0;
                }
            }
            
            if (game.keys['enter'] && game.roomCleared) {
                nextRoom();
            }
            
            // Handle invulnerability frames
            if (game.player.invulnerable) {
                game.player.invulnTime--;
                if (game.player.invulnTime <= 0) {
                    game.player.invulnerable = false;
                }
            }
            
            // Regeneration
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.regen) {
                    game.player.health = Math.min(game.player.maxHealth, 
                        game.player.health + abilityData.effect.regen * 0.016);
                    updateUI();
                }
            });
        }

        function attack() {
            game.shotCounter++;
            // Play a minimal attack SFX (rate-limited) once per attack invocation (not per projectile)
            if (typeof playAttackSfx === 'function') playAttackSfx();
            // Multi-shot stacking logic
            let projectileCount = 1;
            let shotgunBlast = false;
            let multiShotCount = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.projectileCount) {
                    multiShotCount += abilityData.effect.projectileCount;
                }
                if (abilityData && abilityData.effect.shotgunBlast) {
                    shotgunBlast = true;
                }
            });
            if (shotgunBlast) {
                projectileCount = multiShotCount + 5;
            } else if (multiShotCount > 0) {
                projectileCount = multiShotCount;
            }
            // Defensive: if lastDirection is still the old default or zeroed, realign with facing so first
            // shot direction matches the sprite orientation. This can happen if a legacy save/object
            // persisted without movement input before first attack.
            if (game.player) {
                const ld = game.player.lastDirection || {x:0,y:0};
                const nearZero = Math.abs(ld.x) < 0.0001 && Math.abs(ld.y) < 0.0001;
                const legacyRight = ld.x === 1 && ld.y === 0 && game.player.facing && game.player.facing !== 'right';
                if (nearZero || legacyRight) {
                    switch (game.player.facing) {
                        case 'up': game.player.lastDirection = {x:0,y:-1}; break;
                        case 'down': game.player.lastDirection = {x:0,y:1}; break;
                        case 'left': game.player.lastDirection = {x:-1,y:0}; break;
                        case 'right': game.player.lastDirection = {x:1,y:0}; break;
                        default: if (nearZero) game.player.lastDirection = {x:0,y:1};
                    }
                }
            }
            const dir = game.player.lastDirection;
            let targetEnemy = null;
            // Auto-aim
            if (game.player.abilities.includes('Auto-Aim')) {
                let closestDist = Infinity;
                game.enemies.forEach(enemy => {
                    const dist = Math.sqrt((enemy.x - game.player.x) ** 2 + (enemy.y - game.player.y) ** 2);
                    if (dist < closestDist) {
                        closestDist = dist;
                        targetEnemy = enemy;
                    }
                });
            }
            // Determine pattern modifiers from abilities
            const hasOmni = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.omniDirectional);
            const hasRadial = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.radialBurst);
            const hasSpiral = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.spiralPattern);
            const hasUzumaki = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.uzumaki);
            const hasCross = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.crossPattern);
            const hasRandomSpread = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.randomSpread);

            // Pattern count handling: Some pattern abilities define a baseline number of directions.
            // Radial Burst wants 16 evenly spaced shots. Omni Shot wants 8. If the player has additional
            // multi-shot bonuses exceeding the pattern baseline, we keep the higher number so stacking
            // projectile count still scales patterns (i.e., 20-way radial if they somehow stack enough).
            // Ensure Cross Shot provides at least a baseline number BEFORE other pattern scaling so it isn't overwritten.
            const CROSS_MIN_PROJECTILES = 4; // Adjust to raise/lower baseline for Cross Shot
            if (hasCross && projectileCount < CROSS_MIN_PROJECTILES) {
                projectileCount = CROSS_MIN_PROJECTILES;
            }
            const baseMultiBeforePattern = projectileCount; // capture current multi-shot total (after Cross minimum)
            if (hasRadial) {
                // Radial Burst: baseline 16; scale if multi-shot already exceeds
                projectileCount = Math.max(baseMultiBeforePattern, 16);
            } else if (hasOmni) {
                // Omni Shot scaling: previously enforced minimum of 8.
                // New behavior: multiply base multi-shot count into directional set.
                // Example: baseMultiBeforePattern = 5 (e.g., Penta Shot) => 5 * 8 = 40-way omni.
                // If player has only Omni (base=1) => 8 directions (unchanged base case).
                const scaled = baseMultiBeforePattern * 8;
                projectileCount = Math.max(scaled, 8);
            } else if (hasCross) {
                // Cross Shot scaling:
                // Minimum 4 shots (one per orthogonal axis). When multi-shot adds more, we allocate them
                // across the 4 arms (Right, Down, Left, Up) evenly. Each arm beyond its first shot fans
                // slightly using a symmetric angular spread so stacking multi-shot meaningfully increases
                // coverage instead of just repeating the same four directions.
                // Example allocations (baseMultiBeforePattern = n after multi-shot):
                // 1..4 => upgraded to 4 (R,D,L,U)
                // 5 => R,D,L,U + 1 extra (goes to Right arm)
                // 8 => 2 per arm
                // 12 => 3 per arm, etc.
                projectileCount = Math.max(baseMultiBeforePattern, CROSS_MIN_PROJECTILES);
            }
            const patternCount = projectileCount; // final number of shots to emit

            // Defensive: ensure all pattern guard flags are defined before conditional spread tweaks
            const hasQuad = game.player.abilities.includes('Quad Shot');

            for (let i = 0; i < projectileCount; i++) {
                let angle;
                // Base angle towards target or last direction
                if (targetEnemy && game.player.abilities.includes('Auto-Aim') && !hasOmni && !hasRadial && !hasCross) {
                    const dx = targetEnemy.x - game.player.x;
                    const dy = targetEnemy.y - game.player.y;
                    angle = Math.atan2(dy, dx);
                } else {
                    angle = Math.atan2(dir.y, dir.x);
                }

                // Pattern-specific angle calculations
                if (hasOmni) {
                    angle = (i / patternCount) * Math.PI * 2;
                } else if (hasRadial) {
                    angle = (i / patternCount) * Math.PI * 2;
                } else if (hasCross) {
                    // Distribute projectiles into 4 arms with per-arm spread.
                    const baseAngles = [0, Math.PI/2, Math.PI, 3*Math.PI/2]; // R, D, L, U
                    const perArm = Math.ceil(patternCount / 4); // logical capacity per arm (not all arms may reach this if remainder)
                    // Determine which arm this index maps to using a round-robin so early extras distribute evenly.
                    // Alternative approach: fill arms sequentially (could bias Right). Round-robin is fairer.
                    const armIndex = i % 4; // 0..3
                    const occurrence = Math.floor(i / 4); // which pass on that arm
                    const armAngle = baseAngles[armIndex];
                    // Count how many projectiles actually end up on this arm to compute spread width.
                    // Derive total shots assigned to armIndex: either occurrence+1 or occurrence based on remainder.
                    // Simpler: compute allShotsForArm by iterating patternCount mod 4 distribution math.
                    let allShotsForArm = Math.floor(patternCount / 4);
                    if (armIndex < (patternCount % 4)) allShotsForArm += 1; // first remainder arms get one extra
                    // Spread parameters: max +/- spreadAngle radians for edge shots; diminishing with more per arm.
                    const spreadAngleMax = 0.35; // ~20 degrees each side
                    if (allShotsForArm <= 1) {
                        angle = armAngle;
                    } else {
                        // Map occurrence (0..allShotsForArm-1) to symmetric offsets centered at 0.
                        // Use normalized position: k in [0, allShotsForArm-1]. offsetIndex = k - (N-1)/2
                        const offsetIndex = occurrence - (allShotsForArm - 1) / 2;
                        const normalized = (allShotsForArm <= 1) ? 0 : offsetIndex / ((allShotsForArm - 1) / 2);
                        const offset = spreadAngleMax * normalized; // linear; could adopt curve if needed
                        angle = armAngle + offset;
                    }
                } else if (hasSpiral) {
                    // For spiral shots, keep the primary firing direction aligned with player,
                    // but add a very small per-shot offset so multi-shot spirals spread lightly.
                    // The in-flight spiral looping behavior is handled in updateProjectiles().
                    angle += (i - (patternCount - 1) / 2) * 0.02;
                } else if (hasUzumaki) {
                    // Uzumaki: projectiles emitted in a continuously rotating global spiral around player.
                    // Instead of directional spread, we rotate emission angle based on global shotCounter so streams form.
                    // Use shotCounter + index to stagger multi-shot contributions.
                    const spinBase = (game.shotCounter * 0.35) + i * 0.6; // radians progression
                    angle = spinBase % (Math.PI*2);
                } else {
                    if (shotgunBlast || projectileCount > 1) {
                        const spread = shotgunBlast ? 0.6 : 0.4;
                        angle += (i - (projectileCount - 1) / 2) * spread / projectileCount;
                    }
                }


                // Random spread abilities add unpredictable deviation
                if (hasRandomSpread) {
                    angle += (Math.random() - 0.5) * 1.2; // wide random spread
                }

                let speed = 6;
                let size = 4;
                let piercing = game.player.abilities.includes('Pierce Shot') || game.player.abilities.includes('Multi-Pierce');
                let pierceCount = game.player.abilities.includes('Multi-Pierce') ? 999 : 3;
                let homing = game.player.abilities.includes('Homing Shot');
                let weakHoming = game.player.abilities.includes('Seeking Shot');
                let bouncing = game.player.abilities.includes('Bouncing Shot');
                let explosive = game.player.abilities.includes('Explosive Shot');
                // Split Shot removed (previously set splitting flag here)
                let growing = game.player.abilities.includes('Growing Shot');
                // Spiral shot: causes the projectile to curve/rotate in-flight
                let spiral = game.player.abilities.includes('Spiral Shot');
                let bounces = 0;
                // explicit per-attack flags (populated below from ability effects)
                let boomerangFlag = false;
                let orbitalFlag = false;
                let drillingFlag = false;
                let phasingFlag = false;
                let teleportingFlag = false;

                // Map a few ability flags that weren't previously wired up
                game.player.abilities.forEach(ability => {
                    const abilityData = ABILITIES[ability];
                    if (!abilityData || !abilityData.effect) return;
                    if (abilityData.effect.projectileSpeed) speed *= abilityData.effect.projectileSpeed;
                    if (abilityData.effect.projectileSize) size *= abilityData.effect.projectileSize;
                    if (abilityData.effect.novaBlast || abilityData.effect.smartExplosive) explosive = true;
                    // Bouncing behavior: support both 'ricochet' (enemy->enemy) and 'bouncing' (wall bounces)
                    if (abilityData.effect.ricochet) {
                        bouncing = true;
                        bounces = Math.max(bounces, abilityData.effect.bounces || 3);
                    }
                    if (abilityData.effect.bouncing) {
                        bouncing = true;
                        bounces = Math.max(bounces, abilityData.effect.bounces || 3);
                    }
                    if (abilityData.effect.ricochet && abilityData.effect.bounces) bounces = Math.max(bounces, abilityData.effect.bounces);
                    if (abilityData.effect.boomerang) boomerangFlag = true;
                    if (abilityData.effect.orbital) orbitalFlag = true;
                    if (abilityData.effect.drilling) drillingFlag = true;
                    if (abilityData.effect.phasing) phasingFlag = true;
                    if (abilityData.effect.teleporting) teleportingFlag = true;
                    if (abilityData.effect.weaponType === 'dagger' && abilityData.effect.projectileCount) { /* handled by projectileCount */ }
                });
                // Defensive: if bouncing was enabled but no explicit bounces value assigned by any ability effect, fall back to 3
                if (bouncing && bounces === 0) bounces = 3;

                const projectile = {
                    x: game.player.x + Math.cos(angle) * 20,
                    y: game.player.y + Math.sin(angle) * 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 150,
                    // snapshot base damage so later effects (explosions, splits, beams) scale consistently
                    baseDamage: calculateDamage(),
                    size: size,
                    // store the starting size so growth can scale relative to it (fixes interaction with abilities that change initial size)
                    _initialSize: size,
                    piercing: piercing,
                    pierceCount: pierceCount,
                    pierceHits: 0,
                    homing: homing,
                    weakHoming: weakHoming,
                    bouncing: bouncing,
                    initialBounces: (bouncing ? (bounces || 3) : 0),
                    bounces: (bouncing ? (bounces || 3) : 0),
                    explosive: explosive,
                    growing: growing,
                    // Spiral properties (only used when spiral=true)
                    spiral: spiral,
                    uzumaki: hasUzumaki,
                    spinAngle: spiral ? angle : 0,
                    spinSpeed: spiral ? (0.22 + Math.random() * 0.18) : 0,
                    spinDir: spiral ? (Math.random() < 0.5 ? -1 : 1) : 1,
                    spiralGrow: spiral ? 0.008 : 0,
                    // capture initial forward unit vector so spiral uses firing direction even if homing adjusts velocity later
                    _initialFx: Math.cos(angle),
                    _initialFy: Math.sin(angle),
                    // Boomerang/orbital/drill properties (explicitly wired from ability effects)
                    boomerang: boomerangFlag,
                    boomerangReturned: false,
                    orbital: orbitalFlag,
                    drilling: drillingFlag,
                    phasing: phasingFlag,
                    teleporting: teleportingFlag,
                    ricochet: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.ricochet) || false,
                    smartExplosive: game.player.abilities.some(a => ABILITIES[a] && (ABILITIES[a].effect.smartExplosive || ABILITIES[a].effect.novaBlast)) || false,
                    // Additional mapped effects
                    damageType: (function(){
                        for (const ab of game.player.abilities) {
                            const d = ABILITIES[ab] && ABILITIES[ab].effect && ABILITIES[ab].effect.damageType;
                            if (d) return d;
                        }
                        return null;
                    })(),
                    areaEffect: (function(){
                        for (const ab of game.player.abilities) {
                            const ae = ABILITIES[ab] && ABILITIES[ab].effect && ABILITIES[ab].effect.areaEffect;
                            if (ae) return true;
                        }
                        return false;
                    })(),
                    // Respect ignore flags from ABILITIES (Dimensional Rift, Reality Break, etc.)
                    ignoresArmor: (function(){
                        for (const ab of game.player.abilities) {
                            const v = ABILITIES[ab] && ABILITIES[ab].effect && ABILITIES[ab].effect.ignoresArmor;
                            if (v) return true;
                        }
                        return false;
                    })(),
                    ignoresEverything: (function(){
                        for (const ab of game.player.abilities) {
                            const v = ABILITIES[ab] && ABILITIES[ab].effect && ABILITIES[ab].effect.ignoresEverything;
                            if (v) return true;
                        }
                        return false;
                    })(),
                    spreading: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect && ABILITIES[a].effect.spreading) || false,
                    energyType: (function(){
                        for (const ab of game.player.abilities) {
                            const et = ABILITIES[ab] && ABILITIES[ab].effect && ABILITIES[ab].effect.energyType;
                            if (et) return et;
                        }
                        return null;
                    })(),
                    weaponType: (function(){
                        // Collect ALL owned weapon types instead of returning first match so visuals can rotate.
                        const owned = [];
                        for (const ab of game.player.abilities) {
                            const wt = ABILITIES[ab] && ABILITIES[ab].effect && ABILITIES[ab].effect.weaponType;
                            if (wt) owned.push(wt);
                        }
                        if (!owned.length) return null;
                        // Randomly select one for this projectile so multiple weapon abilities visually stack instead of replacing.
                        return owned[(Math.random()*owned.length)|0];
                    })(),
                    knockback: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.knockback) || false,
                    // Determine highest knockback distance among abilities (Wind Blade provides large push) default later to 28 if 0
                    knockbackDistance: (function(){ let d=0; game.player.abilities.forEach(a=>{ const ad=ABILITIES[a]; if(ad&&ad.effect&&ad.effect.knockbackDistance) d=Math.max(d, ad.effect.knockbackDistance); }); return d; })(),
                    armorPiercing: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.armorPiercing) || false,
                    lifeSteal: (function(){
                        let total = 0;
                        game.player.abilities.forEach(ability => {
                            const ad = ABILITIES[ability];
                            if (ad && ad.effect && ad.effect.lifeSteal) total += ad.effect.lifeSteal;
                        });
                        return total;
                    })(),
                    shockwave: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.shockwave) || false,
                    timeWarp: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.timeWarp) || false,
                    blackHole: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.blackHole) || false,
                    vortex: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.vortex) || false,
                    quantum: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.quantum) || false,
                    // multi-hit projectiles (Quantum Shot)
                    hitMultipleTimes: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.hitMultipleTimes) || false,
                    remainingHits: (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.hitMultipleTimes) ? 3 : 0),
                    antimatter: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.antimatter) || false,
                    massiveExplosion: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.massiveExplosion) || false,
                    dimensional: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.dimensional) || false,
                    realityBreak: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.realityBreak) || false,
                    chainExplosion: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.chainExplosion) || false,
                    // Sine wave projectile motion flag and parameters (initialized later in updateProjectiles)
                    sineWave: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.sineWave) || false,
                    wackyZigzag: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.wackyZigzag) || false,
                    ekgWave: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.ekgWave) || false,
                    // If antimatter or massiveExplosion is present, also mark projectile explosive so it triggers area blasts
                    explosive: explosive || game.player.abilities.some(a => ABILITIES[a] && (ABILITIES[a].effect.antimatter || ABILITIES[a].effect.massiveExplosion)) || false,
                    instantTravel: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.instantTravel) || false,
                    enemy: false
                };

                // New pattern flags from abilities
                projectile.lissajousPattern = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.lissajousPattern) || false;
                projectile.slalomPattern = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.slalomPattern) || false;
                projectile.pendulumPattern = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.pendulumPattern) || false;
                projectile.sawWave = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.sawWave) || false;
                projectile.phaseEcho = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.phaseEcho) || false;
                projectile.resonantPulseCore = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.resonantPulseCore) || false;
                projectile.pivotPattern = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.pivotPattern) || false;
                projectile.convergePair = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.convergePair) || false;
                projectile.fragmentWake = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.fragmentWake) || false;
                projectile.spiralBloom = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.spiralBloom) || false;
                projectile.harmonicSplit = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.harmonicSplit) || false;
                projectile.gyroStabilizer = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.gyroStabilizer) || false;
                projectile.temporalDrift = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.temporalDrift) || false;
                projectile.veeringFan = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.veeringFan) || false;
                projectile.echoBloom = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.echoBloom) || false;
                projectile.bloomRing = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.bloomRing) || false;
                projectile.cascadeBurst = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.cascadeBurst) || false;
                projectile.helixPair = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.helixPair) || false;

                // Helix Pair: spawn a mirrored twin once (avoid for beams/meteors/orbitals to reduce spam)
                if (projectile.helixPair && !projectile.beam && !projectile.orbital && !projectile.meteor) {
                    // Convert current projectile into side = -1 and spawn +1 twin
                    projectile._helixSide = -1;
                    projectile._helixRadius = 26; // increased starting lateral separation
                    projectile._helixTargetRadius = 42; // target max separation reached over time
                    projectile._helixPhase = 0;
                    const twin = { ...projectile };
                    twin.x = projectile.x; twin.y = projectile.y;
                    twin._helixSide = 1;
                    // Reduce base damage slightly per twin to keep total DPS sane
                    if (twin.baseDamage) twin.baseDamage = Math.max(1, Math.floor(twin.baseDamage * 0.85));
                    if (projectile.baseDamage) projectile.baseDamage = Math.max(1, Math.floor(projectile.baseDamage * 0.85));
                    game.projectiles.push(twin);
                }

                // Converging Twins: spawn paired projectile with a divergence/convergence state machine
                if (projectile.convergePair && !projectile._convergeSpawned) {
                    const groupId = Symbol('convTwins');
                    projectile._convergeSpawned = true;
                    projectile._convGroup = groupId;
                    projectile._convPhase = 'diverge';
                    projectile._convTimer = 0;
                    projectile._convPrimary = true; // mark original
                    // Give each twin its own angle offset (wider than before for visible separation)
                    const off = 0.48; // radians separation each side
                    const baseAng = angle;
                    // Modify original projectile velocity to negative offset
                    projectile.vx = Math.cos(baseAng - off) * speed;
                    projectile.vy = Math.sin(baseAng - off) * speed;
                    projectile._convSide = -1;
                    const twin = { ...projectile };
                    twin.x = projectile.x; twin.y = projectile.y;
                    twin.vx = Math.cos(baseAng + off) * speed;
                    twin.vy = Math.sin(baseAng + off) * speed;
                    twin._convSide = 1;
                    twin._convPrimary = false;
                    // Slight per-twin base damage reduction so combined + fuse burst doesn't spike too high
                    if (projectile.baseDamage) projectile.baseDamage = Math.max(1, Math.floor(projectile.baseDamage * 0.9));
                    if (twin.baseDamage) twin.baseDamage = Math.max(1, Math.floor(twin.baseDamage * 0.9));
                    twin._convGroup = groupId;
                    game.projectiles.push(twin);
                }

                // Veering Fan: mark for later conversion mid-flight (handled in update)
                if (projectile.veeringFan) {
                    // Store spawn state for distance-based gating so fanning doesn't occur right at the muzzle.
                    projectile._veeringTimer = 22 + Math.floor(Math.random()*12); // slightly longer baseline
                    projectile._veerMinDist = 80; // must travel at least this many pixels before fanning
                    projectile._spawnX = projectile.x;
                    projectile._spawnY = projectile.y;
                }

                // Harmonic Split: record thresholds for life-based splitting
                if (projectile.harmonicSplit) {
                    projectile._harmonicThresholds = [ Math.floor(projectile.life * 0.7), Math.floor(projectile.life * 0.4) ];
                    projectile._harmonicDone = {};
                }

                // Echo Bloom: schedule echo spawn
                if (projectile.echoBloom) {
                    projectile._echoTriggered = false;
                    projectile._echoLifePoint = Math.floor(projectile.life * 0.6);
                }

                // Wacky Chaos Synergy Flag
                // Conditions: Must have Wacky Zigzag AND (Random Spread OR (Omni/Radial pattern) OR BOTH sineWave & ekgWave)
                // Rationale: Encourage combining multiple motion-modifying abilities before escalating to chaos intensity.
                if (projectile.wackyZigzag) {
                    const hasRandomSpreadSynergy = hasRandomSpread;
                    const hasMultiDirectionalSynergy = hasOmni || hasRadial;
                    const hasWaveStackSynergy = projectile.sineWave && projectile.ekgWave; // both waves present
                    if (hasRandomSpreadSynergy || hasMultiDirectionalSynergy || hasWaveStackSynergy) {
                        projectile._wackyChaos = true;
                        // Pre-initialize chaos tuning fields (used in updateProjectiles for burst logic)
                        projectile._wackyChaosTimer = 0;      // counts frames until next chaos direction event
                        projectile._wackyChaosInterval = 8 + Math.floor(Math.random()*10); // dynamic; will shrink randomly
                        projectile._wackyChaosBurst = 0;       // frames of active burst speed modulation
                        projectile._wackyChaosLastFlip = 0;    // track last 180 flip frame to space dramatic turns
                    }
                }

                // Time Bomb ability wiring (was missing): convert ONE projectile per attack into a delayed explosive charge.
                // Design: Only the first spawned projectile of an attack cycle becomes the timed bomb to avoid flooding.
                if (!projectile.energyType && !projectile.orbital && i === 0 && game.player.abilities.includes('Time Bomb')) {
                    projectile.timeBomb = true;
                    // Heavier, slightly slowed, but still does contact damage now.
                    projectile.vx *= 0.62;
                    projectile.vy *= 0.62;
                    projectile.size = Math.max(projectile.size, 12);
                    // Shorter fuse for better pacing (~0.9s at 60fps)
                    projectile._timeBombTimer = 54; // frames
                    projectile._timeBombArmed = false;
                    // Allow a few pierces pre-detonation so it can travel through small crowds lightly
                    projectile.piercing = true;
                    projectile.pierceCount = 4;
                    // No suppression of on-hit damage anymore
                    projectile._suppressOnHitDamage = false;
                    // Store amplified explosion multiplier for central blast deterministically
                    projectile._timeBombExplosionMult = 2.0; // can tune later
                }

                // Meteor ability: spawn auxiliary falling meteor (no longer blocked by energy/orbital projectiles).
                // Previously gated by !projectile.energyType && !projectile.orbital which prevented meteors when using beams.
                // Regression fix: allow spawning with any weapon type; still only once per attack (i===0).
                if (i === 0 && game.player.abilities.includes('Meteor')) {
                    const ringRadius = 180 + Math.random()*60; // spawn origin distance
                    const spawnAng = Math.random()*Math.PI*2;
                    const spawnX = game.player.x + Math.cos(spawnAng) * ringRadius;
                    const spawnY = game.player.y + Math.sin(spawnAng) * ringRadius - (120 + Math.random()*80); // elevated so it descends diagonally
                    const targetRadius = 140; // landing ring
                    const targetAng = Math.random()*Math.PI*2;
                    const targetX = game.player.x + Math.cos(targetAng) * (40 + Math.random()*targetRadius);
                    const targetY = game.player.y + Math.sin(targetAng) * (40 + Math.random()*targetRadius);
                    const travelTime = 70 + Math.floor(Math.random()*35); // frames until impact/telegraph end
                    const meteor = {
                        meteor: true,
                        enemy: false,
                        x: spawnX,
                        y: spawnY,
                        vx: (targetX - spawnX) / travelTime,
                        vy: (targetY - spawnY) / travelTime,
                        size: 20,
                        life: travelTime + 6,
                        baseDamage: Math.floor((projectile.baseDamage || calculateDamage()) * 2.6 + 45),
                        damageType: 'fire',
                        explosive: true,
                        _meteorAoeRadius: 90,
                        _meteorDetonateAt: game.frame + travelTime,
                        _meteorKnockback: 120,
                        pierceHits: 0,
                        pierceCount: 0,
                        homing: false,
                        bouncing: false,
                        // (legacy splitting flag removed)
                        spiral: false,
                        _meteorTargetX: targetX,
                        _meteorTargetY: targetY
                    };
                    if (!game.meteorMarkers) game.meteorMarkers = [];
                    game.meteorMarkers.push({
                        x: targetX,
                        y: targetY,
                        created: Date.now(),
                        life: (travelTime/60)*1000, // ms approximation for fade logic
                        pulse: 0,
                        _explodeFrame: meteor._meteorDetonateAt
                    });
                    meteor._meteorMarkerId = game.meteorMarkers.length - 1;
                    // Store deterministic spawn metadata for interpolation
                    meteor._meteorSpawnFrame = game.frame;
                    meteor._meteorStartX = meteor.x;
                    meteor._meteorStartY = meteor.y;
                    for (let t=0;t<12;t++) addParticle(meteor.x + (Math.random()-0.5)*18, meteor.y + (Math.random()-0.5)*18, '#FFBB66', 'spark');
                    game.projectiles.push(meteor);
                }

                // Multi-Infusion overlay: attach active infusion elements
                if (game.player && game.player.infusions && game.player.infusions.length) {
                    projectile.infusionElements = game.player.infusions.map(i => ({ type: i.type, potency: i.potency }));
                    // If projectile has no inherent damageType, pick the strongest infusion as primary displayed damageType (for color numbers)
                    if (!projectile.damageType) {
                        let chosen = null; let best = -1;
                        game.player.infusions.forEach(i => { if (i.potency > best) { best = i.potency; chosen = i.type; } });
                        projectile.damageType = chosen;
                    } else {
                        // Already elemental; small additive damage from each infusion (applied later) - mark flag
                        projectile._elementalCore = true;
                    }
                }

                // Toenail Clibbins: emit a cluster of random yellow crescent clippings once per attack primary projectile
                if (i === 0 && game.player.abilities.includes('Toenail Clibbins')) {
                    // Spawn 4–6 crescents each attack cycle
                    const crescents = 4 + Math.floor(Math.random()*3);
                    for (let c=0;c<crescents;c++) {
                        const ang = Math.random() * Math.PI * 2;
                        const spd = 3.1 + Math.random()*2.0; // increased base speed
                        const life = 54 + Math.floor(Math.random()*28); // longer lifespan for farther travel
                        const size = 11 + Math.floor(Math.random()*3);
                        const thicknessRatio = 0.35 + Math.random()*0.25; // controls crescent thickness
                        const arcSweep = (Math.PI * (0.85 + Math.random()*0.25)); // length of visible arc
                        const innerOffset = 0.30 + Math.random()*0.15; // how far to offset inner cut to shape
                        const tintShift = (Math.random()*18 - 9); // slight hue/value shift later
                        game.projectiles.push({
                            x: game.player.x, y: game.player.y,
                            vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
                            life, size, enemy:false,
                            baseDamage: Math.max(1, Math.floor((projectile.baseDamage||calculateDamage()) * 0.38)),
                            damage: Math.max(1, Math.floor((projectile.baseDamage||calculateDamage()) * 0.38)),
                            toenail:true,
                            _crescentPhase: Math.random()*Math.PI*2,
                            _crescentDir: (Math.random()<0.5?-1:1),
                            _tnThickness: thicknessRatio,
                            _tnArcSweep: arcSweep,
                            _tnInnerOffset: innerOffset,
                            _tnTintShift: tintShift
                        });
                    }
                }

                // Popcorn: replace primary projectile with a kernel that later pops into two puffs
                if (i === 0 && game.player.abilities.includes('Popcorn')) {
                    // Convert current projectile to a kernel (keep forward velocity)
                    projectile.isPopcornKernel = true;
                    projectile._popFuse = 22; // frames until pop (tweakable)
                    projectile._popDid = false;
                    // Slightly reduce immediate damage; main damage comes from puffs
                    if (projectile.baseDamage) {
                        projectile.baseDamage = Math.max(1, Math.floor(projectile.baseDamage * 0.55));
                        projectile.damage = projectile.baseDamage;
                    }
                }

                // Umbrella Shot: designate the FIRST projectile of the attack as the umbrella core.
                // It will travel a short distance then split into two arc projectiles that swing overhead and return.
                if (i === 0 && game.player.abilities.includes('Umbrella Shot')) {
                    // Umbrella core travels forward then splits into two 180° opposing arcs.
                    projectile.umbrellaCore = true;
                    projectile._umbOriginX = game.player.x;
                    projectile._umbOriginY = game.player.y;
                    projectile._umbTravel = 0; // forward travel distance accumulator
                    projectile._umbSplitDistance = 160; // longer travel so it doesn't pop right in front
                    projectile._umbDidSplit = false;
                    projectile._umbCoreAge = 0; // frames since fired (failsafe split)
                }

                // Laser Beam special-case: continuous beam energy weapon
                // If player has Laser Beam (energyType: 'laser' and continuous=true), spawn a short-lived beam segment
                if (projectile.energyType === 'laser' && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.continuous)) {
                    // beam segments are shorter-lived and tile along forward direction while holding fire
                    projectile.size = 8;
                    projectile.life = 18; // lifespan of each segment (frames)
                    projectile.vx = Math.cos(angle) * 12;
                    projectile.vy = Math.sin(angle) * 12;
                    projectile.beam = true;
                    projectile.beamOwner = 'player';
                    projectile.damage = calculateDamage();
                    // Beam pattern blending: inherit motion flags for visual modulation, not trajectory displacement
                    projectile.sineWave = projectile.sineWave || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave);
                    projectile.wackyZigzag = projectile.wackyZigzag || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag);
                    projectile.ekgWave = projectile.ekgWave || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave);
                    projectile.spiral = projectile.spiral || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern);
                    projectile._beamPatternPhase = 0;
                }
                // Particle Beam: spawn a separate auxiliary short-range beam segment so base projectile remains unaffected.
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'particle')) {
                    const beamAngle = angle; // align with current shot direction
                    const seg = {
                        beam: true,
                        particleBeam: true,
                        beamOwner: 'player',
                        enemy: false,
                        x: game.player.x + Math.cos(beamAngle) * 8,
                        y: game.player.y + Math.sin(beamAngle) * 8,
                        vx: Math.cos(beamAngle) * 9,
                        vy: Math.sin(beamAngle) * 9,
                        life: 28,
                        size: 13,
                        baseDamage: calculateDamage(),
                        damage: Math.floor(calculateDamage() * 1.6) + 8,
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiral: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern),
                        _beamPatternPhase: 0,
                        // Allow status / infusion synergy
                        infusionElements: (game.player.infusions && game.player.infusions.length) ? game.player.infusions.map(i=>({type:i.type,potency:i.potency})) : null,
                        damageType: 'plasma'
                    };
                    game.projectiles.push(seg);
                }

                // Pulse Rifle: emit a short burst of 3 shots quickly instead of single projectile
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'pulse' && ABILITIES[a].effect.burstFire)) {
                    // spawn two extra micro-projectiles with small delays (simulated by short-lived projectiles)
                    for (let b = 0; b < 2; b++) {
                        const ang = angle + (b === 0 ? -0.06 : 0.06);
                        const p = {
                            x: game.player.x + Math.cos(ang) * 20,
                            y: game.player.y + Math.sin(ang) * 20,
                            vx: Math.cos(ang) * (speed * 1.1),
                            vy: Math.sin(ang) * (speed * 1.1),
                            life: 36,
                            size: Math.max(3, size * 0.8),
                            enemy: false,
                            // snapshot damage and carry key flags so micro-shots behave consistently
                            baseDamage: projectile.baseDamage || calculateDamage(),
                            damage: Math.floor((projectile.baseDamage || calculateDamage()) * 0.8),
                            energyType: 'pulse',
                            damageType: projectile.damageType || null,
                            piercing: projectile.piercing || false,
                            pierceCount: projectile.pierceCount || 1,
                            lifeSteal: projectile.lifeSteal || 0,
                            // Split Shot removed – no splitting propagation
                        };
                        game.projectiles.push(p);
                    }
                }
                // Teleport on spawn: instant blink forward a short distance
                if (projectile.teleporting) {
                    // New behavior: Teleport Shot relocates EACH fired projectile (including multi-shot patterns)
                    // to a random position within a radius around the player, then resumes forward travel.
                    // This occurs only once at spawn. We attempt to find a non-wall location.
                    // Tunable teleport field radius (reduced from 140 to tighten spread for better accuracy)
                    const TELEPORT_SHOT_RADIUS = 88; // px (adjust here for balance)
                    const maxRadius = TELEPORT_SHOT_RADIUS;
                    const attempts = 12;
                    const origX = projectile.x;
                    const origY = projectile.y;
                    let placed = false;
                    for (let a = 0; a < attempts; a++) {
                        // Biased random point: favor nearer teleports so shots stay relatively close.
                        // Use pow(rand, 1.35) to skew toward smaller radii (1 => uniform, >1 => bias inward)
                        const r = Math.pow(Math.random(), 1.35) * maxRadius;
                        const theta = Math.random() * Math.PI * 2;
                        let nx = game.player.x + Math.cos(theta) * r;
                        let ny = game.player.y + Math.sin(theta) * r;
                        // Clamp to arena bounds with small margin
                        const margin = 30;
                        nx = Math.max(margin, Math.min(nx, canvas.width - margin));
                        ny = Math.max(margin, Math.min(ny, canvas.height - margin));
                        if (!isWall(nx, ny, Math.max(10, projectile.size))) {
                            projectile.x = nx;
                            projectile.y = ny;
                            placed = true;
                            break;
                        }
                    }
                    // Visual effects: portal burst at destination + faint trail from origin
                    const trailSteps = 6;
                    for (let i=0;i<trailSteps;i++) {
                        const t = i / (trailSteps - 1);
                        const ix = origX + (projectile.x - origX) * t;
                        const iy = origY + (projectile.y - origY) * t;
                        if (Math.random() < 0.6) addParticle(ix + (Math.random()-0.5)*8, iy + (Math.random()-0.5)*8, '#FFE4AA', 'spark');
                    }
                    for (let p=0;p<10;p++) {
                        addParticle(projectile.x + (Math.random()-0.5)*24, projectile.y + (Math.random()-0.5)*24, '#FFDFAA', 'spark');
                    }
                    // Synergy: augment portal visuals depending on other pattern flags
                    if (projectile.spiral) {
                        for (let s=0;s<8;s++) addParticle(projectile.x, projectile.y, '#FFC877', 'explosion');
                    }
                    if (projectile.sineWave) {
                        for (let w=0;w<6;w++) addParticle(projectile.x + Math.sin(w)*18, projectile.y + Math.cos(w)*18, '#FFF2CC', 'spark');
                    }
                    if (projectile.wackyZigzag) {
                        for (let z=0;z<5;z++) addParticle(projectile.x + (Math.random()-0.5)*30, projectile.y + (Math.random()-0.5)*30, '#FFE0AA', 'spark');
                    }
                    if (projectile.ekgWave) {
                        for (let e=0;e<6;e++) addParticle(projectile.x + (Math.random()-0.5)*14, projectile.y + (Math.random()-0.5)*38, '#FFF6DD', 'spark');
                    }
                }
                if (projectile.meteor) {
                    // Gentle steering toward telegraphed target
                    if (projectile._meteorTargetX != null) {
                        const dxT = projectile._meteorTargetX - projectile.x;
                        projectile.vx = dxT / 140; // slower correction for natural descent
                    }
                    // Impact check: when reaching target Y (or bottom safety) trigger explosion once
                    if (!projectile._meteorDetonated && projectile.y >= (projectile._meteorTargetY || (canvas.height*0.6))) {
                        projectile._meteorDetonated = true;
                        const aoe = projectile._meteorAoeRadius || 80;
                        const dmg = projectile.baseDamage || calculateDamage();
                        // Damage enemies in radius
                        game.enemies.forEach(en => {
                            const dx = en.x - projectile.x; const dy = en.y - projectile.y;
                            if (dx*dx + dy*dy <= aoe*aoe) {
                                en.health -= dmg;
                                addDamageNumber(dmg, en.x, en.y - en.size/2, { type:'fire'});
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                            }
                        });
                        // Visual explosion + screen shake
                        addScreenShake(10);
                        explodeProjectile({x:projectile.x,y:projectile.y,size:projectile.size}, Math.floor(dmg*0.6));
                        for (let p=0;p<30;p++) addParticle(projectile.x + (Math.random()-0.5)*aoe*1.4, projectile.y + (Math.random()-0.5)*aoe*1.4, '#FF8844','explosion');
                        // Clear marker if still present
                        if (typeof projectile._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[projectile._meteorMarkerId]) {
                            game.meteorMarkers[projectile._meteorMarkerId].life = 0; // let render prune it
                        }
                        projectile.life = 0; // remove meteor projectile
                    }
                }
                game.projectiles.push(projectile);
                // Diarrhea ability: spawn a mirrored backward shot with brown color that mirrors forward projectile properties.
                if (game.player.abilities.includes('Diarrhea') && !projectile._rearClone && !projectile.beam) {
                    const rear = {
                        ...projectile,
                        x: game.player.x - Math.cos(angle) * 20,
                        y: game.player.y - Math.sin(angle) * 20,
                        vx: -projectile.vx,
                        vy: -projectile.vy,
                        // Ensure rear clone has independent pierce/ life tracking
                        pierceHits: 0,
                        _rearClone: true,
                        // Always show brown; mark override flag
                        _diarrheaBrown: true,
                        // Force consistent size & clear weapon transformations so it never becomes sword/hammer/etc.
                        weaponType: undefined,
                        spin: false,
                        spinSpeed: 0,
                        spinAngle: 0,
                        size: Math.max(6, projectile.size || 6),
                        // Keep baseDamage snapshot so damage parity maintained
                        baseDamage: projectile.baseDamage,
                        // Prevent double meteor/time bomb / other single-per-attack spawns
                        timeBomb: false,
                        meteor: false,
                        _meteorDetonateAt: undefined,
                        _meteorMarkerId: undefined
                    };
                    // Adjust spin direction for aesthetic variety
                    if (rear.spinSpeed) rear.spinSpeed = -rear.spinSpeed;
                    game.projectiles.push(rear);
                }
                // Weapon-type: Sword Throw -> convert base projectile into spinning blade instead of spawning an extra blocky projectile
                if (projectile.weaponType === 'sword') {
                    // Re-shape / flag existing projectile for sword rendering (drawing code branches on weaponType)
                    projectile.size = Math.max(projectile.size || 10, 14);
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.spin = true;
                    projectile.spinAngle = angle;
                    projectile.spinSpeed = 0.45;
                    // Slightly slow it for readability
                    projectile.vx *= 0.85;
                    projectile.vy *= 0.85;
                    // Shorter lifespan so it feels like a thrown arc
                    projectile.life = Math.min(projectile.life, 34);
                    addParticle(projectile.x, projectile.y, '#CCCCCC', 'spark');
                }
                // Weapon-type: Axe Hurl - heavy single projectile with knockback
                if (projectile.weaponType === 'axe') {
                    projectile.size = Math.max(projectile.size, 16);
                    // If projectile was flagged as growing, ensure its baseline reflects post-weapon inflation so growth can continue.
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.6 + 12);
                    projectile.knockback = true;
                    projectile.piercing = false;
                    projectile.slowOnHit = true;
                }
                // Spear Thrust: ensure strong piercing behavior
                if (projectile.weaponType === 'spear') {
                    projectile.piercing = true;
                    projectile.pierceCount = Math.max(projectile.pierceCount || 3, 4);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.2 + 6);
                }
                // Hammer Slam: heavy knockback and stun on impact
                if (projectile.weaponType === 'hammer') {
                    projectile.size = Math.max(projectile.size, 18);
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.8 + 10);
                    projectile._hammer = true; // handle stun in collision
                }
                // Photon torpedo / instant travel: immediately strike the nearest enemy
                if (projectile.instantTravel && !projectile.enemy) {
                    let target = null;
                    let closest = Infinity;
                    game.enemies.forEach(e => {
                        const d = Math.hypot(e.x - game.player.x, e.y - game.player.y);
                        if (d < closest) { closest = d; target = e; }
                    });
                    if (target) {
                        // Compute base damage & resonance/pattern synergy
                        let dmg = Math.floor((projectile.baseDamage || calculateDamage()) * 1.8);
                        // Minor amplification if multiple core motion patterns active (even if instant) to reward pattern hybrid builds
                        const patternCount = ['sineWave','wackyZigzag','ekgWave','spiralPattern'].reduce((n,f)=>n+(game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect[f])?1:0),0);
                        if (patternCount>=2) dmg = Math.floor(dmg * (1 + 0.08 * (patternCount-1))); // +8% per extra pattern
                        // Elemental infusion bonus: treat photon strike as carrying active infusion partials
                        if (game.player.infusions && game.player.infusions.length) {
                            game.player.infusions.forEach(inf=>{ dmg += Math.floor(dmg * 0.15 * inf.potency); });
                        }
                        target.health -= dmg;
                        addDamageNumber(dmg, target.x, target.y - target.size/2, { type:'plasma', crit:false });
                        addScreenShake(7);
                        // Status effects from projectile (ensures blinds, burns, etc., if converted)
                        applyStatusEffects(target);
                        // Record visual strike for rendering
                        if (!Array.isArray(game.photonStrikes)) game.photonStrikes = [];
                        game.photonStrikes.push({
                            x1: game.player.x, y1: game.player.y,
                            x2: target.x, y2: target.y,
                            time: performance.now(),
                            life: 24,
                            impactSize: Math.min(42, 22 + dmg*0.05),
                            color: '#CCFFFF'
                        });
                        // Core particles
                        for (let t = 0; t < 10; t++) addParticle(target.x + (Math.random()-0.5)*30, target.y + (Math.random()-0.5)*30, '#FFFFFF', 'explosion');
                        for (let s = 0; s < 16; s++) addParticle(game.player.x + (Math.random()-0.5)*44, game.player.y + (Math.random()-0.5)*44, '#CCFFFF', 'spark');
                        // Lightning synergy: chain mini zaps
                        if (game.player.abilities.some(a=>a.includes('Lightning Shot')||a.includes('Storm Shot'))) {
                            let chains=0; const maxChains=2;
                            game.enemies.forEach(o=>{ if(o===target||chains>=maxChains) return; const d=Math.hypot(o.x-target.x,o.y-target.y); if(d<140){ const z=Math.max(4,Math.floor(dmg*0.35)); o.health-=z; addDamageNumber(z,o.x,o.y-o.size/2,{type:'lightning'}); addParticle(o.x,o.y,'#FFFFAA','lightning'); chains++; }});
                        }
                        // Explosive synergy
                        if (game.player.abilities.some(a=>a.includes('Explosive Shot')||a.includes('Nova Blast'))) {
                            explodeProjectile({x:target.x,y:target.y,size:12}, Math.floor(dmg*0.5));
                        }
                        // Void synergy: mild armor shred pulse
                        if (game.player.abilities.some(a=>a.includes('Void Shot')||a.includes('Black Hole'))) {
                            game.enemies.forEach(o=>{ const d=Math.hypot(o.x-target.x,o.y-target.y); if(d<110){ o.armorShredded=(o.armorShredded||0)+1; if(o.armorShredded>10) o.armorShredded=10; }});
                        }
                        // Previously removed the projectile instantly (replacing normal shot).
                        // Change: Keep the projectile alive so Photon Torpedo is additive and other
                        // projectile-based abilities (sine, bouncing, plasma trails, etc.) still occur.
                        // If future balance needed, consider reducing projectile.baseDamage after strike.
                        // (Intentionally NOT zeroing life anymore.)
                    }
                }
            }
            // Screen shake for shooting
            // Shockwave ability: emit one traveling wave per attack (cooldown gated)
            if (game.player.abilities && game.player.abilities.includes('Shockwave')) {
                const nowSW = Date.now();
                const swCooldown = 600; // ms
                if (!game._lastShockwave || nowSW - game._lastShockwave >= swCooldown) {
                    const dir = game.player.lastDirection || {x:1,y:0};
                    const ang = Math.atan2(dir.y, dir.x);
                    spawnShockwave(game.player.x, game.player.y, ang);
                    game._lastShockwave = nowSW;
                }
            }
            addScreenShake(2);
        }

        // Dynamic orbital management moved into ensureOrbitals() (called each frame in update())
        function ensureOrbitals() {
            if (!game.player) return;
            const hasOrbital = game.player.abilities && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.orbital);
            // Collect existing orbitals
            let orbitals = game.projectiles.filter(p => p._orbital && !p.enemy);
            if (!hasOrbital) {
                // Remove any stray orbitals if player lost the ability (defensive)
                if (orbitals.length) {
                    game.projectiles = game.projectiles.filter(p => !p._orbital);
                }
                return;
            }
            // Derive desired orbital count from multi-shot style bonuses (mirror attack() logic simplified)
            let multiShotCount = 0;
            let shotgunBlast = false;
            game.player.abilities.forEach(ab => {
                const data = ABILITIES[ab];
                if (!data || !data.effect) return;
                if (data.effect.projectileCount) multiShotCount += data.effect.projectileCount;
                if (data.effect.shotgunBlast) shotgunBlast = true;
            });
            let desired = 1;
            if (shotgunBlast) desired = multiShotCount + 5; // same additive behavior as attack()
            else if (multiShotCount > 0) desired = multiShotCount;
            else desired = 2; // baseline 2 (previous behavior) so ability feels impactful without multishot
            if (desired < 2) desired = 2; // always keep at least two for symmetry
            // Performance safeguard
            desired = Math.min(desired, 40);
            // If count differs, adjust
            if (orbitals.length !== desired) {
                const reSpaceNeeded = true;
                // Trim extras
                if (orbitals.length > desired) {
                    orbitals = orbitals.slice(0, desired);
                }
                // Spawn missing
                if (orbitals.length < desired) {
                    for (let i = orbitals.length; i < desired; i++) {
                        // Angle placeholder; will be re-spaced below
                        const ang = 0;
                        // Wider dynamic radius: scale with desired count (fewer orbitals = tighter, more = slightly larger but capped)
                        // Base 72, add small growth up to 108.
                        const baseRadius = 72 + Math.min(36, desired * 1.2);
                        // Behavior flags inheritance (so orbitals can express projectile motion patterns visually)
                        const sineWave = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.sineWave);
                        const wackyZigzag = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.wackyZigzag);
                        const ekgWave = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.ekgWave);
                        const spiralPattern = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.spiralPattern);
                        orbitals.push({
                            x: game.player.x + Math.cos(ang) * baseRadius,
                            y: game.player.y + Math.sin(ang) * baseRadius,
                            vx: 0,
                            vy: 0,
                            life: 99999,
                            size: 6,
                            piercing: false,
                            pierceCount: 1,
                            pierceHits: 0,
                            homing: false,
                            bouncing: false,
                            explosive: false,
                            // (meteor projectiles no longer track splitting)
                            growing: false,
                            spiral: spiralPattern,
                            spinAngle: 0,
                            spinSpeed: spiralPattern ? (0.25 + Math.random()*0.2) : 0,
                            enemy: false,
                            _orbital: true,
                            _orbitAngle: ang,
                            _orbitRadius: baseRadius,
                            _orbitSpeed: 0.055 + Math.random()*0.035,
                            // Pattern inheritance flags
                            sineWave: sineWave,
                            wackyZigzag: !sineWave && wackyZigzag, // prefer sine over wacky if both somehow present
                            ekgWave: !sineWave && !wackyZigzag && ekgWave,
                            // Track local pattern state containers (initialized lazily in update)
                            _inheritedPattern: true
                        });
                    }
                }
                // Rebuild projectile list: keep all non-orbitals + new orbital set
                game.projectiles = game.projectiles.filter(p => !p._orbital).concat(orbitals);
                // Evenly space angles after any count change
                for (let i = 0; i < orbitals.length; i++) {
                    const ang = (i / orbitals.length) * Math.PI * 2;
                    orbitals[i]._orbitAngle = ang;
                    orbitals[i].x = game.player.x + Math.cos(ang) * orbitals[i]._orbitRadius;
                    orbitals[i].y = game.player.y + Math.sin(ang) * orbitals[i]._orbitRadius;
                }
            }
        }

        // --- Beartrap Ability ---
        function dropBeartrap() {
            if (!game.traps) game.traps = [];
            const MAX_TRAPS = 12;
            if (game.traps.length >= MAX_TRAPS) {
                game.traps.sort((a,b)=>a.created-b.created);
                game.traps.splice(0,1);
            }
            game.traps.push({
                x: game.player.x,
                y: game.player.y,
                radius: 20,
                created: Date.now(),
                triggered: false,
                triggerTime: 0,
                damage: Math.floor(calculateDamage() * 2.2),
                immobilizeMs: 5000
            });
        }

        function updateTraps() {
            if (!game.traps) return;
            const now = Date.now();
            for (let i = game.traps.length - 1; i >= 0; i--) {
                const trap = game.traps[i];
                if (!trap.triggered && now - trap.created > 60000) { game.traps.splice(i,1); continue; }
                if (trap.triggered && now - trap.triggerTime > 800) { game.traps.splice(i,1); continue; }
                if (!trap.triggered) {
                    for (const enemy of game.enemies) {
                        const dx = enemy.x - trap.x;
                        const dy = enemy.y - trap.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < trap.radius) {
                            enemy.health -= trap.damage;
                            // Standardize on frame-based stunTime for reliability and keep a timestamp backup
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, Math.floor(trap.immobilizeMs / 16)); // convert ms -> frames
                            enemy._trapImmobilizeUntil = Date.now() + trap.immobilizeMs; // fallback timestamp in case frame timer desyncs
                            delete enemy.stunnedTime; // remove ms-based variant to avoid confusion
                            addParticle(trap.x, trap.y, '#CCCCCC', 'impact');
                            addDamageNumber(trap.damage, enemy.x, enemy.y - enemy.size, { type:'physical' });
                            trap.triggered = true;
                            trap.triggerTime = now;
                            addScreenShake(3);
                            break;
                        }
                    }
                }
            }
        }

        // --- Punji Pit Ability ---
        function dropPunjiPit() {
            if (!game.pits) game.pits = [];
            const MAX_PITS = 10;
            if (game.pits.length >= MAX_PITS) {
                game.pits.sort((a,b)=>a.created-b.created);
                game.pits.splice(0,1);
            }
            game.pits.push({
                x: game.player.x,
                y: game.player.y,
                radius: 28,
                created: Date.now(),
                duration: 15000, // 15s field
                damageTick: Math.floor(calculateDamage() * 0.5),
                tickInterval: 800, // ms between repeat ticks per enemy
                enemiesHit: {}, // track last tick time per enemy id/hash
                poison: true,
                // Precompute spike layout for consistent rendering (array of {x,y,h,lean})
                spikes: (function(){
                    const arr = [];
                    const count = 18; // dense cluster
                    for (let i=0;i<count;i++) {
                        // random point inside inner disc (avoid edge so heads visible)
                        const ang = Math.random()*Math.PI*2;
                        const rad = Math.sqrt(Math.random()) * 0.75; // bias toward center
                        const rx = Math.cos(ang)*rad;
                        const ry = Math.sin(ang)*rad;
                        const h = 10 + Math.random()*14; // spike height
                        const lean = (Math.random()-0.5)*0.4; // slight lean factor for top offset
                        arr.push({ x: rx, y: ry, h, lean });
                    }
                    return arr;
                })()
            });
        }

        function updatePits() {
            if (!game.pits) return;
            const now = Date.now();
            for (let i = game.pits.length - 1; i >= 0; i--) {
                const pit = game.pits[i];
                if (now - pit.created > pit.duration) { game.pits.splice(i,1); continue; }
                // process enemies
                for (const enemy of game.enemies) {
                    const dx = enemy.x - pit.x;
                    const dy = enemy.y - pit.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < pit.radius) {
                        const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                        const last = pit.enemiesHit[key] || 0;
                        if (now - last >= pit.tickInterval) {
                            // apply damage over time tick
                            enemy.health -= pit.damageTick;
                            addDamageNumber(pit.damageTick, enemy.x, enemy.y - enemy.size, { type:'poison' });
                            enemy.poisoned = true;
                            enemy.poisonTime = Math.max(enemy.poisonTime || 0, 180); // 3s poison baseline or refresh
                            pit.enemiesHit[key] = now;
                            if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#55FF55', 'poison');
                        }
                    }
                }
            }
        }

        function updateEnemies() {
            game.enemies.forEach(enemy => {
                // If enemy is currently under Rizz pull animation, we only interpolate position (handled elsewhere) and skip AI.
                if (enemy._rizzPull && enemy._rizzPull.active) {
                    // decay fear timer if already applied (post pull) else defer.
                    return; // skip rest of processing this frame until pull completes
                }
                // Status effects
                const nowTs = Date.now();
                // Decay crushed timer
                if (enemy.crushedTimer && enemy.crushedTimer > 0) {
                    enemy.crushedTimer -= 16; // approximate per-frame ms
                    if (enemy.crushedTimer < 0) enemy.crushedTimer = 0;
                }
                // Armor shred decay: every ~2200ms remove one stack
                if (enemy.armorShredded && enemy.armorShredded > 0) {
                    if (!enemy._armorShredDecay) enemy._armorShredDecay = nowTs;
                    if (nowTs - enemy._armorShredDecay > 2200) {
                        enemy.armorShredded = Math.max(0, enemy.armorShredded - 1);
                        enemy._armorShredDecay = nowTs;
                    }
                }
                // Freeze stack decay (if not refreshed)
                if (enemy.freezeStacks && enemy.freezeStacks > 0) {
                    if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                        enemy.frozenTimer -= 16;
                        if (enemy.frozenTimer <= 0) enemy.frozenTimer = 0; // will rely on stack decay afterwards
                    }
                    if (enemy.lastFreezeHit && nowTs - enemy.lastFreezeHit > 2000 && !enemy.frozenTimer) {
                        enemy.freezeStacks--;
                        enemy.lastFreezeHit = nowTs; // reset so further decay is spaced
                        if (enemy.freezeStacks <= 0) {
                            enemy.freezeStacks = 0; delete enemy.lastFreezeHit;
                        }
                    }
                }
                if (enemy.poisoned) {
                    enemy.poisonTime--;
                    if (enemy.poisonTime <= 0) {
                        enemy.poisoned = false;
                    } else {
                        let poisonTick = 0.8;
                        const abil = game.player.abilities;
                        const hasVoid = abil.includes('Void Shot') || abil.includes('Black Hole');
                        const hasFire = abil.includes('Fire Shot') || abil.includes('Inferno') || abil.includes('Magma Shot');
                        if (hasVoid) poisonTick *= 1.25; // void amplifies decay
                        if (hasFire) poisonTick *= 1.12; // fire + poison magma synergy
                        enemy.health -= poisonTick;
                        if (Math.random() < 0.1) {
                            addParticle(enemy.x, enemy.y, '#44FF44', 'poison');
                        }
                    }
                }
                
                if (enemy.burning) {
                    enemy.burnTime--;
                    if (enemy.burnTime <= 0) {
                        enemy.burning = false;
                    } else {
                        let burnTick = 1.2;
                        const abil = game.player.abilities;
                        const hasWind = abil.includes('Wind Blade') || abil.includes('Blizzard');
                        const hasPoison = abil.includes('Poison Shot') || abil.includes('Toxic Cloud') || abil.includes('Silent But Deadly');
                        if (hasWind) burnTick *= 1.15; // oxygen fan effect
                        if (hasPoison) burnTick *= 1.10; // toxic combustion
                        enemy.health -= burnTick;
                        if (Math.random() < 0.2) {
                            addParticle(enemy.x, enemy.y, '#FF4444', 'fire');
                        }
                    }
                }
                
                if (enemy.slowed) {
                    enemy.slowTime--;
                    if (enemy.slowTime <= 0) {
                        enemy.slowed = false;
                    }
                }
                // Blind status decay: reduces detection and accuracy
                if (enemy.blinded) {
                    enemy.blindTime = (enemy.blindTime || 0) - 1;
                    if (enemy.blindTime <= 0) {
                        enemy.blinded = false; enemy.blindTime = 0;
                    } else {
                        // Occasional disoriented shuffle (random small drift)
                        if (Math.random() < 0.02) {
                            enemy._blindWanderAngle = Math.random()*Math.PI*2;
                        }
                        if (enemy._blindWanderAngle != null) {
                            enemy.x += Math.cos(enemy._blindWanderAngle) * 0.4;
                            enemy.y += Math.sin(enemy._blindWanderAngle) * 0.4;
                        }
                    }
                }
                
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Process smooth knockback BEFORE stun/freeze early returns so sliding occurs even if stunned.
                if (enemy.kbFrames && enemy.kbFrames > 0 && (enemy.kbVX || enemy.kbVY)) {
                    // Move enemy by current knockback velocity
                    let nx = enemy.x + enemy.kbVX;
                    let ny = enemy.y + enemy.kbVY;
                    // Wall collision: if blocked, zero out remaining knockback to avoid jitter
                    if (!isWall(nx, ny, enemy.size/2)) {
                        enemy.x = nx; enemy.y = ny;
                    } else {
                        enemy.kbFrames = 0; enemy.kbVX = 0; enemy.kbVY = 0; enemy._knockbacking = false;
                    }
                    // Apply decay
                    const decay = enemy._kbDecay || 0.88;
                    enemy.kbVX *= decay; enemy.kbVY *= decay;
                    enemy.kbFrames--;
                    // Edge clamp handled globally after all movement; local failsafe (hard clamp to canvas bounds using size)
                    const r = enemy.size || 16;
                    const minX = r; const maxX = canvas.width - r;
                    const minY = r; const maxY = canvas.height - r;
                    if (enemy.x < minX) { enemy.x = minX; if (enemy.kbVX < 0) enemy.kbVX = 0; }
                    if (enemy.x > maxX) { enemy.x = maxX; if (enemy.kbVX > 0) enemy.kbVX = 0; }
                    if (enemy.y < minY) { enemy.y = minY; if (enemy.kbVY < 0) enemy.kbVY = 0; }
                    if (enemy.y > maxY) { enemy.y = maxY; if (enemy.kbVY > 0) enemy.kbVY = 0; }
                    if (enemy.kbFrames <= 0 || (Math.abs(enemy.kbVX) < 0.1 && Math.abs(enemy.kbVY) < 0.1)) {
                        enemy.kbFrames = 0; enemy.kbVX = 0; enemy.kbVY = 0; enemy._knockbacking = false;
                    }
                    // Generic sliding feedback
                    if (Math.random() < 0.10) addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.4, enemy.y + enemy.size*0.4, '#FFFFFF', 'spark');
                    // Earth-style debris (brown / stone chips) when flagged
                    if (enemy._earthKBFrames && enemy._earthKBFrames > 0) {
                        enemy._earthKBFrames--;
                        if (Math.random() < 0.45) {
                            const debrisColor = Math.random() < 0.5 ? '#6b4a2b' : '#4a3420';
                            addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.6, enemy.y + (Math.random()-0.2)*enemy.size*0.5, debrisColor, 'spark');
                        }
                    }
                    // Skip AI movement & attack this frame while in knockback motion
                    return;
                }

                // Handle stunned / immobilized enemies (beartrap etc.)
                if (enemy.stunned) {
                    // Primary: frame-based stunTime
                    if (enemy.stunTime != null) {
                        enemy.stunTime--;
                        if (enemy.stunTime <= 0) {
                            enemy.stunTime = 0;
                        }
                    }
                    // Fallback: timestamp window (from beartrap)
                    if (enemy._trapImmobilizeUntil && Date.now() >= enemy._trapImmobilizeUntil) {
                        enemy._trapImmobilizeUntil = null;
                        if (!enemy.stunTime || enemy.stunTime <= 0) enemy.stunned = false;
                    }
                    // Legacy ms-based stunnedTime support (convert to frames roughly)
                    if (enemy.stunnedTime != null) {
                        enemy.stunnedTime -= 16;
                        if (enemy.stunnedTime <= 0) { enemy.stunnedTime = 0; if (!enemy.stunTime || enemy.stunTime <= 0) enemy.stunned = false; }
                    }
                    // Failsafe: if flagged stunned but both stunTime and stunnedTime are 0/undefined and no trap immobilize, clear it.
                    if (enemy.stunned && (!enemy.stunTime || enemy.stunTime <= 0) && (enemy.stunnedTime == null || enemy.stunnedTime <= 0) && !enemy._trapImmobilizeUntil) {
                        enemy.stunned = false;
                    }
                    // Watchdog: track total consecutive frames of being stunned to auto-clear pathological cases (e.g., logic bug leaving stun forever)
                    if (enemy.stunned) {
                        enemy._stunWatch = (enemy._stunWatch || 0) + 1;
                        if (enemy._stunWatch > 360) { // 6 seconds at 60fps
                            enemy.stunned = false;
                            enemy.stunTime = 0;
                            enemy.stunnedTime = 0;
                            delete enemy._trapImmobilizeUntil;
                        }
                    } else if (enemy._stunWatch) {
                        // reset counter when not stunned
                        enemy._stunWatch = 0;
                    }
                    // Visual feedback for immobilization root
                    if (Math.random() < 0.15) addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.6, enemy.y + enemy.size/2, '#BBBBBB', 'spark');
                    if (enemy.stunned) return; // still immobilized
                }
                // Full freeze immobilization
                if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                    // visually could add subtle frost particles
                    if (Math.random() < 0.04) addParticle(enemy.x, enemy.y, '#AAEEFF', 'spark');
                    return;
                }

                // Ranged enemy attacks (silenced enemies cannot attack)
                const detectionRange = enemy.blinded ? 120 : 250;
                const enemyCooldown = (ENEMY_TYPES[enemy.type] && ENEMY_TYPES[enemy.type].rangedCooldown) ? ENEMY_TYPES[enemy.type].rangedCooldown : 2500;
                // Global opening delay for ranged attacks: prevent shooting during first 2000ms of a room
                const openingDelayMs = 2000;
                const roomAge = Date.now() - (game.roomStartTime || 0);
                if (roomAge < openingDelayMs) {
                    // ensure lastAttack is at least roomStartTime to avoid burst after delay
                    if (!enemy._openingDelayApplied) {
                        enemy.lastAttack = Date.now();
                        enemy._openingDelayApplied = true;
                    }
                }
                if (roomAge >= openingDelayMs && !enemy.silenced && enemy.ranged && dist < detectionRange && Date.now() - enemy.lastAttack > enemyCooldown) {
                    const baseSpeed = 4;
                    const shots = [];
                    if (enemy.type === 'The Big Quack') {
                        // Triple fan shot: center + slight left/right spread
                        const baseAng = Math.atan2(dy, dx);
                        const spreads = [0, -0.18, 0.18];
                        spreads.forEach(off => {
                            const a = baseAng + off;
                            shots.push({ vx: Math.cos(a)*baseSpeed, vy: Math.sin(a)*baseSpeed, dmgMul: 0.85 });
                        });
                    } else if (enemy.type === 'Boss Gangster') {
                        // Two-round burst (slight vertical jitter)
                        const baseAng = Math.atan2(dy, dx);
                        const jitter = [ -0.05, 0.05 ];
                        jitter.forEach(off => {
                            const a = baseAng + off;
                            shots.push({ vx: Math.cos(a)*baseSpeed*1.05, vy: Math.sin(a)*baseSpeed*1.05, dmgMul: 0.8 });
                        });
                    } else {
                        shots.push({ vx: (dx / dist) * baseSpeed, vy: (dy / dist) * baseSpeed, dmgMul: 0.8 });
                    }
                    shots.forEach(s => {
                        game.projectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: s.vx,
                            vy: s.vy,
                            life: 140,
                            size: enemy.type === 'The Big Quack' ? 5 : 3,
                            enemy: true,
                            damage: Math.floor(enemy.damage * s.dmgMul)
                        });
                        addParticle(enemy.x, enemy.y, '#FFAA00', 'muzzle');
                    });
                    enemy.lastAttack = Date.now();
                }

                // Movement AI
                // Reconstruct baseline each frame from stored baseSpeed to prevent cumulative slow stacking bugs
                if (enemy.baseSpeed == null) enemy.baseSpeed = enemy.speed || 1; // defensive backfill
                enemy.speed = enemy.baseSpeed; // reset any accidental permanent reduction
                let moveSpeed = enemy.speed;
                if (enemy.slowed) moveSpeed *= 0.4;
                // Apply partial freeze slow scaling by stacks (1 or 2 stacks only; 3 is full freeze handled above)
                if (enemy.freezeStacks && enemy.freezeStacks > 0 && (!enemy.frozenTimer || enemy.frozenTimer <= 0)) {
                    if (enemy.freezeStacks === 1) moveSpeed *= 0.6;
                    else if (enemy.freezeStacks === 2) moveSpeed *= 0.35;
                }
                // Blind movement dampening + wandering: do NOT fully immobilize
                if (enemy.blinded) {
                    // Cap blind duration defensively
                    if (enemy.blindTime > 300) enemy.blindTime = 300;
                    moveSpeed *= 0.55; // reduced precision movement
                    // If player out of (very short) pursuit range, wander
                    const shortRange = 70;
                    if (dist > shortRange) {
                        // Create / update wander direction every ~45 frames
                        enemy._blindWanderTicker = (enemy._blindWanderTicker || 0) + 1;
                        if (enemy._blindWanderTicker > 45 || enemy._blindWanderAngle == null) {
                            enemy._blindWanderTicker = 0;
                            enemy._blindWanderAngle = Math.random() * Math.PI * 2;
                        }
                        const wx = Math.cos(enemy._blindWanderAngle) * moveSpeed * 0.7;
                        const wy = Math.sin(enemy._blindWanderAngle) * moveSpeed * 0.7;
                        const nx = enemy.x + wx;
                        const ny = enemy.y + wy;
                        if (!isWall(nx, ny, 15)) { enemy.x = nx; enemy.y = ny; }
                        // Continue to next enemy (skip normal chase) this frame
                        return;
                    }
                }
                // Ensure movement never fully zeroed unless explicitly stunned/frozen
                if (!enemy.stunned && !enemy.frozenTimer) {
                    const minFloor = enemy.baseSpeed * 0.18; // floor at 18% baseline
                    if (moveSpeed < minFloor) moveSpeed = minFloor;
                }

                // Terrifying Aura proximity fear application (room-based only now)
                if (game.player && game.player.auraActive) {
                    const auraRadius = 60; // contact radius
                    const adx = enemy.x - game.player.x;
                    const ady = enemy.y - game.player.y;
                    if (adx*adx + ady*ady <= auraRadius * auraRadius) {
                        // Apply fear for 3s (180 frames) if not already feared or refresh shorter remaining
                        const newFear = 180;
                        if (!enemy.fearTime || enemy.fearTime < newFear * 0.5) {
                            enemy.fearTime = newFear;
                            enemy.feared = true;
                            // one-off particles for feedback
                            addParticle(enemy.x, enemy.y - 12, '#AA44FF', 'spark');
                        }
                    }
                }

                // Fear behavior: run directly away from player
                if (enemy.feared) {
                    enemy.fearTime--;
                    if (enemy.fearTime <= 0) { enemy.feared = false; } else {
                        const fdx = enemy.x - game.player.x;
                        const fdy = enemy.y - game.player.y;
                        const fd = Math.max(1, Math.sqrt(fdx*fdx + fdy*fdy));
                        const fleeSpeed = moveSpeed * 1.15; // slight haste when fleeing
                        const nx = enemy.x + (fdx / fd) * fleeSpeed;
                        const ny = enemy.y + (fdy / fd) * fleeSpeed;
                        if (!isWall(nx, ny, 15)) { enemy.x = nx; enemy.y = ny; }
                        return; // skip rest of AI while feared
                    }
                }

                // Fleeing enemies move away from player
                if (enemy.fleeing) {
                    enemy.fleeTime--;
                    if (enemy.fleeTime <= 0) enemy.fleeing = false;
                    // Move opposite direction
                    const nx = enemy.x - (dx / Math.max(dist, 1)) * moveSpeed;
                    const ny = enemy.y - (dy / Math.max(dist, 1)) * moveSpeed;
                    if (!isWall(nx, ny, 15)) {
                        enemy.x = nx;
                        enemy.y = ny;
                    }
                    return;
                }

                // Charmed enemies: become temporary allies that seek and damage other (non-charmed) enemies.
                if (enemy.charmed) {
                    enemy.charmTime--;
                    if (enemy.charmTime <= 0) { enemy.charmed = false; return; }
                    // Acquire nearest valid hostile target
                    let target = null; let tDist = Infinity;
                    for (const other of game.enemies) {
                        if (other === enemy) continue;
                        if (other.health <= 0) continue;
                        if (other.charmed) continue; // don't attack allies
                        const dx2 = other.x - enemy.x; const dy2 = other.y - enemy.y;
                        const d2 = dx2*dx2 + dy2*dy2;
                        if (d2 < tDist) { tDist = d2; target = other; }
                    }
                    if (target) {
                        const d2 = Math.sqrt(tDist) || 1;
                        const step = moveSpeed * 0.85; // slightly faster than normal to be useful
                        const mx = enemy.x + (target.x - enemy.x)/d2 * step;
                        const my = enemy.y + (target.y - enemy.y)/d2 * step;
                        if (!isWall(mx, my, 15)) { enemy.x = mx; enemy.y = my; }
                        // Contact damage vs target (reduced from original enemy.damage to avoid overpowering)
                        if (Math.sqrt((target.x - enemy.x)**2 + (target.y - enemy.y)**2) < (target.size/2 + enemy.size/2 + 4)) {
                            if (!enemy._charmAttackCooldown || enemy._charmAttackCooldown <= 0) {
                                const base = enemy.damage || 10;
                                const dealt = Math.max(1, Math.floor(base * 0.55));
                                target.health -= dealt;
                                addDamageNumber(dealt, target.x, target.y - target.size/2, { type:'charm' });
                                // Small heart particle burst
                                if (Math.random()<0.6) addParticle(target.x, target.y, '#FF88CC', 'spark');
                                enemy._charmAttackCooldown = 28; // ~0.46s at 60fps
                            }
                        }
                    }
                    if (enemy._charmAttackCooldown) enemy._charmAttackCooldown--;
                    // Occasional ambient charm heart
                    if (Math.random() < 0.04) addParticle(enemy.x + (Math.random()-0.5)*enemy.size, enemy.y - enemy.size/2 - 4, '#FF66BB', 'spark');
                    return; // skip hostile AI
                }

                if (dist > 30) {
                    // Simple pathfinding - try to avoid walls
                    let targetX = enemy.x + (dx / dist) * moveSpeed;
                    let targetY = enemy.y + (dy / dist) * moveSpeed;

                    if (isWall(targetX, targetY, 15)) {
                        // Try alternative paths
                        const perpX = -dy / dist;
                        const perpY = dx / dist;

                        if (!isWall(enemy.x + perpX * moveSpeed * 2, enemy.y + perpY * moveSpeed * 2, 15)) {
                            enemy.x += perpX * moveSpeed;
                            enemy.y += perpY * moveSpeed;
                        } else if (!isWall(enemy.x - perpX * moveSpeed * 2, enemy.y - perpY * moveSpeed * 2, 15)) {
                            enemy.x -= perpX * moveSpeed;
                            enemy.y -= perpY * moveSpeed;
                        }
                    } else {
                        enemy.x = targetX;
                        enemy.y = targetY;
                    }
                }
            });
            
            // Remove dead enemies and award XP
            const deadEnemies = game.enemies.filter(enemy => enemy.health <= 0);
            deadEnemies.forEach(enemy => {
                game.totalKills++;
                // Per-player kill counter (initialize lazily if missing)
                if (game.player) {
                    if (typeof game.player.killCount !== 'number') game.player.killCount = 0;
                    game.player.killCount++;
                    // Terrifying Aura activation: every 25 kills grant aura lasting for 2 rooms (level tracking removed)
                    if (game.player.abilities.includes('Terrifying Aura') && game.player.killCount % 25 === 0) {
                        game.player.auraActive = true;
                        // Level-based fields removed
                        game.player.auraActivatedRoom = game.room || 1;
                        game.player.auraExpireRoom = (game.room || 1) + 2; // expires after 2 rooms
                        // Visual feedback particles
                        for (let k=0;k<18;k++) {
                            const ang = (k/18)*Math.PI*2;
                            const px = game.player.x + Math.cos(ang)*38;
                            const py = game.player.y + Math.sin(ang)*38;
                            addParticle(px, py, '#AA44FF', 'spark');
                        }
                        addScreenShake(4);
                    }
                }
                game.score += enemy.xp;
                
                // Feather poof (white burst then falling) - ensure helper exists
                if (typeof spawnFeatherPoof === 'function') {
                    spawnFeatherPoof(enemy);
                }

                // Death effects (legacy explosions)
                for (let i = 0; i < 5; i++) {
                    addParticle(enemy.x, enemy.y, enemy.color, 'explosion');
                }
                addScreenShake(3);

                // Spontaneous Combustion: on kill, emit radial burning shards
                if (game.player && game.player.abilities.includes('Spontaneous Combustion')) {
                    const shardCount = 12; // base number of shards
                    const baseDmg = calculateDamage();
                    for (let s=0; s<shardCount; s++) {
                        const ang = (s / shardCount) * Math.PI * 2;
                        const sp = 5.5; // speed of emitted shard
                        game.projectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(ang) * sp,
                            vy: Math.sin(ang) * sp,
                            life: 70,
                            size: 5,
                            enemy: false,
                            baseDamage: Math.max(1, Math.floor(baseDmg * 0.45)),
                            damageType: 'fire',
                            burningShard: true,
                            piercing: false
                        });
                    }
                    // Visual combustion particles
                    for (let p=0;p<30;p++) {
                        const pang = Math.random()*Math.PI*2;
                        const pr = Math.random()*28;
                        addParticle(enemy.x + Math.cos(pang)*pr, enemy.y + Math.sin(pang)*pr, (Math.random()<0.3?'#FFDD66':'#FF7722'), 'explosion');
                    }
                    addScreenShake(5);

                    // Synergy: if player also has Explosive Shot or Chain Explosion, schedule delayed secondary rings.
                    const hasExplosive = game.player.abilities.includes('Explosive Shot');
                    const hasChainExplosion = game.player.abilities.includes('Chain Explosion');
                    if (hasExplosive || hasChainExplosion) {
                        if (!game._pendingCombustionRings) game._pendingCombustionRings = [];
                        // Secondary ring (slightly larger, fewer but stronger shards)
                        game._pendingCombustionRings.push({
                            x: enemy.x,
                            y: enemy.y,
                            spawnFrame: (game.frame||0) + 10, // ~0.16s delay
                            count: hasChainExplosion ? 14 : 10,
                            speed: 6.0,
                            dmgFrac: hasChainExplosion ? 0.5 : 0.42,
                            fire: true,
                            tier: 2
                        });
                        if (hasChainExplosion) {
                            // Tertiary micro-ring (fast fade, crowd control filler)
                            game._pendingCombustionRings.push({
                                x: enemy.x,
                                y: enemy.y,
                                spawnFrame: (game.frame||0) + 22,
                                count: 18,
                                speed: 6.8,
                                dmgFrac: 0.34,
                                fire: true,
                                tier: 3
                            });
                        }
                    }
                }

                // Final boss defeat check
                if (enemy.type === 'The Big Quack') {
                    game._bigQuackDefeated = true;
                    console.info('[Endgame] The Big Quack defeated. Preparing ending overlay.');
                    // Swap to ending music (play cleansing theme regardless of previous track)
                    try {
                        if (game.bgMusic) { try { game.bgMusic.pause(); } catch(e) {} }
                        game.bgMusic = new Audio('assets/audio/Cleansing.mp3');
                        game.bgMusic.loop = true;
                        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
                    } catch(e) {}
                    // Display ending image overlay
                    if (!document.getElementById('endingOverlay')) {
                        const overlay = document.createElement('div');
                        overlay.id = 'endingOverlay';
                        overlay.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:#000;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:30000;';
                        const img = document.createElement('img');
                        img.src = 'assets/Ending.png';
                        img.alt = 'Ending';
                        img.style.maxWidth = '90%';
                        img.style.maxHeight = '80%';
                        img.style.marginBottom = '24px';
                        overlay.appendChild(img);
                        const prompt = document.createElement('div');
                        prompt.textContent = 'Press FIRE to choose a permanent ability';
                        prompt.style.cssText = 'color:#ffd700;font:20px Arial;text-shadow:0 0 8px #aa8800;';
                        overlay.appendChild(prompt);
                        document.body.appendChild(overlay);
                        console.info('[Endgame] Ending overlay displayed. Awaiting SPACE for permanent ability choice.');
                    }
                }
                
                // Life steal healing
                let totalLifeSteal = 0;
                game.player.abilities.forEach(ability => {
                    const abilityData = ABILITIES[ability];
                    if (abilityData && abilityData.effect.lifeSteal) {
                        totalLifeSteal += abilityData.effect.lifeSteal;
                    }
                });
                
                if (totalLifeSteal > 0) {
                    const healAmount = Math.floor(25 * totalLifeSteal);
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + healAmount);
                    addParticle(game.player.x, game.player.y - 20, '#00FF00', 'heal');
                    updateUI();
                }

                // Chance to drop a health bread slice (pickup heals 25)
                // Base 10% chance; modified by Treasure Hunter (breadDropBonus adds percentage multiplicatively)
                let dropChance = 0.10;
                if (game.player.abilities.includes('Treasure Hunter')) {
                    const th = ABILITIES['Treasure Hunter'];
                    if (th && th.effect && th.effect.breadDropBonus) {
                        dropChance *= (1 + th.effect.breadDropBonus); // e.g., 0.10 * 1.5 = 0.15
                    }
                }
                if (Math.random() < dropChance && game.pickups.length < 40) {
                    game.pickups.push({
                        type: 'bread',
                        x: enemy.x + (Math.random()-0.5)*12,
                        y: enemy.y + (Math.random()-0.5)*12,
                        spawnTime: performance.now(),
                        collected: false
                    });
                }
            });
            
            game.enemies = game.enemies.filter(enemy => enemy.health > 0);
        }

        // Post-update status ticks: doom and weakness durations
        (function postStatusTick() {
            game.enemies.forEach(enemy => {
                if (enemy.doomed) {
                    enemy.doomTime = (enemy.doomTime || 0) - 1;
                    if (enemy.doomTime <= 0) {
                        enemy.doomed = false;
                    } else {
                        enemy.health -= 0.9;
                        if (Math.random() < 0.12) addParticle(enemy.x, enemy.y, '#880088', 'impact');
                    }
                }
                // Corrosion: periodic true damage & temporary armor reduction
                if (enemy.corroded) {
                    enemy.corrodeTime = (enemy.corrodeTime || 0) - 1;
                    if ((enemy.corrodeTime % 30) === 0) {
                        enemy.health -= 2; // small true damage
                        addParticle(enemy.x, enemy.y, '#44FF44', 'impact');
                    }
                    if (enemy.corrodeTime <= 0) {
                        enemy.corroded = false;
                        // remove one stack of armorShredded if present
                        if (enemy.armorShredded) enemy.armorShredded = Math.max(0, enemy.armorShredded - 1);
                    }
                }
                // Void touched: small periodic true damage
                if (enemy.voidTouched) {
                    enemy.voidTime = (enemy.voidTime || 0) - 1;
                    if ((enemy.voidTime % 40) === 0) {
                        enemy.health -= 3;
                        addParticle(enemy.x, enemy.y, '#AA00FF', 'impact');
                    }
                    if (enemy.voidTime <= 0) enemy.voidTouched = false;
                }
                // Bleeding: periodic physical damage (half mitigated by armor)
                if (enemy.bleeding) {
                    enemy.bleedTime = (enemy.bleedTime || 0) - 1;
                    if ((enemy.bleedTime % 25) === 0) {
                        const base = 4;
                        const mitigated = Math.max(1, base - (enemy.armor || 0) * 0.5);
                        enemy.health -= mitigated;
                        addParticle(enemy.x, enemy.y, '#CC2222', 'impact');
                    }
                    if (enemy.bleedTime <= 0) enemy.bleeding = false;
                }
                if (enemy.weakness) {
                    enemy.weaknessTime = (enemy.weaknessTime || 0) - 1;
                    if (enemy.weaknessTime <= 0) enemy.weakness = false;
                }
                if (enemy.cursed) {
                    enemy.curseTime = (enemy.curseTime || 0) - 1;
                    if (enemy.curseTime <= 0) enemy.cursed = false;
                }
            });
        })();

        function updateProjectiles() {
            // Helper to safely obtain (or recompute) projectile speed.
            const getProjSpeed = (p) => {
                if (!p) return 0.0001;
                if (p._agg && p._agg.baseSpeed) return p._agg.baseSpeed;
                return Math.sqrt(p.vx*p.vx + p.vy*p.vy) || 0.0001;
            };
            game.projectiles = game.projectiles.filter(proj => {
                // Pattern Amplification (SHOOTING INTENSIFIES)
                // We apply a one-time per-frame amplification to pattern-induced lateral/oscillatory components.
                // Implementation approach: after each pattern block mutates velocity (later in the function), we scale
                // key stored intermediate amplitudes. To avoid deep invasive edits across every pattern branch, we
                // apply a consolidated multiplier early that downstream calculations reference. New patterns should
                // consult proj._patternAmpFactor if needing amplitude. Existing code using literal values will receive
                // a post-hoc velocity inflation (controlled) to approximate amplitude boost.
                if (!proj._patternAmpTagged) {
                    // Base factor: +40% amplitude/speed for wave/spiral like motions.
                    let amp = 1.0;
                    if (!proj.enemy && game.player && game.player.abilities && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.patternAmplify)) {
                        amp = 1.4;
                        // Slight scaling if multiple core patterns active (diminishing stacking): add up to +10% more.
                        const patternFlags = ['sineWave','wackyZigzag','ekgWave','spiral','spiralPattern','uzumaki','helixPair','lissajousPattern','slalomPattern','pendulumPattern','sawWave','pivotPattern','convergePair','spiralBloom','temporalDrift','veeringFan','echoBloom'];
                        let count = 0; for (const f of patternFlags) if (proj[f]) count++;
                        if (count > 1) amp *= (1 + Math.min(0.10, (count-1)*0.025));
                        // Store factor for downstream logic that may reference it.
                        proj._patternAmpFactor = amp;
                    } else {
                        proj._patternAmpFactor = 1.0;
                    }
                    proj._patternAmpTagged = true; // mark so we don't recompute excessively
                }
                // Capture pre-pattern position each frame for reliable bounce rewind when complex patterns adjust position before base move.
                proj._prePatternX = proj.x;
                proj._prePatternY = proj.y;
                // Lightning projectile spark trail (visual only)
                if (!proj.enemy && (proj.damageType === 'lightning' || proj.damageType === 'storm')) {
                    if (Math.random() < 0.45) {
                        addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFFFAA', 'lightning');
                    }
                    if (Math.random() < 0.18) {
                        addParticle(proj.x, proj.y, '#FFF6AA', 'spark');
                    }
                }
                // Dimensional Rift projectile interaction: refraction, bending, occasional duplication / teleport
                if (!proj.enemy && !proj.beam && game._dimRifts && game._dimRifts.length) {
                    for (let ri = 0; ri < game._dimRifts.length; ri++) {
                        const rift = game._dimRifts[ri];
                        if (!rift) continue;
                        const dxR = proj.x - rift.x;
                        const dyR = proj.y - rift.y;
                        const distR2 = dxR*dxR + dyR*dyR;
                        const rr = rift.r;
                        if (distR2 <= rr*rr) {
                            const distR = Math.sqrt(distR2) || 1;
                            // Lens bending: mix current velocity with a tangential component to create an arc around center
                            if (!proj._riftBent) {
                                const vx = proj.vx; const vy = proj.vy;
                                // Tangent vector (perpendicular to radius) for swirling deflection
                                const tx = -dyR / distR; const ty = dxR / distR;
                                // Strength scales with closeness to center (stronger near core)
                                const closeness = 1 - (distR / rr);
                                const bend = 0.35 * closeness; // tunable
                                // Blend velocities
                                proj.vx = vx * (1 - bend) + tx * getProjSpeed(proj) * bend;
                                proj.vy = vy * (1 - bend) + ty * getProjSpeed(proj) * bend;
                                proj._riftBent = true;
                                // Slight life extension so refracted shots persist visually
                                proj.life += 4;
                            }
                            // Refraction / duplication (single time per projectile per rift)
                            if (!proj._riftRefracted) {
                                const canDuplicate = game.projectiles.length < 1200; // safety cap
                                if (canDuplicate && Math.random() < 0.34) {
                                    const copies = (Math.random() < 0.25) ? 2 : 1; // occasionally spawn two extra
                                    for (let c=0; c<copies; c++) {
                                        const ang = Math.atan2(proj.vy, proj.vx) + (Math.random()*0.9 - 0.45); // wide scatter
                                        const spd = getProjSpeed(proj) * (0.75 + Math.random()*0.4);
                                        const dup = {
                                            ...proj,
                                            x: proj.x + Math.cos(ang)*6,
                                            y: proj.y + Math.sin(ang)*6,
                                            vx: Math.cos(ang)*spd,
                                            vy: Math.sin(ang)*spd,
                                            life: Math.max(40, Math.floor(proj.life * (0.55 + Math.random()*0.25))),
                                            _riftChild: true,
                                            _riftBent: true,
                                            _riftRefracted: true
                                        };
                                        // Reduce damage a bit for children to avoid runaway DPS
                                        if (dup.baseDamage) dup.baseDamage = Math.max(1, Math.floor(dup.baseDamage * 0.8));
                                        game.projectiles.push(dup);
                                        addParticle(dup.x, dup.y, '#AA44FF', 'spark');
                                    }
                                }
                                proj._riftRefracted = true;
                            }
                            // Chance to micro-teleport projectile to rim, preserving direction
                            if (!proj._riftTeleported && Math.random() < 0.12) {
                                const dirAng = Math.atan2(proj.vy, proj.vx);
                                // place on circumference slightly ahead in direction to create skip feel
                                const offsetAng = dirAng + (Math.random()*0.4 - 0.2);
                                const radius = rr * (0.85 + Math.random()*0.15);
                                proj.x = rift.x + Math.cos(offsetAng) * radius;
                                proj.y = rift.y + Math.sin(offsetAng) * radius;
                                // Slight speed boost to emphasize warp
                                proj.vx *= 1.12; proj.vy *= 1.12;
                                proj._riftTeleported = true;
                                addParticle(proj.x, proj.y, '#DD88FF', 'explosion');
                            }
                            // Mark projectile to ignore armor while inside rift (per ability desc) until it leaves radius once
                            proj.ignoresArmor = true;
                            break; // only interact with first rift per frame
                        } else if (proj._riftBent && distR2 > rr*rr*1.21) {
                            // Once clearly outside, allow future bending again if it re-enters another rift
                            proj._riftBent = false;
                        }
                    }
                }
                if (proj.smartExplosive && !proj.enemy && proj.life > 0) {
                    let closest = Infinity;
                    for (let e of game.enemies) {
                        const d = Math.hypot(e.x - proj.x, e.y - proj.y);
                        if (d < closest) closest = d;
                    }
                    if (closest < 48) {
                        explodeProjectile(proj, calculateDamage());
                        proj.life = 0;
                        return false;
                    }
                }
                // Growing effect (enhanced):
                //  - Higher max size (≈4.25x base) with soft cap & diminishing returns near end
                //  - Early growth slightly faster; slows as it approaches cap
                //  - Pattern synergy: if projectile also has spiral OR sineWave, grant mild extra growth potential
                //  - Infusion synergy: active infusions raise cap modestly (stacking small boosts)
                if (proj.growing && !proj.enemy) {
                    const start = (typeof proj._initialSize === 'number') ? proj._initialSize : 4;
                    if (!proj._growInit) {
                        proj._growInit = true;
                        proj._growTicks = 0;
                        // Base cap multiplier
                        let baseCapMult = 4.0; // from 2.5 -> 4.0 baseline
                        // Motion pattern synergy adds headroom
                        if (proj.spiral) baseCapMult += 0.35;
                        if (proj.sineWave) baseCapMult += 0.25;
                        // Wacky / EKG minor extra (avoid runaway)
                        if (proj.wackyZigzag) baseCapMult += 0.15;
                        if (proj.ekgWave) baseCapMult += 0.15;
                        // Infusion scaling (each adds 4% cap up to +12%)
                        if (proj.infusionElements && proj.infusionElements.length) {
                            baseCapMult += Math.min(0.12, 0.04 * proj.infusionElements.length);
                        }
                        // Store absolute cap and softCap start (where diminishing returns start)
                        proj._growHardCap = start * baseCapMult; // absolute max
                        proj._growSoftCap = start * (baseCapMult * 0.78); // start easing here
                    }
                    proj._growTicks++;
                    const size = proj.size;
                    const hardCap = proj._growHardCap;
                    const softCap = proj._growSoftCap;
                    if (size < hardCap - 0.05) {
                        // Base growth factor: early faster (first 40 ticks), then normal
                        const earlyPhase = proj._growTicks < 40;
                        let growthRate = earlyPhase ? 1.032 : 1.018; // multiplicative
                        // Diminishing returns after soft cap: interpolate toward 1.0 multiplier
                        if (size > softCap) {
                            const t = (size - softCap) / (hardCap - softCap); // 0..1
                            const damp = 1 - Math.min(1, t); // remaining growth influence
                            growthRate = 1 + (growthRate - 1) * damp * 0.85; // reduce acceleration steeply
                        }
                        // Safety clamp (avoid micro-floating above cap)
                        const newSize = Math.min(size * growthRate, hardCap);
                        proj.size = newSize;
                    }
                }
                // Spiral in-flight motion: looping swirl around the forward path
                if (proj.spiral && !proj.enemy) {
                    // Initialize loop parameters on first pass
                    if (!proj._loopInitialized) {
                        proj._loopInitialized = true;
                        // Prefer the initial firing direction if present so spirals curve around the original path
                        proj._forwardSpeed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) || 0.0001;
                        const initFx = typeof proj._initialFx === 'number' ? proj._initialFx : (proj.vx / proj._forwardSpeed);
                        const initFy = typeof proj._initialFy === 'number' ? proj._initialFy : (proj.vy / proj._forwardSpeed);
                        // normalize captured forward vector
                        const inorm = Math.sqrt(initFx*initFx + initFy*initFy) || 0.0001;
                        proj._fx = initFx / inorm;
                        proj._fy = initFy / inorm;
                        proj._px = -proj._fy; // perpendicular unit
                        proj._py = proj._fx;
                        proj._loopRadius = 6 + Math.random() * 10; // loop radius in px
                        proj._loopAngle = 0;
                        proj._loopSpeed = 0.22 + Math.random() * 0.36; // how fast it spins around
                        proj._lastLoopOffsetX = 0;
                        proj._lastLoopOffsetY = 0;
                    }
                    // advance loop angle (spinDir keeps earlier randomness)
                    proj._loopAngle += proj._loopSpeed * (proj.spinDir || 1);

                    // Optionally modulate radius slightly for breathing effect
                    const radiusMod = proj._loopRadius * (0.85 + 0.3 * Math.sin(proj._loopAngle * 0.7));

                    // compute offset in perpendicular direction to create loops around centerline
                    const offsetX = proj._px * Math.cos(proj._loopAngle) * radiusMod;
                    const offsetY = proj._py * Math.cos(proj._loopAngle) * radiusMod;

                    // forward motion remains the principal velocity
                    const forwardMoveX = proj._fx * proj._forwardSpeed;
                    const forwardMoveY = proj._fy * proj._forwardSpeed;

                    // desired velocity is forward plus the delta of offset to create local loop travel
                    const desiredVx = forwardMoveX + (offsetX - proj._lastLoopOffsetX) * 0.6;
                    const desiredVy = forwardMoveY + (offsetY - proj._lastLoopOffsetY) * 0.6;

                    proj._lastLoopOffsetX = offsetX;
                    proj._lastLoopOffsetY = offsetY;

                    // softly lerp current velocity toward desired velocity so motion is smooth
                    proj.vx = proj.vx * 0.84 + desiredVx * 0.16;
                    proj.vy = proj.vy * 0.84 + desiredVy * 0.16;
                    // keep life stable
                    proj.life -= 0;
                }
                // Uzumaki global spiral: projectile travels in expanding spiral path centered on player position at spawn.
                if (proj.uzumaki && !proj.enemy) {
                    if (!proj._uzuInit) {
                        proj._uzuInit = true;
                        // Anchor center at player's position at spawn (stationary center) for consistent swirl.
                        proj._uzuCx = proj._spawnPlayerX || game.player.x; // fallback if not set
                        proj._uzuCy = proj._spawnPlayerY || game.player.y;
                        proj._uzuAngle = Math.atan2(proj.y - proj._uzuCy, proj.x - proj._uzuCx);
                        proj._uzuRadius = 18; // initial radius from center
                        proj._uzuAngularVel = 0.18 + Math.random()*0.04; // base rotational speed
                        proj._uzuRadialVel = 1.4 + Math.random()*0.4; // outward expansion speed
                        proj._uzuDrag = 0.000; // radial drag currently unused (kept for tuning)
                        // Shorter life so spiral stream refreshes
                        proj.life = Math.min(proj.life, 120 + (Math.random()*30)|0);
                    }
                    // Increase radius outward; mild acceleration taper so it doesn't explode outward too fast.
                    proj._uzuRadius += proj._uzuRadialVel;
                    proj._uzuRadialVel *= (1 - proj._uzuDrag);
                    // Spin
                    proj._uzuAngle += proj._uzuAngularVel;
                    // Slowly accelerate angular velocity a touch for visual tightening
                    proj._uzuAngularVel *= 1.003;
                    // Compute new target position
                    const targetX = proj._uzuCx + Math.cos(proj._uzuAngle) * proj._uzuRadius;
                    const targetY = proj._uzuCy + Math.sin(proj._uzuAngle) * proj._uzuRadius;
                    // Derive velocity toward new position (lerp style for smoothness)
                    const desiredVx = (targetX - proj.x);
                    const desiredVy = (targetY - proj.y);
                    proj.vx = proj.vx * 0.40 + desiredVx * 0.60;
                    proj.vy = proj.vy * 0.40 + desiredVy * 0.60;
                    // Optionally spawn spiral dust particles
                    if (Math.random() < 0.08) addParticle(proj.x, proj.y, '#FFAaff', 'swirl');
                }
                // --- APPLY CONSOLIDATED PATTERN AMPLIFICATION ---
                // After individual pattern logic has potentially modified vx/vy, apply a gentle outward scaling of the
                // lateral (non-forward) component to simulate increased amplitude. We approximate lateral component by
                // subtracting original forward direction (captured at spawn if available) so base travel speed doesn't inflate too much.
                if (proj._patternAmpFactor && proj._patternAmpFactor > 1 && !proj._patternAmpAppliedFrame) {
                    // Derive forward vector baseline
                    const speed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                    let fx = proj._initialFx, fy = proj._initialFy;
                    if (typeof fx !== 'number' || typeof fy !== 'number') {
                        fx = proj.vx / speed; fy = proj.vy / speed;
                    }
                    // Project velocity onto forward
                    const forwardMag = proj.vx*fx + proj.vy*fy; // dot product (signed)
                    const forwardVx = fx * forwardMag;
                    const forwardVy = fy * forwardMag;
                    let lateralVx = proj.vx - forwardVx;
                    let lateralVy = proj.vy - forwardVy;
                    // Scale lateral portion only
                    lateralVx *= proj._patternAmpFactor;
                    lateralVy *= proj._patternAmpFactor;
                    // Recombine
                    proj.vx = forwardVx + lateralVx;
                    proj.vy = forwardVy + lateralVy;
                    // Clamp total speed to avoid runaway (allow up to +25% total speed boost)
                    const newSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                    const maxSpeed = speed * 1.25;
                    if (newSpeed > maxSpeed) {
                        const scale = maxSpeed / newSpeed;
                        proj.vx *= scale; proj.vy *= scale;
                    }
                    proj._patternAmpAppliedFrame = true; // could be reset externally if multi-stage patterns later adjust
                } else if (proj._patternAmpAppliedFrame) {
                    // Reset marker for next frame (since we operate per-frame inside filter loop)
                    proj._patternAmpAppliedFrame = false;
                }
                // === New Pattern Motions ===
                // Helix Pair lateral orbiting around forward trajectory (applied before aggregation so it influences basis subtly)
                if (proj.helixPair && proj._helixSide) {
                    if (!proj._helixInit) {
                        proj._helixInit = true;
                        // capture forward direction
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._helixSpeed = sp;
                        proj._helixFx = proj.vx / sp; proj._helixFy = proj.vy / sp;
                        proj._helixPx = -proj._helixFy; proj._helixPy = proj._helixFx;
                    }
                    proj._helixPhase += 0.25; // spin speed
                    // Ease radius toward target (wider look) then gently breathe
                    if (proj._helixTargetRadius) {
                        const diff = proj._helixTargetRadius - proj._helixRadius;
                        proj._helixRadius += diff * 0.045; // approach target smoothly
                    }
                    // Mild breathing after near target
                    if (Math.abs(proj._helixTargetRadius - proj._helixRadius) < 1.5) {
                        proj._helixRadius += Math.sin(proj._helixPhase*0.18 + (proj._helixSide||1)) * 0.20;
                    }
                    const radius = proj._helixRadius * 0.55; // scaling to keep on-screen clarity
                    const off = Math.sin(proj._helixPhase) * radius * proj._helixSide;
                    proj.x += proj._helixPx * off * 0.11;
                    proj.y += proj._helixPy * off * 0.11;
                }
                // Lissajous pattern: evolving figure-eight / knot path with dynamic frequency ratio, amplitude flips, and motion pulses
                if (proj.lissajousPattern && !proj.enemy && !proj.beam) {
                    if (!proj._lissaInit) {
                        proj._lissaInit = true;
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._lissaFx = proj.vx / sp; proj._lissaFy = proj.vy / sp; // forward basis
                        proj._lissaPx = -proj._lissaFy; proj._lissaPy = proj._lissaFx; // lateral basis
                        proj._lissaT = 0;
                        // amplitude envelope (now wider default for clearer figure)
                        // Tunables: widen factor allows quick global scaling.
                        proj._lissaWidenFactor = 1.55; // CHANGE THIS to globally widen/narrow (1 = old scale)
                        proj._lissaBaseA = (20 + Math.random()*8) * proj._lissaWidenFactor;
                        proj._lissaBaseB = (14 + Math.random()*6) * (proj._lissaWidenFactor * 0.85);
                        proj._lissaA = proj._lissaBaseA;
                        proj._lissaB = proj._lissaBaseB;
                        // start with near 1:2 ratio then morph toward 2:3 or 3:4 to create evolving shape
                        proj._lissaFreqA = 0.16; // base horizontal component
                        proj._lissaFreqB = 0.32; // vertical double
                        proj._lissaTargetSets = [ [0.21,0.31], [0.24,0.40], [0.18,0.27] ];
                        proj._lissaCurTarget = 0;
                        proj._lissaPhase = Math.random()*Math.PI*2;
                        proj._lissaRot = 0; // slow rotation of local frame
                        proj._lissaLast = { x:0, y:0 };
                        proj._lissaFlipTimer = 80 + Math.floor(Math.random()*50); // amplitude flip cadence
                        proj._lissaPulseTimer = 55 + Math.floor(Math.random()*40); // motion pulse cadence
                        proj._lissaSpeedPulse = 0; // frames of active speed modulation
                    }
                    proj._lissaT++;
                    // Periodically retarget frequency pair for evolving curve
                    if (proj._lissaT % 160 === 0) {
                        proj._lissaCurTarget = (proj._lissaCurTarget + 1) % proj._lissaTargetSets.length;
                    }
                    const tgt = proj._lissaTargetSets[proj._lissaCurTarget];
                    // Ease current freqs toward target
                    proj._lissaFreqA += (tgt[0] - proj._lissaFreqA) * 0.015;
                    proj._lissaFreqB += (tgt[1] - proj._lissaFreqB) * 0.015;
                    // Light amplitude breathing
                    const ampPulse = 1 + Math.sin(proj._lissaT*0.02)*0.08;
                    proj._lissaA = proj._lissaBaseA * ampPulse;
                    proj._lissaB = proj._lissaBaseB * (1 - Math.sin(proj._lissaT*0.017)*0.06);
                    // Amplitude flip event (swap roles & invert one axis briefly)
                    proj._lissaFlipTimer--;
                    if (proj._lissaFlipTimer === 0) {
                        const tmp = proj._lissaBaseA;
                        proj._lissaBaseA = proj._lissaBaseB;
                        proj._lissaBaseB = tmp * (0.90 + Math.random()*0.25);
                        proj._lissaFlipTimer = 95 + Math.floor(Math.random()*70);
                        // minor inversion of Y component for dramatic knot
                        proj._lissaFreqB *= (Math.random()<0.5? -1:1);
                        addParticle(proj.x, proj.y, '#66E0FF','spark');
                    }
                    // Speed pulse event: temporarily exaggerate lateral displacement
                    proj._lissaPulseTimer--;
                    if (proj._lissaPulseTimer === 0) {
                        proj._lissaPulseTimer = 140 + Math.floor(Math.random()*70);
                        proj._lissaSpeedPulse = 22; // frames
                        addParticle(proj.x, proj.y, '#44F6FF','spark');
                    }
                    // path sample
                    const ax = Math.sin(proj._lissaT * proj._lissaFreqA + proj._lissaPhase) * proj._lissaA;
                    const ay = Math.sin(proj._lissaT * proj._lissaFreqB) * proj._lissaB * Math.sin(proj._lissaT*0.005 + proj._lissaPhase*0.5);
                    // diff to last sample -> local displacement
                    const dx = ax - proj._lissaLast.x;
                    const dy = ay - proj._lissaLast.y;
                    proj._lissaLast.x = ax; proj._lissaLast.y = ay;
                    // Rotate local frame slowly around forward vector to create figure-eight twist
                    proj._lissaRot += 0.0035;
                    const cosr = Math.cos(proj._lissaRot), sinr = Math.sin(proj._lissaRot);
                    // rotated perpendicular basis
                    const rPxX = proj._lissaPx * cosr + proj._lissaFx * sinr * 0.4; // slight coupling of forward to lateral for depth
                    const rPxY = proj._lissaPy * cosr + proj._lissaFy * sinr * 0.4;
                    const rFxX = proj._lissaFx * cosr - proj._lissaPx * sinr * 0.4;
                    const rFxY = proj._lissaFy * cosr - proj._lissaPy * sinr * 0.4;
                    // apply displacement
                    let pulseScale = 1;
                    if (proj._lissaSpeedPulse > 0) { pulseScale = 1.5; proj._lissaSpeedPulse--; }
                    // Increased displacement multipliers to widen path (scaled by widen factor)
                    const lateralScale = 0.24 * (proj._lissaWidenFactor || 1);
                    const forwardScale = 0.12 * (proj._lissaWidenFactor || 1) * 0.9; // keep forward modulation gentler
                    proj.x += (rPxX * dx * lateralScale + rFxX * dy * forwardScale) * pulseScale;
                    proj.y += (rPxY * dx * lateralScale + rFxY * dy * forwardScale) * pulseScale;
                    // trailing particles with higher density during pulse
                    if (Math.random() < (proj._lissaSpeedPulse > 0 ? 0.22 : 0.085)) {
                        const col = proj._lissaSpeedPulse>0?'#55FFFF':'#AAEEFF';
                        addParticle(proj.x, proj.y, col,'spark');
                        // Occasional accent ring when pulse active for readability
                        if (proj._lissaSpeedPulse>0 && Math.random()<0.15) addParticle(proj.x, proj.y, '#66FFFF','ring');
                    }
                }
                // Slalom pattern: sharp gated zigzag (hold straight segments, sudden corner turns)
                if (proj.slalomPattern && !proj.enemy && !proj.beam) {
                    if (!proj._slalomInit) {
                        proj._slalomInit = true;
                        proj._slalomSegment = 0; // frames into current segment
                        proj._slalomSegmentLen = 16; // length of straight run
                        proj._slalomTurnAngle = 0.42; // radians per corner (sharper than before)
                        proj._slalomDir = 1; // next turn direction sign
                        proj._slalomMaxSegments = 8; // after this revert to straight
                        proj._slalomMade = 0;
                        proj._slalomTrailTick = 0;
                    }
                    proj._slalomSegment++;
                    proj._slalomTrailTick++;
                    // light trailing particles while in segment to emphasize straightness
                    if (proj._slalomTrailTick % 7 === 0 && proj._slalomMade < proj._slalomMaxSegments) {
                        addParticle(proj.x, proj.y, '#BBD9FF','trail');
                    }
                    if (proj._slalomSegment >= proj._slalomSegmentLen && proj._slalomMade < proj._slalomMaxSegments) {
                        proj._slalomSegment = 0;
                        proj._slalomMade++;
                        // perform sharp corner turn
                        const ang = Math.atan2(proj.vy, proj.vx);
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        const newAng = ang + proj._slalomDir * proj._slalomTurnAngle;
                        proj.vx = Math.cos(newAng) * sp;
                        proj.vy = Math.sin(newAng) * sp;
                        // flip direction for next corner
                        proj._slalomDir *= -1;
                        // corner visual burst
                        for (let k=0;k<4;k++) addParticle(proj.x, proj.y, '#88C4FF','spark');
                    }
                    // After finishing designated segments, damp pattern to avoid wave illusions
                    if (proj._slalomMade >= proj._slalomMaxSegments) {
                        proj.slalomPattern = false; // stop further zigzagging; projectile resumes straight path
                    }
                }
                // Pendulum pattern (distinct redesign): heavy initial swing with decaying amplitude, variable forward speed
                // slows near peak and accelerates at center (unlike sine wave constant forward). Also adds vertical sag (1-cosθ)
                // and a forward speed boost when swing settles.
                if (proj.pendulumPattern && !proj.enemy && !proj.beam) {
                    if (!proj._pendInit) {
                        proj._pendInit = true;
                        const sp = Math.hypot(proj.vx, proj.vy)||0.0001;
                        proj._pendBaseSpeed = sp; // base linear speed reference
                        proj._pendFx = proj.vx/sp; proj._pendFy = proj.vy/sp;
                        proj._pendPx = -proj._pendFy; proj._pendPy = proj._pendFx;
                        proj._pendAnchorX = proj.x; proj._pendAnchorY = proj.y;
                        proj._pendAngle = (Math.random()<0.5?1:-1) * 0.85; // larger initial deflection (~49°) to differentiate visually
                        proj._pendAngVel = 0;
                        proj._pendLength = 42 + Math.random()*14; // longer to exaggerate arc
                        proj._pendGravity = 0.07; // slightly higher for natural period
                        proj._pendDamp = 0.991;   // very gentle damping
                        proj._pendFrame = 0;
                        proj._pendMaxFrames = 240; // slightly longer showcase
                        proj._pendMinSwingVel = 0.0022;
                        proj._pendLastSign = Math.sign(proj._pendAngle);
                        proj._pendPeaks = 0;
                    }
                    proj._pendFrame++;
                    // Physics integration
                    const angAcc = -proj._pendGravity * Math.sin(proj._pendAngle);
                    proj._pendAngVel += angAcc;
                    proj._pendAngVel *= proj._pendDamp;
                    proj._pendAngle += proj._pendAngVel;
                    // Detect peak (sign change in angular velocity or near-zero crossing of angle with opposite sign soon)
                    if (proj._pendLastSign !== 0) {
                        const curSign = Math.sign(proj._pendAngVel);
                        if (curSign !== 0 && curSign !== proj._pendLastSign) {
                            proj._pendPeaks++;
                            // Peak particle fan
                            for (let k=0;k<5;k++) addParticle(proj.x + (Math.random()-0.5)*12, proj.y + (Math.random()-0.5)*12, '#FFD580','spark');
                        }
                        proj._pendLastSign = curSign;
                    }
                    // Variable forward anchor advance: scaled by |cos(angle)| so it nearly pauses at peaks
                    const forwardScale = Math.max(0.15, Math.abs(Math.cos(proj._pendAngle))); // never fully zero
                    const fStep = proj._pendBaseSpeed * 0.9 * forwardScale; // slightly reduced base
                    proj._pendAnchorX += proj._pendFx * fStep;
                    proj._pendAnchorY += proj._pendFy * fStep;
                    // Lateral displacement and vertical sag: sag = (1 - cosθ) * sagScale along perpendicular negative Y of pendulum plane (simulate depth by projecting onto forward-normal blend)
                    const lateral = Math.sin(proj._pendAngle) * proj._pendLength;
                    const sag = (1 - Math.cos(proj._pendAngle)) * (proj._pendLength * 0.20);
                    // Apply lateral along perpendicular, sag along small downward world Y bias for visual depth
                    proj.x = proj._pendAnchorX + proj._pendPx * lateral;
                    proj.y = proj._pendAnchorY + proj._pendPy * lateral + sag * 0.25; // subtle downward curve
                    // Instantaneous velocity approximation for downstream systems
                    const latVel = Math.cos(proj._pendAngle) * proj._pendLength * proj._pendAngVel;
                    const instVx = proj._pendFx * fStep + proj._pendPx * latVel;
                    const instVy = proj._pendFy * fStep + proj._pendPy * latVel + (sag * 0.25 - (proj._pendPrevSag||0))*0.9;
                    proj.vx = instVx; proj.vy = instVy;
                    proj._pendPrevSag = sag * 0.25;
                    // Trail particles more intense near center (fast) using cos-based intensity
                    const trailIntensity = 0.06 + Math.abs(Math.cos(proj._pendAngle))*0.12;
                    if (Math.random() < trailIntensity) addParticle(proj.x, proj.y, '#FFC899','spark');
                    // Termination: when angular velocity minimal OR time cap
                    if ((Math.abs(proj._pendAngVel) < proj._pendMinSwingVel && Math.abs(proj._pendAngle) < 0.12) || proj._pendFrame >= proj._pendMaxFrames) {
                        // Forward speed boost proportional to how many peaks (diminishing)
                        const boost = 1 + Math.min(0.35, proj._pendPeaks * 0.05);
                        const finalSp = proj._pendBaseSpeed * boost;
                        proj.vx = proj._pendFx * finalSp;
                        proj.vy = proj._pendFy * finalSp;
                        for (let b=0;b<8;b++) addParticle(proj.x + (Math.random()-0.5)*14, proj.y + (Math.random()-0.5)*14, '#FFD9AA','spark');
                        proj.pendulumPattern = false;
                    }
                }
                // Sawtooth wave: slow drift then snap
                if (proj.sawWave && !proj.enemy && !proj.beam) {
                    if (!proj._sawInit) {
                        proj._sawInit = true;
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        proj._sawFx = proj.vx/sp; proj._sawFy = proj.vy/sp;
                        proj._sawPx = -proj._sawFy; proj._sawPy = proj._sawFx;
                        proj._sawT = 0;
                        proj._sawPeriod = 38 + Math.floor(Math.random()*14);
                        proj._sawAmp = 24 + Math.random()*10;
                    }
                    proj._sawT = (proj._sawT + 1) % proj._sawPeriod;
                    const t = proj._sawT / proj._sawPeriod; // 0..1
                    let wave = t; // ramp
                    // At snap point, invert quickly
                    if (t > 0.92) wave = -1 + (t - 0.92)/0.08; // rapid return
                    const lateral = (wave - 0.46) * 2 * proj._sawAmp; // center
                    const dl = (lateral - (proj._sawLast||0));
                    proj._sawLast = lateral;
                    proj.x += proj._sawPx * dl * 0.12;
                    proj.y += proj._sawPy * dl * 0.12;
                }
                // Vector Pivot (pivotPattern): straight flight segments punctuated by crisp quarter-turn pivots.
                if (proj.pivotPattern && !proj.enemy && !proj.beam && !proj._orbital) {
                    if (!proj._pivotInit) {
                        proj._pivotInit = true;
                        proj._pivotInterval = 26 + Math.floor(Math.random()*10); // frames between pivots
                        proj._pivotTimer = 0;
                        proj._pivotDir = (Math.random()<0.5?1:-1); // rotation direction sign
                        proj._pivotEasing = 0; // 0..1 during active pivot
                        proj._pivotActive = false;
                        proj._pivotTurns = 0;
                        proj._pivotMaxTurns = 6;
                        proj._pivotBaseSpeed = Math.hypot(proj.vx, proj.vy)||1;
                    }
                    proj._pivotTimer++;
                    if (!proj._pivotActive && proj._pivotTimer >= proj._pivotInterval && proj._pivotTurns < proj._pivotMaxTurns) {
                        proj._pivotActive = true;
                        proj._pivotTimer = 0;
                        proj._pivotEasing = 0;
                        const sp = Math.hypot(proj.vx, proj.vy)||1;
                        proj._pivotStartVX = proj.vx/sp; proj._pivotStartVY = proj.vy/sp;
                        const tx = proj._pivotDir * -proj._pivotStartVY;
                        const ty = proj._pivotDir * proj._pivotStartVX;
                        proj._pivotTargetVX = tx; proj._pivotTargetVY = ty;
                        proj._pivotTurns++;
                        proj._pivotDir *= -1; // alternate
                        for (let k=0;k<4;k++) addParticle(proj.x, proj.y, '#FFD980','spark');
                    }
                    if (proj._pivotActive) {
                        proj._pivotEasing += 0.12;
                        const p = proj._pivotEasing;
                        const ease = p < 1 ? (1 - Math.pow(1-p, 3)) : 1; // cubic ease-out
                        const nx = proj._pivotStartVX * (1 - ease) + proj._pivotTargetVX * ease;
                        const ny = proj._pivotStartVY * (1 - ease) + proj._pivotTargetVY * ease;
                        const spd = proj._pivotBaseSpeed;
                        proj.vx = nx * spd;
                        proj.vy = ny * spd;
                        if (p >= 1) {
                            proj._pivotActive = false;
                            addParticle(proj.x, proj.y, '#FFC040','spark');
                        }
                    }
                    if (proj._pivotTurns >= proj._pivotMaxTurns) {
                        proj.pivotPattern = false;
                    }
                }
                // Temporal Drift: phase cycles
                if (proj.temporalDrift && !proj.enemy && !proj.beam) {
                    if (!proj._tdInit) {
                        proj._tdInit = true;
                        proj._tdPhase = 0; // 0 slow-stretch, 1 normal, 2 surge
                        proj._tdTimer = 0;
                    }
                    proj._tdTimer++;
                    const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                    if (proj._tdPhase === 0) { // slow stretch
                        proj.vx *= 0.985; proj.vy *= 0.985;
                        if (proj._tdTimer > 22) { proj._tdPhase = 1; proj._tdTimer = 0; }
                    } else if (proj._tdPhase === 1) {
                        if (proj._tdTimer > 18) { proj._tdPhase = 2; proj._tdTimer = 0; }
                    } else if (proj._tdPhase === 2) { // surge
                        proj.vx *= 1.018; proj.vy *= 1.018;
                        if (proj._tdTimer > 14) { proj._tdPhase = 0; proj._tdTimer = 0; }
                    }
                    // clamp speed increase to 1.9x original
                    const nsp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                    const cap = sp * 1.9;
                    if (nsp > cap) { proj.vx = proj.vx/nsp*cap; proj.vy = proj.vy/nsp*cap; }
                }
                // Pattern motion aggregation: multiple pattern flags can now stack.
                // We'll accumulate desired velocity adjustments and apply once later for base projectile types.
                if (!proj._patternInit) {
                    proj._patternInit = true;
                    proj._agg = { baseSpeed: null, fwX: null, fwY: null, px: null, py: null };
                }
                let patternApplied = false;
                let aggDX = 0, aggDY = 0; // additive velocity deltas from patterns
                // Establish forward & perpendicular bases lazily
                const ensureBasis = () => {
                    if (proj._agg.baseSpeed) return;
                    const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                    proj._agg.baseSpeed = sp;
                    proj._agg.fwX = proj.vx / sp;
                    proj._agg.fwY = proj.vy / sp;
                    // choose a stable perpendicular (seeded by projectile id via random) for repeatability
                    if (Math.random() < 0.5) { proj._agg.px = -proj._agg.fwY; proj._agg.py = proj._agg.fwX; }
                    else { proj._agg.px = proj._agg.fwY; proj._agg.py = -proj._agg.fwX; }
                };
                // Sine wave lateral oscillation (now stackable)
                if (proj.sineWave && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    // Initialize sine metadata once
                    if (!proj._sineInit) {
                        proj._sineInit = true;
                        // capture forward direction unit vector
                        proj._fwx = proj._agg.fwX; proj._fwy = proj._agg.fwY;
                        proj._px = proj._agg.px;  proj._py = proj._agg.py;
                        // amplitude scales lightly with speed but clamped
                        const ampBase = 14 + Math.random()*8; // 14-22
                        // Use stored baseSpeed (captured in ensureBasis) instead of undefined 'sp'
                        const baseSp = proj._agg && proj._agg.baseSpeed ? proj._agg.baseSpeed : Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._sineAmp = Math.min(26, ampBase + baseSp*1.2);
                        // frequency determines how tight the wave is (cycles per 60 frames)
                        proj._sineFreq = 0.18 + Math.random()*0.10; // radians increment per frame
                        proj._sinePhase = Math.random() * Math.PI * 2; // starting phase
                        proj._lastOffset = 0;
                        // store a stable forward speed so homing/other minor steering keeps wave consistent
                        proj._baseSpeed = proj._agg.baseSpeed;
                    }
                    // advance phase
                    proj._sinePhase += proj._sineFreq;
                    // desired lateral offset relative to centerline
                    const offset = Math.sin(proj._sinePhase) * proj._sineAmp;
                    // delta lateral movement this frame
                    const delta = offset - proj._lastOffset;
                    proj._lastOffset = offset;
                    aggDX += proj._px * delta;
                    aggDY += proj._py * delta;
                    patternApplied = true;
                }
                // Wacky zigzag: adds perpendicular velocity component flips (stackable; reduced amplitude if combined)
                if (proj.wackyZigzag && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    if (!proj._wackyInit) {
                        proj._wackyInit = true;
                        const sp = proj._agg.baseSpeed;
                        // Store base forward speed for reference
                        proj._baseSpeed = sp;
                        // New omni-directional jitter system:
                        // Instead of just flipping perpendicular, we pick a random direction vector (including diagonals)
                        // every few frames and blend it in as a steering impulse.
                        proj._wackyTimer = 0;
                        proj._wackyInterval = 5 + Math.floor(Math.random()*8); // 5-12 frames per direction
                        proj._wackyAmpBase = Math.min(32, 14 + sp * 1.8 + Math.random()*10); // base magnitude potential
                        proj._wackyVec = { x: 0, y: 0 };
                        proj._wackyTarget = { x: 0, y: 0 };
                        proj._wackyJitterPhase = Math.random()*Math.PI*2;
                        // Helper to choose next direction from 8-way set (including diagonals) with slight random magnitude skew
                        proj._pickWackyDir = function() {
                            const dirs = [
                                {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},
                                {x:0.707,y:0.707},{x:-0.707,y:0.707},{x:0.707,y:-0.707},{x:-0.707,y:-0.707}
                            ];
                            const d = dirs[Math.floor(Math.random()*dirs.length)];
                            // random magnitude modulation (0.6 - 1.1)
                            const mag = 0.6 + Math.random()*0.5;
                            proj._wackyTarget.x = d.x * mag;
                            proj._wackyTarget.y = d.y * mag;
                        };
                        proj._pickWackyDir();
                        // Chaos variant minor initialization adjustments (if flagged at spawn)
                        if (proj._wackyChaos) {
                            // Slightly higher starting amplitude ceiling
                            proj._wackyAmpBase = Math.min(40, proj._wackyAmpBase + 6 + Math.random()*4);
                            // Shorter first interval for instant flair
                            proj._wackyInterval = 4 + Math.floor(Math.random()*5);
                        }
                    }
                    proj._wackyTimer++;
                    if (proj._wackyTimer >= proj._wackyInterval) {
                        proj._wackyTimer = 0;
                        proj._wackyInterval = 5 + Math.floor(Math.random()*8);
                        proj._pickWackyDir();
                        // occasional spark to indicate sudden re-vectoring
                        if (Math.random() < 0.5) addParticle(proj.x, proj.y, '#FFDD55', 'spark');
                        // mild amplitude modulation on each pick
                        const ampJitter = (Math.random()*6 - 3);
                        proj._wackyAmpBase = Math.max(10, Math.min(36, proj._wackyAmpBase + ampJitter));
                    }
                    // Chaos variant overlay behavior
                    let chaosFactor = 1;
                    if (proj._wackyChaos) {
                        // Frame-based timers (fallback if no global frame counter by using projectile life inverse)
                        const frameNow = (typeof game.frame === 'number') ? game.frame : (game.tick || (6000 - proj.life));
                        proj._wackyChaosTimer = (proj._wackyChaosTimer||0) + 1;
                        if (proj._wackyChaosTimer >= (proj._wackyChaosInterval||12)) {
                            proj._wackyChaosTimer = 0;
                            // Re-roll next chaos interval (tighter range than normal steering interval)
                            proj._wackyChaosInterval = 4 + Math.floor(Math.random()*6); // 4-9
                            // 20% chance: amplitude surge burst
                            if (Math.random() < 0.20) {
                                proj._wackyAmpBase = Math.min(48, proj._wackyAmpBase + 8 + Math.random()*6);
                                proj._wackyChaosBurst = 6 + Math.floor(Math.random()*6); // sustain heightened amplitude
                                addParticle(proj.x, proj.y, '#FFBB44', 'spark');
                            }
                            // 10% chance: dramatic 180 flip (cooldown 24 frames to avoid spam)
                            if (Math.random() < 0.10 && (proj._wackyChaosLastFlip||0) + 24 < frameNow) {
                                proj._wackyTarget.x *= -1; proj._wackyTarget.y *= -1;
                                proj._wackyChaosLastFlip = frameNow;
                                addParticle(proj.x, proj.y, '#FFA722', 'spark');
                            } else {
                                // Otherwise occasionally force an immediate new dir (55%)
                                if (Math.random() < 0.55) proj._pickWackyDir();
                            }
                            // Rare lateral micro explosion impulse (5%)
                            if (Math.random() < 0.05) {
                                const burstAng = Math.random()*Math.PI*2;
                                const impulse = 6 + Math.random()*10;
                                aggDX += Math.cos(burstAng) * impulse;
                                aggDY += Math.sin(burstAng) * impulse;
                                addParticle(proj.x + Math.cos(burstAng)*4, proj.y + Math.sin(burstAng)*4, '#FFD155', 'spark');
                            }
                        }
                        if (proj._wackyChaosBurst && proj._wackyChaosBurst > 0) {
                            proj._wackyChaosBurst--;
                            const t = proj._wackyChaosBurst/10; // 0..~1
                            chaosFactor = 1 + 0.35 * Math.sin(t*Math.PI); // smooth ease in/out
                            if (Math.random() < 0.18) addParticle(proj.x, proj.y, '#FFC966', 'spark');
                        }
                        // Additional subtle random lateral twitches (very small, frequent)
                        if (Math.random() < 0.12) {
                            aggDX += (Math.random()-0.5) * 4;
                            aggDY += (Math.random()-0.5) * 4;
                        }
                    }
                    // Smoothly steer current vector toward target (gives curve instead of instant snap)
                    proj._wackyVec.x = proj._wackyVec.x * 0.72 + proj._wackyTarget.x * 0.28;
                    proj._wackyVec.y = proj._wackyVec.y * 0.72 + proj._wackyTarget.y * 0.28;
                    // Add a subtle sinusoidal micro jitter layered on top (breathing motion)
                    proj._wackyJitterPhase += 0.35 + Math.random()*0.15;
                    const micro = Math.sin(proj._wackyJitterPhase) * 0.35;
                    let vx = proj._wackyVec.x + micro*(Math.random()<0.5?1:-1);
                    let vy = proj._wackyVec.y + micro*(Math.random()<0.5?1:-1);
                    // Normalize vector then scale by dynamic amplitude with pattern dampening
                    const len = Math.sqrt(vx*vx + vy*vy) || 1;
                    vx /= len; vy /= len;
                    const patternDampen = (proj.sineWave ? 0.55 : 1) * (proj.ekgWave ? 0.75 : 1) * (proj.spiral ? 0.85 : 1);
                    const amp = proj._wackyAmpBase * patternDampen * (chaosFactor || 1);
                    aggDX += vx * amp;
                    aggDY += vy * amp;
                    patternApplied = true;
                }
                // EKG wave: cardiogram-like offset spikes (stackable)
                if (proj.ekgWave && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    if (!proj._ekgInit) {
                        proj._ekgInit = true;
                        proj._fwx = proj._agg.fwX; proj._fwy = proj._agg.fwY;
                        proj._px = proj._agg.px;  proj._py = proj._agg.py;
                        proj._baseSpeed = proj._agg.baseSpeed;
                        // Phase timing (frames) sequence: flat -> pre-pulse -> spike ascend -> spike descend -> recovery
                        // We'll encode as state machine
                        proj._ekgState = 'flat';
                        proj._ekgTimer = 0;
                        // randomize cycle length slightly so multiple shots desync
                        proj._ekgFlatDur = 22 + Math.floor(Math.random()*14); // baseline length
                        proj._ekgPreDur = 4;   // small jitter pulses
                        proj._ekgAscDur = 3;   // fast rise
                        proj._ekgDescDur = 3;  // fast fall
                        proj._ekgRecoverDur = 5; // settle back
                        // Max spike lateral amplitude (increased for more dramatic spikes)
                        // Tunable constants: adjust EKG_AMP_BASE / EKG_AMP_VAR / EKG_AMP_MULT to quickly rebalance.
                        const EKG_AMP_BASE = 68;      // was 42
                        const EKG_AMP_VAR  = 16;      // was 10
                        const EKG_AMP_MULT = 1.25;    // additional global multiplier
                        proj._ekgAmp = (EKG_AMP_BASE + Math.random()*EKG_AMP_VAR) * EKG_AMP_MULT;
                        proj._lastOffset = 0;
                    }
                    proj._ekgTimer++;
                    let offset = 0;
                    const st = proj._ekgState;
                    if (st === 'flat') {
                        // tiny baseline flicker (scaled up slightly so baseline feels more alive relative to larger spikes)
                        offset = Math.sin(proj._ekgTimer*0.6) * 3.2; // was *2
                        if (proj._ekgTimer >= proj._ekgFlatDur) { proj._ekgState = 'pre'; proj._ekgTimer = 0; }
                    } else if (st === 'pre') {
                        // small rapid pulses that grow leading into spike (amplitude increased proportionally)
                        const t = proj._ekgTimer / proj._ekgPreDur; // 0..1
                        offset = Math.sin(proj._ekgTimer*3) * (5 + t*9); // was (4 + t*6)
                        if (proj._ekgTimer >= proj._ekgPreDur) { proj._ekgState = 'asc'; proj._ekgTimer = 0; }
                    } else if (st === 'asc') {
                        const t = proj._ekgTimer / proj._ekgAscDur; // 0..1
                        offset = -proj._ekgAmp * Math.sin(t * (Math.PI/2)); // rapid upward (or downward) spike (sign randomized by px orientation)
                        if (proj._ekgTimer >= proj._ekgAscDur) { proj._ekgState = 'desc'; proj._ekgTimer = 0; }
                        // Add a bright particle at apex start
                        if (proj._ekgTimer === 1) addParticle(proj.x, proj.y, '#88FFAA', 'spark');
                    } else if (st === 'desc') {
                        const t = proj._ekgTimer / proj._ekgDescDur;
                        // mirror descent overshoot with a stronger rebound (~32% vs prior 20%) to accentuate spike snap-back
                        offset = -proj._ekgAmp * (1 - t) + proj._ekgAmp*0.32 * t; // was 0.2
                        if (proj._ekgTimer >= proj._ekgDescDur) { proj._ekgState = 'recover'; proj._ekgTimer = 0; }
                    } else if (st === 'recover') {
                        const t = proj._ekgTimer / proj._ekgRecoverDur;
                        // ease back to baseline
                        offset = (proj._lastOffset) * (1 - t);
                        if (proj._ekgTimer >= proj._ekgRecoverDur) { proj._ekgState = 'flat'; proj._ekgTimer = 0; proj._ekgFlatDur = 18 + Math.floor(Math.random()*18); }
                    }
                    // Convert offset to lateral delta (perpendicular axis)
                    const delta = offset - (proj._lastOffset || 0);
                    proj._lastOffset = offset;
                    // Slightly reduce spikeScale to keep composite speed within cap after amplitude increase
                    const spikeScale = (st==='asc' || st==='desc') ? 0.82 : 0.58; // was 0.95 / 0.6
                    aggDX += proj._px * delta * spikeScale;
                    aggDY += proj._py * delta * spikeScale;
                    patternApplied = true;
                    // subtle trail particle at spike apex / transition
                    if (st === 'asc' && proj._ekgTimer === Math.floor(proj._ekgAscDur/2)) {
                        addParticle(proj.x, proj.y, '#66FFCC', 'spark');
                    }
                }
                // Apply aggregated pattern adjustments (only for non-orbital, non-beam, non-enemy projectiles)
                if (patternApplied && !proj._orbital && !proj.beam && !proj.enemy) {
                    // Rebuild forward component from stored basis, add aggregated lateral
                    const fwSpeed = proj._agg.baseSpeed;
                    // Keep forward velocity magnitude stable while adding lateral influence
                    let desiredVx = proj._agg.fwX * fwSpeed + aggDX;
                    let desiredVy = proj._agg.fwY * fwSpeed + aggDY;
                    // Gyro Stabilizer: reduce lateral displacement influence (acts like damping)
                    if (proj.gyroStabilizer) {
                        const lateralVx = desiredVx - proj._agg.fwX * fwSpeed;
                        const lateralVy = desiredVy - proj._agg.fwY * fwSpeed;
                        desiredVx = proj._agg.fwX * fwSpeed + lateralVx * 0.55;
                        desiredVy = proj._agg.fwY * fwSpeed + lateralVy * 0.55;
                    }
                    // Soft normalization to avoid runaway speed inflation
                    const maxSpeed = fwSpeed * 1.85;
                    const sp2 = Math.sqrt(desiredVx*desiredVx + desiredVy*desiredVy) || 0.0001;
                    if (sp2 > maxSpeed) {
                        desiredVx = desiredVx / sp2 * maxSpeed;
                        desiredVy = desiredVy / sp2 * maxSpeed;
                    }
                    // Blend for smoothness
                    proj.vx = proj.vx * 0.58 + desiredVx * 0.42;
                    proj.vy = proj.vy * 0.58 + desiredVy * 0.42;
                }
                // === Emission / Lifecycle Behaviors (new abilities) ===
                if (!proj.enemy && !proj.beam) {
                    // Bloom Ring: emit expanding pellet ring periodically
                    if (proj.bloomRing) {
                        // Hybrid mode C: Occasional small sub-ring emissions from projectiles (low density)
                        // while main large rings are handled at player level (updateBloomRings())
                        // Use per-projectile stagger so not all cores emit on same frame
                        const subInterval = 160 + ((proj._bloomSubRand)||(proj._bloomSubRand = Math.floor(Math.random()*90))); // ~2.5s avg
                        proj._bloomSubTimer = (proj._bloomSubTimer||0)+1;
                        if (proj._bloomSubTimer >= subInterval) {
                            proj._bloomSubTimer = 0;
                            // Emit a tiny petal burst (6) for visual continuity
                            const count = 6;
                            const baseDmg = proj.baseDamage || calculateDamage();
                            for (let r=0;r<count;r++) {
                                const ang = (r/count)*Math.PI*2;
                                const spd = 3.6 + Math.random()*0.5;
                                game.projectiles.push({
                                    x: proj.x, y: proj.y,
                                    vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
                                    life: 34,
                                    size: Math.max(2, Math.floor(proj.size*0.45)),
                                    enemy:false,
                                    damage: Math.max(1, Math.floor(baseDmg * 0.22)),
                                    baseDamage: Math.max(1, Math.floor(baseDmg * 0.22)),
                                    bloomChild:true,
                                    _petal:true
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFEEDD','spark');
                        }
                    }
                    // Cascade Burst: pulsing forward micro-bursts
                    if (proj.cascadeBurst) {
                        if (!proj._cascInit) { proj._cascInit=true; proj._cascTimer=12; }
                        proj._cascTimer--;
                        if (proj._cascTimer<=0) {
                            proj._cascTimer = 14; // reset
                            const ang = Math.atan2(proj.vy, proj.vx);
                            const parts = 3;
                            for (let k=0;k<parts;k++) {
                                const off = (k - (parts-1)/2)*0.08;
                                game.projectiles.push({
                                    x: proj.x + Math.cos(ang)*8,
                                    y: proj.y + Math.sin(ang)*8,
                                    vx: Math.cos(ang+off)* (getProjSpeed(proj)*1.05),
                                    vy: Math.sin(ang+off)* (getProjSpeed(proj)*1.05),
                                    life: 40,
                                    size: Math.max(2, proj.size*0.45),
                                    enemy:false,
                                    damage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.32)),
                                    baseDamage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.32)),
                                    cascadeChild:true,
                                    _initialFx: Math.cos(ang+off), _initialFy: Math.sin(ang+off)
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFD4AA','spark');
                            for (let q=0;q<3;q++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFB866','spark');
                        }
                    }
                    // Fragment Wake: trailing small lingering damaging sparks (new system)
                    if (proj.fragmentWake) {
                        // Initialize per-projectile emission tracking
                        if (!proj._fwPrevX) { proj._fwPrevX = proj.x; proj._fwPrevY = proj.y; proj._fwDistAcc = 0; }
                        const dx = proj.x - proj._fwPrevX, dy = proj.y - proj._fwPrevY;
                        const dist = Math.hypot(dx, dy);
                        proj._fwDistAcc += dist;
                        proj._fwPrevX = proj.x; proj._fwPrevY = proj.y;
                        // Emit a spark every ~18px traveled (slightly randomized spacing)
                        const spacing = 14 + (proj._fwRandOff || (proj._fwRandOff = Math.random()*6));
                        while (proj._fwDistAcc >= spacing) {
                            proj._fwDistAcc -= spacing;
                            const baseDmg = (proj.baseDamage||calculateDamage());
                            if (!Array.isArray(game.fragmentSparks)) game.fragmentSparks = [];
                            if (game.fragmentSparks.length > 220) game.fragmentSparks.splice(0, game.fragmentSparks.length - 220);
                            game.fragmentSparks.push({
                                x: proj.x + (Math.random()-0.5)*6,
                                y: proj.y + (Math.random()-0.5)*6,
                                r: 6 + Math.random()*3,
                                ttl: 38,
                                maxTtl: 38,
                                damage: Math.max(1, Math.floor(baseDmg * 0.10)),
                                dpsTick: 0,
                                hitMap: new Set(),
                                pulse: Math.random()*Math.PI*2
                            });
                        }
                    }
                    // Phase Echo: spawn afterimages that later pop for mini-hit
                    if (proj.phaseEcho) {
                        if (!proj._echoInit) { proj._echoInit=true; proj._echoTimer=10; }
                        proj._echoTimer--;
                        if (proj._echoTimer<=0) {
                            proj._echoTimer = 26; // cadence
                            if ((proj._echoesSpawned||0) < 3) {
                                const ghost = {
                                    x: proj.x, y: proj.y, vx: 0, vy:0, life: 22, size: Math.max(2, proj.size*0.6), enemy:false,
                                    phaseGhost:true, parentRef: proj, damage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.25)), baseDamage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.25))
                                };
                                game.projectiles.push(ghost);
                                proj._echoesSpawned=(proj._echoesSpawned||0)+1;
                            }
                        }
                    }
                    // Resonant Pulse Core: emits periodic expanding ring that grants temporary speed/damage/homing buff
                    if (proj.resonantPulseCore) {
                        proj._resCoreTimer = (proj._resCoreTimer||0)+1;
                        proj._resActiveRings = proj._resActiveRings || [];
                        const interval = 90; // frames between pulses
                        if (proj._resCoreTimer >= interval) {
                            proj._resCoreTimer = 0;
                            const ring = { r: 0, max: 150, life: 38 };
                            proj._resActiveRings.push(ring);
                        }
                        // Update rings
                        for (let i=proj._resActiveRings.length-1;i>=0;i--) {
                            const ring = proj._resActiveRings[i];
                            ring.r += (ring.max - ring.r) * 0.18; // ease out expansion
                            ring.life--;
                            // Apply buff to touched projectiles this frame
                            const rad2 = ring.r*ring.r;
                            game.projectiles.forEach(p2=>{
                                if (p2===proj || p2.enemy || p2.beam) return;
                                const dx = p2.x - proj.x; const dy = p2.y - proj.y;
                                const d2 = dx*dx+dy*dy;
                                if (d2 <= rad2 && !p2._resBuffedFrame) {
                                    // Mark buff application frame and set buff timers
                                    p2._resBuffedFrame = game._frameCount || performance.now();
                                    p2._resBuffSpeed = Math.max(p2._resBuffSpeed||0, 26); // speed buff frames
                                    p2._resBuffDamage = Math.max(p2._resBuffDamage||0, 30); // damage buff frames
                                    p2._resBuffHoming = Math.max(p2._resBuffHoming||0, 24); // slight homing assistance
                                    addParticle(p2.x, p2.y, '#C7A4FF','spark');
                                }
                            });
                            if (ring.life <= 0 || ring.r > ring.max*0.98) proj._resActiveRings.splice(i,1);
                        }
                        // Local optional glow particle
                        if (Math.random()<0.08) addParticle(proj.x, proj.y, '#B88CFF','ambient');
                    }
                    // Spiral Bloom: projectile corkscrews inward tightening radius then detonates into rotating petal spiral
                    if (proj.spiralBloom) {
                        if (!proj._sbInit) {
                            proj._sbInit=true;
                            proj._sbPhase='tighten';
                            proj._sbTimer=0;
                            proj._sbRadius=34;
                            proj._sbAngle = 0; // rotation phase for visible spiral motion
                            // capture forward & perpendicular for local spiral positioning
                            const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                            proj._sbFx = proj.vx/sp; proj._sbFy = proj.vy/sp;
                            proj._sbPx = -proj._sbFy; proj._sbPy = proj._sbFx;
                        }
                        proj._sbTimer++;
                        if (proj._sbPhase==='tighten') {
                            proj._sbAngle += 0.38; // spin
                            proj._sbRadius *= 0.965; // contract
                            // apply a local spiral offset around the forward axis (minor visual swirl)
                            const swirl = proj._sbRadius*0.12;
                            const sx = Math.cos(proj._sbAngle)*swirl;
                            const sy = Math.sin(proj._sbAngle)*swirl;
                            proj.x += proj._sbPx * sx * 0.08 + proj._sbFx * sy * 0.02;
                            proj.y += proj._sbPy * sx * 0.08 + proj._sbFy * sy * 0.02;
                            if (proj._sbTimer>52 || proj._sbRadius<5.5) { proj._sbPhase='bloom'; proj._sbTimer=0; }
                            if (Math.random()<0.18) addParticle(proj.x, proj.y, '#FFE6AA','spark');
                        } else if (proj._sbPhase==='bloom') {
                            if (!proj._sbBloomed) {
                                proj._sbBloomed = true;
                                const petals = 8;
                                const base = proj.baseDamage||calculateDamage();
                                // Emit petals with initial angular offset to create rotating ring that expands
                                for (let p=0;p<petals;p++) {
                                    const ang = (p/petals)*Math.PI*2;
                                    const speed = 2.4 + (p%2)*0.8; // slight alternation
                                    const vx = Math.cos(ang)*speed;
                                    const vy = Math.sin(ang)*speed;
                                    game.projectiles.push({
                                        x: proj.x, y: proj.y,
                                        vx, vy,
                                        life: 75,
                                        size: Math.max(3, proj.size*0.55), enemy:false,
                                        damage: Math.max(1, Math.floor(base*0.42)), baseDamage: Math.max(1, Math.floor(base*0.42)),
                                        petal:true,
                                        petalSpin: (Math.random()<0.5?1:-1) * (0.06 + Math.random()*0.04)
                                    });
                                }
                                // central burst particles
                                addParticle(proj.x, proj.y, '#FFEEAA','explosion');
                                for (let k=0;k<10;k++) addParticle(proj.x, proj.y, '#FFC870','spark');
                            }
                            // After bloom, remove core projectile
                            proj.life = 0;
                        }
                    }
                    // Harmonic Split: spawn angled child pair at life thresholds; parent continues until all splits done
                    if (proj.harmonicSplit && proj._harmonicThresholds && !proj._harmonicDoneAll) {
                        const ang = Math.atan2(proj.vy, proj.vx);
                        for (let idx=0; idx<proj._harmonicThresholds.length; idx++) {
                            const th = proj._harmonicThresholds[idx];
                            if (proj.life <= th && !proj._harmonicDone[th]) {
                                proj._harmonicDone[th] = true;
                                const base = proj.baseDamage||calculateDamage();
                                const childSpeed = getProjSpeed(proj) * 0.92;
                                const spread = 0.34; // radians offset (~19.5 deg)
                                for (let dir=-1; dir<=1; dir+=2) {
                                    const cAng = ang + dir*spread;
                                    game.projectiles.push({
                                        x: proj.x, y: proj.y,
                                        vx: Math.cos(cAng) * childSpeed,
                                        vy: Math.sin(cAng) * childSpeed,
                                        life: Math.max(12, Math.floor(proj.life * 0.78)),
                                        size: Math.max(2, proj.size*0.65), enemy:false,
                                        damage: Math.max(1, Math.floor(base * 0.58)), baseDamage: Math.max(1, Math.floor(base * 0.58)),
                                        harmonicChild:true,
                                        // inherit some pattern flags for visual continuity
                                        sineWave: proj.sineWave, wackyZigzag: proj.wackyZigzag, ekgWave: proj.ekgWave,
                                        spiral: proj.spiral, lissajousPattern: proj.lissajousPattern
                                    });
                                }
                                // Visual burst
                                for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE2BB','spark');
                                addParticle(proj.x, proj.y, '#FFC070','trail');
                                // Optionally trim parent damage slightly each split so total DPS doesn't overscale
                                if (proj.baseDamage) proj.baseDamage = Math.max(1, Math.floor(proj.baseDamage * 0.9));
                            }
                        }
                        if (Object.keys(proj._harmonicDone).length === proj._harmonicThresholds.length) {
                            proj._harmonicDoneAll = true;
                            // Small final marker particle
                            addParticle(proj.x, proj.y, '#FFCC88','ambient');
                        }
                    }
                    // Popcorn kernel fuse handling
                    if (proj.isPopcornKernel && !proj._popDid) {
                        proj._popFuse--;
                        // Flicker effect prior to popping
                        if (proj._popFuse < 10 && Math.random()<0.3) addParticle(proj.x, proj.y, '#FFF5AA','spark');
                        if (proj._popFuse <= 0) {
                            proj._popDid = true;
                            const base = proj.baseDamage || calculateDamage();
                            // Generate two puffs at slight random angles
                            for (let k=0;k<2;k++) {
                                const ang = Math.atan2(proj.vy, proj.vx) + (Math.random()*0.9 - 0.45);
                                const speed = (getProjSpeed(proj) * 0.85) + Math.random()*1.2;
                                game.projectiles.push({
                                    x: proj.x, y: proj.y,
                                    vx: Math.cos(ang)*speed,
                                    vy: Math.sin(ang)*speed,
                                    life: 40 + Math.floor(Math.random()*18),
                                    size: 12, enemy:false,
                                    popcornPuff:true,
                                    baseDamage: Math.max(1, Math.floor(base * 0.75)),
                                    damage: Math.max(1, Math.floor(base * 0.75)),
                                    _puffSpin: Math.random()*Math.PI*2,
                                    _puffDir: (Math.random()<0.5? -1:1)
                                });
                            }
                            // Kernel consumed
                            proj.life = 0;
                            for (let s=0;s<10;s++) addParticle(proj.x + (Math.random()-0.5)*12, proj.y + (Math.random()-0.5)*12, '#FFEFA0','spark');
                        }
                    }
                    // Umbrella Shot split trigger: convert core into two arc projectiles once distance threshold reached
                    if (proj.umbrellaCore && !proj._umbDidSplit) {
                        const stepDist = Math.hypot(proj.vx, proj.vy);
                        proj._umbTravel += stepDist;
                        proj._umbCoreAge = (proj._umbCoreAge||0)+1;
                        // Failsafe: only if very old (>80f) OR slowed to near stop (speed <0.5)
                        // Additional failsafe: if remaining life is low (<=10) force split so it never expires silently.
                        const lowLife = proj.life != null && proj.life <= 10;
                        const forceSplit = (proj._umbCoreAge > 80) || stepDist < 0.5 || lowLife;
                        if (proj._umbTravel >= (proj._umbSplitDistance || 160) || forceSplit) {
                            proj._umbDidSplit = true;
                            const base = proj.baseDamage || calculateDamage();
                            let ang = Math.atan2(proj.vy, proj.vx);
                            if (!isFinite(ang) || (Math.abs(proj.vx) < 0.0001 && Math.abs(proj.vy) < 0.0001)) {
                                // Fallback: derive from player lastDirection so arcs always have a forward reference
                                const ld = (game.player && game.player.lastDirection) || {x:1,y:0};
                                ang = Math.atan2(ld.y, ld.x);
                            }
                            const arcRadius = 140; // larger radius for a broad overhead sweep
                            for (let side=-1; side<=1; side+=2) {
                                game.projectiles.push({
                                    x: proj.x, y: proj.y,
                                    vx: 0, vy: 0,
                                    life: 110,
                                    size: Math.max(5, proj.size*0.9), enemy:false,
                                    baseDamage: Math.max(1, Math.floor(base * 0.65)),
                                    damage: Math.max(1, Math.floor(base * 0.65)),
                                    umbrellaArc: true,
                                    _arcSide: side,
                                    _arcOriginX: proj.x,
                                    _arcOriginY: proj.y,
                                    _arcBaseAngle: ang,
                                    _arcProgress: 0,
                                    _arcRadius: arcRadius,
                                    _arcAngularSpan: Math.PI, // 180° sweep
                                    _arcSpeed: 0.028,
                                    _arcDone: false,
                                    sineWave: proj.sineWave, wackyZigzag: proj.wackyZigzag, ekgWave: proj.ekgWave, spiral: proj.spiral
                                });
                            }
                            for (let p=0;p<18;p++) addParticle(proj.x + (Math.random()-0.5)*24, proj.y + (Math.random()-0.5)*24, '#FFDFAA','spark');
                            // Debug: mark origin in a distinct color briefly (helps verify spawn)
                            addParticle(proj.x, proj.y, '#FFAA55','ambient');
                            addParticle(proj.x, proj.y, '#FFE8CC','trail');
                            proj.life = 0;
                        }
                    }
                    // Umbrella arc motion handler (true 180° opposing sweeps, then fade)
                    if (proj.umbrellaArc) {
                        if (!proj._arcDone) {
                            proj._arcProgress += proj._arcSpeed;
                            if (proj._arcProgress > 1) proj._arcProgress = 1;
                            const curAng = proj._arcBaseAngle + proj._arcSide * (proj._arcProgress * proj._arcAngularSpan);
                            proj.x = proj._arcOriginX + Math.cos(curAng) * proj._arcRadius;
                            proj.y = proj._arcOriginY + Math.sin(curAng) * proj._arcRadius;
                            if (Math.random()<0.10) addParticle(proj.x, proj.y, '#FFE8BB','spark');
                            if (proj._arcProgress >= 1) {
                                proj._arcDone = true;
                                proj._arcFade = 18; // brief linger
                                // Endpoint marker to confirm full 180° reach
                                addParticle(proj.x, proj.y, '#FFCC55','spark');
                            }
                        } else {
                            proj._arcFade--;
                            if (proj._arcFade <= 0) proj.life = 0;
                            else if (Math.random()<0.12) addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFDFAA','spark');
                        }
                    }
                    // Echo Bloom: staged echo spawning culminating in amplified bloom burst
                    if (proj.echoBloom) {
                        if (!proj._echoInit) {
                            proj._echoInit = true;
                            proj._echoStage = 0; // stages 0..N then final bloom
                            proj._echoNextLifePoint = Math.floor(proj.life * 0.70); // initial trigger threshold
                            proj._echoMaxStages = 2; // number of intermediate echoes before final
                            proj._echoPetalColor = '#FFE0FF';
                            proj._echoTelegraph = 0; // grows near bloom
                            proj._echoTelegraphMax = 42; // frames of max telegraph before bloom
                        }
                        // Spawn echoes at descending life thresholds
                        if (proj.life <= proj._echoNextLifePoint && proj._echoStage < proj._echoMaxStages) {
                            const scale = 0.55 + proj._echoStage*0.15;
                            const dmgScale = 0.30 + proj._echoStage*0.1;
                            const echo = {
                                x: proj.x, y: proj.y,
                                vx: proj.vx* (0.35 + proj._echoStage*0.1),
                                vy: proj.vy* (0.35 + proj._echoStage*0.1),
                                life: proj.life + 18 + proj._echoStage*6,
                                size: Math.max(2, proj.size*scale), enemy:false,
                                echoChild:true, parentRef: proj,
                                baseDamage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*dmgScale)),
                                damage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*dmgScale))
                            };
                            game.projectiles.push(echo);
                            for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFC8FF','spark');
                            proj._echoStage++;
                            // schedule next threshold deeper into life (fractional)
                            proj._echoNextLifePoint = Math.floor(proj.life * (0.55 - proj._echoStage*0.10));
                        }
                        // Check for echoes converging; when all spawned echoes have converged, trigger bloom
                        if (proj._echoStage === proj._echoMaxStages && !proj._echoBloomed) {
                            let converged = true;
                            let echoCount = 0;
                            for (let p2 of game.projectiles) {
                                if (p2.echoChild && p2.parentRef === proj) {
                                    echoCount++;
                                    const dx=p2.x-proj.x; const dy=p2.y-proj.y; if (dx*dx+dy*dy > 36) { converged=false; break; }
                                }
                            }
                            // Telegraph growth once all echoes spawned
                            if (echoCount && !proj._echoBloomed) {
                                proj._echoTelegraph = Math.min(proj._echoTelegraph + 1, proj._echoTelegraphMax);
                                if (proj._echoTelegraph > proj._echoTelegraphMax * 0.65 && Math.random()<0.25) {
                                    addParticle(proj.x + (Math.random()-0.5)*20, proj.y + (Math.random()-0.5)*20, '#FFD6FF','spark');
                                }
                            }
                            if (echoCount && converged) {
                                // Perform bloom: radial petal ring + explosion damage
                                proj._echoBloomed = true;
                                const base = proj.baseDamage||calculateDamage();
                                const burstDmg = Math.max(1, Math.floor(base * 1.10)); // stronger central pop
                                explodeProjectile({x:proj.x,y:proj.y,size:proj.size,enemy:false}, burstDmg);
                                addScreenShake(6);
                                // Larger petal count scaling with multi-shot patterns (optional simple scale)
                                const petals = 10 + Math.floor(Math.random()*4);
                                for (let p=0;p<petals;p++) {
                                    const ang = (p/petals)*Math.PI*2;
                                    game.projectiles.push({
                                        x: proj.x, y: proj.y,
                                        vx: Math.cos(ang)*(2.8 + Math.random()*0.6), vy: Math.sin(ang)*(2.8 + Math.random()*0.6),
                                        life: 65,
                                        size: Math.max(2, proj.size*0.55), enemy:false,
                                        damage: Math.max(1, Math.floor(base*0.42)), baseDamage: Math.max(1, Math.floor(base*0.42)),
                                        echoPetal:true
                                    });
                                }
                                // Resonance field: lingering aura dealing periodic pulse damage near center
                                const field = {
                                    x: proj.x, y: proj.y,
                                    radius: 120,
                                    createdAt: Date.now(),
                                    duration: 1800,
                                    tickEvery: 300,
                                    lastTick: 0,
                                    baseDamage: Math.max(1, Math.floor(base * 0.30)),
                                    type: 'echoBloom'
                                };
                                if (!game.echoBloomFields) game.echoBloomFields = [];
                                game.echoBloomFields.push(field);
                                addParticle(proj.x, proj.y, '#FFE6FF','explosion');
                                for (let r=0;r<20;r++) addParticle(proj.x + (Math.random()-0.5)*140, proj.y + (Math.random()-0.5)*140, '#FFC8FF','spark');
                                // consume echoes
                                for (let p2 of game.projectiles) {
                                    if (p2.echoChild && p2.parentRef === proj) p2.life = 0;
                                }
                            }
                        }
                    }
                    // Veering Fan: mid-flight conversion to multi-shot
                    if (proj.veeringFan && proj._veeringTimer !== undefined) {
                        // Distance gating: ensure projectile traveled enough before considering split.
                        const dxSpawn = proj.x - (proj._spawnX||proj.x);
                        const dySpawn = proj.y - (proj._spawnY||proj.y);
                        const distSq = dxSpawn*dxSpawn + dySpawn*dySpawn;
                        if (distSq < (proj._veerMinDist||0)*(proj._veerMinDist||0)) {
                            // Defer countdown until distance met.
                        } else {
                            proj._veeringTimer--;
                        }
                        if (proj._veeringTimer === 0 && !proj._veered) {
                            proj._veered = true;
                            const ang = Math.atan2(proj.vy, proj.vx);
                            const speed = getProjSpeed(proj);
                            const base = proj.baseDamage||calculateDamage();
                            const sideCount = 4; // number of side projectiles (excludes original center)
                            const maxSpread = 0.55; // total radians from far left to far right (~31 deg)
                            // Keep original projectile as CENTER; adjust its stats slightly
                            proj.baseDamage = Math.max(1, Math.floor(base * 0.65));
                            proj.damage = proj.baseDamage;
                            proj.size = Math.max(2, proj.size * 0.75);
                            proj._centerVeer = true;
                            // Generate side projectiles in symmetrical pairs with easing spread
                            for (let i=0;i<sideCount;i++) {
                                const t = (i/(sideCount-1)) * 2 - 1; // -1 .. 1
                                // Ease towards extremes (quadratic) so inner shots cluster near center
                                const eased = t * Math.abs(t); // stronger near edges
                                const offset = eased * (maxSpread/2);
                                if (Math.abs(offset) < 0.0001) continue; // skip near-zero offset (center occupied)
                                const vx = Math.cos(ang + offset) * speed * 0.97;
                                const vy = Math.sin(ang + offset) * speed * 0.97;
                                game.projectiles.push({
                                    x: proj.x, y: proj.y,
                                    vx, vy,
                                    life: Math.floor(proj.life * 0.85),
                                    size: Math.max(2, proj.size * 0.60), enemy:false,
                                    damage: Math.max(1, Math.floor(base * 0.45)), baseDamage: Math.max(1, Math.floor(base * 0.45)),
                                    veerChild:true,
                                    _initialFx: Math.cos(ang + offset), _initialFy: Math.sin(ang + offset)
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFF2CC','spark');
                        }
                    }
                    // Converging Twins (new phased behavior): diverge -> curve inward -> fuse -> fused projectile persists
                    if (proj.convergePair && proj._convGroup) {
                        proj._convTimer = (proj._convTimer||0)+1;
                        const phase = proj._convPhase || 'diverge';
                        const sp = Math.hypot(proj.vx, proj.vy) || 0.0001;
                        const ang = Math.atan2(proj.vy, proj.vx);
                        if (phase === 'diverge') {
                            // Maintain slight outward lateral drift for a set duration
                            if (proj._convTimer > 14) {
                                proj._convPhase = 'curveIn';
                                proj._convTimer = 0;
                            }
                        } else if (phase === 'curveIn') {
                            // Apply curvature toward central forward direction gradually
                            // Determine average heading of group by sampling partner
                            let partner = null;
                            for (const p2 of game.projectiles) {
                                if (p2!==proj && p2._convGroup === proj._convGroup && !p2._fused && !proj._fused) { partner = p2; break; }
                            }
                            const forwardAng = partner ? Math.atan2((proj.vy+partner.vy)/2, (proj.vx+partner.vx)/2) : ang;
                            const blend = 0.05 + Math.min(0.18, proj._convTimer*0.004);
                            const newAng = ang + (forwardAng - ang)*blend;
                            proj.vx = Math.cos(newAng)*sp;
                            proj.vy = Math.sin(newAng)*sp;
                            if (proj._convTimer > 26) {
                                proj._convPhase = 'fuseCheck';
                                proj._convTimer = 0;
                            }
                        } else if (phase === 'fuseCheck') {
                            // Only one (primary) attempts fusion logic
                            if (proj._convPrimary) {
                                let partner = null;
                                for (const p2 of game.projectiles) {
                                    if (p2!==proj && p2._convGroup === proj._convGroup && !p2._fused && !proj._fused) { partner = p2; break; }
                                }
                                if (partner) {
                                    const dx = partner.x - proj.x; const dy = partner.y - proj.y; const d2 = dx*dx+dy*dy;
                                    // Allow fairly wide detection so they fuse mid-screen; shrink over time
                                    const fuseRadius = 110 - Math.min(70, proj._convTimer*2); // starts large, narrows
                                    if (d2 <= fuseRadius*fuseRadius) {
                                        // If very close perform actual fusion
                                        if (d2 < 38*38) {
                                            const baseCombined = (proj.baseDamage||calculateDamage()) + (partner.baseDamage||calculateDamage());
                                            const fuseX = (proj.x+partner.x)/2; const fuseY = (proj.y+partner.y)/2;
                                            const fuseVx = (proj.vx+partner.vx)/2; const fuseVy = (proj.vy+partner.vy)/2;
                                            // Spawn fused projectile with boosted size and damage (not full sum to avoid runaway)
                                            const fusedDmg = Math.max(1, Math.floor(baseCombined * 0.95));
                                            game.projectiles.push({
                                                x: fuseX, y: fuseY,
                                                vx: fuseVx, vy: fuseVy,
                                                life: Math.max(proj.life, partner.life) + 40,
                                                size: Math.max(proj.size, partner.size) + 4,
                                                enemy:false,
                                                damage: fusedDmg,
                                                baseDamage: fusedDmg,
                                                fusedTwin:true,
                                                _fuseAuraTimer: 0,
                                                _convFused:true
                                            });
                                            proj._fused = true; partner._fused = true; proj.life = 0; partner.life = 0;
                                            // AoE burst on fuse (reward mid-range)
                                            const burstR = 90;
                                            const burstDamage = Math.max(2, Math.floor(fusedDmg * 0.45));
                                            if (game.enemies && game.enemies.length) {
                                                for (const en of game.enemies) {
                                                    const ex = en.x - fuseX; const ey = en.y - fuseY;
                                                    if (ex*ex+ey*ey <= burstR*burstR) {
                                                        en.health -= burstDamage;
                                                        addDamageNumber(burstDamage, en.x, en.y - en.size/2, { type:'arcane' });
                                                    }
                                                }
                                            }
                                            addParticle(fuseX, fuseY, '#BBAAFF','explosion');
                                        }
                                    }
                                    // After some time, if not fused yet, gently pull them together
                                    if (!proj._fused && proj._convTimer > 40 && partner) {
                                        const dx2 = partner.x - proj.x; const dy2 = partner.y - proj.y; const d = Math.hypot(dx2, dy2) || 1;
                                        const pull = Math.min(0.35, 12/d);
                                        proj.vx += dx2/d * pull * 0.5; proj.vy += dy2/d * pull * 0.5;
                                        partner.vx -= dx2/d * pull * 0.5; partner.vy -= dy2/d * pull * 0.5;
                                    }
                                }
                            }
                            proj._convTimer++;
                            // Fail-safe: stop checking after long time to avoid infinite state retention
                            if (proj._convTimer > 160) proj._convPhase = 'expired';
                        }
                    }
                }
                // Resonance framework: count active core motion patterns (excluding orbital/beam/enemy)
                if (!proj.enemy && !proj.beam) {
                    const motionPatterns = [proj.sineWave, proj.wackyZigzag, proj.ekgWave, proj.spiral];
                    let patternCount = 0;
                    for (let mp of motionPatterns) if (mp) patternCount++;
                    if (patternCount >= 2) {
                        // light intrinsic damage amplification stored on projectile
                        if (!proj._resonanceApplied) {
                            proj._resonanceApplied = true;
                            // store a multiplier rather than immediately mutating baseDamage so later scaling uses it
                            proj._resonanceMult = 1 + (patternCount === 2 ? 0.08 : patternCount === 3 ? 0.15 : 0.22);
                        }
                        // escalate multiplier if projectile later gains more patterns (e.g., via inheritance)
                        if (proj._resonanceMult) {
                            const desiredMult = 1 + (patternCount === 2 ? 0.08 : patternCount === 3 ? 0.15 : 0.22);
                            if (desiredMult > proj._resonanceMult) proj._resonanceMult = desiredMult;
                        }
                        // resonance pulse setup for >=3 patterns
                        if (patternCount >= 3) {
                            proj._resPulseTimer = (proj._resPulseTimer || 0) + 1;
                            // base interval shrinks slightly with patternCount (e.g., 90 -> 70 frames)
                            const interval = patternCount === 3 ? 90 : 70;
                            if (proj._resPulseTimer >= interval) {
                                proj._resPulseTimer = 0;
                                // spawn a lightweight pulse marker (handled immediately here for simplicity)
                                const pulseRadius = 52 + patternCount * 10;
                                const baseDmg = (proj.baseDamage || calculateDamage());
                                const pulseDamage = Math.floor(baseDmg * (0.18 + 0.04 * (patternCount - 3))); // 18% or 22%
                                game.enemies.forEach(en => {
                                    const dx = en.x - proj.x; const dy = en.y - proj.y;
                                    if (dx*dx + dy*dy <= pulseRadius * pulseRadius) {
                                        en.health -= pulseDamage;
                                        addParticle(en.x, en.y, '#AA66FF', 'impact');
                                    }
                                });
                                // visual ring particles
                                for (let k=0;k<24;k++) {
                                    const ang = (k/24)*Math.PI*2;
                                    addParticle(proj.x + Math.cos(ang)*pulseRadius, proj.y + Math.sin(ang)*pulseRadius, patternCount===3?'#66DDFF':'#FF55FF', 'spark');
                                }
                            }
                        }
                        // Quad resonance (all four patterns) occasional hypersurge: brief speed spike & particle
                        if (patternCount === 4) {
                            proj._quadTick = (proj._quadTick || 0) + 1;
                            if (proj._quadTick % 120 === 0) {
                                // small forward burst
                                const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                                proj.vx *= 1.25; proj.vy *= 1.25;
                                // clamp after burst
                                const nsp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                                const max = sp * 1.8;
                                if (nsp > max) { proj.vx = proj.vx / nsp * max; proj.vy = proj.vy / nsp * max; }
                                addParticle(proj.x, proj.y, '#FF99FF', 'spark');
                            }
                        }
                    }
                }
                // Homing behavior (full homing and weak homing)
                if (!proj.enemy && game.enemies.length > 0 && (proj.homing || proj.weakHoming)) {
                    // find nearest enemy
                    let target = null;
                    let closestDist = Infinity;
                    game.enemies.forEach(enemy => {
                        const dist = Math.sqrt((enemy.x - proj.x) ** 2 + (enemy.y - proj.y) ** 2);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = enemy;
                        }
                    });
                    if (target) {
                        const dx = target.x - proj.x;
                        const dy = target.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                        if (proj.homing) {
                            // stronger homing: steer more aggressively and normalize
                            const steer = 0.12;
                            proj.vx += (dx / dist) * steer;
                            proj.vy += (dy / dist) * steer;
                            const sp = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) || 0.0001;
                            const desired = Math.max(0.6, sp);
                            proj.vx = (proj.vx / sp) * desired;
                            proj.vy = (proj.vy / sp) * desired;
                        } else if (proj.weakHoming) {
                            // weak homing: slight steering so the effect is noticeable but not overpowering
                            const steer = 0.045;
                            proj.vx += (dx / dist) * steer;
                            proj.vy += (dy / dist) * steer;
                        }
                    }
                }
                // Pattern Trail Visuals: emit lightweight particles indicating motion synergy
                if (!proj.enemy && !proj.beam) {
                    // Determine if projectile should spawn a trail this frame
                    // Base chance for any projectile with motion pattern; higher for chaos wacky
                    let spawnTrail = false;
                    let baseChance = 0;
                    const motionCount = (proj.sineWave?1:0)+(proj.wackyZigzag?1:0)+(proj.ekgWave?1:0)+(proj.spiral?1:0);
                    if (motionCount > 0) baseChance = 0.10 + motionCount * 0.03; // 10% +3% per pattern
                    if (proj.wackyZigzag) baseChance += 0.05;
                    if (proj._wackyChaos) baseChance += 0.12; // more intense trail for chaos variant
                    if (Math.random() < baseChance) spawnTrail = true;
                    if (spawnTrail) {
                        const hex = getProjectileSynergyColor(proj);
                        // Particle size scales with motion complexity
                        const pSize =  proj._wackyChaos ? 6 : (3 + Math.min(3, motionCount));
                        // Emit 1-2 particles, slight backward offset along velocity
                        const backX = proj.x - proj.vx*0.08;
                        const backY = proj.y - proj.vy*0.08;
                        addParticle(backX, backY, hex, 'spark');
                        if (proj._wackyChaos && Math.random()<0.5) addParticle(backX + (Math.random()-0.5)*6, backY + (Math.random()-0.5)*6, hex, 'spark');
                    }
                }
                // Beam pattern blending (visual modulation) - apply after homing but before movement finalize
                if (proj.beam && !proj.enemy) {
                    // increment phase
                    proj._beamPatternPhase = (proj._beamPatternPhase || 0) + 1;
                    // slight oscillation perpendicular to direction for sine
                    if (!proj._beamBasis) {
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||1;
                        proj._beamBasis = { fx: proj.vx/sp, fy: proj.vy/sp };
                        proj._beamBasis.px = -proj._beamBasis.fy; proj._beamBasis.py = proj._beamBasis.fx;
                    }
                    let offX = 0, offY = 0;
                    const phase = proj._beamPatternPhase;
                    if (proj.sineWave) {
                        const amp = 4 + (proj.spiral?2:0);
                        const s = Math.sin(phase * 0.3) * amp;
                        offX += proj._beamBasis.px * s; offY += proj._beamBasis.py * s;
                    }
                    if (proj.wackyZigzag) {
                        const dirFlip = ((phase/6)|0)%2===0?1:-1;
                        offX += proj._beamBasis.px * dirFlip * 3;
                        offY += proj._beamBasis.py * dirFlip * 3;
                    }
                    if (proj.ekgWave) {
                        const cyc = phase % 50;
                        if (cyc < 8) {
                            const t = cyc/8; const spike = -Math.sin(t*Math.PI)*10;
                            offX += proj._beamBasis.px * spike; offY += proj._beamBasis.py * spike;
                        }
                    }
                    if (proj.spiral) {
                        const rotAng = phase * 0.15;
                        // rotate offset around small circle
                        offX += Math.cos(rotAng)*2; offY += Math.sin(rotAng)*2;
                    }
                    proj.x += offX * 0.25; // damp to avoid large displacement changing collision fairness
                    proj.y += offY * 0.25;
                    // occasional pattern particle
                    if (Math.random() < 0.12) {
                        const color = proj.spiral?'#FF66FF': (proj.ekgWave?'#66FFCC': (proj.wackyZigzag?'#FFDD55':'#66AAFF'));
                        addParticle(proj.x, proj.y, color, 'spark');
                    }
                }
                // Boomerang behavior (ensured return + chaining + movement bias + wind synergy)
                if (proj.boomerang && !proj.enemy) {
                    // Initialization of boomerang arc parameters
                    if (!proj._boomInit) {
                        proj._boomInit = true;
                        // Store origin and initial forward unit vector
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 1;
                        proj._boomFx = proj.vx / sp; proj._boomFy = proj.vy / sp;
                        // Random lateral sign for variety
                        proj._boomSide = (Math.random() < 0.5 ? -1 : 1);
                        // Max lateral offset radius (arc width)
                        proj._boomMaxLat = 90 + Math.random()*30; // px
                        // Distance before turning back
                        proj._boomOutboundDist = 180 + Math.random()*40; // slightly shorter to ensure visible return
                        proj._boomTravel = 0; // accumulated forward distance
                        proj._boomReturn = false;
                        proj._boomChained = false; // echo spawn flag
                        proj._boomOriginX = proj.x; proj._boomOriginY = proj.y;
                        proj._boomAge = 0; // frames alive for safety timeout
                        proj._boomForced = false; // whether forced return occurred
                        proj._boomBaseLife = proj.life || 140;
                    }
                    proj._boomAge++;
                    // Compute forward speed magnitude
                    let speed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.01;
                    // Update forward travel distance using projection onto initial forward vector
                    const stepForward = (proj.vx*proj._boomFx + proj.vy*proj._boomFy);
                    // Accumulate more aggressively so high lateral components still progress outbound timer
                    proj._boomTravel += Math.max(0, stepForward * 0.9);
                    // Fallback: also measure radial distance from origin; if that exceeds outboundDist * 0.9, trigger return
                    if (!proj._boomReturn) {
                        const ox = proj.x - proj._boomOriginX; const oy = proj.y - proj._boomOriginY;
                        const radial = Math.hypot(ox,oy);
                        if (radial > proj._boomOutboundDist * 0.95) proj._boomReturn = true;
                    }

                    // Trigger return when outbound distance met OR if exceeded arena bounds
                    if (!proj._boomReturn && proj._boomTravel >= proj._boomOutboundDist) {
                        proj._boomReturn = true;
                    }
                    // Safety timeout: if not yet returning by frame 90, force it
                    if (!proj._boomReturn && proj._boomAge > 90) {
                        proj._boomReturn = true; proj._boomForced = true;
                    }

                    // Movement bias: if player currently moving, gently bias lateral side toward movement perpendicular (outbound only)
                    if (!proj._boomReturn) {
                        const mvx = (game.keys['d']?1:0) - (game.keys['a']?1:0);
                        const mvy = (game.keys['s']?1:0) - (game.keys['w']?1:0);
                        if (mvx || mvy) {
                            const ml = Math.hypot(mvx,mvy)||1; const nmx = mvx/ml, nmy = mvy/ml;
                            const cross = (proj._boomFx * nmy - proj._boomFy * nmx); // signed relation
                            if (Math.abs(cross) > 0.2) {
                                proj._boomSide = cross > 0 ? 1 : -1;
                            }
                        }
                    }

                    // Base forward direction: outbound uses initial forward; return aims toward player gradually
                    let fx = proj._boomFx, fy = proj._boomFy;
                    if (proj._boomReturn) {
                        const dxp = game.player.x - proj.x;
                        const dyp = game.player.y - proj.y;
                        const dpl = Math.hypot(dxp,dyp)||1;
                        const tFx = dxp / dpl, tFy = dyp / dpl;
                        // Smoothly rotate toward player direction (lerp of unit vectors) stronger when forced
                        const blend = proj._boomForced ? 0.25 : 0.12;
                        fx = fx * (1-blend) + tFx * blend; fy = fy * (1-blend) + tFy * blend;
                        const norm = Math.hypot(fx,fy)||1; fx/=norm; fy/=norm;
                        proj._boomFx = fx; proj._boomFy = fy;
                        // Mirror arc side for return for a classic boomerang path
                        proj._boomSide = proj._boomSide || 1; // safety
                        proj._boomReturnSide = (typeof proj._boomReturnSide==='number')?proj._boomReturnSide: -proj._boomSide;
                        // Extend life on entering return so it doesn't vanish prematurely
                        if (!proj._boomLifeExtended) { proj.life = Math.max(proj.life, 60); proj._boomLifeExtended = true; }
                    }

                    // Lateral progress (0..1) along outbound or return; use sine for graceful arc
                    const phaseFrac = Math.min(1, proj._boomTravel / proj._boomOutboundDist);
                    // Ease the lateral amplitude: outbound grows then stabilizes, return decreases
                    let lateralFrac;
                    if (!proj._boomReturn) {
                        lateralFrac = Math.sin(phaseFrac * Math.PI * 0.9); // peaks before full outbound
                    } else {
                        lateralFrac = Math.sin((1 - phaseFrac) * Math.PI * 0.9); // fade down
                    }
                    lateralFrac = Math.max(0, lateralFrac);
                    const latMag = proj._boomMaxLat * lateralFrac;
                    // Perpendicular vector to forward (fx,fy)
                    const px = -fy, py = fx;
                    // Determine side: outbound uses _boomSide, return uses mirrored side for a figure
                    const side = proj._boomReturn ? (proj._boomReturnSide) : proj._boomSide;
                    // Target lateral position relative to straight-line forward ray
                    proj._boomLat = latMag * side;
                    // We convert lateral displacement into a small velocity tweak pulling the projectile outward along perpendicular
                    // Then speed toward forward direction is slightly reduced near peak arc to curve naturally.
                    const lateralStrength = 0.12;
                    proj.vx = fx * speed * 0.97 + px * (proj._boomLat/ proj._boomMaxLat) * lateralStrength * speed;
                    proj.vy = fy * speed * 0.97 + py * (proj._boomLat/ proj._boomMaxLat) * lateralStrength * speed;
                    // Minimum forward speed clamp so it doesn't stall mid-air
                    const curSpeed = Math.hypot(proj.vx, proj.vy) || 0.01;
                    if (curSpeed < 2) {
                        const boost = (proj._boomReturn ? 1.25 : 1.12);
                        proj.vx = (proj.vx / curSpeed) * (curSpeed * boost + 0.05);
                        proj.vy = (proj.vy / curSpeed) * (curSpeed * boost + 0.05);
                    }
                    // Slight acceleration on return to ensure timely comeback
                    if (proj._boomReturn) {
                        proj.vx *= 1.012; proj.vy *= 1.012;
                    }
                    // Wind synergy: dynamic widening & swirl particles
                    if (game.player && game.player.abilities && game.player.abilities.includes('Wind Blade')) {
                        proj._boomMaxLat = Math.min(170, proj._boomMaxLat * 1.004 + 0.05);
                        if (Math.random() < 0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#AEEFFF','spark');
                    }
                    // Multi-boomerang chaining (echo spawns) during outbound
                    if (!proj._boomReturn && !proj._boomChained && !proj._boomEcho && proj._boomTravel > proj._boomOutboundDist * 0.50) {
                        proj._boomChained = true;
                        const echoCount = 1 + (Math.random()<0.45 ? 1 : 0);
                        for (let e=0;e<echoCount;e++) {
                            const angJitter = (Math.random()-0.5)*0.3;
                            const baseSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) * (0.85 - e*0.1);
                            const ang = Math.atan2(proj.vy, proj.vx) + angJitter;
                            const echo = {
                                x: proj.x + Math.cos(ang)*6,
                                y: proj.y + Math.sin(ang)*6,
                                vx: Math.cos(ang)*baseSpeed,
                                vy: Math.sin(ang)*baseSpeed,
                                size: Math.max(4, (proj.size||6)*0.85),
                                life: Math.min(160, (proj.life||140)),
                                enemy: false,
                                baseDamage: Math.floor((proj.baseDamage||calculateDamage()) * 0.55),
                                damageType: proj.damageType,
                                boomerang: true,
                                boomerangReturned: false,
                                _boomInit: false,
                                _boomEcho: true,
                                piercing: proj.piercing,
                                pierceCount: proj.pierceCount||0,
                                pierceHits: 0
                            };
                            for (let p=0;p<6;p++) addParticle(echo.x + (Math.random()-0.5)*10, echo.y + (Math.random()-0.5)*10, '#FFFFFF','spark');
                            game.projectiles.push(echo);
                        }
                    }
                    // Arrival check (close to player once returning)
                    const dxp2 = proj.x - game.player.x;
                    const dyp2 = proj.y - game.player.y;
                    if (proj._boomReturn && Math.hypot(dxp2,dyp2) < 22) {
                        for (let k=0;k<5;k++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFFFFF', 'spark');
                        return false;
                    }
                    // Decorative trailing sparkle (subtle) while returning
                    if (proj._boomReturn && Math.random()<0.18) addParticle(proj.x, proj.y, '#E0F8FF','spark');
                }
                // Time Bomb: delayed explosion after a timer
                if (proj.timeBomb && !proj.enemy) {
                    proj._timeBombTimer = (typeof proj._timeBombTimer === 'number') ? proj._timeBombTimer : 54; // default short fuse
                    proj._timeBombTimer--;
                    const t = proj._timeBombTimer;
                    // Pulse visuals escalate quickly
                    if (t % 10 === 0) addParticle(proj.x, proj.y, '#FFECAA', 'spark');
                    if (t < 36 && t % 5 === 0) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFC744', 'spark');
                    if (t < 18 && t % 2 === 0) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FF9922', 'spark');
                    if (t === 20) proj._timeBombArmed = true;
                    // Mild flashing scale indicator when armed
                    if (proj._timeBombArmed && t % 4 === 0) {
                        addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFD777', 'spark');
                    }
                    if (t <= 0) {
                        const damage = Math.floor((proj.baseDamage || calculateDamage()) * (proj._timeBombExplosionMult || 2.0));
                        explodeProjectile(proj, damage);
                        proj.life = 0;
                    }
                }
                // Meteor: guided descent toward target; guaranteed timed explosion with knockback
                if (proj.meteor && !proj.enemy) {
                    // Flame / trail particles
                    proj._flameTick = (proj._flameTick || 0) + 1;
                    if (proj._flameTick % 2 === 0) {
                        addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFB347', 'spark');
                        if (Math.random() < 0.30) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFD27F', 'spark');
                    }
                    if (proj._flameTick % 5 === 0) addParticle(proj.x + (Math.random()-0.5)*16, proj.y + (Math.random()-0.5)*16, '#663300', 'explosion');
                    // Deterministic interpolation based on spawn/detonate frames
                    if (proj._meteorDetonateAt && proj._meteorSpawnFrame != null && proj._meteorStartY != null) {
                        const total = Math.max(1, proj._meteorDetonateAt - proj._meteorSpawnFrame);
                        const elapsed = Math.min(total, game.frame - proj._meteorSpawnFrame);
                        const t = Math.min(1, elapsed / total);
                        if (proj._meteorTargetX != null && proj._meteorStartX != null) {
                            const easeT = t < 0.5 ? (2*t*t) : (-1 + (4 - 2*t)*t); // easeInOut
                            proj.x = proj._meteorStartX + (proj._meteorTargetX - proj._meteorStartX) * easeT;
                        }
                        if (proj._meteorTargetY != null) {
                            proj.y = proj._meteorStartY + (proj._meteorTargetY - proj._meteorStartY) * t;
                        }
                    }
                    if (game.frame >= proj._meteorDetonateAt && !proj._meteorExploded) {
                        proj._meteorExploded = true;                        
                        const dmg = proj.baseDamage || calculateDamage();
                        const radius = proj._meteorAoeRadius || 90;
                        // Damage + knockback
                        game.enemies.forEach(en => {
                            const dx = en.x - proj.x; const dy = en.y - proj.y; const dist = Math.hypot(dx,dy);
                            if (dist <= radius) {
                                const mult = (1 - dist / radius) * 0.75 + 0.25; // soften edge
                                const dealt = Math.floor(dmg * mult);
                                en.health -= dealt;
                                addDamageNumber(dealt, en.x, en.y - en.size/2, { type: 'fire' });
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                                // Knockback outward
                                const k = (proj._meteorKnockback || 120) * (1 - dist / radius);
                                if (k > 8) applyKnockback(en, k, dx, dy);
                            }
                        });
                        addScreenShake(11);
                        // Visual blast
                        explodeProjectile({ x: proj.x, y: proj.y, size: proj.size, damageType: 'fire', knockback: true, knockbackDistance: proj._meteorKnockback || 120 }, dmg);
                        for (let p=0;p<38;p++) addParticle(proj.x + (Math.random()-0.5)*radius*1.4, proj.y + (Math.random()-0.5)*radius*1.4, '#FF8844','explosion');
                        // Retire telegraph marker
                        if (typeof proj._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[proj._meteorMarkerId]) {
                            game.meteorMarkers[proj._meteorMarkerId].dead = true;
                        }
                        proj.life = 0;
                    } else if (proj.life <= 0 && !proj._meteorExploded) {
                        // Fallback: if life ended prematurely (e.g., offscreen cull modification) still trigger explosion
                        proj._meteorExploded = true;
                        const dmg = proj.baseDamage || calculateDamage();
                        const radius = proj._meteorAoeRadius || 90;
                        game.enemies.forEach(en => {
                            const dx = en.x - proj.x; const dy = en.y - proj.y; const dist = Math.hypot(dx,dy);
                            if (dist <= radius) {
                                const mult = (1 - dist / radius) * 0.75 + 0.25;
                                const dealt = Math.floor(dmg * mult);
                                en.health -= dealt;
                                addDamageNumber(dealt, en.x, en.y - en.size/2, { type: 'fire' });
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                                const k = (proj._meteorKnockback || 120) * (1 - dist / radius);
                                if (k > 8) applyKnockback(en, k, dx, dy);
                            }
                        });
                        addScreenShake(9);
                        explodeProjectile({ x: proj.x, y: proj.y, size: proj.size, damageType: 'fire', knockback: true, knockbackDistance: proj._meteorKnockback || 120 }, dmg);
                        for (let p=0;p<26;p++) addParticle(proj.x + (Math.random()-0.5)*radius*1.2, proj.y + (Math.random()-0.5)*radius*1.2, '#FF7744','explosion');
                        if (typeof proj._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[proj._meteorMarkerId]) {
                            game.meteorMarkers[proj._meteorMarkerId].dead = true;
                        }
                    }
                }
                // Quantum shot: slight life regen so it can hit multiple times
                if (proj.quantum && !proj.enemy) {
                    proj.life += 0.15;
                }
                // Reality field refraction: if projectile passes through an active reality field, bend its velocity
                if (!proj.enemy && game.activeRealityFields && game.activeRealityFields.length > 0) {
                    game.activeRealityFields.forEach(field => {
                        const dx = proj.x - field.x;
                        const dy = proj.y - field.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < field.radius) {
                            // compute vector from field center to projectile and apply small lateral impulse
                            const angleToCenter = Math.atan2(proj.y - field.y, proj.x - field.x);
                            const lateral = (Math.cos(angleToCenter + Math.PI/2) * 0.6);
                            // nudge velocity perpendicular to radial vector to create refraction-like bend
                            const spd = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                            proj.vx += lateral * (1 - dist / field.radius) * 0.6;
                            proj.vy += Math.sin(angleToCenter + Math.PI/2) * (1 - dist / field.radius) * 0.6;
                            // normalize to keep speed stable
                            const nsp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                            proj.vx = (proj.vx / nsp) * spd;
                            proj.vy = (proj.vy / nsp) * spd;
                            // small visual cue
                            if (Math.random() < 0.08) addParticle(proj.x, proj.y, '#66FFFF', 'spark');
                        }
                    });
                }
                // Orbital projectiles: now inherit motion pattern modifiers for dynamic paths & resonance
                if (proj._orbital && !proj.enemy) {
                    // Initialize pattern fusion state once
                    if (!proj._orbitalInit) {
                        proj._orbitalInit = true;
                        proj._baseRadius = proj._orbitRadius;
                        proj._sinePhase = Math.random() * Math.PI * 2;
                        proj._wackyTimer = 0;
                        proj._ekgState = 'flat'; proj._ekgTimer = 0;
                        proj._spiralPhase = 0;
                        // Derive pattern presence flags from existing projectile flags (inherited at spawn)
                        proj._patSine = !!proj.sineWave;
                        proj._patWacky = !!proj.wackyZigzag;
                        proj._patEKG = !!proj.ekgWave;
                        proj._patSpiral = !!proj.spiral;
                        // Base resonance multiplier grows with number of patterns (match non-orbital logic but reduced)
                        const pc = (proj._patSine?1:0)+(proj._patWacky?1:0)+(proj._patEKG?1:0)+(proj._patSpiral?1:0);
                        proj._resonanceOrbMult = pc>=4?1.18: pc===3?1.13: pc===2?1.08:1.0; // gentler than projectile version
                    }
                    proj._orbitAngle += proj._orbitSpeed;
                    let dynamicRadius = proj._baseRadius;
                    // Sine: smooth pulsation of radius
                    if (proj._patSine) {
                        proj._sinePhase += 0.07; // slow pulse
                        dynamicRadius += Math.sin(proj._sinePhase) * (8 + Math.min(18, proj._baseRadius * 0.12));
                    }
                    // Wacky: small angular jitter & radius micro noise
                    if (proj._patWacky) {
                        proj._wackyTimer++;
                        if (proj._wackyTimer % 14 === 0) {
                            proj._orbitAngle += (Math.random() - 0.5) * 0.9; // burst re-vector
                        }
                        dynamicRadius += (Math.random() - 0.5) * 10;
                    }
                    // EKG: periodic sharp contraction / expansion pulses
                    if (proj._patEKG) {
                        proj._ekgTimer++;
                        const cyc = proj._ekgTimer % 120; // 120f cycle (~2s)
                        if (cyc < 12) {
                            // Ascending spike – rapid contraction
                            const t = cyc / 12;
                            dynamicRadius -= (18 + proj._baseRadius * 0.15) * Math.sin(t * Math.PI/2);
                        } else if (cyc >= 12 && cyc < 24) {
                            // Descend & rebound
                            const t = (cyc-12)/12;
                            dynamicRadius -= (18 + proj._baseRadius * 0.15) * (1 - t) * 0.6;
                        }
                    }
                    // Spiral: slow precession of orbital angle and mild radius growth/decay wave
                    if (proj._patSpiral) {
                        proj._spiralPhase += 0.03;
                        proj._orbitAngle += Math.sin(proj._spiralPhase * 0.8) * 0.015;
                        dynamicRadius += Math.sin(proj._spiralPhase * 1.3) * 12;
                    }
                    // Clamp radius to safe bounds
                    const minR = Math.max(40, proj._baseRadius * 0.55);
                    const maxR = Math.min(260, proj._baseRadius * 1.45);
                    if (dynamicRadius < minR) dynamicRadius = minR;
                    if (dynamicRadius > maxR) dynamicRadius = maxR;
                    proj._orbitRadius = dynamicRadius;
                    // Position orbital
                    proj.x = game.player.x + Math.cos(proj._orbitAngle) * dynamicRadius;
                    proj.y = game.player.y + Math.sin(proj._orbitAngle) * dynamicRadius;
                    // Pattern particle trail (color shift with resonance strength)
                    if (Math.random() < 0.22) {
                        const pc = (proj._patSine?1:0)+(proj._patWacky?1:0)+(proj._patEKG?1:0)+(proj._patSpiral?1:0);
                        const color = pc>=4?'#FF99FF': pc===3?'#AA88FF': pc===2?'#88EEFF':'#88EEFF';
                        addParticle(proj.x, proj.y, color, 'spark');
                    }
                    // Damage nearby enemies (resonance multiplier applied)
                    const baseTick = Math.floor(calculateDamage() * 0.6 * (proj._resonanceOrbMult || 1));
                    game.enemies.forEach(enemy => {
                        if (enemy.health<=0) return;
                        const dx = proj.x - enemy.x; const dy = proj.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < (enemy.size/2 + proj.size)) {
                            enemy.health -= Math.max(1, baseTick);
                            addParticle(enemy.x, enemy.y, '#88EEFF', 'impact');
                        }
                    });
                    proj.life = 99999; // persistent
                }
                // Spinning blade (weapon) visual/logic (unchanged behavior for weapon spin)
                if (proj.spin && !proj.enemy && !proj.spiral) {
                    proj.spinAngle += proj.spinSpeed || 0.5;
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    game.enemies.forEach((enemy) => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        if (d < (enemy.size/2 + (proj.size||10))) {
                            enemy.health -= Math.floor(calculateDamage() * 0.9);
                            addParticle(enemy.x, enemy.y, '#CCCCCC', 'impact');
                        }
                    });
                }
                // True Spiral Shot motion: projectiles with proj.spiral orbit along a local circular path while advancing forward.
                if (proj.spiral && !proj.enemy) {
                    // Initialize spiral state once
                    if (!proj._spiralInit) {
                        proj._spiralInit = true;
                        // Base forward direction from initial velocity
                        const baseDirAngle = Math.atan2(proj.vy, proj.vx);
                        proj._spiralBaseAngle = baseDirAngle; // stored for forward drift
                        proj._spiralPhase = 0; // current angle around local loop
                        // Enlarged spiral parameters for more dramatic looping
                        proj._spiralRadius = Math.max(10, Math.min(42, (proj.size||6) * 2.2)); // bigger starting loop
                        proj._spiralRadiusGrowth = 0.085; // faster outward expansion
                        proj._spiralAngularSpeed = 0.30 + Math.random()*0.10; // slightly slower to keep large loops readable
                        proj._spiralForwardSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy);
                        // Stronger damping so forward drift doesn't stretch the spiral too quickly
                        proj._spiralForwardSpeed *= 0.70;
                        // Preserve damage tracking
                    }
                    // Advance spiral phase & radius (cap radius growth to avoid huge loops)
                    proj._spiralPhase += proj._spiralAngularSpeed;
                    // Increase cap for new bigger loops
                    proj._spiralRadius = Math.min(110, proj._spiralRadius + proj._spiralRadiusGrowth);
                    // Compute local circular offset
                    const ox = Math.cos(proj._spiralPhase) * proj._spiralRadius;
                    const oy = Math.sin(proj._spiralPhase) * proj._spiralRadius;
                    // Forward drift anchor moves along base direction each frame
                    proj._spiralAnchorX = (proj._spiralAnchorX == null ? proj.x : proj._spiralAnchorX) + Math.cos(proj._spiralBaseAngle) * proj._spiralForwardSpeed;
                    proj._spiralAnchorY = (proj._spiralAnchorY == null ? proj.y : proj._spiralAnchorY) + Math.sin(proj._spiralBaseAngle) * proj._spiralForwardSpeed;
                    proj.x = proj._spiralAnchorX + ox;
                    proj.y = proj._spiralAnchorY + oy;
                    // Slight spin for visual flair if rendering uses spinAngle
                    proj.spinAngle = (proj.spinAngle || 0) + (proj.spinSpeed || 0.3);
                    // Life decay (already applied below normally) – we override base movement so skip the generic proj.x+=vx/vy step later by flagging
                    proj._skipBaseMove = true;
                    // Optional: emit small spiral particles occasionally
                    if (Math.random() < 0.18) addParticle(proj.x + (Math.random()-0.5)*4, proj.y + (Math.random()-0.5)*4, '#FF66FF', 'spark');
                }
                // Drilling shot: increases pierce and leaves a dust trail
                if (proj.drilling && !proj.enemy) {
                    proj.piercing = true;
                    proj.pierceCount = Math.max(proj.pierceCount, 6);
                    if (Math.random() < 0.2) addParticle(proj.x, proj.y, '#CCCCCC', 'spark');
                    proj._drillTicks = (proj._drillTicks || 0) + 1;
                    if (proj._drillTicks % 30 === 0) {
                        proj.baseDamage = Math.floor((proj.baseDamage || calculateDamage()) * 1.05);
                        addParticle(proj.x, proj.y, '#EEEEEE', 'spark');
                    }
                }
                if (!proj._skipBaseMove) {
                    // Store last safe position before movement for bounce recovery
                    proj._lastX = proj.x;
                    proj._lastY = proj.y;
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                }
                // Apply Resonant buff effects (speed/damage/homing) after base movement so velocity mod applies next frame
                if (!proj.enemy) {
                    if (proj._resBuffSpeed && proj._resBuffSpeed>0) {
                        proj._resBuffSpeed--;
                        proj.vx *= 1.045; proj.vy *= 1.045;
                    }
                    if (proj._resBuffDamage && proj._resBuffDamage>0) {
                        proj._resBuffDamage--;
                        if (proj.baseDamage) proj.damage = Math.max(proj.damage||1, Math.floor(proj.baseDamage * 1.15));
                    }
                    if (proj._resBuffHoming && proj._resBuffHoming>0) {
                        proj._resBuffHoming--;
                        // mild steering toward nearest enemy
                        let nearest=null; let nd2=Infinity;
                        for (const enemy of game.enemies) {
                            if (enemy.dead) continue;
                            const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const d2 = dx*dx+dy*dy; if (d2<nd2) { nd2=d2; nearest=enemy; }
                        }
                        if (nearest) {
                            const sp = Math.hypot(proj.vx, proj.vy)||1;
                            const tx = (nearest.x - proj.x)/Math.sqrt(nd2||1);
                            const ty = (nearest.y - proj.y)/Math.sqrt(nd2||1);
                            // blend velocity slightly
                            proj.vx = proj.vx*0.92 + tx*sp*0.08;
                            proj.vy = proj.vy*0.92 + ty*sp*0.08;
                        }
                    }
                }
                // Reset skip flag for next frame
                proj._skipBaseMove = false;
                // Prevent life decay for orbitals (already set high) to avoid unnecessary churn
                if (!proj._orbital) proj.life--;
                // Bouncing: handle wall and edge collisions robustly
                // Phasing synergy: if phasing is active, we still decrement bounces on edge contact, and we allow
                // ricochet chaining (enemy-to-enemy) without requiring an actual wall collision.
                if (proj.bouncing && proj.bounces > 0) {
                    let bounced = false;
                    // Predict next position to determine collision normal
                    const nextX = proj.x + proj.vx;
                    const nextY = proj.y + proj.vy;

                    // If we are already overlapping a wall (pattern lateral shift pushed us inside), rewind to last safe and force bounce
                    if (!proj.phasing && isWall(proj.x, proj.y, Math.max(8, proj.size))) {
                        // Use last base move position or pre-pattern snapshot if available
                        if (proj._lastX != null && proj._lastY != null) {
                            proj.x = proj._lastX; proj.y = proj._lastY;
                        } else if (proj._prePatternX != null) {
                            proj.x = proj._prePatternX; proj.y = proj._prePatternY;
                        }
                        // Determine which axis caused penetration by testing offset separately
                        const testXBlocked = isWall(proj.x + proj.vx, proj.y, Math.max(8, proj.size));
                        const testYBlocked = isWall(proj.x, proj.y + proj.vy, Math.max(8, proj.size));
                        if (testXBlocked && !testYBlocked) {
                            proj.vx = -proj.vx * 0.85;
                        } else if (testYBlocked && !testXBlocked) {
                            proj.vy = -proj.vy * 0.85;
                        } else {
                            proj.vx = -proj.vx * 0.78;
                            proj.vy = -proj.vy * 0.78;
                        }
                        bounced = true;
                    }

                    // Bounce off canvas edges (phasing still bounces on arena bounds)
                    if (nextX - proj.size <= 0 || nextX + proj.size >= canvas.width) {
                        proj.vx = -proj.vx * 0.86;
                        bounced = true;
                    }
                    if (nextY - proj.size <= 0 || nextY + proj.size >= canvas.height) {
                        proj.vy = -proj.vy * 0.86;
                        bounced = true;
                    }

                    // Bounce off walls (skip internal walls if phasing, but edge bounce already handled above)
                    if (!proj.phasing) {
                        // Check collision at next position with a modest size to detect wall contact
                        if (isWall(nextX, nextY, Math.max(8, proj.size))) {
                            // Determine which axis to reflect based on wall overlap by sampling small offsets
                            // If horizontal offset is more obstructed, flip vx, else flip vy.
                            const horBlocked = isWall(proj.x + proj.vx, proj.y, Math.max(8, proj.size));
                            const verBlocked = isWall(proj.x, proj.y + proj.vy, Math.max(8, proj.size));
                            if (horBlocked && !verBlocked) {
                                proj.vx = -proj.vx * 0.82;
                            } else if (verBlocked && !horBlocked) {
                                proj.vy = -proj.vy * 0.82;
                            } else {
                                // both blocked or unclear - reflect both with damping
                                proj.vx = -proj.vx * 0.76;
                                proj.vy = -proj.vy * 0.76;
                            }
                            bounced = true;
                            // Split Shot: split on wall bounce
                            // (Split Shot removed – no wall-bounce splitting)
                        }
                    }

                    if (bounced) {
                        proj.bounces = Math.max(0, proj.bounces - 1);
                        proj.life += 40;
                        addParticle(proj.x, proj.y, '#FFFFFF', 'spark');
                        // Maintain a reasonable minimum travel speed after damping so projectiles don't stall
                        const sp = Math.hypot(proj.vx, proj.vy) || 0;
                        const minSpeed = 3.8;
                        if (sp < minSpeed) {
                            // Re-normalize velocity to minSpeed preserving direction
                            const nx = (proj.vx || 0) / (sp || 1);
                            const ny = (proj.vy || 0) / (sp || 1);
                            proj.vx = nx * minSpeed;
                            proj.vy = ny * minSpeed;
                        }
                        // Phasing bounce visual accent (a faint cyan flash) so player sees the virtual ricochet
                        if (proj.phasing) {
                            addParticle(proj.x, proj.y, '#66EEFF', 'spark');
                            // Added brief cyan ring flash for clearer phasing ricochet feedback
                            if (typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#66EEFF', radius:24, life:18 });
                            } else {
                                // Fallback: spawn extra outward spark petals
                                for (let rf=0; rf<5; rf++) {
                                    addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#AAFFFF', 'spark');
                                }
                            }
                        }
                    }
                } else {
                    // Non-bouncing projectiles collide with walls and are removed (unless phasing)
                    if (!proj.phasing && isWall(proj.x, proj.y, Math.max(5, proj.size))) {
                        // Split Shot: split on wall impact
                        // (Split Shot removed – no wall-impact splitting)
                        return false;
                    }
                }
                // Beam segments: continuous tick damage (not orbital)
                if (proj.beam && !proj.enemy) {
                    if (!proj._beamHitTimes) proj._beamHitTimes = {};
                    proj._beamTickFrame = (proj._beamTickFrame || 0) + 1;
                    if (Math.random() < 0.15) addParticle(proj.x + (Math.random()-0.5)*proj.size, proj.y + (Math.random()-0.5)*proj.size, '#99EEFF', 'spark');
                    const tickIntervalFrames = 5;
                    const base = (proj.damage || calculateDamage());
                    const tickDamage = Math.max(1, Math.floor(base * 0.18));
                    game.enemies.forEach(enemy => {
                        const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const r = enemy.size/2 + proj.size;
                        if (dx*dx + dy*dy <= r*r) {
                            const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                            const last = proj._beamHitTimes[key] || 0;
                            if (proj._beamTickFrame - last >= tickIntervalFrames) {
                                proj._beamHitTimes[key] = proj._beamTickFrame;
                                enemy.health -= tickDamage;
                                addDamageNumber(tickDamage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType || 'laser' });
                                if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#55CCFF', 'impact');
                            }
                        }
                    });
                    // Close-range fallback: if an enemy is extremely close to the player along the beam's forward arc but
                    // not caught due to the beam segment offset, apply a reduced tick so hugging enemies still get hurt.
                    if (game.player) {
                        const originX = game.player.x;
                        const originY = game.player.y;
                        const dirX = proj.vx || Math.cos(proj.spinAngle || 0) || 1;
                        const dirY = proj.vy || Math.sin(proj.spinAngle || 0) || 0;
                        const dirLen = Math.hypot(dirX, dirY) || 1;
                        const ux = dirX / dirLen; const uy = dirY / dirLen;
                        const fallbackRadius = 42; // small circle around player
                        const arcCos = Math.cos(Math.PI/2); // 90 deg half-angle (only slight forward bias)
                        const miniTick = Math.max(1, Math.floor(base * 0.12));
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - originX; const dy = enemy.y - originY;
                            const dist2 = dx*dx + dy*dy;
                            if (dist2 <= fallbackRadius * fallbackRadius) {
                                const dist = Math.sqrt(dist2) || 1;
                                const dot = (dx/dist)*ux + (dy/dist)*uy;
                                if (dot >= arcCos) { // roughly within forward 180° (wide) to avoid punishing behind player
                                    const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                                    const last = proj._beamHitTimes[key] || 0;
                                    if (proj._beamTickFrame - last >= tickIntervalFrames) {
                                        proj._beamHitTimes[key] = proj._beamTickFrame;
                                        enemy.health -= miniTick;
                                        addDamageNumber(miniTick, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType || 'laser' });
                                        if (Math.random() < 0.18) addParticle(enemy.x, enemy.y, '#66BBFF', 'impact');
                                    }
                                }
                            }
                        });
                    }
                }
                // Final positional cull / life check
                const alive = proj.life > 0 && proj.x > -20 && proj.x < canvas.width + 20 && proj.y > -20 && proj.y < canvas.height + 20;
                if (!alive && proj.damageType === 'crystal' && !proj._crystalShattered) {
                    createCrystalShatter(proj.x, proj.y, proj.baseDamage || proj.damage || calculateDamage(), proj);
                }
                return alive;
            });
            // Orphan meteor marker cleanup: remove markers whose scheduled explode frame passed without a meteor claiming them
            if (Array.isArray(game.meteorMarkers)) {
                for (let i = game.meteorMarkers.length - 1; i >= 0; i--) {
                    const m = game.meteorMarkers[i];
                    if (!m) { game.meteorMarkers.splice(i,1); continue; }
                    if (m.dead) { game.meteorMarkers.splice(i,1); continue; }
                    if (m._explodeFrame && game.frame > m._explodeFrame + 5) { // small grace period
                        // If no meteor set dead flag, prune to prevent misleading lingering marker
                        game.meteorMarkers.splice(i,1);
                    }
                }
            }
        }

        function updateParticles() {
            game.particles = game.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.alpha = particle.life / particle.maxLife;
                return particle.life > 0;
            });
        }

        function checkCollisions() {
            // --- Helper utilities (declared inside so they capture freshest sprites) ---
            function getEnemyAABB(enemy) {
                if (!enemy) return null;
                if (!game.enemySprites) return null;
                const map = {
                    'Thug':'thug',
                    'Street Dog':'streetDog',
                    'Punk':'punk',
                    'Gangster':'gangster',
                    'Dealer':'dealer',
                    'Enforcer':'enforcer',
                    'Boss Thug':'bossThug',
                    'Boss Gangster':'bossGangster',
                    'The Big Quack':'bigQuack'
                };
                const key = map[enemy.type];
                if (!key) return null;
                const entry = game.enemySprites[key];
                if (!entry || !entry.loaded) return null;
                // computeHitbox original APIs differ: thug returned {w,h,ox,oy}; new ones return either offset style or absolute; normalize.
                if (entry.computeHitbox) {
                    try {
                        const hb = entry.computeHitbox(enemy);
                        if (!hb) return null;
                        if ('ox' in hb || 'oy' in hb) {
                            // Center-relative definition
                            return { x: enemy.x + (hb.ox||0), y: enemy.y + (hb.oy||0), w: hb.w, h: hb.h };
                        } else if ('x' in hb && 'y' in hb) {
                            return { x: hb.x, y: hb.y, w: hb.w, h: hb.h };
                        }
                    } catch(e) { /* fallback later */ }
                }
                return null;
            }
            function circleIntersectsAABB(cx, cy, r, box) {
                const clampedX = Math.max(box.x, Math.min(cx, box.x + box.w));
                const clampedY = Math.max(box.y, Math.min(cy, box.y + box.h));
                const dx = cx - clampedX; const dy = cy - clampedY;
                return (dx*dx + dy*dy) <= r*r;
            }
            function playerCircleRadius() { return 20; } // consolidated constant for player collision

            // --- Player contact damage (enemy -> player) using AABB when available ---
            if (!game.player.invulnerable) {
                const pr = playerCircleRadius();
                game.enemies.forEach(enemy => {
                    if (enemy.dead || enemy.health <= 0) return;
                    const box = getEnemyAABB(enemy);
                    let collide = false;
                    if (box) {
                        collide = circleIntersectsAABB(game.player.x, game.player.y, pr, box);
                    } else {
                        // fallback circle vs circle
                        const dx = game.player.x - enemy.x; const dy = game.player.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < pr + enemy.size/2) collide = true;
                    }
                    if (collide) {
                        const incoming = Math.floor(enemy.damage * (enemy.cursed ? 0.7 : 1));
                        takeDamage(incoming);
                    }
                });

                // Enemy projectiles hitting player (remain circle-based for now)
                game.projectiles = game.projectiles.filter(proj => {
                    if (proj.enemy) {
                        const dx = proj.x - game.player.x;
                        const dy = proj.y - game.player.y;
                        if (Math.sqrt(dx * dx + dy * dy) < pr) {
                            takeDamage(proj.damage || 15);
                            addParticle(proj.x, proj.y, '#FF4444', 'impact');
                            return false;
                        }
                    }
                    return true;
                });
            }

            // --- Player projectiles vs enemies (AABB preferred) ---
            game.projectiles = game.projectiles.filter(proj => {
                if (proj.enemy) return true; // skip enemy-fired
                if (proj.beam) return true;   // beams handled elsewhere
                let consumedGlobal = false;
                const r = proj.size || 6;
                for (let i = 0; i < game.enemies.length && !consumedGlobal; i++) {
                    const enemy = game.enemies[i];
                    if (!enemy || enemy.dead || enemy.health <= 0) continue;
                    let hit = false;
                    const box = getEnemyAABB(enemy);
                    if (box) {
                        hit = circleIntersectsAABB(proj.x, proj.y, r, box);
                    } else {
                        // fallback radial
                        const dx = proj.x - enemy.x; const dy = proj.y - enemy.y; const dist = Math.hypot(dx, dy);
                        if (dist < (enemy.size/2 + r)) hit = true;
                    }
                    if (hit) {
                        const consumed = applyProjectileHit(enemy, proj);
                        if (consumed) consumedGlobal = true;
                    }
                }
                return !consumedGlobal;
            });
            
            // Chest interactions
            game.chests.forEach(chest => {
                if (!chest.opened) {
                    const dx = game.player.x - chest.x;
                    const dy = game.player.y - chest.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 35) {
                        openChest(chest);
                    }
                }
            });
        }

        // Utility: Blend a projectile's motion pattern & infusion colors into one representative hex.
        function getProjectileSynergyColor(proj) {
            if (proj && proj._diarrheaBrown) return '#8B4513';
            const colors = [];
            if (proj.sineWave) colors.push('#66AAFF');
            if (proj.wackyZigzag && !proj._wackyChaos) colors.push('#FFDD55');
            if (proj._wackyChaos) colors.push('#FFAA33');
            if (proj.ekgWave) colors.push('#66FFCC');
            if (proj.spiral) colors.push('#FF66FF');
            if (proj.infusionElements && proj.infusionElements.length) {
                let strongest = proj.infusionElements[0];
                proj.infusionElements.forEach(el=>{ if (el.potency > strongest.potency) strongest = el; });
                const infusionMap = { fire:'#FF5533', poison:'#55FF55', ice:'#99DDFF', arc:'#DDDDFF', shadow:'#AA66FF', lightning:'#FFFF99', void:'#8844AA', wind:'#BBFFEE' };
                const infCol = infusionMap[strongest.type] || '#FFFFFF';
                colors.push(infCol);
            }
            if (!colors.length) return '#CCCCCC';
            let r=0,g=0,b=0; colors.forEach(c=>{ const v=parseInt(c.slice(1),16); r+=(v>>16)&255; g+=(v>>8)&255; b+=v&255; });
            r=Math.min(255, Math.floor(r/colors.length)); g=Math.min(255, Math.floor(g/colors.length)); b=Math.min(255, Math.floor(b/colors.length));
            if (proj._wackyChaos && Math.random()<0.35) { r=Math.min(255,r+35); g=Math.min(255,g+20);} // subtle flicker
            return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).toUpperCase();
        }

        function calculateDamage() {
            let damage = 25;
            
            // Base damage bonuses
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageBonus) {
                    damage += abilityData.effect.damageBonus;
                }
            });
            
            // Rage mode
            if (game.player.abilities.includes('Rage Mode')) {
                damage += game.totalKills * 3;
            }
            
            // Berserker
            if (game.player.abilities.includes('Berserker')) {
                const healthPercent = game.player.health / game.player.maxHealth;
                const berserkerMultiplier = 1 + (1 - healthPercent) * 0.5;
                damage = Math.floor(damage * berserkerMultiplier);
            }
            
            // Critical strikes
            let critChance = 0;
            let critMultiplier = 2;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.critChance) {
                    critChance = Math.max(critChance, abilityData.effect.critChance);
                }
                if (abilityData && abilityData.effect.critMultiplier) {
                    critMultiplier = abilityData.effect.critMultiplier;
                }
            });
            
            if (Math.random() < critChance) {
                damage *= critMultiplier;
                addScreenShake(5);
            }
            
            // Death touch
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.deathTouch) {
                    if (Math.random() < abilityData.effect.deathTouch) {
                        damage = 9999; // Instant kill
                        addScreenShake(8);
                    }
                }
            });

            // If player has an ability that ignores armor globally, we may want to
            // reflect that in damage by ensuring armor reductions aren't applied later.
            // For now we keep calculateDamage generic; the per-projectile ignoresArmor flag
            // will be used at damage application time.
            
            return damage;
        }

        // Centralized hit resolution for projectiles. Returns true if projectile is consumed.
        function applyProjectileHit(enemy, proj) {
            if (!enemy || !proj) return true;
            // Time Bomb: armed hits near fuse end can trigger early detonation (feels responsive)
            if (proj.timeBomb && proj._timeBombArmed && proj._timeBombTimer <= 16) {
                const dmg = Math.floor((proj.baseDamage || calculateDamage()) * (proj._timeBombExplosionMult || 2.0));
                explodeProjectile(proj, dmg);
                proj.life = 0;
                return true;
            }
            let damage = proj.damage || proj.baseDamage || calculateDamage();
            // Apply resonance multiplier if present
            if (proj._resonanceMult) {
                damage = Math.floor(damage * proj._resonanceMult);
            }
            // Multi-Infusion bonus pre-modifiers: each infusion adds scaled portion of base (diminishing after first)
            if (proj.infusionElements && proj.infusionElements.length) {
                // Sort by potency to apply strongest first
                const sorted = [...proj.infusionElements].sort((a,b)=>b.potency-a.potency);
                let bonus = 0; let idx=0;
                sorted.forEach(inf => { const weight = (idx===0?1: (idx===1?0.6:0.4)); bonus += (damage * inf.potency * weight); idx++; });
                damage = Math.floor(damage + bonus);
            }
            // Elemental amplifier pre-processing: gather player elemental ability presence
            if (!proj._elemAmpComputed) {
                proj._elemAmpComputed = true;
                const abil = game.player.abilities;
                proj._hasFire = abil.some(a=>a.includes('Fire Shot')||a.includes('Inferno')||a.includes('Magma')||a.includes('Inferno')||a.includes('Steam Shot')||a.includes('Magma Shot'));
                proj._hasWind = abil.some(a=>a.includes('Wind Blade')||a.includes('Blizzard'));
                proj._hasIce = abil.some(a=>a.includes('Ice Shot')||a.includes('Frost')||a.includes('Blizzard'));
                proj._hasLightning = abil.some(a=>a.includes('Lightning Shot')||a.includes('Storm Shot'));
                proj._hasPoison = abil.some(a=>a.includes('Poison Shot')||a.includes('Toxic')||a.includes('Silent But Deadly'));
                proj._hasVoid = abil.some(a=>a.includes('Void Shot')||a.includes('Black Hole'));
                proj._hasEarth = abil.some(a=>a.includes('Earth Spike')||a.includes('Magma Shot'));
            }
            // Fire + Wind: slight damage amp and faster burn tick (handled in status) -> immediate small boost
            if (proj._hasFire && proj._hasWind) {
                damage = Math.floor(damage * 1.06);
            }
            // Ice + Lightning: chance to shatter for bonus burst (simulate crit-like extra)
            if (proj._hasIce && proj._hasLightning) {
                if (Math.random() < 0.12) {
                    const extra = Math.floor(damage * 0.35);
                    enemy.health -= extra; // apply directly
                    addDamageNumber(extra, enemy.x, enemy.y - enemy.size/2 - 14, { type: 'frost', crit: true });
                    addParticle(enemy.x, enemy.y, '#AAEEFF','impact');
                }
            }
            // Poison + Void: amplify damage over time potential (apply immediate small amp)
            if (proj._hasPoison && proj._hasVoid) {
                damage = Math.floor(damage * 1.08);
            }
            // Fire + Poison (Magma/Inferno synergy) further increases immediate hit slightly
            if (proj._hasFire && proj._hasPoison) {
                damage = Math.floor(damage * 1.05);
            }
            // Fire + Earth (true Magma combustion) additional micro-boost beyond Fire+Poison if Earth present
            if (proj._hasFire && proj._hasEarth) {
                damage = Math.floor(damage * 1.04);
            }
            // Earth + Wind: modest knockback amplification (applied post-damage as status effect via enemy displacement)
            if (proj._hasEarth && proj._hasWind && proj.knockbackDistance) {
                proj.knockbackDistance = Math.floor(proj.knockbackDistance * 1.15 + 6);
            }
            // Freeze escalation (before armor so bonus can apply later if desired)
            if (proj.freezes && proj.damageType === 'frost') {
                // initialize freeze tracking fields
                enemy.freezeStacks = Math.min(3, (enemy.freezeStacks || 0) + 1);
                enemy.lastFreezeHit = Date.now();
                if (enemy.freezeStacks === 3) {
                    enemy.frozenTimer = Math.max(enemy.frozenTimer || 0, 900); // full freeze 0.9s
                }
            }
            // Crush logic: first hammer impact applies crushedTimer + stun; subsequent impacts during window deal amplified damage
            if (proj.crushDamage || proj.weaponType === 'hammer' || proj._hammer) {
                if (!enemy.crushedTimer || enemy.crushedTimer <= 0) {
                    enemy.crushedTimer = 700; // ms window
                    enemy.stunned = true; enemy.stunTime = Math.max(enemy.stunTime || 0, 60);
                    // apply an armor shred stack (temporary) and schedule its decay timer if not existing
                    enemy.armorShredded = (enemy.armorShredded || 0) + 1;
                    if (enemy.armorShredded > 8) enemy.armorShredded = 8; // cap
                    enemy._armorShredDecay = enemy._armorShredDecay || Date.now();
                    addParticle(enemy.x, enemy.y, '#EECCAA','impact');
                } else {
                    // Already crushed: bonus damage multiplier
                    damage = Math.floor(damage * 1.4);
                    addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, crit: true });
                }
            }
            if (enemy.weakness) damage = Math.floor(damage * 1.35);
            if (proj.ignoresEverything) damage = Math.floor(damage * 1.25);
            if (!proj.ignoresEverything && !proj.ignoresArmor && !proj.armorPiercing) {
                const shred = enemy.armorShredded || 0;
                const effectiveArmor = Math.max(0, (enemy.armor || 0) - shred);
                damage = Math.max(1, damage - effectiveArmor);
                if (effectiveArmor > 0) {
                    addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, armor: true });
                }
            }
            // Bonus damage while fully frozen
            if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                damage = Math.floor(damage * 1.2);
            }
            enemy.health -= damage;
            if (!proj._suppressDamageNumber) {
                addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, crit: proj.ignoresEverything });
            }
            addParticle(enemy.x, enemy.y, '#FFAA00', 'impact');
            // Plasma splash: on hit create small area heat burst (excludes original enemy for secondary damage)
            if (proj.damageType === 'plasma' && !proj._plasmaSplashed) {
                proj._plasmaSplashed = true;
                const splashRadius = 60;
                const splashDmg = Math.max(1, Math.floor(damage * 0.6));
                // visual burst particles (plasma hue)
                for (let p=0;p<14;p++) {
                    const ang = Math.random()*Math.PI*2;
                    const dist = Math.random()*splashRadius*0.9;
                    addParticle(enemy.x + Math.cos(ang)*dist, enemy.y + Math.sin(ang)*dist, '#ff4455', 'spark');
                }
                game.enemies.forEach(other => {
                    if (other === enemy || other.health <= 0) return;
                    const dx = other.x - enemy.x;
                    const dy = other.y - enemy.y;
                    if (dx*dx + dy*dy <= splashRadius * splashRadius) {
                        other.health -= splashDmg;
                        addDamageNumber(splashDmg, other.x, other.y - other.size/2, { type: 'plasma' });
                        // brief burn extension
                        other.burning = true;
                        other.burnTime = Math.max(other.burnTime || 0, 120);
                    }
                });
            }
            // (Meteor on-hit explosion removed; meteor now detonates strictly at telegraph end for consistency)
            // Infusion status application (projectile-specific overlay)
            if (proj.infusionElements && proj.infusionElements.length) {
                proj.infusionElements.forEach(inf => {
                    switch(inf.type) {
                        case 'fire': enemy.burning = true; enemy.burnTime = Math.max(enemy.burnTime||0, 120 + Math.floor(60*inf.potency)); break;
                        case 'ice': enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime||0, 140 + Math.floor(40*inf.potency)); break;
                        case 'poison': enemy.poisoned = true; enemy.poisonTime = Math.max(enemy.poisonTime||0, 180 + Math.floor(60*inf.potency)); break;
                        case 'lightning': // small chain mini pulse
                            if (Math.random() < 0.15 + inf.potency*0.3) {
                                let chained=0; game.enemies.forEach(o=>{ if(o===enemy||chained>=2) return; const d=Math.hypot(o.x-enemy.x,o.y-enemy.y); if(d<120){ const zap=Math.max(4,Math.floor(damage*0.25)); o.health-=zap; addDamageNumber(zap,o.x,o.y-o.size/2,{type:'lightning'}); addParticle(o.x,o.y,'#FFFF99','spark'); chained++; } }); }
                            break;
                        case 'void': // mild armor shred stacking
                            enemy.armorShredded = (enemy.armorShredded||0) + (inf.potency>0.4?2:1); if (enemy.armorShredded>10) enemy.armorShredded=10; break;
                        case 'wind': // push slight
                            const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const dist=Math.hypot(dx,dy)||1; applyKnockback(enemy, 20 + inf.potency*40, dx, dy);
                            break;
                    }
                });
            }
            // Life steal
            if (proj.lifeSteal && proj.lifeSteal > 0) {
                const heal = Math.max(1, Math.floor(damage * 0.1 * proj.lifeSteal));
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                addParticle(game.player.x, game.player.y - 18, '#00FF55', 'heal');
                updateUI();
            }
            applyStatusEffects(enemy);
            if (proj.knockback) {
                const pdx = enemy.x - proj.x; const pdy = enemy.y - proj.y; const pd = Math.hypot(pdx,pdy) || 1;
                let kbDist = proj.knockbackDistance || 0;
                if (!kbDist && proj.weaponType === 'hammer') kbDist = 40; // hammer baseline
                if (!kbDist) kbDist = 28; // default fallback
                // Earth Spike / Magma derived impacts: always use smooth knockback (less jarring)
                // proj._hasEarth is precomputed earlier (includes Magma combo). We slightly reduce raw distance
                // so the slide duration feels physical instead of a huge displacement burst.
                const isEarthStyle = proj._hasEarth;
                if (isEarthStyle) {
                    const earthDist = Math.max(14, Math.floor(kbDist * 0.75)); // temper distance for smoother slide
                    applySmoothKnockback(enemy, pdx/pd, pdy/pd, earthDist);
                    enemy._earthKBFrames = Math.max(enemy._earthKBFrames || 0, Math.min(38, Math.floor(earthDist * 0.9))); // debris duration
                } else {
                    // Large knockback distances (e.g. Wind Blade 120) look like teleporting when instant.
                    // Use smooth velocity-based knockback if threshold exceeded; otherwise keep instant push.
                    if (kbDist >= 60) {
                        applySmoothKnockback(enemy, pdx/pd, pdy/pd, kbDist);
                    } else {
                        applyKnockback(enemy, kbDist, pdx, pdy);
                    }
                }
            }
            if (proj._hammer) {
                enemy.stunned = true; enemy.stunTime = Math.max(enemy.stunTime || 0, 46); addParticle(enemy.x, enemy.y, '#FFDFFF', 'impact');
            }
            if (proj.weaponType === 'axe') { enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime || 0, 90); }
            if (proj.chaining) {
                let next=null, nd=Infinity; game.enemies.forEach(o=>{ if(o===enemy) return; const d=Math.hypot(o.x-enemy.x,o.y-enemy.y); if(d<140&&d<nd){nd=d;next=o;} });
                if (next) { const cd=Math.max(1, Math.floor(damage*0.5)); next.health -= cd; addParticle(next.x,next.y,'#FFDFAA','impact'); addDamageNumber(cd, next.x, next.y - next.size/2, { type: proj.damageType }); }
            }
            // Reality break projectile single-target hit also boosts distortion a bit
            if (proj.realityBreak) {
                if (!game.realityBreakDistort) game.realityBreakDistort = { time:0, intensity:0 };
                game.realityBreakDistort.time = Math.min(game.realityBreakDistort.time + 40, 240);
                game.realityBreakDistort.intensity = Math.min(1.0, game.realityBreakDistort.intensity + 0.15);
            }
            // Split trigger (primary): ensure Split Shot triggers on first enemy impact even if projectile will continue (piercing, ricochet, etc.).
            // Exclude beams and orbitals to avoid excessive child spam.
            // (Split Shot primary enemy-impact trigger removed)
            // Crystal Shot shatter: spawn shards on first enemy impact (before potential pierce continuation) once.
            if (proj.damageType === 'crystal' && !proj._crystalShattered) {
                createCrystalShatter(enemy.x, enemy.y, proj.baseDamage || proj.damage || calculateDamage(), proj);
            }
            if (proj.hitMultipleTimes) {
                proj.remainingHits = (typeof proj.remainingHits === 'number') ? proj.remainingHits : 3; proj.remainingHits--; proj.life += 12; addParticle(proj.x, proj.y, '#66FFFF','spark');
                if (proj.remainingHits > 0) { const sp=Math.hypot(proj.vx,proj.vy)||1; proj.vx = (proj.vx/sp)*(sp*1.04); proj.vy=(proj.vy/sp)*(sp*1.04); return false; }
            }
            if ((proj.antimatter || proj.massiveExplosion) && proj.explosive) {
                const explosDmg = Math.max(200, Math.floor((proj.baseDamage || damage) * 1.5));
                explodeProjectile(proj, explosDmg); proj.life = 0; return true;
            }
            // Ricochet chaining: allow when ricochet flag set AND remaining bounces >0; phasing no longer blocks logic.
            if (proj.ricochet && proj.bounces > 0) {
                // Initialize ricochet state
                if (!proj._ricochetHits) proj._ricochetHits = [];
                // Prevent hitting same enemy consecutively unless only one remains
                proj._ricochetHits.push(enemy._id || (enemy._id = Math.random().toString(36).slice(2)));
                const already = new Set(proj._ricochetHits);
                const maxRange = 240; // search radius for next bounce
                let nextTarget = null, nextDist = Infinity;
                game.enemies.forEach(o => {
                    if (o === enemy || o.health <= 0) return;
                    const oid = o._id || (o._id = Math.random().toString(36).slice(2));
                    // Allow re-targeting if we've hit nearly everyone (fallback) after 3 unique hits
                    const allowRepeat = proj._ricochetHits.length > 3 && proj._ricochetHits.length > game.enemies.length - 2;
                    if (!allowRepeat && already.has(oid)) return;
                    const d = Math.hypot(o.x - proj.x, o.y - proj.y);
                    if (d < nextDist && d <= maxRange) { nextDist = d; nextTarget = o; }
                });
                if (nextTarget) {
                    const ang = Math.atan2(nextTarget.y - proj.y, nextTarget.x - proj.x);
                    // Preserve existing speed but enforce a floor and mild retention (avoid cumulative slowdown)
                    const prevSpeed = Math.hypot(proj.vx, proj.vy) || 0;
                    const sp = Math.max(5, prevSpeed * 0.95); // slight damping only
                    // Blend direction for smoother turn instead of instant snap
                    const desiredVx = Math.cos(ang) * sp;
                    const desiredVy = Math.sin(ang) * sp;
                    proj.vx = desiredVx;
                    proj.vy = desiredVy;
                    proj.bounces--;
                    // Extend life a bit so chained ricochets travel meaningful distance
                    proj.life = Math.max(proj.life + 55, proj.life);
                    // Small flash particle at source to indicate energy jump
                    // Light energy arc particle burst
                    for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*14, proj.y + (Math.random()-0.5)*14, '#FFEFAA','spark');
                    return false; // keep projectile alive
                }
            }
            if (proj.piercing) {
                proj.pierceHits=(proj.pierceHits||0)+1;
                // Do NOT split again here; primary split already occurred above if applicable.
                if (proj.pierceHits < proj.pierceCount) return false; // keep traveling until pierce limit reached
            }
            // (Split Shot final consumption trigger removed)
            // Time Bomb safeguard: do not consume the projectile via normal hit logic before its fuse expires.
            // Rationale: Previously the projectile could reach its pierce limit and be removed before the countdown hit 0,
            // preventing the explosion from ever triggering. We allow it to keep traveling (no extra special damage changes)
            // until the timer section in updateProjectiles() detonates it, or the armed early-detonation condition fires above.
            if (proj.timeBomb && proj._timeBombTimer > 0) {
                return false; // keep projectile alive until explosion
            }
            return true;
        }

        function applyStatusEffects(enemy) {
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageType) {
                    switch (abilityData.effect.damageType) {
                        case 'poison':
                            enemy.poisoned = true;
                            let poisonDur = 240;
                            // Poison + Void synergy extends duration
                            if (game.player.abilities.includes('Void Shot') || game.player.abilities.includes('Black Hole')) {
                                poisonDur += 90; // extend 1.5s
                            }
                            enemy.poisonTime = Math.max(enemy.poisonTime || 0, poisonDur);
                            break;
                        case 'ice':
                            enemy.slowed = true;
                            let slowDur = 180;
                            // Ice + Wind (Blizzard synergy) increases slow duration
                            if (game.player.abilities.includes('Wind Blade') || game.player.abilities.includes('Blizzard')) {
                                slowDur += 60;
                            }
                            enemy.slowTime = Math.max(enemy.slowTime || 0, slowDur);
                            break;
                        case 'fire':
                            enemy.burning = true;
                            let burnDur = 200;
                            if (game.player.abilities.includes('Wind Blade')) burnDur += 40; // fire + wind extends burn
                            if (game.player.abilities.includes('Poison Shot') || game.player.abilities.includes('Toxic Cloud') || game.player.abilities.includes('Inferno') || game.player.abilities.includes('Magma Shot')) {
                                burnDur += 30; // fire + poison style synergy (magma) extends further
                            }
                            enemy.burnTime = Math.max(enemy.burnTime || 0, burnDur);
                            break;
                        case 'lightning':
                            // Chain lightning
                            let chained = 0;
                            const maxChains = 3;
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && chained < maxChains) {
                                    const dx = otherEnemy.x - enemy.x;
                                    const dy = otherEnemy.y - enemy.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < 100) {
                                        const zapDmg = Math.floor(calculateDamage() * 0.6);
                                        otherEnemy.health -= zapDmg;
                                        addDamageNumber(zapDmg, otherEnemy.x, otherEnemy.y - otherEnemy.size/2, { type: 'lightning' });
                                        addParticle(otherEnemy.x, otherEnemy.y, '#FFFF44', 'lightning');
                                        // Visual lightning arc from enemy -> otherEnemy
                                        if (typeof createLightningArc === 'function') createLightningArc(enemy.x, enemy.y, otherEnemy.x, otherEnemy.y, 5 + Math.random()*3);
                                        chained++;
                                    }
                                }
                            });
                            break;
                        case 'stun':
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, 60);
                            break;
                        case 'frost':
                            // freezing: short stun + slow
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, 36);
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 160);
                            break;
                        case 'plasma':
                            // plasma applies burning over time
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 200);
                            break;
                        case 'acid':
                            // acid: applies corrosion (armor shred) and DoT bypassing armor
                            enemy.corroded = true;
                            enemy.corrodeTime = Math.max(enemy.corrodeTime || 0, 200);
                            enemy.armorShredded = (enemy.armorShredded || 0) + 1; // track stacks
                            break;
                        case 'void':
                            // void: applies a weakening field (extra damage taken) and a small true damage tick over time
                            enemy.voidTouched = true;
                            enemy.voidTime = Math.max(enemy.voidTime || 0, 180);
                            enemy.weakness = true;
                            enemy.weaknessTime = Math.max(enemy.weaknessTime || 0, 180);
                            break;
                        case 'earth':
                            // earth: minor stun/slow due to impact shock
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 50);
                            if (Math.random() < 0.18) { // slightly lower chance
                                enemy.stunned = true;
                                // Cap cumulative stun chain length
                                const newDur = Math.max(enemy.stunTime || 0, 18);
                                enemy.stunTime = Math.min(newDur, 50); // hard cap
                            }
                            break;
                        case 'solar':
                            // solar blinds (reduces detection range)
                            if (abilityData.effect && abilityData.effect.blinds) {
                                enemy.blinded = true;
                                enemy.blindTime = Math.max(enemy.blindTime || 0, 120);
                                // Flash particles
                                for (let f=0; f<6; f++) addParticle(enemy.x + (Math.random()-0.5)*28, enemy.y + (Math.random()-0.5)*28, '#FFEFA5','explosion');
                                // Small radial spark ring
                                for (let s=0; s<10; s++) addParticle(enemy.x + Math.cos((s/10)*Math.PI*2)*18, enemy.y + Math.sin((s/10)*Math.PI*2)*12, '#FFF7D1','spark');
                                // Optional mini AoE blind pulse (shorter duration) around primary target
                                const aoeR = 80;
                                game.enemies.forEach(o=>{ if(o===enemy) return; const dx=o.x-enemy.x; const dy=o.y-enemy.y; const d=Math.sqrt(dx*dx+dy*dy); if(d<aoeR){ o.blinded=true; o.blindTime=Math.max(o.blindTime||0,60); if(Math.random()<0.25) addParticle(o.x,o.y,'#FFEFA5','spark'); } });
                            }
                            break;
                        case 'shadow':
                            // shadow drains life slightly on hit
                            const heal = Math.max(1, Math.floor(calculateDamage() * 0.06));
                            game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                            addParticle(game.player.x, game.player.y - 18, '#AA00AA', 'heal');
                            break;
                        case 'wind':
                            // gust: small knockback
                            const kdx = enemy.x - game.player.x;
                            const kdy = enemy.y - game.player.y;
                            const kdist = Math.sqrt(kdx*kdx + kdy*kdy) || 0.0001;
                            applyKnockback(enemy, 12, kdx, kdy);
                            break;
                        case 'steam':
                            // steam = hot + cold: burn and slow a little
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 120);
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 120);
                            break;
                        case 'magma':
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 260);
                            // heavy shove
                            const mdx = enemy.x - game.player.x;
                            const mdy = enemy.y - game.player.y;
                            const mdist = Math.sqrt(mdx*mdx + mdy*mdy) || 0.0001;
                            applyKnockback(enemy, Math.max(6, Math.floor((mdist) * 0.06)), mdx, mdy);
                            break;
                        case 'storm':
                            // storm: small chain lightning + slow
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 140);
                            // mini chain
                            let chainedLocal = 0; const maxChainsLocal = 2;
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && chainedLocal < maxChainsLocal) {
                                    const dx = otherEnemy.x - enemy.x; const dy = otherEnemy.y - enemy.y;
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist < 90) {
                                        otherEnemy.health -= Math.floor(calculateDamage() * 0.35);
                                        addParticle(otherEnemy.x, otherEnemy.y, '#FFFF88', 'lightning');
                                        chainedLocal++;
                                    }
                                }
                            });
                            break;
                        case 'crystal':
                            // Crystal Shot: reliable shatter on hit spawning prismatic shards
                            // Always spawn (consistency); shard count scales slightly with overkill potential
                            const shardBase = 3 + Math.floor(Math.random()*2); // 3-4
                            for (let s = 0; s < shardBase; s++) {
                                const ang = Math.random()*Math.PI*2;
                                const sp = 3.2 + Math.random()*3.2;
                                const dmgFrac = 0.18 + Math.random()*0.09; // 18-27% of base damage
                                game.projectiles.push({
                                    x: enemy.x + Math.cos(ang)*6,
                                    y: enemy.y + Math.sin(ang)*6,
                                    vx: Math.cos(ang)*sp,
                                    vy: Math.sin(ang)*sp,
                                    life: 46 + Math.floor(Math.random()*12),
                                    size: 4,
                                    enemy: false,
                                    damage: Math.max(1, Math.floor(calculateDamage()*dmgFrac)),
                                    damageType: 'crystal',
                                    refract: true // flag for future synergy (e.g., bonus vs armored)
                                });
                            }
                            // Visual sparkle burst
                            for (let p=0;p<6;p++) addParticle(enemy.x + (Math.random()-0.5)*20, enemy.y + (Math.random()-0.5)*20, '#88EEFF', 'spark');
                            break;
                        case 'fear':
                            enemy.fleeing = true;
                            enemy.fleeTime = Math.max(enemy.fleeTime || 0, 120);
                            break;
                        case 'blind':
                            enemy.blinded = true;
                            enemy.blindTime = Math.max(enemy.blindTime || 0, 100);
                            break;
                        case 'charm':
                            enemy.charmed = true;
                            enemy.charmTime = Math.max(enemy.charmTime || 0, 120);
                            break;
                        case 'silence':
                            enemy.silenced = true;
                            enemy.silenceTime = Math.max(enemy.silenceTime || 0, 120);
                            break;
                        case 'curse':
                            // reduce enemy damage output for a period
                            enemy.cursed = true;
                            enemy.curseTime = Math.max(enemy.curseTime || 0, 240);
                            break;
                        case 'weakness':
                            // increase damage taken
                            enemy.weakness = true;
                            enemy.weaknessTime = Math.max(enemy.weaknessTime || 0, 240);
                            break;
                        case 'doom':
                            // mark for death: small periodic damage
                            enemy.doomed = true;
                            enemy.doomTime = Math.max(enemy.doomTime || 0, 300);
                            break;
                        case 'knockback':
                            // shove enemy away from player
                            const kx = enemy.x - game.player.x;
                            const ky = enemy.y - game.player.y;
                            const kdist2 = Math.sqrt(kx*kx + ky*ky) || 0.0001;
                            applyKnockback(enemy, 30, kx, ky);
                            break;
                    }
                }
            });
            // Post-processing: lifeSteal from abilities (apply on next hit resolution)
            // lifeSteal is handled when enemies die in updateEnemies; ensure flag exists
        }

        function explodeProjectile(proj, damage) {
            // Create explosion particles
            for (let i = 0; i < 8; i++) {
                addParticle(proj.x, proj.y, '#FF6600', 'explosion');
            }
            
            // Damage nearby enemies (use proj.baseDamage when available so effects remain consistent)
            const baseRadius = proj.antimatter ? 120 : 60;
            const radius = baseRadius * (proj.antimatter ? 1.4 : 1);
            const sourceDmg = proj.baseDamage || damage;
            game.enemies.forEach(enemy => {
                const dx = enemy.x - proj.x;
                const dy = enemy.y - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    // chainExplosion: cause secondary smaller explosions on nearby enemies
                    // If enemy is weakened, take extra damage
                    const mult = enemy.weakness ? 1.45 : 1.0;
                    // Allow explosion to bypass armor if flagged
                    let applied = Math.floor(sourceDmg * (proj.antimatter ? 1.0 : 0.7) * mult);
                    if (proj.ignoresEverything) applied = Math.floor(applied * 1.3);
                    // ignoresArmor would skip any armor calculation; since we don't have an armor
                    // scalar in this build, keeping applied as-is but honoring the flag for future hooks
                    enemy.health -= applied;
                    addParticle(enemy.x, enemy.y, '#FF4444', 'impact');
                    addDamageNumber(applied, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType || (proj.antimatter ? 'void' : null) });
                    if (proj.chainExplosion) {
                        // small secondary blast
                        setTimeout(() => {
                            explodeProjectile({ x: enemy.x, y: enemy.y, chainExplosion: false }, Math.floor(sourceDmg * 0.5));
                        }, 80);
                    }
                    // apply knockback if flagged
                    if (proj.knockback) {
                        const push = Math.max(10, Math.floor((radius - dist) * 0.25));
                        const ndx = dx / Math.max(dist,1);
                        const ndy = dy / Math.max(dist,1);
                        applyKnockback(enemy, push, ndx, ndy);
                    }
                    // lifeSteal: heal player slightly based on damage dealt
                    if (proj.lifeSteal && proj.lifeSteal > 0) {
                        const heal = Math.min(10, Math.floor(sourceDmg * 0.06));
                        game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                        addParticle(game.player.x, game.player.y - 18, '#00FF00', 'heal');
                    }
                }
            });
            
            addScreenShake(proj.antimatter ? 12 : 6);

            // Trigger area effects if the projectile carried those abilities
            if (proj.shockwave) {
                createShockwave(proj.x, proj.y);
            }
            if (proj.timeWarp) {
                createTimeWarp(proj.x, proj.y);
            }
            if (proj.blackHole) {
                createBlackHole(proj.x, proj.y);
            }
            if (proj.vortex) {
                createVortex(proj.x, proj.y);
            }

            // Elemental area effects
            if (proj.areaEffect || proj.damageType === 'toxic') {
                // Toxic cloud: poisons enemies in area
                for (let i = 0; i < 6; i++) addParticle(proj.x + (Math.random()-0.5)*40, proj.y + (Math.random()-0.5)*40, '#44AA44', 'poison');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 90) {
                        enemy.poisoned = true;
                        enemy.poisonTime = Math.max(enemy.poisonTime || 0, 240);
                    }
                });
            }
            if (proj.damageType === 'blizzard' || proj.energyType === 'pulse') {
                // Blizzard: slows in area and small ice particles
                for (let i = 0; i < 8; i++) addParticle(proj.x + (Math.random()-0.5)*60, proj.y + (Math.random()-0.5)*60, '#88EEFF', 'fire');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 110) {
                        enemy.slowed = true;
                        enemy.slowTime = Math.max(enemy.slowTime || 0, 200);
                    }
                });
            }
            if (proj.spreading || proj.damageType === 'inferno' || proj.energyType === 'laser') {
                // Inferno / spreading fire: ignite nearby area and apply burning
                for (let i = 0; i < 10; i++) addParticle(proj.x + (Math.random()-0.5)*80, proj.y + (Math.random()-0.5)*80, '#FF3333', 'fire');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 130) {
                        enemy.burning = true;
                        enemy.burnTime = Math.max(enemy.burnTime || 0, 220);
                    }
                });
            }

            // Dimensional Rift: tears space, pulls enemies, damages and occasionally teleports them
            if (proj.dimensional) {
                createDimensionalRift(proj.x, proj.y, Math.max(80, Math.floor(damage * 0.8)));
            }
            // Reality Break: unpredictable physics distortions, small periodic damage and enemy jitter
            if (proj.realityBreak) {
                // slightly stronger base than dimensional by default
                createRealityBreak(proj.x, proj.y, Math.max(120, Math.floor(damage * 1.0)));
            }
        }

        // Area effect: shockwave knocks back and damages
        function createShockwave(x, y) {
                    // Expanding shockwave: short-lived ring that applies damage ticks as it expands
                    const maxRadius = 160;
                    const steps = 8;
                    const intervalMs = 28; // ~28ms per step for a quick expansion
                    let step = 0;
                    addParticle(x, y, '#AAAAFF', 'explosion');
                    const swInterval = setInterval(() => {
                        const r = (step / steps) * maxRadius;
                        // visual ring particles
                        for (let i = 0; i < 12; i++) {
                            const ang = Math.random() * Math.PI * 2;
                            const px = x + Math.cos(ang) * (r + (Math.random() - 0.5) * 12);
                            const py = y + Math.sin(ang) * (r + (Math.random() - 0.5) * 12);
                            addParticle(px, py, '#AAAAFF', 'spark');
                        }
                        // damage enemies near the ring edge
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - x;
                            const dy = enemy.y - y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > Math.max(0, r - 18) && dist < r + 18) {
                                enemy.health -= Math.floor(12 * (1 - step / steps));
                                // small shove away from ring center
                                enemy.x += (dx / Math.max(dist, 1)) * 10;
                                enemy.y += (dy / Math.max(dist, 1)) * 10;
                                addParticle(enemy.x, enemy.y, '#AAAAFF', 'impact');
                            }
                        });
                        step++;
                        if (step > steps) {
                            clearInterval(swInterval);
                            addScreenShake(3);
                        }
                    }, intervalMs);
        }

        // --- Dimensional Rift (fallback implementation) ---
        // Creates a transient singularity that gently pulls nearby enemies and deals minor ticking damage.
        // Called by explodeProjectile when proj.dimensional is true. Ensures game won't crash if ability acquired.
        function createDimensionalRift(x, y, power) {
            // power ~ base damage reference; scale effects lightly
            const radius = Math.min(220, 80 + Math.sqrt(power)*4);
            const life = 60; // frames
            const tickDamage = Math.max(6, Math.floor(power * 0.12));
            const rift = { x, y, r: radius, life, maxLife: life, tickDamage, t:0 };
            if (!game._dimRifts) game._dimRifts = [];
            game._dimRifts.push(rift);
        }

        // Update Dimensional Rifts (pull + damage + visuals)
        function updateDimensionalRifts() {
            if (!game._dimRifts || !game._dimRifts.length) return;
            for (let i = game._dimRifts.length - 1; i >= 0; i--) {
                const r = game._dimRifts[i];
                r.life--;
                // Visual particles: violet sparks
                if (r.life % 4 === 0) {
                    for (let p=0; p<4; p++) {
                        addParticle(r.x + (Math.random()-0.5)*r.r*1.6, r.y + (Math.random()-0.5)*r.r*1.6, '#AA44FF', 'spark');
                    }
                }
                // Apply pull + tick damage every 10 frames
                if (r.life % 10 === 0) {
                    game.enemies.forEach(enemy => {
                        if (enemy.health <= 0) return;
                        const dx = r.x - enemy.x;
                        const dy = r.y - enemy.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        if (dist < r.r) {
                            // Pull strength decays with distance
                            const pull = Math.max(0.4, 1 - dist / r.r) * 14;
                            enemy.x += (dx / dist) * pull;
                            enemy.y += (dy / dist) * pull;
                            // Damage (ignores armor per ability description context)
                            enemy.health -= r.tickDamage;
                            addParticle(enemy.x, enemy.y, '#AA44FF', 'impact');
                        }
                    });
                }
                if (r.life <= 0) {
                    // Collapse effect
                    for (let c=0;c<16;c++) addParticle(r.x, r.y, '#DD99FF', 'spark');
                    game._dimRifts.splice(i,1);
                }
            }
        }

        // --- Traveling Shockwave (linear ground wave) ---
        function spawnShockwave(x, y, angle) {
            if (!game.shockwaves) game.shockwaves = [];
            game.shockwaves.push({
                x, y,
                angle,
                distance: 0,
                speed: 15,
                length: 70,
                width: 80,
                life: 36,
                maxLife: 36,
                hit: []
            });
        }

        function updateShockwaves() {
            if (!game.shockwaves || !game.shockwaves.length) return;
            for (let i = game.shockwaves.length - 1; i >= 0; i--) {
                const w = game.shockwaves[i];
                w.life--;
                w.distance += w.speed;
                const ax = Math.cos(w.angle), ay = Math.sin(w.angle);
                const frontStart = Math.max(0, w.distance - w.length);
                const frontEnd = w.distance;
                game.enemies.forEach(enemy => {
                    if (enemy.health <= 0) return;
                    if (w.hit.includes(enemy)) return;
                    const dx = enemy.x - w.x;
                    const dy = enemy.y - w.y;
                    const along = dx * ax + dy * ay;
                    if (along < frontStart || along > frontEnd) return;
                    const perp = Math.abs(-ay * dx + ax * dy);
                    if (perp > w.width * 0.5) return;
                    // Apply damage & push
                    const pct = 1 - (along / (frontEnd + 0.0001));
                    const base = calculateDamage();
                    const dmg = Math.max(5, Math.floor(base * 0.5 * (0.65 + 0.35 * pct)));
                    enemy.health -= dmg;
                    addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type: 'earth' });
                    applyKnockback(enemy, 34, ax, ay);
                    addParticle(enemy.x, enemy.y, '#AAAACC', 'impact');
                    w.hit.push(enemy);
                });
                // Auto remove when expired or out of bounds
                const endX = w.x + ax * w.distance;
                const endY = w.y + ay * w.distance;
                if (w.life <= 0 || endX < -100 || endX > canvas.width + 100 || endY < -100 || endY > canvas.height + 100) {
                    game.shockwaves.splice(i,1);
                }
            }
        }

        // Transient lightning arc segment (visual only)
        function createLightningArc(x1, y1, x2, y2, life = 8) {
            if (!game.lightningArcs) game.lightningArcs = [];
            const segs = 6 + Math.floor(Math.random()*4); // number of jitter points
            const points = [];
            for (let i=0;i<=segs;i++) {
                const t = i / segs;
                const bx = x1 + (x2 - x1) * t;
                const by = y1 + (y2 - y1) * t;
                const jitterScale = Math.sin(Math.PI * t); // 0 at ends, 1 mid
                const jx = (Math.random()-0.5) * 22 * jitterScale;
                const jy = (Math.random()-0.5) * 22 * jitterScale;
                points.push({ x: bx + jx, y: by + jy });
            }
            game.lightningArcs.push({ points, life, maxLife: life });
        }

        // Time warp: slows enemies in area briefly
        function createTimeWarp(x, y) {
            // Persistent temporal distortion field
            if (!game.timeWarpFields) game.timeWarpFields = [];
            const field = {
                x, y,
                radius: 170,
                createdAt: Date.now(),
                duration: 3000, // ms lifetime
                pulseInterval: 400, // ms between slow pulses
                lastPulse: 0,
                wave: 0 // internal animation phase
            };
            game.timeWarpFields.push(field);
            for (let i = 0; i < 14; i++) addParticle(x + (Math.random()-0.5)*field.radius*0.4, y + (Math.random()-0.5)*field.radius*0.4, '#44FFFF', 'victory');
            addScreenShake(2);
        }

        function updateTimeWarpFields() {
            if (!game.timeWarpFields || !game.timeWarpFields.length) return;
            const now = Date.now();
            for (let i = game.timeWarpFields.length - 1; i >= 0; i--) {
                const f = game.timeWarpFields[i];
                const age = now - f.createdAt;
                if (age > f.duration) {
                    // collapse burst
                    for (let p=0;p<10;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.3, f.y + (Math.random()-0.5)*f.radius*0.3, '#2277FF', 'spark');
                    game.timeWarpFields.splice(i,1);
                    continue;
                }
                f.wave += 0.06;
                if (now - f.lastPulse >= f.pulseInterval) {
                    f.lastPulse = now;
                    // Apply slow to enemies inside radius
                    game.enemies.forEach(enemy => {
                        if (enemy.health <= 0) return;
                        const dx = enemy.x - f.x;
                        const dy = enemy.y - f.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < f.radius) {
                            enemy.slowed = true;
                            // refresh / extend but cap to avoid infinite stacking
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 150);
                            // Optional: add tiny temporal jitter particle
                            if (Math.random() < 0.3) addParticle(enemy.x, enemy.y - enemy.size/2, '#66AAFF', 'spark');

        // === Bloom Ring System (Hybrid Mode C) ===
        // Player periodically spawns large expanding damage rings. Projectiles emit occasional sub-petal bursts (handled inline earlier).
        // Each enemy is damaged at most once per ring (edge pass). Ring has telegraph (pre-detonation) then expansion phase.
        function spawnBloomRing(x, y, opts) {
            if (!game.bloomRings) game.bloomRings = [];
            const maxActive = 6;
            if (game.bloomRings.length >= maxActive) game.bloomRings.shift();
            // Vortex proximity synergy: if spawning within any vortex innerRadius*1.1, boost damage and growth slightly
            let vortexBoost = 1;
            if (Array.isArray(game.vortexFields) && game.vortexFields.length) {
                for (const vf of game.vortexFields) {
                    const dx = x - vf.x, dy = y - vf.y; const d = Math.hypot(dx, dy);
                    if (d < vf.innerRadius * 1.1) { vortexBoost = 1.18; break; }
                }
            }
            const ring = {
                x, y,
                radius: 0,
                width: opts && opts.width || 26,
                growth: (opts && opts.growth || 7.2) * (vortexBoost>1?1.06:1),
                maxRadius: (opts && opts.maxRadius || 420) * (vortexBoost>1?1.04:1),
                damage: (opts && opts.damage || Math.max(2, Math.floor(calculateDamage() * 0.55))) * vortexBoost,
                createdAt: Date.now(),
                maxLife: (opts && opts.maxLife) || 6000, // ms fail-safe
                hits: new Set(),
                detonated: true, // expansion begins immediately (telegraph handled visually for first few frames)
                seed: Math.random()*Math.PI*2
            };
            game.bloomRings.push(ring);
            // Petal emission (stronger, fewer) at ring birth
            const petals = 8;
            for (let i=0;i<petals;i++) {
                const ang = (i/petals)*Math.PI*2;
                const spd = 4.2 + Math.random()*0.8;
                game.projectiles.push({
                    x, y,
                    vx: Math.cos(ang)*spd,
                    vy: Math.sin(ang)*spd,
                    life: 46,
                    size: 4,
                    enemy:false,
                    damage: Math.max(1, Math.floor(ring.damage * 0.42 * (vortexBoost>1?1.1:1))),
                    baseDamage: Math.max(1, Math.floor(ring.damage * 0.42 * (vortexBoost>1?1.1:1))),
                    bloomChild:true,
                    _petal:true
                });
            }
            if (typeof addScreenShake === 'function') addScreenShake(4, 180);
            addParticle(x, y, '#FFE4CC','explosion');
        }

        function updateBloomRings() {
            if (!game.player || !game.player.abilities || !game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect && ABILITIES[a].effect.bloomRing)) return;
            if (!game._bloomRingCharge) game._bloomRingCharge = 0;
            const chargeTime = 58; // frames between main rings (approx 1s at 60fps)
            game._bloomRingCharge++;
            if (game._bloomRingCharge >= chargeTime) {
                game._bloomRingCharge = 0;
                // Spawn ring at player location (slightly ahead if moving for dynamism)
                let sx = game.player.x;
                let sy = game.player.y;
                if (game.player && game.player.vx && game.player.vy) {
                    sx += game.player.vx * 4;
                    sy += game.player.vy * 4;
                }
                // Optional synergy: if Echo Bloom field active, increase radius a bit
                const activeEcho = game.echoBloomFields && game.echoBloomFields.length;
                spawnBloomRing(sx, sy, activeEcho ? { maxRadius: 470, growth: 7.8 } : null);
            }
            // Ring progression & damage application
            if (!game.bloomRings || !game.bloomRings.length) return;
            for (let i = game.bloomRings.length - 1; i >= 0; i--) {
                const rg = game.bloomRings[i];
                rg.radius += rg.growth;
                // Vortex intersection synergy: when ring edge passes through vortex radius for first time, spawn bonus petals & temp damage buff
                if (!rg._vortexProc && Array.isArray(game.vortexFields) && game.vortexFields.length) {
                    for (const vf of game.vortexFields) {
                        const dxv = rg.x - vf.x, dyv = rg.y - vf.y; const dv = Math.hypot(dxv, dyv);
                        // Check if ring edge intersects vortex outer radius band this frame
                        if (Math.abs(dv - rg.radius) < rg.growth + 8 && dv < vf.radius + rg.width) {
                            rg._vortexProc = true;
                            // Damage boost for remaining expansion
                            rg.damage *= 1.15;
                            rg.growth *= 1.08;
                            // Spawn bonus petals focused tangentially (12 smaller petals)
                            const bonus = 12;
                            for (let b=0;b<bonus;b++) {
                                const ang = (b/bonus)*Math.PI*2;
                                const spd = 4.6 + Math.random()*0.9;
                                game.projectiles.push({
                                    x: rg.x + Math.cos(ang)*rg.radius,
                                    y: rg.y + Math.sin(ang)*rg.radius,
                                    vx: Math.cos(ang + Math.PI/2)*spd*0.55,
                                    vy: Math.sin(ang + Math.PI/2)*spd*0.55,
                                    life: 34,
                                    size: 3,
                                    enemy:false,
                                    damage: Math.max(1, Math.floor(rg.damage * 0.24)),
                                    baseDamage: Math.max(1, Math.floor(rg.damage * 0.24)),
                                    bloomChild:true,
                                    _petal:true,
                                    _vortexPetal:true
                                });
                            }
                            addParticle(rg.x, rg.y, '#FFEEDD','explosion');
                            if (typeof addScreenShake === 'function') addScreenShake(3, 160);
                            break;
                        }
                    }
                }
                // Lifespan fail-safe (ms)
                if (Date.now() - rg.createdAt > rg.maxLife || rg.radius > rg.maxRadius + rg.width*1.2) {
                    game.bloomRings.splice(i,1);
                    continue;
                }
                // Damage band: treat ring edge as annulus
                if (game.enemies && game.enemies.length) {
                    for (const enemy of game.enemies) {
                        if (!enemy || enemy.health <= 0) continue;
                        const id = enemy._id || enemy.__rid || enemy; // fallback: object ref
                        if (rg.hits.has(id)) continue;
                        const dx = enemy.x - rg.x;
                        const dy = enemy.y - rg.y;
                        const dist = Math.hypot(dx, dy);
                        const edgeDelta = Math.abs(dist - rg.radius);
                        if (edgeDelta <= rg.width * 0.55 && dist <= rg.radius + rg.width) {
                            rg.hits.add(id);
                            const dmg = Math.max(1, Math.floor(rg.damage * (0.85 + Math.random()*0.3)));
                            applyPlayerDamage(enemy, dmg);
                            addDamageNumber(enemy.x, enemy.y - (enemy.size||18)/2, dmg, '#FFC8AA');
                            if (Math.random()<0.5) addParticle(enemy.x, enemy.y, '#FFDCC0','spark');
                        }
                    }
                }
            }
        }
                        }
                    });
                }
            }
        }

        // Black hole: persistent field handled in update loop for deterministic pulling
        function createBlackHole(x, y) {
            if (!game.blackHoles) game.blackHoles = [];
            const hole = {
                x, y,
                radius: 200,
                createdAt: performance.now(),
                lifeMs: 1900, // total duration
                pulseTimer: 0,
                pulseInterval: 140, // add a damage pulse every 140ms
                spin: 0,
                strength: 5.5, // base pull (effective strength now ramps over life)
                damagePerSecond: 32, // slight tweak (pull stronger so balanced DPS)
                id: Math.random().toString(36).slice(2)
            };
            // Initial particles
            for (let i = 0; i < 18; i++) addParticle(x + (Math.random()-0.5)*40, y + (Math.random()-0.5)*40, '#331133', 'explosion');
            game.blackHoles.push(hole);
            addScreenShake(6);
        }

        function updateBlackHoles() {
            if (!game.blackHoles || !game.blackHoles.length) return;
            const now = performance.now();
            for (let i = game.blackHoles.length - 1; i >= 0; i--) {
                const h = game.blackHoles[i];
                const age = now - h.createdAt;
                const lifeT = age / h.lifeMs; // 0..1
                if (lifeT >= 1) {
                    // collapse burst
                    for (let p=0;p<14;p++) addParticle(h.x + (Math.random()-0.5)*h.radius*0.3, h.y + (Math.random()-0.5)*h.radius*0.3, '#662244','spark');
                    game.blackHoles.splice(i,1);
                    continue;
                }
                // Spin for visual modulation; spawn subtle inward drifting sparks
                h.spin += 0.04 + lifeT*0.06;
                if (Math.random() < 0.45) addParticle(h.x + Math.cos(h.spin)* (40 + Math.random()*50), h.y + Math.sin(h.spin)*(40 + Math.random()*50), '#442244','spark');
                // Pull + damage
                const radius = h.radius * (1 - lifeT*0.05); // shrink a little less over life
                const pullFalloff = 0.75;
                const frameDamage = (h.damagePerSecond / 60);
                h.pulseTimer += (1000/60);
                const doPulse = h.pulseTimer >= h.pulseInterval;
                if (doPulse) h.pulseTimer = 0;
                game.enemies.forEach(enemy => {
                    if (enemy.health <= 0) return;
                    const dx = h.x - enemy.x;
                    const dy = h.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < radius) {
                        const norm = dist || 0.0001;
                        // Raw falloff 0..1 (1 = center)
                        const fallRaw = (radius - dist) / radius;
                        // Lifetime scaling: suction ramps up toward collapse (0.6..1.5x)
                        const lifeBoost = 0.6 + lifeT * 0.9;
                        // Blend so outer ring still moves meaningfully (min motion) while inner accelerates strongly
                        const blended = 0.25 + Math.max(0, fallRaw) * 0.75; // 0.25..1.0
                        const base = h.strength * lifeBoost;
                        const pull = Math.max(0.35, base * blended * pullFalloff); // ensure minimum noticeable pull
                        enemy.x += (dx / norm) * pull;
                        enemy.y += (dy / norm) * pull;
                        // Frame damage scaled a bit less by distance now (outer ring still hurts some)
                        enemy.health -= frameDamage * (0.5 + blended * 0.5);
                        if (doPulse) {
                            const burst = Math.max(2, Math.floor(frameDamage * 12 * blended));
                            enemy.health -= burst;
                            addDamageNumber(burst, enemy.x, enemy.y - enemy.size/2, { type:'void'});
                            addParticle(enemy.x, enemy.y, '#8844AA','impact');
                        }
                    }
                });
            }
        }

        // Vortex: spinning damage field that applies burning
        function createVortex(x, y) {
            // Spawn a persistent field entry. Fields update in updateVortexFields.
            if (!Array.isArray(game.vortexFields)) game.vortexFields = [];
            const field = {
                x, y,
                radius: 135,
                innerRadius: 34,
                createdAt: Date.now(),
                duration: 4200, // ms lifetime (longer)
                tickEvery: 200, // ms between damage ticks (faster)
                lastTick: 0,
                spin: Math.random() * Math.PI * 2,
                spinSpeed: 0.10 + Math.random()*0.05,
                pullStrength: 3.2, // px per frame at center falloff (stronger)
                damagePerTick: 12, // higher base damage
                burnTime: 200
            };
            game.vortexFields.push(field);
            for (let i = 0; i < 18; i++) addParticle(x + (Math.random()-0.5)*field.radius*0.65, y + (Math.random()-0.5)*field.radius*0.65, '#FF33FF', 'explosion');
            addScreenShake(4);
        }

        // Update active vortex fields (called from update())
        function updateVortexFields() {
            if (!Array.isArray(game.vortexFields) || game.vortexFields.length === 0) return;
            const now = Date.now();
            for (let i = game.vortexFields.length - 1; i >= 0; i--) {
                const f = game.vortexFields[i];
                if (!f) { game.vortexFields.splice(i,1); continue; }
                // Lifetime expiry
                if (now - f.createdAt > f.duration) {
                    // small dissipate effect
                    for (let p=0;p<8;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.5, f.y + (Math.random()-0.5)*f.radius*0.5, '#AA44AA', 'spark');
                    game.vortexFields.splice(i,1);
                    continue;
                }
                f.spin += f.spinSpeed;
                // Pull + damage ticks
                game.enemies.forEach(enemy => {
                    const dx = f.x - enemy.x;
                    const dy = f.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < f.radius) {
                        // Pull strength scales with proximity
                        const pullScale = (f.radius - dist) / f.radius;
                        enemy.x += (dx / Math.max(dist,1)) * f.pullStrength * pullScale;
                        enemy.y += (dy / Math.max(dist,1)) * f.pullStrength * pullScale;
                        // Apply mild slow while inside vortex
                        enemy.slowed = true;
                        enemy.slowTime = Math.max(enemy.slowTime||0, 30);
                        if (now - f.lastTick >= f.tickEvery) {
                            // Apply damage + burn once per tick interval
                            let dmg = f.damagePerTick;
                            if (enemy.weakness) dmg = Math.floor(dmg * 1.3);
                            enemy.health -= dmg;
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, f.burnTime);
                            addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type: 'void' });
                            if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#FF66FF', 'impact');
                        }
                    }
                });
                if (now - f.lastTick >= f.tickEvery) {
                    f.lastTick = now;
                    // Pulse visual: ring contraction particles
                    for (let p=0;p<8;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.9, f.y + (Math.random()-0.5)*f.radius*0.9, '#AA44AA','spark');
                }
            }
        }

        // Echo Bloom lingering resonance fields
        function updateEchoBloomFields() {
            if (!Array.isArray(game.echoBloomFields) || !game.echoBloomFields.length) return;
            const now = Date.now();
            for (let i = game.echoBloomFields.length - 1; i >= 0; i--) {
                const f = game.echoBloomFields[i];
                if (now - f.createdAt > f.duration) { game.echoBloomFields.splice(i,1); continue; }
                if (now - f.lastTick >= f.tickEvery) {
                    f.lastTick = now;
                    game.enemies.forEach(en => {
                        if (en.health<=0) return;
                        const dx = en.x - f.x; const dy = en.y - f.y; const d = Math.hypot(dx,dy);
                        if (d < f.radius) {
                            const fall = 0.45 + 0.55*(1 - d / f.radius);
                            const dmg = Math.max(1, Math.floor(f.baseDamage * fall));
                            en.health -= dmg;
                            addDamageNumber(dmg, en.x, en.y - en.size/2, { type:'void' });
                            if (Math.random()<0.25) addParticle(en.x, en.y, '#FFC8FF','impact');
                        }
                    });
                }
            }
        }

        // Reality Break: short, chaotic distortion that jitters enemies, applies small damage ticks,
        // and occasionally warps an enemy's position to a random nearby location. Conservative safe defaults.
        function createRealityBreak(x, y, baseDamage) {
            for (let i = 0; i < 12; i++) addParticle(x + (Math.random()-0.5)*100, y + (Math.random()-0.5)*100, '#66FFFF', 'explosion');
            const duration = 100; // frames (~1.6s)
            const radius = 220;
            const start = Date.now();
            // register active reality field for projectile refraction
            const field = { x, y, radius, expiresAt: start + duration * 16 };
            game.activeRealityFields.push(field);
            // Boost global distortion effect (cumulative but clamped)
            if (!game.realityBreakDistort) game.realityBreakDistort = { time:0, intensity:0 };
            game.realityBreakDistort.time = Math.min(game.realityBreakDistort.time + 90, 240);
            game.realityBreakDistort.intensity = Math.min(1.0, game.realityBreakDistort.intensity + 0.35);
            const interval = setInterval(() => {
                // chaotic visual sparks
                if (Math.random() < 0.6) addParticle(x + (Math.random()-0.5)*160, y + (Math.random()-0.5)*160, '#99FFFF', 'spark');

                game.enemies.forEach(enemy => {
                    const dx = enemy.x - x;
                    const dy = enemy.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 220) {
                        // small random jitter to simulate physics break
                        enemy.x += (Math.random() - 0.5) * Math.min(18, (220 - dist) / 8);
                        enemy.y += (Math.random() - 0.5) * Math.min(18, (220 - dist) / 8);

                        // periodic small damage ticks scaled down for safety
                        const dmg = Math.max(1, Math.floor(baseDamage * 0.035));
                        enemy.health -= dmg;
                        if (Math.random() < 0.12) addParticle(enemy.x, enemy.y, '#66FFFF', 'impact');

                        // small chance to randomly teleport the enemy a short distance (disorienting)
                        if (Math.random() < 0.035) {
                            const tx = enemy.x + (Math.random()-0.5) * 120;
                            const ty = enemy.y + (Math.random()-0.5) * 120;
                            enemy.x = Math.max(40, Math.min(tx, canvas.width - 40));
                            enemy.y = Math.max(40, Math.min(ty, canvas.height - 40));
                            addParticle(enemy.x, enemy.y, '#FFFFFF', 'spark');
                        }
                    }
                });

                // subtle camera feedback
                if (Math.random() < 0.08) addScreenShake(3);

                if (Date.now() - start > duration * 16) {
                    clearInterval(interval);
                    // final destabilizing burst
                    for (let i = 0; i < 10; i++) addParticle(x + (Math.random()-0.5)*140, y + (Math.random()-0.5)*140, '#66FFFF', 'explosion');
                    addScreenShake(8);
                    // remove field from active list
                    const idx = game.activeRealityFields.indexOf(field);
                    if (idx >= 0) game.activeRealityFields.splice(idx, 1);
                }
            }, 16);
        }

        // splitProjectile removed (Split Shot ability deprecated)

        // Crystal Shot helper: spawn prismatic shards on shatter
        function createCrystalShatter(x, y, baseDamage, sourceProj) {
            const abil = game.player.abilities || [];
            let shardCount = 4 + Math.floor(Math.random()*2); // 4-5 baseline
            // Synergy: ice increases control -> +1 shard
            if (abil.some(a=>/Ice Shot|Frost|Blizzard/i.test(a))) shardCount++;
            // Synergy: lightning energizes fracture -> +1 shard (chance)
            if (abil.some(a=>/Lightning Shot|Storm Shot/i.test(a)) && Math.random()<0.6) shardCount++;
            // Cap to avoid spam
            shardCount = Math.min(8, shardCount);
            for (let i=0;i<shardCount;i++) {
                const ang = Math.random()*Math.PI*2;
                const sp = 3.4 + Math.random()*2.4;
                const dmgFrac = 0.20 + Math.random()*0.08; // 20-28%
                const vx = Math.cos(ang)*sp;
                const vy = Math.sin(ang)*sp;
                game.projectiles.push({
                    x: x + Math.cos(ang)*4,
                    y: y + Math.sin(ang)*4,
                    vx, vy,
                    life: 55 + Math.floor(Math.random()*18),
                    size: 5,
                    enemy:false,
                    damage: Math.max(1, Math.floor((baseDamage||calculateDamage()) * dmgFrac)),
                    baseDamage: Math.max(1, Math.floor((baseDamage||calculateDamage()) * dmgFrac)),
                    damageType: 'crystal',
                    piercing: false,
                    crystalShard: true,
                    refract: true,
                    homing: false,
                    // (removed splitting flag)
                });
            }
            // Visual sparkle field
            for (let s=0;s<10;s++) addParticle(x + (Math.random()-0.5)*28, y + (Math.random()-0.5)*28, '#AAEEFF', 'spark');
            addScreenShake(4);
            if (sourceProj) sourceProj._crystalShattered = true;
        }

        function takeDamage(amount) {
            let finalDamage = amount;
            
            // Damage reduction
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageReduction) {
                    finalDamage -= abilityData.effect.damageReduction;
                }
            });
            
            // Block chance
            let blockChance = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.blockChance) {
                    blockChance = Math.max(blockChance, abilityData.effect.blockChance);
                }
            });
            
            if (Math.random() < blockChance) {
                finalDamage = 0;
                addParticle(game.player.x, game.player.y - 15, '#0088FF', 'shield');
            }
            
            finalDamage = Math.max(0, finalDamage);
            
            if (finalDamage > 0) {
                game.player.health -= finalDamage;
                game.player.invulnerable = true;
                game.player.invulnTime = 80;
                addScreenShake(4);
                addParticle(game.player.x, game.player.y, '#FF4444', 'damage');
            }
            
            if (game.player.health <= 0 && !game.gameOver && !game._bigQuackDefeated) {
                // Prevent game over overlapping with victory/ending flow
                triggerGameOver();
            }
            
            updateUI();
        }

        function triggerGameOver() {
            game.gameOver = true;
            // Pause gameplay music
            try { if (game.bgMusic) game.bgMusic.pause(); } catch(e) {}
            // One-shot game over audio (respect SFX preference)
            try {
                if (game._gameOverSound) { try { game._gameOverSound.pause(); } catch(e) {} }
                game._gameOverSound = new Audio('assets/audio/gameover.mp3');
                game._gameOverSound.loop = false;
                if (game.sfxEnabled) {
                    game._gameOverSound.play().catch(()=>{});
                }
            } catch(e) {}
            // Enforce a 1 second delay before restart allowed
            game._gameOverAt = performance.now();
            const restart = (e) => {
                if (e.code !== 'Space' && e.key !== ' ' ) return; // only fire button (Space)
                if (performance.now() - game._gameOverAt < 1000) return; // delay
                window.removeEventListener('keydown', restart);
                // Prevent any residual room-cleared flow from advancing
                game.roomCleared = false;
                game.gameOver = false;
                // Reset progression to the same street (do NOT advance) – keep current dungeon & room unless they were out of range
                if (game.room < 1 || game.room > 5) game.room = 1;
                if (game.dungeon < 1 || game.dungeon > 10) game.dungeon = 1;
                // Clear any transient flags that could trigger nextRoom()
                game._pendingAdvance = false;
                resetGame();
                if (typeof rebuildPlayerSprite === 'function') rebuildPlayerSprite();
            };
            window.addEventListener('keydown', restart);
        }

        function openChest(chest) {
            chest.opened = true;
            game.chestsOpened++;
            // Opening effect (color keyed to variant)
            const baseColor = chest.variant === 'platinum' ? '#FFFFFF' : chest.variant === 'irradiated' ? '#b4ff5c' : '#FFD700';
            for (let i = 0; i < 8; i++) addParticle(chest.x, chest.y, baseColor, 'treasure');

            let newAbility = chest.ability || null;
            if (newAbility && game.player.abilities.includes(newAbility)) {
                // Already have it (maybe acquired after spawn). Try to find another of same tier.
                const tier = ABILITIES[newAbility] ? (ABILITIES[newAbility].tier || 1) : 1;
                const sameTierPool = Object.keys(ABILITIES).filter(a => !game.player.abilities.includes(a) && (ABILITIES[a].tier || 1) === tier);
                if (sameTierPool.length > 0) newAbility = sameTierPool[Math.floor(Math.random()*sameTierPool.length)];
                else newAbility = null; // nothing available
            }
            if (!newAbility) {
                // Fallback: any remaining ability
                const pool = Object.keys(ABILITIES).filter(a => !game.player.abilities.includes(a));
                if (pool.length > 0) newAbility = pool[Math.floor(Math.random()*pool.length)];
            }

            if (newAbility) {
                game.player.abilities.push(newAbility);
                showAbilityTooltip(newAbility);
                const abilityData = ABILITIES[newAbility];
                if (abilityData && abilityData.effect.maxHealthBonus) {
                    game.player.maxHealth += abilityData.effect.maxHealthBonus;
                    game.player.health += abilityData.effect.maxHealthBonus;
                }
                updateUI();
                addScreenShake(3);
            }
        }

        function checkRoomComplete() {
            // Grace guard: ignore empty enemy list for a few frames right after a restart to prevent false 'Street Cleared'.
            if (game._restartGraceFrames && game._restartGraceFrames > 0) {
                game._restartGraceFrames--;
                return;
            }
            if (!game.roomCleared && game.enemies.length === 0 && (game._roomSpawnedEnemies||0) > 0) {
                game.roomCleared = true;
                game.roomsCleared++;
                game.score += 50 * game.dungeon;
                
                // Room clear effect
                for (let i = 0; i < 10; i++) {
                    addParticle(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        '#00FF00',
                        'victory'
                    );
                }
                
                updateUI();
            }
        }

        function nextRoom() {
            game.room++;
            
            if (game.room > 5) {
                game.dungeon++;
                game.room = 1;
                // New district: reset chest counter
                game.chestsThisCycle = 0;
                
                if (game.dungeon > 10) {
                    completeGame();
                    return;
                }
            }
            
            generateRoom();
            updateUI();
        }

        function completeGame() {
            // Victory screen
            // Prevent multiple invocations (some pathways may call completeGame or offerPermanentAbilityChoice twice)
            if (game._victorySequenceShown) return; // hard guard
            game._victorySequenceShown = true;
            const overlay = document.createElement('div');
            overlay.id = 'endingOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(circle, rgba(0,255,0,0.2), rgba(0,0,0,0.9));
                display: flex; flex-direction: column; justify-content: center; align-items: center;
                color: white; font-family: 'Courier New', monospace; z-index: 1000;
                animation: fadeIn 1s ease-in;
            `;
            
            overlay.innerHTML = `
                <h1 style="color: #00FF00; font-size: 48px; text-shadow: 0 0 20px #00FF0088; margin-bottom: 20px;">
                    VICTORY!
                </h1>
                <h2 style="color: #FFFF00; margin-bottom: 30px;">
                    All Districts Cleared!
                </h2>
                <div style="background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center;">
                    <p><strong>Final Score:</strong> ${game.score.toLocaleString()}</p>
                    <p><strong>Total Kills:</strong> ${game.totalKills}</p>
                    <p><strong>Streets Cleared:</strong> ${game.roomsCleared}</p>
                    <p><strong>Chests Opened:</strong> ${game.chestsOpened}</p>
                    <button onclick="this.parentElement.parentElement.remove(); resetGame();" 
                            style="margin-top: 20px; padding: 10px 20px; font-size: 16px; 
                                   background: #333; color: white; border: 2px solid #666; 
                                   border-radius: 5px; cursor: pointer;">
                        Play Again
                    </button>
                </div>
offerPermanentAbilityChoice();
`;
            // Only offer permanent ability if not already done (flagged elsewhere via Space key path)
            if (!game._finalAbilityOffered) {
                offerPermanentAbilityChoice();
                game._finalAbilityOffered = true;
            }
            
            
            // Add fadeIn animation
            const style = document.createElement('style');
            style.textContent = '@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }';
            document.head.appendChild(style);
            
            document.body.appendChild(overlay);
        }

        function resetGame() {
                    // Preserve existing sprite sheet/meta before wiping player object so we don't lose load state
                    const prevSheet = game.player && game.player.spriteSheet;
                    const prevMeta = game.player && game.player.spriteMeta;
                    const prevFrames = game.player && game.player.directionalFrames;
                    const prevScale = game.player && game.player.spriteScale;
                    const prevLoaded = game.player && game.player.spriteLoaded;
                    // Restore standard gameplay music if coming from boss/ending sequences
                    try {
                        if (game.bgMusic) { try { game.bgMusic.pause(); } catch(e) {} }
                        game.bgMusic = new Audio('assets/audio/QuackshotChronicles.mp3');
                        game.bgMusic.loop = true; game._bossMusicPlaying = false;
                        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
                    } catch(e) {}
                    game._bigQuackDefeated = false;
                    game._finalAbilityOffered = false;
                    game._victorySequenceShown = false; // reset victory guard
            game.player = {
                x: 320, y: 240, health: 100, maxHealth: 100,
                abilities: [], permanentAbilities: [],
                facing: 'down',
                lastDirection: { x: 0, y: 1 },
                invulnerable: false, invulnTime: 0,
                speed: 2.5,
                // Terrifying Aura tracking
                killCount: 0,
                auraActive: false,
                // Removed level-based fields: auraActivatedLevel, auraExpireLevel
                auraExpireRoom: 0,
                auraKillCounter: 0, // explicit counter separate from totalKills if used for 25 threshold UI
                // Rendering / visibility control fields reset
                blinkTimer: 0,
                wasHitTimer: 0,
                directionalFrames: prevFrames || null,
                spriteScale: prevScale || null,
                spriteSheet: prevSheet || null,
                spriteMeta: prevMeta || (prevSheet ? { rows: 4, cols: 4, frameWidth: 48, frameHeight: 48, order: ['down','left','right','up'] } : null),
                spriteLoaded: prevLoaded || (prevSheet ? prevSheet.complete : false)
            };

            // If sprite sheet was lost (first ever reset before load code ran), reinitialize it similar to startup
            if (!game.player.spriteSheet) {
                game.player.spriteSheet = new Image();
                game.player.spriteSheet.src = 'assets/player.png';
                game.player.spriteMeta = { rows: 4, cols: 4, frameWidth: 48, frameHeight: 48, order: ['down','left','right','up'] };
                game.player.spriteSheet.onload = () => {
                    game.player.spriteLoaded = true;
                    rebuildPlayerSprite();
                };
            }

            // --- Permanent Ability Integration ---
            loadPermanentAbilities();
            grantPermanentAbilities();

            game.dungeon = 1;
            game.room = 1;
            game.score = 0;
            game.shotCounter = 0;
            game.chestsThisCycle = 0;
            game.totalKills = 0;
            game.roomsCleared = 0;
            game.chestsOpened = 0;
            game.paused = false;

            // Clear any lingering Terrifying Aura UI text / prompts (defensive)
            const auraNotice = document.getElementById('auraNotice');
            if (auraNotice) auraNotice.remove();
            if (game.player) {
                game.player.auraActive = false;
                // auraExpireLevel removed
                game.player.auraExpireRoom = 0;
                game.player.auraKillCounter = 0;
            }

            // Hide pause menu if open (fix: check if element exists)
            var pauseOverlay = document.getElementById('pauseOverlay');
            if (pauseOverlay) {
                pauseOverlay.style.display = 'none';
            }

            // Hard purge of any lingering entities from previous run (defensive in case a reference was kept elsewhere)
            game.enemies = [];
            game.projectiles = [];
            game.particles = [];
            game.chests = [];
            game.pickups = [];
            game.traps = [];
            game.pits = [];
            game.nukes = [];
            game.poisonClouds = [];
            game.shockwaves = [];
            game.vortexFields = [];
            game.lightningArcs = [];
            // Restart grace: suppress premature room clear until enemies have visibly spawned
            game._restartGraceFrames = 30; // ~0.5s at 60fps
            game._roomSpawnedEnemies = 0;
            // Rebuild & force visibility (will also set spriteLoaded true)
            if (typeof rebuildPlayerSprite === 'function') {
                rebuildPlayerSprite();
            } else if (typeof window !== 'undefined' && typeof window.rebuildPlayerSprite === 'function') {
                window.rebuildPlayerSprite();
            } else {
                console.warn('[Reset] rebuildPlayerSprite unavailable at call time');
            }
            // If for any reason directionalFrames not established, mark for early retry
            if (!game.player.directionalFrames) {
                game.player._pendingSpriteRetry = 6; // attempt for first 6 frames
            }
            game.player.spriteLoaded = true; // hard assert loaded since sheet persisted
            game.player.forceVisibleFrames = 90; // extend a bit longer (1.5s) to visually confirm

            // Ensure no lingering pause or overlays hide player
            game.gameOver = false;
            game.paused = false;
            game._bigQuackDefeated = false; // already set above, reinforce

            generateRoom();
            updateUI();
        }

        // (Removed floating Reset Progress button; now in Pause -> Options)

        function addParticle(x, y, color, type) {
            // Cosmetic gating: suppress low-priority particle categories if user disabled them.
            const cosmeticTypes = { spark:1, ambient:1, lightning:1, heal:1, shield:1, damage:1, treasure:1 };
            if (game.disableCosmeticParticles && cosmeticTypes[type]) return;
            const particle = {
                x: x + (Math.random() - 0.5) * 10,
                y: y + (Math.random() - 0.5) * 10,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 30 + Math.random() * 20,
                maxLife: 50,
                color: color,
                type: type,
                alpha: 1
            };
            
            // Type-specific properties
            switch (type) {
                case 'explosion':
                    particle.vx *= 2;
                    particle.vy *= 2;
                    particle.life = 20;
                    break;
                case 'fire':
                    particle.vy -= 1;
                    break;
                case 'heal':
                    particle.vy -= 2;
                    particle.vx = 0;
                    break;
                case 'treasure':
                    particle.vy -= 1.5;
                    particle.life = 60;
                    break;
            }
            
            game.particles.push(particle);
        }

        // Feather poof helper (re-added / ensured). Creates an initial bright burst and spawns drifting feather particles.
        function spawnFeatherPoof(enemy) {
            if (!enemy || !game || !game.particles) return;
            const size = enemy.size || 20;
            const scaleFactor = size / 20;
            const burstCount = Math.min(40, Math.floor(18 * scaleFactor));
            // Bright radial flash (quick fade) using featherSingle for a few for variety
            for (let i=0;i<burstCount;i++) {
                const ang = Math.random()*Math.PI*2;
                const dist = Math.random()* (6 + size*0.15);
                const px = enemy.x + Math.cos(ang)*dist;
                const py = enemy.y + Math.sin(ang)*dist;
                if (i < burstCount * 0.25) {
                    addParticle(px, py, '#ffffff', 'featherSingle');
                } else {
                    addParticle(px, py, '#ffffff', 'spark');
                }
            }
            // Drifting long-lived feathers
            const featherCount = Math.min(80, Math.floor(22 * scaleFactor));
            for (let f=0; f<featherCount; f++) {
                const ang = Math.random()*Math.PI*2;
                const sp = (Math.random()*1.8 + 0.6) * (0.8 + scaleFactor*0.2);
                const vx = Math.cos(ang)*sp;
                const vy = Math.sin(ang)*sp - (Math.random()*1.1 + 0.3);
                const life = 60 + Math.random()*70;
                const feather = {
                    x: enemy.x + (Math.random()-0.5)*size*0.4,
                    y: enemy.y + (Math.random()-0.5)*size*0.4,
                    vx, vy,
                    gravity: 0.055 + Math.random()*0.045,
                    life,
                    maxLife: life,
                    color: '#ffffff',
                    type: 'feather',
                    alpha: 1,
                    spin: Math.random()*Math.PI*2,
                    spinSpeed: (Math.random()*0.22 - 0.11),
                    scale: 0.45 + Math.random()*0.85 * (0.85 + scaleFactor*0.25),
                    drift: (Math.random()*0.5 - 0.25)
                };
                game.particles.push(feather);
            }
        }

        function addAmbientParticles() {
            // Skip ambient emissions entirely if cosmetic FX disabled
            if (game.disableCosmeticParticles) return;
            // Add some ambient city particles
            if (Math.random() < 0.3) {
                addParticle(
                    Math.random() * canvas.width,
                    canvas.height + 10,
                    '#666666',
                    'ambient'
                );
            }
        }

        // --- Minimal Attack SFX (WebAudio) ---
        let _atkAudioCtx = null;
        let _atkCompressor = null;
        let _atkLast = 0;
        function _ensureAtkAudio() {
            if (_atkAudioCtx) return;
            try {
                _atkAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                _atkCompressor = _atkAudioCtx.createDynamicsCompressor();
                _atkCompressor.threshold.setValueAtTime(-28, _atkAudioCtx.currentTime);
                _atkCompressor.knee.setValueAtTime(18, _atkAudioCtx.currentTime);
                _atkCompressor.ratio.setValueAtTime(8, _atkAudioCtx.currentTime);
                _atkCompressor.attack.setValueAtTime(0.003, _atkAudioCtx.currentTime);
                _atkCompressor.release.setValueAtTime(0.08, _atkAudioCtx.currentTime);
                _atkCompressor.connect(_atkAudioCtx.destination);
            } catch(e) { /* audio blocked */ }
        }
        function playAttackSfx() {
            if (!game.sfxEnabled) return;
            const nowMs = performance.now();
            const MIN_INTERVAL = 45; // allow slightly faster cadence for automatic fire, still limited
            if (nowMs - _atkLast < MIN_INTERVAL) return;
            _atkLast = nowMs;
            _ensureAtkAudio(); if (!_atkAudioCtx) return;
            const t = _atkAudioCtx.currentTime;
            // Lower-pitched redesign:
            // Layer 1: Core body (sawtooth with short decay, mid-low frequency sweep)
            const bodyOsc = _atkAudioCtx.createOscillator();
            const bodyGain = _atkAudioCtx.createGain();
            const bodyStart = 620 + Math.random()*80; // previously ~1800, now much lower
            const bodyEnd = bodyStart * 0.55;
            bodyOsc.type = 'sawtooth';
            bodyOsc.frequency.setValueAtTime(bodyStart, t);
            bodyOsc.frequency.exponentialRampToValueAtTime(bodyEnd, t + 0.09);
            bodyGain.gain.setValueAtTime(0.0001, t);
            bodyGain.gain.linearRampToValueAtTime(0.34, t + 0.004);
            bodyGain.gain.exponentialRampToValueAtTime(0.0005, t + 0.16);

            // Layer 2: Wider noise burst (lower bandpass center)
            const noiseBuffer = _atkAudioCtx.createBuffer(1, 4410, 44100);
            const data = noiseBuffer.getChannelData(0);
            for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
            const noiseSrc = _atkAudioCtx.createBufferSource(); noiseSrc.buffer = noiseBuffer;
            const bp = _atkAudioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.setValueAtTime(900, t); bp.Q.value = 2.2;
            const noiseGain = _atkAudioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.42, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.0005, t + 0.18);

            // Layer 3: Deep thump (even lower fundamental)
            const thumpOsc = _atkAudioCtx.createOscillator(); thumpOsc.type='sine';
            const thumpGain = _atkAudioCtx.createGain();
            const thumpFreq = 90 + Math.random()*15; // was ~140
            thumpOsc.frequency.setValueAtTime(thumpFreq, t);
            thumpOsc.frequency.exponentialRampToValueAtTime(thumpFreq * 0.65, t + 0.12);
            thumpGain.gain.setValueAtTime(0.0001, t);
            thumpGain.gain.linearRampToValueAtTime(0.28, t + 0.006);
            thumpGain.gain.exponentialRampToValueAtTime(0.0004, t + 0.20);

            // Sub emphasis (short sine burst one octave below thump)
            const subOsc = _atkAudioCtx.createOscillator(); subOsc.type='sine';
            const subGain = _atkAudioCtx.createGain();
            subOsc.frequency.setValueAtTime(thumpFreq/2, t);
            subGain.gain.setValueAtTime(0.0001, t);
            subGain.gain.linearRampToValueAtTime(0.18, t + 0.008);
            subGain.gain.exponentialRampToValueAtTime(0.0003, t + 0.17);

            // Master filters shifted lower
            const hp = _atkAudioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(140, t);
            const lp = _atkAudioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.setValueAtTime(3800, t);

            bodyOsc.connect(bodyGain);
            noiseSrc.connect(bp); bp.connect(noiseGain);
            thumpOsc.connect(thumpGain);
            subOsc.connect(subGain);
            const merger = _atkAudioCtx.createGain();
            bodyGain.connect(merger); noiseGain.connect(merger); thumpGain.connect(merger); subGain.connect(merger);
            merger.connect(hp); hp.connect(lp); lp.connect(_atkCompressor || _atkAudioCtx.destination);

            bodyOsc.start(t); bodyOsc.stop(t + 0.18);
            thumpOsc.start(t); thumpOsc.stop(t + 0.22);
            subOsc.start(t); subOsc.stop(t + 0.20);
            noiseSrc.start(t); noiseSrc.stop(t + 0.20);
        }

        function addScreenShake(intensity) {
            game.screenShake = Math.max(game.screenShake, intensity);
            game.screenShakeIntensity = intensity;
        }

        function render() {
            // Handle screen shake
            let shakeX = 0, shakeY = 0;
            if (game.screenShake > 0) {
                shakeX = (Math.random() - 0.5) * game.screenShakeIntensity;
                shakeY = (Math.random() - 0.5) * game.screenShakeIntensity;
            }
            
            ctx.save();
            ctx.translate(shakeX, shakeY);
            
            // Clear with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw street lines
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 3;
            ctx.setLineDash([15, 15]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw walls (restored original manual drawing)
            game.walls.forEach(wall => {
                ctx.save();
                switch (wall.type) {
                    case 'building':
                        ctx.fillStyle = '#404040';
                        ctx.fillRect(wall.x, wall.y, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(wall.x + 2, wall.y + 2, TILE_SIZE - 4, 4);
                        ctx.fillStyle = '#ffff88';
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 2; j++) {
                                if (Math.random() < 0.7) {
                                    ctx.fillRect(wall.x + 4 + i * 8, wall.y + 8 + j * 8, 4, 4);
                                }
                            }
                        }
                        break;
                    case 'car': {
                        // Car palette selection deterministic by x for variety
                        const bodyColors = ['#c62828','#1565c0','#2e7d32','#f57c00'];
                        const body = bodyColors[Math.floor(wall.x / 100) % bodyColors.length];
                        const x = wall.x;
                        const y = wall.y;
                        const w = TILE_SIZE;
                        const h = TILE_SIZE; // treat each tile square as parking footprint
                        // Main body (lower chassis)
                        ctx.fillStyle = body;
                        ctx.fillRect(x, y + h*0.25, w, h*0.55);
                        // Roof section (smaller, centered)
                        ctx.fillStyle = shadeColor(body, -20);
                        const roofW = w*0.70;
                        const roofH = h*0.28;
                        const roofX = x + (w - roofW)/2;
                        const roofY = y + h*0.30;
                        ctx.fillRect(roofX, roofY, roofW, roofH);
                        // Windows (front & rear on roof)
                        ctx.fillStyle = 'rgba(180,220,255,0.85)';
                        ctx.fillRect(roofX + roofW*0.08, roofY + roofH*0.10, roofW*0.32, roofH*0.80);
                        ctx.fillRect(roofX + roofW*0.60, roofY + roofH*0.10, roofW*0.32, roofH*0.80);
                        // Mid pillar line
                        ctx.fillStyle = shadeColor(body, -40);
                        ctx.fillRect(roofX + roofW*0.50 - 1, roofY + roofH*0.08, 2, roofH*0.84);
                        // Wheels (four circles protruding slightly)
                        ctx.fillStyle = '#111';
                        const wheelR = h*0.12;
                        const wheelYF = y + h*0.28 + h*0.50; // same vertical alignment front/back
                        ctx.beginPath();
                        ctx.arc(x + w*0.18, y + h*0.80, wheelR, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x + w*0.82, y + h*0.80, wheelR, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x + w*0.18, y + h*0.32, wheelR, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x + w*0.82, y + h*0.32, wheelR, 0, Math.PI*2); ctx.fill();
                        // Wheel hubs
                        ctx.fillStyle = '#bbb';
                        const hubR = wheelR*0.45;
                        ;['#c','#c','#c','#c'].forEach(()=>{}); // no-op placeholder
                        ctx.beginPath(); ctx.arc(x + w*0.18, y + h*0.80, hubR, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(x + w*0.82, y + h*0.80, hubR, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(x + w*0.18, y + h*0.32, hubR, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(x + w*0.82, y + h*0.32, hubR, 0, Math.PI*2); ctx.fill();
                        // Headlights (front assumed left-to-right => front at x side?) We'll treat top edge as front for simplicity
                        ctx.fillStyle = '#ffeb3b';
                        ctx.fillRect(x + w*0.10, y + h*0.20, w*0.18, h*0.08);
                        ctx.fillRect(x + w*0.72, y + h*0.20, w*0.18, h*0.08);
                        // Tail lights (bottom side)
                        ctx.fillStyle = '#ff1744';
                        ctx.fillRect(x + w*0.10, y + h*0.84, w*0.18, h*0.07);
                        ctx.fillRect(x + w*0.72, y + h*0.84, w*0.18, h*0.07);
                        // Center stripe / hood line
                        ctx.strokeStyle = shadeColor(body, -50);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + w*0.50, y + h*0.25);
                        ctx.lineTo(x + w*0.50, y + h*0.80);
                        ctx.stroke();
                        // Simple shading overlay (gradient simulation)
                        ctx.fillStyle = 'rgba(0,0,0,0.18)';
                        ctx.fillRect(x, y + h*0.55, w, h*0.25);
                        // Outline
                        ctx.strokeStyle = '#00000055';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x + 0.5, y + h*0.25 + 0.5, w - 1, h*0.55 - 1);
                        break;
                    }
                    case 'dumpster': {
                        // Enhanced dumpster graphic sized to closely match the full tile hitbox.
                        // Previous version used only ~70% vertical height causing perceived collision overshoot.
                        const x = wall.x, y = wall.y, w = TILE_SIZE, h = TILE_SIZE;
                        const bodyTop = y + h*0.06; // tighten top gap so sprite nearly fills tile
                        const bodyHeight = h*0.82;
                        // Back panel (slightly darker, gives depth)
                        ctx.fillStyle = '#274727';
                        ctx.fillRect(x + 1, bodyTop, w - 2, bodyHeight);
                        // Main body front face (lighter green)
                        ctx.fillStyle = '#2f522f';
                        ctx.fillRect(x, bodyTop + h*0.02, w, bodyHeight - h*0.04);
                        // Vertical slats (front panels)
                        ctx.fillStyle = '#366c36';
                        const slatTop = bodyTop + h*0.06;
                        const slatHeight = bodyHeight - h*0.14;
                        for (let i=0;i<6;i++) {
                            const pw = w*0.075;
                            const gap = w*0.02;
                            const px = x + w*0.07 + i*(pw+gap);
                            ctx.fillRect(px, slatTop, pw, slatHeight);
                        }
                        // Side handles
                        ctx.fillStyle = '#1e341e';
                        const handleW = w*0.10, handleH = h*0.08;
                        ctx.fillRect(x - handleW*0.3, bodyTop + bodyHeight*0.40, handleW, handleH);
                        ctx.fillRect(x + w - handleW*0.70, bodyTop + bodyHeight*0.40, handleW, handleH);
                        // Rim / lip (thicker)
                        ctx.fillStyle = '#1b2f1b';
                        const rimY = bodyTop - h*0.02;
                        ctx.fillRect(x - 1, rimY, w + 2, h*0.07);
                        // Lid (slightly open perspective)
                        ctx.fillStyle = '#234423';
                        ctx.beginPath();
                        ctx.moveTo(x - 3, rimY + h*0.00);
                        ctx.lineTo(x + w + 3, rimY + h*0.00);
                        ctx.lineTo(x + w - 6, y + h*0.00);
                        ctx.lineTo(x + 6, y + h*0.00);
                        ctx.closePath();
                        ctx.fill();
                        // Lid highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.08)';
                        ctx.fillRect(x + 6, rimY + 2, w - 12, h*0.015);
                        // Inner shadow (bottom)
                        const grad = ctx.createLinearGradient(0, bodyTop + bodyHeight*0.55, 0, bodyTop + bodyHeight);
                        grad.addColorStop(0, 'rgba(0,0,0,0)');
                        grad.addColorStop(1, 'rgba(0,0,0,0.25)');
                        ctx.fillStyle = grad;
                        ctx.fillRect(x, bodyTop + bodyHeight*0.55, w, bodyHeight*0.45);
                        // Wheels
                        const wheelR = h*0.075;
                        const wheelY = y + h*0.94;
                        ctx.fillStyle = '#111';
                        ctx.beginPath(); ctx.arc(x + w*0.20, wheelY, wheelR, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(x + w*0.80, wheelY, wheelR, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#585858';
                        ctx.beginPath(); ctx.arc(x + w*0.20, wheelY, wheelR*0.5, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(x + w*0.80, wheelY, wheelR*0.5, 0, Math.PI*2); ctx.fill();
                        // Subtle front highlight band
                        ctx.fillStyle = 'rgba(255,255,255,0.06)';
                        ctx.fillRect(x + w*0.04, bodyTop + h*0.10, w*0.24, bodyHeight*0.55);
                        // Outline matching full occupied area
                        ctx.strokeStyle = '#0d160d';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x + 0.5, bodyTop + h*0.02 + 0.5, w - 1, bodyHeight - h*0.04 - 1);
                        // Ground shadow to reinforce footprint (helps player perceive full collision width)
                        ctx.fillStyle = 'rgba(0,0,0,0.20)';
                        ctx.beginPath();
                        ctx.ellipse(x + w/2, y + h*0.99, w*0.46, h*0.08, 0, 0, Math.PI*2);
                        ctx.fill();
                        break;
                    }
                    case 'streetlight': {
                        const x = wall.x, y = wall.y, w = TILE_SIZE, h = TILE_SIZE;
                        const poleX = x + w*0.45;
                        // Pole
                        ctx.fillStyle = '#7a7a7a';
                        ctx.fillRect(poleX, y - h*0.30, w*0.10, h*1.30);
                        // Base
                        ctx.fillStyle = '#575757';
                        ctx.fillRect(poleX - w*0.10, y + h*0.95, w*0.30, h*0.08);
                        // Arm
                        ctx.fillStyle = '#6c6c6c';
                        ctx.fillRect(poleX + w*0.05, y - h*0.18, w*0.40, h*0.06);
                        // Lamp head
                        const lampX = poleX + w*0.42;
                        const lampY = y - h*0.18 + h*0.03;
                        ctx.fillStyle = '#444';
                        ctx.fillRect(lampX, lampY, w*0.24, h*0.14);
                        // Bulb + glow cone
                        ctx.fillStyle = '#ffec66';
                        ctx.fillRect(lampX + w*0.04, lampY + h*0.02, w*0.16, h*0.10);
                        // Light cone (semi-transparent)
                        const coneGradient = ctx.createLinearGradient(lampX, lampY + h*0.14, lampX, lampY + h*0.80);
                        coneGradient.addColorStop(0, 'rgba(255,236,102,0.45)');
                        coneGradient.addColorStop(1, 'rgba(255,236,102,0)');
                        ctx.fillStyle = coneGradient;
                        ctx.beginPath();
                        ctx.moveTo(lampX - w*0.05, lampY + h*0.14);
                        ctx.lineTo(lampX + w*0.29, lampY + h*0.14);
                        ctx.lineTo(lampX + w*0.18, lampY + h*0.90);
                        ctx.lineTo(lampX + w*0.06, lampY + h*0.90);
                        ctx.closePath();
                        ctx.fill();
                        // Subtle radial glow around bulb
                        const rg = ctx.createRadialGradient(lampX + w*0.12, lampY + h*0.07, 2, lampX + w*0.12, lampY + h*0.07, 18);
                        rg.addColorStop(0, 'rgba(255,236,102,0.6)');
                        rg.addColorStop(1, 'rgba(255,236,102,0)');
                        ctx.fillStyle = rg;
                        ctx.beginPath();
                        ctx.arc(lampX + w*0.12, lampY + h*0.07, 18, 0, Math.PI*2);
                        ctx.fill();
                        // Outline pole
                        ctx.strokeStyle = '#444';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(poleX, y - h*0.30, w*0.10, h*1.30);
                        break;
                    }
                    case 'barrier': {
                        const x = wall.x, y = wall.y, w = TILE_SIZE, h = TILE_SIZE;
                        // Support posts
                        ctx.fillStyle = '#5e5e5e';
                        ctx.fillRect(x + w*0.08, y + h*0.10, w*0.12, h*0.70);
                        ctx.fillRect(x + w*0.80, y + h*0.10, w*0.12, h*0.70);
                        // Feet
                        ctx.fillStyle = '#444';
                        ctx.fillRect(x + w*0.02, y + h*0.78, w*0.24, h*0.10);
                        ctx.fillRect(x + w*0.74, y + h*0.78, w*0.24, h*0.10);
                        // Panel background
                        const panelY = y + h*0.18;
                        const panelH = h*0.42;
                        ctx.fillStyle = '#d8d8d8';
                        ctx.fillRect(x + w*0.12, panelY, w*0.76, panelH);
                        // Diagonal stripes
                        const stripeW = w*0.10;
                        for (let sx = x + w*0.10; sx < x + w*0.90 + stripeW; sx += stripeW*1.3) {
                            ctx.fillStyle = '#ff3b30';
                            ctx.beginPath();
                            ctx.moveTo(sx, panelY);
                            ctx.lineTo(sx + stripeW, panelY);
                            ctx.lineTo(sx + stripeW - panelH, panelY + panelH);
                            ctx.lineTo(sx - panelH, panelY + panelH);
                            ctx.closePath();
                            ctx.fill();
                        }
                        // Reflectors (top row small circles)
                        ctx.fillStyle = '#fffb9a';
                        for (let i=0;i<3;i++) {
                            ctx.beginPath();
                            ctx.arc(x + w*0.24 + i*w*0.20, panelY + panelH*0.18, w*0.04, 0, Math.PI*2);
                            ctx.fill();
                        }
                        // Shadow at base
                        ctx.fillStyle = 'rgba(0,0,0,0.25)';
                        ctx.fillRect(x + w*0.08, y + h*0.88, w*0.84, h*0.06);
                        // Outline panel
                        ctx.strokeStyle = '#6a6a6a';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x + w*0.12 + 0.5, panelY + 0.5, w*0.76 - 1, panelH - 1);
                        break;
                    }
                }
                ctx.restore();
            });

            // Poison cloud trail rendering (Silent But Deadly) - beneath enemies/projectiles for readability
            if (Array.isArray(game.poisonClouds) && game.poisonClouds.length) {
                game.poisonClouds.forEach(c => {
                    const p = c.life / c.maxLife; // 1 -> 0
                    const r = c.radius * (1 + (1-p)*0.15);
                    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r);
                    g.addColorStop(0, `rgba(120,255,150,${0.18 + 0.12*p})`);
                    g.addColorStop(0.5, `rgba(90,220,120,${0.12 + 0.10*p})`);
                    g.addColorStop(1, 'rgba(40,80,50,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, r, 0, Math.PI*2);
                    ctx.fill();
                    // Subtle swirling outline pulses
                    if (p > 0.25) {
                        ctx.save();
                        ctx.strokeStyle = `rgba(160,255,180,${0.08*p})`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6,12]);
                        ctx.lineDashOffset = (Date.now()/90 + c.x*0.2) % 18;
                        ctx.beginPath();
                        ctx.arc(c.x, c.y, r*0.7 + Math.sin(Date.now()/300 + c.y*0.05)*3, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }

            // Fragment Wake sparks (above ground effects but beneath main projectiles)
            if (Array.isArray(game.fragmentSparks) && game.fragmentSparks.length) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const now = Date.now();
                game.fragmentSparks.forEach(s => {
                    const lifeRatio = s.ttl / s.maxTtl; // 1 -> 0
                    const pulse = 0.55 + Math.sin(s.pulse)*0.45;
                    const radius = s.r * (0.7 + 0.6*pulse) * (0.6 + 0.4*lifeRatio);
                    const grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, radius);
                    grd.addColorStop(0, `rgba(255,210,140,${0.55 * lifeRatio})`);
                    grd.addColorStop(0.4, `rgba(255,140,60,${0.30 * lifeRatio})`);
                    grd.addColorStop(1, 'rgba(255,80,0,0)');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, radius, 0, Math.PI*2);
                    ctx.fill();
                    // Core spark flick
                    ctx.fillStyle = `rgba(255,240,200,${0.35 * lifeRatio})`;
                    ctx.beginPath();
                    ctx.arc(s.x + Math.sin(now/50 + s.x*0.1)*1.2, s.y + Math.cos(now/60 + s.y*0.1)*1.2, radius*0.25, 0, Math.PI*2);
                    ctx.fill();
                });
                ctx.restore();
            }

            // Vortex field rendering (beneath enemies for clarity, above ground effects)
            if (Array.isArray(game.vortexFields) && game.vortexFields.length) {
                const t = Date.now();
                game.vortexFields.forEach(f => {
                    const age = t - f.createdAt;
                    const lifeRatio = 1 - Math.min(1, age / f.duration);
                    const baseR = f.radius * (0.95 + Math.sin(t/260 + f.x*0.01 + f.spin)*0.05);
                    // Outer swirling gradient
                    const grad = ctx.createRadialGradient(f.x, f.y, f.innerRadius*0.3, f.x, f.y, baseR);
                    grad.addColorStop(0, `rgba(255,120,255,${0.30 * lifeRatio})`);
                    grad.addColorStop(0.55, `rgba(140,20,150,${0.22 * lifeRatio})`);
                    grad.addColorStop(1, 'rgba(60,0,70,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, baseR, 0, Math.PI*2);
                    ctx.fill();
                    // Rotating arc spokes
                    ctx.save();
                    ctx.translate(f.x, f.y);
                    ctx.rotate(f.spin);
                    const spokes = 6;
                    for (let s=0;s<spokes;s++) {
                        const a = (s/spokes)*Math.PI*2;
                        const len = baseR * 0.82;
                        const w = 5 + Math.sin(t/180 + s)*2;
                        ctx.strokeStyle = `rgba(255,180,255,${0.18 * lifeRatio})`;
                        ctx.lineWidth = w;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(a)*f.innerRadius*0.6, Math.sin(a)*f.innerRadius*0.6);
                        ctx.lineTo(Math.cos(a)*len, Math.sin(a)*len);
                        ctx.stroke();
                    }
                    ctx.restore();
                    // Inner core pulse
                    const coreR = f.innerRadius * (1 + Math.sin(t/140 + f.y*0.02)*0.25);
                    const cgrad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, coreR);
                    cgrad.addColorStop(0, `rgba(255,200,255,${0.55 * lifeRatio})`);
                    cgrad.addColorStop(1, 'rgba(255,200,255,0)');
                    ctx.fillStyle = cgrad;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, coreR, 0, Math.PI*2);
                    ctx.fill();
                });
            }

            // Echo Bloom resonance field rendering (beneath enemies, above vortex for contrast)
            if (Array.isArray(game.echoBloomFields) && game.echoBloomFields.length) {
                const nowT = Date.now();
                game.echoBloomFields.forEach(f => {
                    const age = nowT - f.createdAt;
                    const life = 1 - Math.min(1, age / f.duration);
                    const pulse = 0.5 + Math.sin(nowT/170 + f.x*0.05 + f.y*0.03)*0.5;
                    const radius = f.radius * (0.92 + pulse*0.08);
                    const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, radius);
                    g.addColorStop(0, `rgba(255,230,255,${0.40 * life})`);
                    g.addColorStop(0.45, `rgba(230,140,255,${0.18 * life})`);
                    g.addColorStop(1, 'rgba(160,60,200,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(f.x, f.y, radius, 0, Math.PI*2); ctx.fill();
                    // Subtle rotating petal spokes
                    ctx.save();
                    ctx.translate(f.x, f.y);
                    ctx.rotate(age/600);
                    const petals = 8;
                    for (let p=0;p<petals;p++) {
                        const a = (p/petals)*Math.PI*2;
                        const ir = radius*0.15; const or = radius*0.75;
                        ctx.strokeStyle = `rgba(255,200,255,${0.10 * life})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(a)*ir, Math.sin(a)*ir);
                        ctx.lineTo(Math.cos(a)*or, Math.sin(a)*or);
                        ctx.stroke();
                    }
                    ctx.restore();
                });
            }

            // Bloom Rings rendering (after Echo Bloom resonance so rings sit above fields but below lightning)
            if (Array.isArray(game.bloomRings) && game.bloomRings.length) {
                const nowBR = Date.now();
                game.bloomRings.forEach(rg => {
                    const age = nowBR - rg.createdAt;
                    const lifeRatio = 1 - Math.min(1, age / rg.maxLife);
                    const growthPhase = Math.min(1, rg.radius / rg.maxRadius);
                    const alpha = 0.65 * lifeRatio;
                    // Outer glow donut
                    const grad = ctx.createRadialGradient(rg.x, rg.y, Math.max(0, rg.radius - rg.width*0.65), rg.x, rg.y, rg.radius + rg.width*0.4);
                    grad.addColorStop(0, 'rgba(255,230,255,0)');
                    grad.addColorStop(0.55, `rgba(255,230,210,${alpha*0.18})`);
                    grad.addColorStop(0.82, `rgba(255,160,120,${alpha*0.55})`);
                    grad.addColorStop(1, 'rgba(255,120,60,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.radius + rg.width*0.4, 0, Math.PI*2);
                    ctx.fill();
                    // Core thin inner ring (charging telegraph fade out early)
                    if (!rg.detonated) {
                        const teleA = 0.35 + Math.sin(nowBR/140 + rg.x*0.02)*0.25;
                        ctx.strokeStyle = `rgba(255,240,240,${teleA})`;
                        ctx.lineWidth = 2 + Math.sin(nowBR/90)*1.5;
                        ctx.beginPath();
                        ctx.arc(rg.x, rg.y, 12 + Math.sin(nowBR/120)*3, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    // Ring edge (main visible band)
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = `rgba(255,200,160,${alpha * 0.85})`;
                    ctx.lineWidth = rg.width * (0.55 + Math.sin(nowBR/200 + rg.seed)*0.1);
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.radius, 0, Math.PI*2);
                    ctx.stroke();
                    // Rotating spokes for motion cue
                    ctx.translate(rg.x, rg.y);
                    ctx.rotate(age/600 + rg.seed);
                    const spokes = 4;
                    for (let s=0;s<spokes;s++) {
                        const ang = (s/spokes)*Math.PI*2;
                        ctx.strokeStyle = `rgba(255,200,180,${alpha*0.22})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(ang)*(rg.radius-rg.width*0.5), Math.sin(ang)*(rg.radius-rg.width*0.5));
                        ctx.lineTo(Math.cos(ang)*(rg.radius+rg.width*0.5), Math.sin(ang)*(rg.radius+rg.width*0.5));
                        ctx.stroke();
                    }
                    ctx.restore();
                });
            }

            // Lightning arcs rendering (after vortex so arcs sit on top of fields but beneath enemies for clarity)
            if (Array.isArray(game.lightningArcs) && game.lightningArcs.length) {
                for (let i = game.lightningArcs.length - 1; i >= 0; i--) {
                    const a = game.lightningArcs[i];
                    a.life--;
                    if (!a.points || a.points.length < 2) { game.lightningArcs.splice(i,1); continue; }
                    const fade = Math.max(0, a.life / a.maxLife);
                    // Glow pass
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = `rgba(255,255,180,${0.12 * fade})`;
                    ctx.lineWidth = 10;
                    ctx.beginPath();
                    ctx.moveTo(a.points[0].x, a.points[0].y);
                    for (let p=1;p<a.points.length;p++) ctx.lineTo(a.points[p].x, a.points[p].y);
                    ctx.stroke();
                    ctx.restore();
                    // Core stroke (slightly jagged each frame)
                    ctx.save();
                    ctx.strokeStyle = `rgba(255,255,120,${0.85 * fade})`;
                    ctx.lineWidth = 2 + 1*Math.random();
                    ctx.beginPath();
                    ctx.moveTo(a.points[0].x, a.points[0].y);
                    for (let p=1;p<a.points.length;p++) {
                        const pt = a.points[p];
                        // slight per-frame jitter for liveliness
                        const jx = (Math.random()-0.5) * 2;
                        const jy = (Math.random()-0.5) * 2;
                        ctx.lineTo(pt.x + jx, pt.y + jy);
                    }
                    ctx.stroke();
                    ctx.restore();
                    if (a.life <= 0) game.lightningArcs.splice(i,1);
                }
            }

            // Draw punji pits
            if (game.pits && game.pits.length) {
                game.pits.forEach(pit => {
                    const age = Date.now() - pit.created;
                    const fade = Math.max(0.15, 1 - age / pit.duration);
                    ctx.save();
                    ctx.translate(pit.x, pit.y);
                    const r = pit.radius;
                    // Ground base (dirt ring)
                    const baseGrad = ctx.createRadialGradient(0,0,r*0.2,0,0,r);
                    baseGrad.addColorStop(0,'rgba(90,60,30,'+(0.35*fade)+')');
                    baseGrad.addColorStop(1,'rgba(50,30,15,'+(0.55*fade)+')');
                    ctx.fillStyle = baseGrad;
                    ctx.beginPath();
                    ctx.arc(0,0,r,0,Math.PI*2);
                    ctx.fill();
                    // Inner trench shadow
                    ctx.fillStyle = 'rgba(0,0,0,'+(0.25*fade)+')';
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.55,0,Math.PI*2);
                    ctx.fill();
                    // Poison aura subtle (kept but softer to not clash with spikes)
                    const aura = ctx.createRadialGradient(0,0,r*0.15,0,0,r*0.85);
                    aura.addColorStop(0,'rgba(120,255,140,'+(0.18*fade)+')');
                    aura.addColorStop(1,'rgba(40,120,50,0)');
                    ctx.fillStyle = aura;
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.9,0,Math.PI*2);
                    ctx.fill();
                    // Spikes: vertical wooden stakes with darker tips
                    const spikesArr = pit.spikes || [];
                    spikesArr.forEach(sp => {
                        const sx = sp.x * r; // local space
                        const sy = sp.y * r;
                        const h = sp.h; // height in pixels
                        const baseW = 4 + (h*0.08); // width scales lightly with height
                        // Slight lean offset
                        const topOffsetX = sp.lean * h;
                        // Shaft
                        ctx.strokeStyle = '#6B4A2B';
                        ctx.lineWidth = baseW * 0.55;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(sx + topOffsetX, sy - h);
                        ctx.stroke();
                        // Wood fill (behind stroke for thickness): draw a narrow polygon
                        ctx.fillStyle = '#8B5E34';
                        ctx.beginPath();
                        ctx.moveTo(sx - baseW*0.35, sy);
                        ctx.lineTo(sx + baseW*0.35, sy);
                        ctx.lineTo(sx + topOffsetX + baseW*0.15, sy - h*0.94);
                        ctx.lineTo(sx + topOffsetX - baseW*0.15, sy - h*0.94);
                        ctx.closePath();
                        ctx.fill();
                        // Tip (darker, sharpened)
                        ctx.fillStyle = '#3A2412';
                        ctx.beginPath();
                        ctx.moveTo(sx + topOffsetX, sy - h);
                        ctx.lineTo(sx + topOffsetX + baseW*0.25, sy - h*0.88);
                        ctx.lineTo(sx + topOffsetX - baseW*0.25, sy - h*0.88);
                        ctx.closePath();
                        ctx.fill();
                        // Highlight edge (simple light stroke on one side)
                        ctx.strokeStyle = 'rgba(255,230,180,'+(0.35*fade)+')';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(sx + topOffsetX - baseW*0.1, sy - h*0.94);
                        ctx.lineTo(sx - baseW*0.25, sy);
                        ctx.stroke();
                    });
                    // Ambient poison motes (light, low density)
                    if (Math.random() < 0.15 * fade) {
                        addParticle(pit.x + (Math.random()-0.5)*r*1.2, pit.y + (Math.random()-0.5)*r*1.2, '#66FF66','poison');
                    }
                    ctx.restore();
                });
            }

            // Draw beartraps
            if (game.traps && game.traps.length) {
                game.traps.forEach(trap => {
                    const armed = !trap.triggered;
                    ctx.save();
                    ctx.translate(trap.x, trap.y);
                    // base circle
                    ctx.beginPath();
                    ctx.arc(0,0, armed ? 14 : 16, 0, Math.PI*2);
                    ctx.fillStyle = armed ? '#444' : '#772222';
                    ctx.fill();
                    // teeth
                    const teeth = 10;
                    ctx.strokeStyle = armed ? '#bbbbbb' : '#ffdddd';
                    ctx.lineWidth = 2;
                    for (let t=0;t<teeth;t++) {
                        const ang = (t/teeth)*Math.PI*2;
                        const r1 = armed ? 10 : 8;
                        const r2 = armed ? 14 : 16;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
                        ctx.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
                        ctx.stroke();
                    }
                    if (!armed) {
                        ctx.fillStyle = '#ff4444aa';
                        ctx.beginPath();
                        ctx.arc(0,0,8,0,Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                });
            }
            
            // Draw chests
            const now = performance.now();
            game.chests.forEach(chest => {
                if (!chest.opened) {
                    const cx = chest.x;
                    const cy = chest.y;
                    const r = 18;
                    const variant = chest.variant || 'gold';
                    // Proximity jiggle will modify lid vertical offset later; precompute distance to player
                    const dx = game.player.x - cx;
                    const dy = game.player.y - cy;
                    const dist = Math.hypot(dx, dy);
                    // Update jiggle phase
                    const near = dist < 130;
                    chest.jigglePhase = (chest.jigglePhase || 0) + (near ? 0.12 : 0.02);
                    const lidLift = (near ? Math.sin(chest.jigglePhase)*2.4 : Math.sin(chest.jigglePhase)*0.8);

                    // Variant colors
                    const variantSpecs = {
                        gold: { top:'#ffe680', mid:'#f7c846', bot:'#cfa02d', rib:'rgba(255,255,255,0.35)', glow:'rgba(255,223,90,', handle:'#cfa02d' },
                        platinum: { top:'#f2f2f2', mid:'#d9d9d9', bot:'#b0b0b0', rib:'rgba(255,255,255,0.55)', glow:'rgba(200,200,255,', handle:'#e0e0e0' },
                        rusty: { top:'#e8b270', mid:'#b96a33', bot:'#7a3f1c', rib:'rgba(255,220,180,0.25)', glow:'rgba(255,170,60,', handle:'#a85622' },
                        irradiated: { top:'#d2ff7a', mid:'#9bdf31', bot:'#5e8f18', rib:'rgba(255,255,255,0.30)', glow:'rgba(170,255,90,', handle:'#9bdf31' }
                    };
                    const spec = variantSpecs[variant] || variantSpecs.gold;
                    const grad = ctx.createLinearGradient(cx, cy - r, cx, cy + r);
                    grad.addColorStop(0, spec.top);
                    grad.addColorStop(0.4, spec.mid);
                    grad.addColorStop(1, spec.bot);
                    ctx.fillStyle = grad;
                    // Top ellipse (body top) hidden mostly under lid
                    ctx.beginPath();
                    ctx.ellipse(cx, cy - r*0.25, r*0.90, r*0.35, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Side wall
                    ctx.fillRect(cx - r*0.90, cy - r*0.25, r*1.80, r*1.10);
                    // Bottom ellipse
                    ctx.fillStyle = spec.bot;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + r*0.85, r*0.88, r*0.30, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Vertical ribs
                    ctx.strokeStyle = spec.rib;
                    ctx.lineWidth = 2;
                    for (let i=0;i<6;i++) {
                        const t = -r*0.70 + i*(r*1.40/5);
                        ctx.beginPath();
                        ctx.moveTo(cx + t*0.6, cy - r*0.20);
                        ctx.lineTo(cx + t*0.75, cy + r*0.78);
                        ctx.stroke();
                    }
                    // Lid (raised + jiggle)
                    const lidY = cy - r*0.40 - lidLift*0.4;
                    ctx.fillStyle = spec.top;
                    ctx.beginPath();
                    ctx.ellipse(cx, lidY, r*0.95, r*0.38, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = spec.bot;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(cx, lidY, r*0.95, r*0.38, 0, 0, Math.PI*2);
                    ctx.stroke();
                    // Handle arc
                    ctx.strokeStyle = spec.handle;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(cx, lidY - r*0.08, r*0.25, Math.PI*0.90, Math.PI*0.10, false);
                    ctx.stroke();
                    // Side handles
                    ctx.strokeStyle = spec.handle;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(cx - r*1.00, cy + r*0.10);
                    ctx.lineTo(cx - r*1.15, cy + r*0.00);
                    ctx.moveTo(cx + r*1.00, cy + r*0.10);
                    ctx.lineTo(cx + r*1.15, cy + r*0.00);
                    ctx.stroke();
                    // Orbiting sparkles (not for rusty; more for premium variants)
                    if (variant !== 'rusty') {
                        const sparkleCount = 6;
                        for (let i=0;i<sparkleCount;i++) {
                            const ang = (now*0.002 + i*(Math.PI*2/sparkleCount));
                            const sr = r*1.15;
                            const sx = cx + Math.cos(ang)*sr;
                            const sy = cy + Math.sin(ang)*sr*0.65; // ellipse orbit
                            const pulse = 0.5 + 0.5*Math.sin(now*0.005 + i);
                            ctx.globalAlpha = 0.6 * pulse;
                            ctx.fillStyle = variant === 'platinum' ? '#ffffff' : (variant === 'irradiated' ? '#d6ff88' : '#ffec8a');
                            ctx.beginPath();
                            ctx.moveTo(sx, sy - 3);
                            ctx.lineTo(sx + 3, sy);
                            ctx.lineTo(sx, sy + 3);
                            ctx.lineTo(sx - 3, sy);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    }
                    // Special glow / flicker
                    let alphaBase = 0.45;
                    if (variant === 'platinum') alphaBase = 0.55;
                    if (variant === 'rusty') alphaBase = 0.25;
                    if (variant === 'irradiated') alphaBase = 0.60 + Math.sin(now*0.008)*0.15;
                    const chestGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, r*1.6);
                    chestGlow.addColorStop(0, spec.glow + alphaBase + ')');
                    chestGlow.addColorStop(1, spec.glow + '0)');
                    ctx.fillStyle = chestGlow;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r*1.6, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            // Draw pickups (bread slices)
            if (game.pickups && game.pickups.length) {
                game.pickups.forEach(p => {
                    if (p.type === 'bread') {
                        const t = (performance.now() - p.spawnTime) / 1000;
                        const bob = Math.sin(t * 4) * 4;
                        const x = p.x;
                        const y = p.y + bob;
                        const w = 20, h = 20;
                        // Shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.25)';
                        ctx.beginPath(); ctx.ellipse(x, y + h*0.55, w*0.55, h*0.28, 0, 0, Math.PI*2); ctx.fill();
                        // Crust
                        ctx.fillStyle = '#b57533';
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(x - w/2, y - h/2, w, h, 4) : ctx.rect(x - w/2, y - h/2, w, h);
                        ctx.fill();
                        // Crumb interior slightly inset
                        ctx.fillStyle = '#f4e2b6';
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(x - w/2 + 2, y - h/2 + 2, w - 4, h - 6, 3) : ctx.rect(x - w/2 + 2, y - h/2 + 2, w - 4, h - 6);
                        ctx.fill();
                        // Random seed specks (deterministic-ish per spawn)
                        const seedCount = 4;
                        for (let i=0;i<seedCount;i++) {
                            const sx = x - w/2 + 4 + (i * (w-8)/(seedCount-1));
                            const sy = y - 2 + ((i*31)%5) - 2;
                            ctx.fillStyle = '#d9c190';
                            ctx.fillRect(sx, sy, 2, 2);
                        }
                        // Light highlight
                        ctx.strokeStyle = '#ffffff66';
                        ctx.beginPath();
                        ctx.moveTo(x - w/2 + 4, y - h/2 + 4);
                        ctx.lineTo(x + w/2 - 4, y - h/2 + 4);
                        ctx.stroke();
                    }
                });
            }
            
            // Draw particles
            game.particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                
                switch (particle.type) {
                    case 'explosion':
                    case 'fire':
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'feather': {
                        // Draw a slim rotated feather (white) with subtle tip fade
                        const s = (particle.scale || 1) * 4.0; // base length
                        const w = s * 0.35;
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.spin || 0);
                        const grad = ctx.createLinearGradient(0, -s/2, 0, s/2);
                        grad.addColorStop(0, 'rgba(255,255,255,' + (particle.alpha*0.2).toFixed(3) + ')');
                        grad.addColorStop(0.3, 'rgba(255,255,255,' + (particle.alpha*0.85).toFixed(3) + ')');
                        grad.addColorStop(1, 'rgba(255,255,255,' + (particle.alpha*0.05).toFixed(3) + ')');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.ellipse(0,0, w, s, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Center spine
                        ctx.strokeStyle = 'rgba(255,255,255,' + (particle.alpha*0.55).toFixed(3) + ')';
                        ctx.lineWidth = Math.max(0.6, w*0.22);
                        ctx.beginPath();
                        ctx.moveTo(0, -s*0.48);
                        ctx.lineTo(0, s*0.48);
                        ctx.stroke();
                        // Small barb hints
                        ctx.lineWidth = Math.max(0.4, w*0.12);
                        ctx.beginPath();
                        ctx.moveTo(0, -s*0.20); ctx.lineTo(w*0.8, -s*0.05);
                        ctx.moveTo(0, s*0.05); ctx.lineTo(-w*0.8, s*0.20);
                        ctx.stroke();
                        break;
                    }
                    case 'spark':
                    case 'lightning':
                        ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                        break;
                    case 'heal':
                        ctx.font = '12px Arial';
                        ctx.fillText('+', particle.x, particle.y);
                        break;
                    case 'treasure':
                        ctx.font = '8px Arial';
                        ctx.fillText('★', particle.x, particle.y);
                        break;
                    case 'shield':
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'damage':
                        ctx.font = '10px Arial';
                        ctx.fillText('!', particle.x, particle.y);
                        break;
                    case 'victory':
                        ctx.font = '14px Arial';
                        ctx.fillText('✓', particle.x, particle.y);
                        break;
                    default:
                        ctx.fillRect(particle.x - 1, particle.y - 1, 2, 2);
                }
                ctx.restore();
            });
            
            // Duck Dynasty flock rendering (beneath projectile layer, above ground telegraphs)
            if (Array.isArray(game.duckFlocks) && game.duckFlocks.length) {
                game.duckFlocks.forEach(d => {
                    if (d.x == null || d.y == null) return;
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    // Orientation based on instantaneous motion (approx using last two positions if cached)
                    if (!d._lx) { d._lx = d.x; d._ly = d.y; }
                    const mvx = d.x - d._lx; const mvy = d.y - d._ly;
                    d._lx = d.x; d._ly = d.y;
                    const ang = Math.atan2(mvy, mvx);
                    ctx.rotate(ang);
                    const bodyR = d.size * 0.5;
                    // Body ellipse
                    const g = ctx.createLinearGradient(-bodyR,0,bodyR,0);
                    g.addColorStop(0,(d.color||'#FFE8AA')+'AA');
                    g.addColorStop(1,(d.color||'#FFE8AA'));
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.ellipse(0,0, bodyR, bodyR*0.55, 0,0,Math.PI*2); ctx.fill();
                    // Head
                    ctx.fillStyle = d.color||'#FFE8AA';
                    ctx.beginPath(); ctx.ellipse(bodyR*0.95, -bodyR*0.15, bodyR*0.38, bodyR*0.34, 0,0,Math.PI*2); ctx.fill();
                    // Beak
                    ctx.fillStyle = '#FFB243';
                    ctx.beginPath(); ctx.moveTo(bodyR*1.25,-bodyR*0.12); ctx.lineTo(bodyR*1.55,0); ctx.lineTo(bodyR*1.25, bodyR*0.12); ctx.closePath(); ctx.fill();
                    // Wings out (static spread + slight undulation)
                    const flap = Math.sin((d.wingPhase||0)*0.8) * 0.25;
                    const wingSpan = bodyR * 1.9;
                    ctx.fillStyle = (d.color||'#FFE8AA')+'BB';
                    // Left wing
                    ctx.save(); ctx.rotate(-0.25 + flap);
                    ctx.beginPath(); ctx.ellipse(-bodyR*0.2,0, wingSpan*0.55, wingSpan*0.22, 0,0,Math.PI*2); ctx.fill(); ctx.restore();
                    // Right wing
                    ctx.save(); ctx.rotate(0.25 - flap);
                    ctx.beginPath(); ctx.ellipse(-bodyR*0.2,0, wingSpan*0.55, wingSpan*0.22, 0,0,Math.PI*2); ctx.fill(); ctx.restore();
                    // Tail accent
                    ctx.fillStyle = (d.color||'#FFE8AA')+'AA';
                    ctx.beginPath(); ctx.moveTo(-bodyR*0.9, -bodyR*0.15); ctx.lineTo(-bodyR*0.9, bodyR*0.15); ctx.lineTo(-bodyR*0.55, 0); ctx.closePath(); ctx.fill();
                    ctx.restore();
                });
            }
            
            // Nuke pre-impact telegraphs (draw beneath enemies & player for clarity)
            if (Array.isArray(game.nukes) && game.nukes.length) {
                const now = Date.now();
                game.nukes.forEach(n => {
                    if (!n || n.exploded) return; // only telegraph pending strikes
                    const totalWarn = n.impactAt - n.spawnAt;
                    const remaining = Math.max(0, n.impactAt - now);
                    const t = remaining / totalWarn; // 1 -> 0
                    const pulse = 1 + Math.sin(now/120 + n.x*0.05) * 0.05;
                    const radius = n.radius * pulse;
                    // Soft fill glow
                    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, radius);
                    g.addColorStop(0, 'rgba(255,180,40,0.10)');
                    g.addColorStop(0.65, 'rgba(255,120,0,0.08)');
                    g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, radius, 0, Math.PI*2);
                    ctx.fill();
                    // Outer warning ring (animated dash)
                    ctx.save();
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10,8]);
                    const dashOffset = (now/40) % 18;
                    ctx.lineDashOffset = -dashOffset;
                    ctx.strokeStyle = `rgba(${Math.round(255*(1-t))}, ${Math.round(200*t)}, 40, 0.85)`; // shifts to red
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.radius, 0, Math.PI*2);
                    ctx.stroke();
                    // Countdown shrinking inner ring
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, Math.max(6, n.radius * t), 0, Math.PI*2);
                    ctx.stroke();
                    // Crosshair lines
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = 'rgba(255,220,120,0.5)';
                    ctx.beginPath();
                    ctx.moveTo(n.x - n.radius, n.y);
                    ctx.lineTo(n.x + n.radius, n.y);
                    ctx.moveTo(n.x, n.y - n.radius);
                    ctx.lineTo(n.x, n.y + n.radius);
                    ctx.stroke();
                    ctx.restore();
                    // Time text
                    const secs = (remaining/1000).toFixed(2);
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.fillText(secs, n.x, n.y + 6);
                });
            }

            // Meteor impact telegraph markers (appear where meteor will land)
            if (Array.isArray(game.meteorMarkers) && game.meteorMarkers.length) {
                for (let i = game.meteorMarkers.length - 1; i >= 0; i--) {
                    const m = game.meteorMarkers[i];
                    // Convert legacy ms life to frame-based if needed
                    if (!m._initFrameLife) {
                        // If marker provided 'life' as ms ( > 300 ), translate to frames (~60fps)
                        if (m.life && m.life > 300) {
                            m.maxLife = Math.floor((m.life / 1000) * 60);
                        } else {
                            m.maxLife = m.life || 220;
                        }
                        m.life = m.maxLife;
                        m._initFrameLife = true;
                    }
                    // If created timestamp exists and exceeds original requested lifespan (1600ms default), flag dead
                    if (m.created && Date.now() - m.created > 1800) {
                        m.dead = true;
                    }
                    m.life = (typeof m.life === 'number') ? m.life - 1 : (m.maxLife||220) - 1;
                    m.pulse = (m.pulse || 0) + 1;
                    if (m.dead || m.life <= 0) { game.meteorMarkers.splice(i,1); continue; }
                    const t = 1 - (m.life / m.maxLife); // 0 -> 1
                    const baseAlpha = 0.55 * (1 - t);
                    const pulseA = 0.35 + 0.25*Math.sin(m.pulse/6);
                    const alpha = Math.max(0, Math.min(1, baseAlpha + pulseA*(1-t)));
                    const r = 26 + 24 * t; // ring expands slightly
                    const lineW = 3 + 2*Math.sin(m.pulse/5);
                    ctx.save();
                    ctx.translate(m.x, m.y);
                    // shadow / scorch oval (beneath ring)
                    ctx.globalAlpha = 0.35 * (1 - t);
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(0,0,r*1.15,r*0.55,0,0,Math.PI*2);
                    ctx.fill();
                    // main warning ring
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = (m.enemyTarget) ? '#ff8240' : '#ffcf40';
                    ctx.lineWidth = lineW;
                    ctx.beginPath();
                    ctx.ellipse(0,0,r,r*0.65,0,0,Math.PI*2);
                    ctx.stroke();
                    // inner hot core
                    const innerR = r*0.35 + 4*Math.sin(m.pulse/7);
                    ctx.globalAlpha = 0.35 + 0.25*Math.sin(m.pulse/4);
                    ctx.fillStyle = '#ffef9c';
                    ctx.beginPath();
                    ctx.ellipse(0,0,innerR,innerR*0.65,0,0,Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Photon strike beams (rendered after telegraphs, before enemies/projectiles overlays)
            if (Array.isArray(game.photonStrikes) && game.photonStrikes.length) {
                for (let i = game.photonStrikes.length - 1; i >= 0; i--) {
                    const s = game.photonStrikes[i];
                    s.life--;
                    if (s.life <= 0) { game.photonStrikes.splice(i,1); continue; }
                    const alpha = s.life / 24;
                    const grad = ctx.createLinearGradient(s.x1, s.y1, s.x2, s.y2);
                    grad.addColorStop(0, 'rgba(120,200,255,'+(alpha*0.35)+')');
                    grad.addColorStop(0.5, 'rgba(255,255,255,'+(alpha*0.9)+')');
                    grad.addColorStop(1, 'rgba(120,200,255,'+(alpha*0.35)+')');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.lineWidth = 4 + 3 * alpha;
                    ctx.strokeStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(s.x1, s.y1);
                    ctx.lineTo(s.x2, s.y2);
                    ctx.stroke();
                    // Impact flash orb
                    ctx.globalAlpha = alpha * 0.85;
                    ctx.fillStyle = 'rgba(255,255,255,'+(alpha*0.6)+')';
                    ctx.beginPath();
                    ctx.arc(s.x2, s.y2, (s.impactSize||30) * (0.6 + 0.4*alpha), 0, Math.PI*2);
                    ctx.fill();
                    // Subtle core
                    ctx.fillStyle = 'rgba(200,255,255,'+(alpha*0.8)+')';
                    ctx.beginPath();
                    ctx.arc(s.x2, s.y2, Math.max(6, (s.impactSize||30)*0.3*alpha), 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
                if (game.photonStrikes.length > 40) game.photonStrikes.length = 40; // defensive cap
            }

            // Traveling Shockwaves (Shockwave ability) - draw BEFORE enemies/projectiles so they appear on ground
            if (Array.isArray(game.shockwaves) && game.shockwaves.length) {
                game.shockwaves.forEach(w => {
                    const lifePct = w.life / w.maxLife; // 1 -> 0
                    const ax = Math.cos(w.angle), ay = Math.sin(w.angle);
                    const startDist = Math.max(0, w.distance - w.length);
                    const endDist = w.distance;
                    const startX = w.x + ax * startDist;
                    const startY = w.y + ay * startDist;
                    const endX = w.x + ax * endDist;
                    const endY = w.y + ay * endDist;
                    const width = w.width * (0.85 + 0.25*Math.sin((w.maxLife - w.life)/3));
                    const halfW = width * 0.5;
                    // Perp vector
                    const px = -ay, py = ax;
                    const fade = 0.55 * lifePct + 0.15*Math.sin(Date.now()/160 + w.x*0.03);
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, fade);
                    const grad = ctx.createLinearGradient(startX, startY, endX, endY);
                    grad.addColorStop(0, 'rgba(180,200,255,0)');
                    grad.addColorStop(0.15, 'rgba(160,190,255,0.25)');
                    grad.addColorStop(0.55, 'rgba(140,170,255,0.35)');
                    grad.addColorStop(1, 'rgba(110,140,220,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(startX + px*halfW, startY + py*halfW);
                    ctx.lineTo(endX + px*halfW, endY + py*halfW);
                    ctx.lineTo(endX - px*halfW, endY - py*halfW);
                    ctx.lineTo(startX - px*halfW, startY - py*halfW);
                    ctx.closePath();
                    ctx.fill();
                    // Edge highlights
                    ctx.globalAlpha = fade * 0.9;
                    ctx.strokeStyle = 'rgba(200,220,255,0.55)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(startX + px*halfW, startY + py*halfW);
                    ctx.lineTo(endX + px*halfW, endY + py*halfW);
                    ctx.moveTo(startX - px*halfW, startY - py*halfW);
                    ctx.lineTo(endX - px*halfW, endY - py*halfW);
                    ctx.stroke();
                    // Front impact arc (slightly rounded tip)
                    ctx.globalAlpha = fade * 0.75;
                    const tipR = Math.min(40, halfW * 0.8);
                    const tipGrad = ctx.createRadialGradient(endX, endY, tipR*0.15, endX, endY, tipR);
                    tipGrad.addColorStop(0,'rgba(255,255,255,0.55)');
                    tipGrad.addColorStop(1,'rgba(150,180,255,0)');
                    ctx.fillStyle = tipGrad;
                    ctx.beginPath();
                    ctx.arc(endX, endY, tipR, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                });
            }
            
            // Draw enemies (restored original logic)
            game.enemies.forEach(enemy => {
                let baseColor = enemy.color;
                if (enemy.poisoned && enemy.burning) {
                    baseColor = '#8B4B00';
                } else if (enemy.poisoned && enemy.slowed) {
                    baseColor = '#4B6040';
                } else if (enemy.burning && enemy.slowed) {
                    baseColor = '#8B0080';
                } else if (enemy.poisoned) {
                    baseColor = '#4B8040';
                } else if (enemy.burning) {
                    baseColor = '#FF4040';
                } else if (enemy.slowed) {
                    baseColor = '#4040BB';
                }
                // Duck-style enemy drawing helper (lightweight, with fallback or sprite override)
                const drawDuckEnemy = (ctx, enemy, tintColor) => {
                    try {
                        // Thug sprite override
                        if (enemy.type === 'Thug' && game.enemySprites && game.enemySprites.thug && game.enemySprites.thug.loaded) {
                            const ts = game.enemySprites.thug;
                            const frameSet = ts.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ts.image;
                            const size = enemy.size; // existing radius-like metric
                            const scale = ts.baseScaleForSize ? ts.baseScaleForSize(size) : ( (size*2) / (box ? box.h : 1) );
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save();
                                ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) {
                                        ctx.scale(-1,1);
                                        ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    } else {
                                        ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) {
                                    ctx.strokeStyle = 'rgba(0,255,0,0.6)';
                                    ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH);
                                }
                                ctx.restore();
                                return; // skip procedural drawing
                            }
                        }
                        // Street Dog sprite override
                        if (enemy.type === 'Street Dog' && game.enemySprites && game.enemySprites.streetDog && game.enemySprites.streetDog.loaded) {
                            const ds = game.enemySprites.streetDog;
                            const frameSet = ds.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ds.image;
                            const size = enemy.size;
                            const scale = ds.baseScaleForSize ? ds.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,200,255,0.6)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Punk sprite override
                        if (enemy.type === 'Punk' && game.enemySprites && game.enemySprites.punk && game.enemySprites.punk.loaded) {
                            const ps = game.enemySprites.punk;
                            const frameSet = ps.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ps.image;
                            const size = enemy.size;
                            const scale = ps.baseScaleForSize ? ps.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,0,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Dealer sprite override
                        if (enemy.type === 'Dealer' && game.enemySprites && game.enemySprites.dealer && game.enemySprites.dealer.loaded) {
                            const ds = game.enemySprites.dealer;
                            const frameSet = ds.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ds.image;
                            const size = enemy.size;
                            const scale = ds.baseScaleForSize ? ds.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,255,0,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Gangster sprite override
                        if (enemy.type === 'Gangster' && game.enemySprites && game.enemySprites.gangster && game.enemySprites.gangster.loaded) {
                            const gs = game.enemySprites.gangster;
                            const frameSet = gs.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = gs.image;
                            const size = enemy.size;
                            const scale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,255,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Enforcer sprite override
                        if (enemy.type === 'Enforcer' && game.enemySprites && game.enemySprites.enforcer && game.enemySprites.enforcer.loaded) {
                            const es = game.enemySprites.enforcer;
                            const frameSet = es.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = es.image;
                            const size = enemy.size;
                            const scale = es.baseScaleForSize ? es.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,128,0,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Boss Thug sprite override
                        if (enemy.type === 'Boss Thug' && game.enemySprites && game.enemySprites.bossThug && game.enemySprites.bossThug.loaded) {
                            const bs = game.enemySprites.bossThug;
                            const frameSet = bs.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = bs.image;
                            const size = enemy.size;
                            const scale = bs.baseScaleForSize ? bs.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(170,90,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Boss Gangster sprite override
                        if (enemy.type === 'Boss Gangster' && game.enemySprites && game.enemySprites.bossGangster && game.enemySprites.bossGangster.loaded) {
                            const gs = game.enemySprites.bossGangster;
                            const frameSet = gs.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = gs.image;
                            const size = enemy.size;
                            const scale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(90,170,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // The Big Quack final boss sprite override
                        if (enemy.type === 'The Big Quack' && game.enemySprites && game.enemySprites.bigQuack && game.enemySprites.bigQuack.loaded) {
                            const bq = game.enemySprites.bigQuack;
                            const frameSet = bq.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = bq.image;
                            const size = enemy.size;
                            const scale = bq.baseScaleForSize ? bq.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,80,80,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Cache style palette per type on the function to avoid re-allocation
                        if (!drawDuckEnemy._styles) {
                            drawDuckEnemy._styles = {
                                'Thug': { body:'#6b4d2e', head:'#765633', beak:'#d08c00', wing:'#5a3f25' },
                                'Gangster': { body:'#2d2d2d', head:'#383838', beak:'#d08c00', wing:'#1f1f1f', hat:'#000000' },
                                'Street Dog': { body:'#704214', head:'#804c19', beak:'#c07000', wing:'#5a3410', ears:true },
                                'Punk': { body:'#91298f', head:'#a936a7', beak:'#ffb000', wing:'#762177', mohawk:true },
                                'Dealer': { body:'#2a6b2a', head:'#2f7a2f', beak:'#d08c00', wing:'#1e4d1e', stripe:'#ffff66' },
                                'Enforcer': { body:'#7c0a02', head:'#8f1208', beak:'#ff9c00', wing:'#5a0601', pads:true },
                                'Boss Thug': { body:'#4a2c85', head:'#533296', beak:'#ffb000', wing:'#392063', crown:true },
                                'Boss Gangster': { body:'#1c1c1c', head:'#262626', beak:'#d08c00', wing:'#131313', hat:'#000000', pinstripe:true },
                                'The Big Quack': { body:'#050505', head:'#0a0a0a', beak:'#e0a800', wing:'#050505', hat:'#000000', pinstripe:true, overfedora:true }
                            };
                        }
                        const style = drawDuckEnemy._styles[enemy.type] || {};
                        const bodyColor = tintColor || style.body || enemy.color || '#888888';
                        const headColor = style.head || bodyColor;
                        const beakColor = style.beak || '#d08c00';
                        const wingColor = style.wing || bodyColor;

                        // Left/right facing only: determine horizontal facing
                        const faceLeft = game.player.x < enemy.x;
                        const s = enemy.size; // base scale reference

                        ctx.save();
                        ctx.translate(enemy.x, enemy.y);
                        // Visual cue if blinded: golden halo + slight dim of body
                        if (enemy.blinded) {
                            const pulse = 0.6 + 0.4*Math.sin(performance.now()/180 + enemy.x*0.02);
                            ctx.globalAlpha = 0.55 * pulse;
                            ctx.fillStyle = '#FFEFA5';
                            ctx.beginPath();
                            ctx.ellipse(0, enemy.size*0.15, enemy.size*0.9, enemy.size*0.45, 0, 0, Math.PI*2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        if (enemy.blinded) {
                            ctx.filter = 'brightness(0.85)';
                        }
                        if (faceLeft) {
                            ctx.scale(-1, 1); // mirror horizontally
                        }

                        // Body (ellipse)
                        ctx.fillStyle = bodyColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.05, 0, s*0.55, s*0.38, 0, 0, Math.PI*2);
                        ctx.fill();

                        // Trenchcoat (wrapped) — sculpted shape hugging body with flare and collar
                        const coatColor = '#3f2c1b';
                        const coatShadow = '#281a10';
                        const coatHighlight = '#705030';
                        // Adjusted for full body coverage
                        const coatTopY = -s*0.28; // raised under beak
                        const coatBottomY = s*0.62; // lowered to cover lower ellipse
                        const coatHalf = s*0.60; // wider wrap to exceed body ellipse width
                        ctx.fillStyle = coatColor;
                        ctx.beginPath();
                        // Top curve (collar base)
                        ctx.moveTo(-coatHalf*0.90, coatTopY + s*0.05);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatTopY - s*0.10, 0, coatTopY - s*0.08);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatTopY - s*0.10, coatHalf*0.90, coatTopY + s*0.05);
                        // Side down (left)
                        ctx.lineTo(coatHalf*0.68, coatBottomY - s*0.06);
                        // Bottom flare waves (extended)
                        ctx.quadraticCurveTo(coatHalf*0.25, coatBottomY + s*0.14, 0, coatBottomY + s*0.06);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatBottomY + s*0.14, -coatHalf*0.68, coatBottomY - s*0.06);
                        // Close along left side
                        ctx.closePath();
                        ctx.fill();
                        // Collar & lapels overlay
                        ctx.fillStyle = coatHighlight;
                        ctx.beginPath();
                        ctx.moveTo(-coatHalf*0.55, coatTopY + s*0.04);
                        ctx.lineTo(-coatHalf*0.20, coatTopY + s*0.36);
                        ctx.lineTo(-coatHalf*0.06, coatTopY + s*0.04);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(coatHalf*0.55, coatTopY + s*0.04);
                        ctx.lineTo(coatHalf*0.20, coatTopY + s*0.36);
                        ctx.lineTo(coatHalf*0.06, coatTopY + s*0.04);
                        ctx.closePath();
                        ctx.fill();
                        // Inner shadow (gradient simulation via semi-transparent stroke)
                        ctx.strokeStyle = coatShadow + 'aa';
                        ctx.lineWidth = Math.max(1, s*0.06);
                        ctx.beginPath();
                        ctx.moveTo(0, coatTopY - s*0.06);
                        ctx.lineTo(0, coatBottomY);
                        ctx.stroke();
                        // Buttons (shifted slightly right for wrap illusion)
                        ctx.fillStyle = '#cfae72';
                        for (let i=0;i<4;i++) {
                            ctx.beginPath();
                            ctx.arc(s*0.07, coatTopY + s*(0.18 + i*0.20), s*0.038, 0, Math.PI*2);
                            ctx.fill();
                        }
                        // Belt suggestion (two small horizontal strokes)
                        ctx.strokeStyle = coatShadow;
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.beginPath();
                        ctx.moveTo(-s*0.32, coatTopY + s*0.54);
                        ctx.lineTo(s*0.32, coatTopY + s*0.54);
                        ctx.moveTo(-s*0.32, coatTopY + s*0.57);
                        ctx.lineTo(s*0.20, coatTopY + s*0.57);
                        ctx.stroke();
                        // Wing aperture (eroded area) + sleeve cap
                        ctx.save();
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.beginPath();
                        ctx.ellipse(-s*0.20, 0, s*0.24, s*0.20, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                        ctx.fillStyle = coatColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.20, -s*0.02, s*0.22, s*0.18, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Subtle outline
                        ctx.strokeStyle = '#00000044';
                        ctx.lineWidth = Math.max(1, s*0.025);
                        ctx.beginPath();
                        ctx.moveTo(-coatHalf*0.90, coatTopY + s*0.05);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatTopY - s*0.10, 0, coatTopY - s*0.08);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatTopY - s*0.10, coatHalf*0.90, coatTopY + s*0.05);
                        ctx.lineTo(coatHalf*0.68, coatBottomY - s*0.06);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatBottomY + s*0.14, 0, coatBottomY + s*0.06);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatBottomY + s*0.14, -coatHalf*0.68, coatBottomY - s*0.06);
                        ctx.closePath();
                        ctx.stroke();
                        // Wing (simple arc) drawn after coat so it appears on top/side
                        ctx.fillStyle = wingColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.15, 0, s*0.30, s*0.22, Math.PI/6, Math.PI*0.15, Math.PI*1.15);
                        ctx.fill();

                        // Head
                        ctx.fillStyle = headColor;
                        ctx.beginPath();
                        ctx.arc(s*0.42, -s*0.15, s*0.28, 0, Math.PI*2);
                        ctx.fill();

                        // Beak
                        ctx.fillStyle = beakColor;
                        ctx.beginPath();
                        ctx.moveTo(s*0.62, -s*0.10);
                        ctx.lineTo(s*0.90, -s*0.05);
                        ctx.lineTo(s*0.62,  -s*0.00);
                        ctx.closePath();
                        ctx.fill();

                        // Eye
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(s*0.50, -s*0.22, s*0.07, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(s*0.515, -s*0.22, s*0.03, 0, Math.PI*2);
                        ctx.fill();

                        // Weapon (before hat so it sits below hat brim visually)
                        // Decide melee vs ranged using enemy.ranged flag
                        if (enemy.ranged) {
                            // Gun lowered to body line (emerges from wing/coat front)
                            const gunBaseX = s*0.42; // forward in facing direction
                            const gunBaseY = s*0.18; // lowered
                            ctx.save();
                            ctx.translate(gunBaseX, gunBaseY);
                            ctx.rotate(-0.08); // slight downward-forward angle
                            ctx.fillStyle = '#2b2b2b';
                            // Body
                            ctx.fillRect(0, -s*0.07, s*0.40, s*0.12);
                            // Barrel
                            ctx.fillRect(s*0.40, -s*0.045, s*0.30, s*0.055);
                            // Front sight
                            ctx.fillRect(s*0.68, -s*0.055, s*0.04, s*0.02);
                            // Grip
                            ctx.fillStyle = '#3d3d3d';
                            ctx.fillRect(s*0.08, s*0.02, s*0.14, s*0.20);
                            // Highlight line
                            ctx.strokeStyle = '#ffffff22';
                            ctx.lineWidth = Math.max(1, s*0.015);
                            ctx.beginPath();
                            ctx.moveTo(s*0.02, -s*0.035);
                            ctx.lineTo(s*0.36, -s*0.035);
                            ctx.stroke();
                            ctx.restore();
                        } else {
                            // Knife lowered to appear held at body level
                            const knifeBaseX = s*0.36;
                            const knifeBaseY = s*0.20;
                            ctx.save();
                            ctx.translate(knifeBaseX, knifeBaseY);
                            ctx.rotate(-0.12);
                            // Handle
                            ctx.fillStyle = '#3a2412';
                            ctx.fillRect(-s*0.05, -s*0.035, s*0.12, s*0.10);
                            // Guard
                            ctx.fillStyle = '#cfae72';
                            ctx.fillRect(s*0.02, -s*0.045, s*0.07, s*0.032);
                            // Blade
                            ctx.fillStyle = '#c8d0d5';
                            ctx.beginPath();
                            ctx.moveTo(s*0.06, -s*0.04);
                            ctx.lineTo(s*0.40, -s*0.012);
                            ctx.lineTo(s*0.06,  s*0.018);
                            ctx.closePath();
                            ctx.fill();
                            // Edge highlight
                            ctx.strokeStyle = '#ffffff55';
                            ctx.lineWidth = Math.max(1, s*0.015);
                            ctx.beginPath();
                            ctx.moveTo(s*0.08, -s*0.030);
                            ctx.lineTo(s*0.36, -s*0.010);
                            ctx.stroke();
                            ctx.restore();
                        }

                        // Type-specific accents
                        // Universal fedora (gangster look)
                        // Fedora: dynamic palette (black for gangster variants)
                        const isBossGang = enemy.type === 'Boss Gangster' || enemy.type === 'The Big Quack' || enemy.type === 'Gangster';
                        const hatBrimColor = isBossGang ? '#000000' : '#5a3b19';
                        const hatCrownColor = isBossGang ? '#111111' : '#6d4722';
                        const hatBandColor = isBossGang ? '#222222' : '#3a2613';
                        const highlightColor = '#ffffff18';
                        // Slightly larger brim
                        const brimWidth = s*0.50;
                        const brimHeight = s*0.085;
                        const brimX = s*0.18;
                        const brimY = -s*0.44;
                        ctx.fillStyle = hatBrimColor;
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(brimX, brimY, brimWidth, brimHeight, brimHeight*0.4) : ctx.fillRect(brimX, brimY, brimWidth, brimHeight);
                        ctx.fill();
                        // Crown (tapered)
                        const crownBaseWidth = s*0.30;
                        const crownTopWidth = crownBaseWidth * 0.70; // taper
                        const crownHeight = s*0.26;
                        const crownBaseX = brimX + (brimWidth - crownBaseWidth)/2;
                        const crownTopX = crownBaseX + (crownBaseWidth - crownTopWidth)/2;
                        const crownBottomY = brimY - s*0.01;
                        const crownTopY = crownBottomY - crownHeight;
                        ctx.fillStyle = hatCrownColor;
                        ctx.beginPath();
                        ctx.moveTo(crownBaseX, crownBottomY);
                        ctx.lineTo(crownBaseX + crownBaseWidth, crownBottomY);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY);
                        ctx.lineTo(crownTopX, crownTopY);
                        ctx.closePath();
                        ctx.fill();
                        // Band wraps around lower third
                        const bandHeight = crownHeight * 0.22;
                        const bandY = crownBottomY - bandHeight - crownHeight*0.18;
                        ctx.fillStyle = hatBandColor;
                        ctx.fillRect(crownBaseX, bandY, crownBaseWidth, bandHeight);
                        // Highlight along top ridge
                        ctx.strokeStyle = highlightColor;
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.beginPath();
                        ctx.moveTo(crownTopX, crownTopY + s*0.01);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY + s*0.01);
                        ctx.stroke();
                        // Outline
                        ctx.strokeStyle = isBossGang ? '#00000088' : '#2b1b0d88';
                        ctx.lineWidth = Math.max(1, s*0.035);
                        ctx.beginPath();
                        ctx.moveTo(crownBaseX, crownBottomY);
                        ctx.lineTo(crownBaseX + crownBaseWidth, crownBottomY);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY);
                        ctx.lineTo(crownTopX, crownTopY);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.strokeStyle = isBossGang ? '#00000066' : '#2b1b0d66';
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.strokeRect(brimX, brimY, brimWidth, brimHeight);
                        // Pinstripes for suit (body area) on boss gangster & big quack
                        if (style.pinstripe) {
                            ctx.save();
                            ctx.translate(0,0);
                            ctx.strokeStyle = enemy.type === 'The Big Quack' ? '#44444488' : '#555555AA';
                            ctx.lineWidth = Math.max(1, s*0.01);
                            for (let ps=-s*0.55; ps<=s*0.55; ps+= s*0.12) {
                                ctx.beginPath();
                                ctx.moveTo(ps, -s*0.30);
                                ctx.lineTo(ps, s*0.55);
                                ctx.stroke();
                            }
                            ctx.restore();
                        }
                        if (style.overfedora) {
                            // Add a subtle wider shadow under brim to emphasize scale
                            ctx.save();
                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = '#000000';
                            ctx.beginPath();
                            ctx.ellipse(brimX + brimWidth/2, brimY + brimHeight*0.65, brimWidth*0.65, brimHeight*0.9, 0, 0, Math.PI*2);
                            ctx.fill();
                            ctx.restore();
                        }
                        if (style.mohawk) {
                            ctx.fillStyle = '#ff00ff';
                            ctx.beginPath();
                            ctx.moveTo(s*0.38, -s*0.42);
                            ctx.lineTo(s*0.44, -s*0.60);
                            ctx.lineTo(s*0.50, -s*0.42);
                            ctx.closePath();
                            ctx.fill();
                        }
                        if (style.ears) {
                            ctx.fillStyle = headColor;
                            ctx.beginPath();
                            ctx.arc(s*0.30, -s*0.34, s*0.08, 0, Math.PI*2);
                            ctx.arc(s*0.54, -s*0.34, s*0.08, 0, Math.PI*2);
                            ctx.fill();
                        }
                        if (style.stripe) {
                            ctx.strokeStyle = style.stripe;
                            ctx.lineWidth = Math.max(2, s*0.08);
                            ctx.beginPath();
                            ctx.moveTo(-s*0.55, -s*0.10);
                            ctx.lineTo(s*0.10, s*0.12);
                            ctx.stroke();
                        }
                        if (style.pads) {
                            ctx.fillStyle = '#ffaa33';
                            ctx.fillRect(-s*0.30, s*0.14, s*0.18, s*0.10);
                            ctx.fillRect(-s*0.05, s*0.14, s*0.18, s*0.10);
                        }
                        // (Removed crown accent in favor of universal fedora)

                        // Subtle outline
                        ctx.strokeStyle = '#00000055';
                        ctx.lineWidth = Math.max(1, s*0.05);
                        ctx.beginPath();
                        ctx.ellipse(-s*0.05, 0, s*0.55, s*0.38, 0, 0, Math.PI*2);
                        ctx.stroke();

                        ctx.restore();
                    } catch (e) {
                        // Fallback to original rectangle if anything goes wrong
                        ctx.save();
                        ctx.fillStyle = tintColor || enemy.color || '#888';
                        ctx.fillRect(enemy.x - enemy.size/2, enemy.y - enemy.size/2, enemy.size, enemy.size);
                        ctx.restore();
                    }
                };

                // Apply fear/flee tint (purple) while under those effects
                const isPanic = enemy.feared || enemy.fleeing;
                const tintColor = isPanic ? '#AA44FF' : baseColor;
                drawDuckEnemy(ctx, enemy, tintColor);
                // Subtle pulsing glow to highlight panic state
                if (isPanic) {
                    const pulse = 0.45 + 0.25 * Math.sin(performance.now()/160 + enemy.x*0.04);
                    ctx.save();
                    ctx.globalAlpha = 0.35 * pulse;
                    ctx.fillStyle = '#AA44FF';
                    ctx.beginPath();
                    ctx.ellipse(enemy.x, enemy.y + enemy.size*0.10, enemy.size*0.95, enemy.size*0.55, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
                // Health bar
                if (enemy.health < enemy.maxHealth && enemy.maxHealth > 0) {
                    const barWidth = enemy.size + 10;
                    const barHeight = 4;
                    const barY = enemy.y - enemy.size/2 - 8;
                    // Clamp ratio to [0,1] to avoid flash expansion when health dips below 0 or state mutates on death
                    let ratio = enemy.health / enemy.maxHealth;
                    if (!isFinite(ratio)) ratio = 0; // safeguard
                    ratio = Math.min(1, Math.max(0, ratio));
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, barHeight);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, barHeight);
                    if (ratio > 0) {
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(enemy.x - barWidth/2, barY, barWidth * ratio, barHeight);
                    }
                }
                
                // Status effect indicators
                let indicatorY = enemy.y - enemy.size/2 - 15;
                if (enemy.poisoned) {
                    ctx.fillStyle = '#90EE90';
                    ctx.fillRect(enemy.x - 8, indicatorY, 16, 3);
                    indicatorY -= 5;
                }
                if (enemy.burning) {
                    ctx.fillStyle = '#FF6600';
                    ctx.fillRect(enemy.x - 8, indicatorY, 16, 3);
                    indicatorY -= 5;
                }
                if (enemy.slowed) {
                    ctx.fillStyle = '#4040ff';
                    ctx.fillRect(enemy.x - 6, indicatorY, 12, 2);
                }
            });
            
            // Draw projectiles with enhanced effects
            game.projectiles.forEach(proj => {
                if (proj.enemy) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(proj.x - 3, proj.y - 3, 6, 6);
                    return;
                }
                // Visual Accent: Pattern Amplification halo (SHOOTING INTENSIFIES)
                if (proj._patternAmpFactor && proj._patternAmpFactor > 1.01) {
                    const pulse = 0.55 + Math.sin(performance.now()/140 + (proj.x+proj.y)*0.01)*0.25; // 0.3 amplitude
                    const radius = (proj.size||6) * (1.4 + pulse*0.6);
                    ctx.save();
                    const g = ctx.createRadialGradient(proj.x, proj.y, radius*0.15, proj.x, proj.y, radius);
                    g.addColorStop(0,'rgba(255,255,255,0.55)');
                    g.addColorStop(0.45,'rgba(120,255,200,0.35)');
                    g.addColorStop(1,'rgba(0,255,160,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, radius, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                }
                // Visual Accent: Cascade Burst core flicker prior to pulses
                if (proj.cascadeBurst) {
                    // Mild warm core sheen; intensity spikes right before emission when timer small
                    const tLeft = proj._cascTimer || 0;
                    const intensity = (tLeft <= 3) ? 0.85 : (tLeft <= 6 ? 0.55 : 0.25);
                    if (Math.random() < 0.6) {
                        addParticle(proj.x + (Math.random()-0.5)*4, proj.y + (Math.random()-0.5)*4, intensity>0.6?'#FFE5AA':'#FFC877', 'spark');
                    }
                }
                // Determine base elemental color (fallback cyan)
                let baseColor = '#00BFFF';
                if (proj.damageType === 'fire') baseColor = '#FF5522';
                else if (proj.damageType === 'poison') baseColor = '#33DD55';
                else if (proj.damageType === 'ice' || proj.damageType === 'frost') baseColor = '#44AAFF';
                else if (proj.damageType === 'lightning' || proj.damageType === 'storm') baseColor = '#FFFF55';
                else if (proj.damageType === 'acid') baseColor = '#66FF44';
                else if (proj.damageType === 'void') baseColor = '#AA00FF';
                else if (proj.damageType === 'shadow') baseColor = '#663399';
                else if (proj.damageType === 'crystal') baseColor = '#88EEFF';
                else if (proj.damageType === 'magma') baseColor = '#FF7722';
                else if (proj.damageType === 'plasma') baseColor = '#FF4455';
                else if (proj.damageType === 'inferno') baseColor = '#FF3311';
                else if (proj.damageType === 'blizzard') baseColor = '#C0F8FF';
                else if (proj.damageType === 'toxic') baseColor = '#55FFAA';
                // Energy type overrides
                if (proj.energyType) {
                    const energyColors = {
                        laser: '#99EEFF',
                        particle: '#66FFE4',
                        ion: '#FFE066',
                        pulse: '#FF88DD',
                        photon: '#FFFFFF'
                    };
                    if (energyColors[proj.energyType]) baseColor = energyColors[proj.energyType];
                }
                // Homing tint accent
                if (proj.homing) baseColor = '#FFFFFF';
                else if (proj.weakHoming) baseColor = shadeColor(baseColor, 30);
                // Quantum flicker: random slight hue shift
                if (proj.quantum && Math.random() < 0.25) baseColor = '#66FFFF';
                // Plasma trailing ion particles (add subtle heat haze dots)
                if (proj.damageType === 'plasma' && Math.random() < 0.5) {
                    addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FF7766', 'spark');
                    if (Math.random() < 0.25) addParticle(proj.x, proj.y, '#FFAA99', 'spark');
                }
                // Weapon-specific override accents
                const wt = proj.weaponType;
                const angle = Math.atan2(proj.vy, proj.vx);
                // Toenail Clibbins enhanced crescent rendering (half-moon keratin shard)
                if (proj.toenail) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    // Gentle forward pointing orientation plus spin
                    const spin = (proj._crescentPhase||0);
                    ctx.rotate(spin);
                    const baseR = (proj.size||10) * 0.95;
                    const thicknessRatio = proj._tnThickness || 0.5;
                    const innerR = baseR * (1 - thicknessRatio);
                    const arcSweep = proj._tnArcSweep || (Math.PI*1.0);
                    const innerOffset = (proj._tnInnerOffset||0.32) * baseR;
                    // Outer arc path
                    ctx.beginPath();
                    const startA = -arcSweep/2;
                    const endA = arcSweep/2;
                    ctx.arc(0,0,baseR,startA,endA,false);
                    // Inner reverse arc (offset center for crescent thickness)
                    const cutX = innerOffset;
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    // Keratin gradient (subtle off-yellow to pale ivory)
                    const grad = ctx.createLinearGradient(-baseR, -baseR, baseR, baseR);
                    grad.addColorStop(0,'#FFF8D7');
                    grad.addColorStop(0.45,'#FFE684');
                    grad.addColorStop(0.75,'#F3D266');
                    grad.addColorStop(1,'#D8B850');
                    ctx.fillStyle = grad;
                    ctx.fill();
                    // Rough edge speckles along outer rim
                    ctx.save();
                    ctx.clip();
                    for (let s=0;s<6;s++) {
                        const a = startA + Math.random()*arcSweep;
                        const rr = baseR - Math.random()*3;
                        ctx.fillStyle = 'rgba(255,255,255,'+(0.25+Math.random()*0.35)+')';
                        ctx.beginPath(); ctx.arc(Math.cos(a)*rr, Math.sin(a)*rr, 1 + Math.random()*1.4, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.restore();
                    // Outline & inner shine
                    ctx.lineWidth = 1.4; ctx.strokeStyle = '#B3943A';
                    ctx.beginPath();
                    ctx.arc(0,0,baseR,startA,endA,false);
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    ctx.stroke();
                    // Inner warm glow
                    const glowR = innerR * 0.85;
                    const g2 = ctx.createRadialGradient(cutX*0.55,0, glowR*0.1, cutX*0.55,0, glowR);
                    g2.addColorStop(0,'rgba(255,240,200,0.6)');
                    g2.addColorStop(1,'rgba(255,240,200,0)');
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = g2;
                    ctx.beginPath(); ctx.arc(cutX*0.55,0,glowR,0,Math.PI*2); ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                    // Occasional sparkle near tip
                    if (Math.random() < 0.10) addParticle(proj.x + Math.cos(spin+0.2)*baseR*0.6 + (Math.random()-0.5)*4, proj.y + Math.sin(spin+0.2)*baseR*0.6 + (Math.random()-0.5)*4, '#FFF6AA','spark');
                    return;
                }
                // Popcorn kernel rendering
                if (proj.isPopcornKernel) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const wob = Math.sin((proj._kernelWobble||0))*0.25;
                    ctx.rotate(wob);
                    const r = (proj.size||6)*0.9;
                    // Outer golden shell
                    const grad = ctx.createRadialGradient(0,-r*0.3, r*0.2, 0,0,r);
                    grad.addColorStop(0,'#FFF7AA');
                    grad.addColorStop(1,'#E0B540');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
                    // Subtle seam
                    ctx.strokeStyle = '#C09030AA';
                    ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(0,0,r*0.65, Math.PI*0.15, Math.PI*1.15); ctx.stroke();
                    ctx.restore();
                    if (Math.random()<0.08) addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFEFA0','spark');
                    return;
                }
                // Popcorn puff rendering
                if (proj.popcornPuff) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(proj._puffSpin||0);
                    const r = (proj.size||10)*0.85;
                    // Draw clustered lobes
                    ctx.fillStyle = '#FFF9D6';
                    for (let l=0;l<5;l++) {
                        const ang = l/5 * Math.PI*2;
                        const lr = r * (0.55 + ((l%2)*0.15));
                        const lx = Math.cos(ang)*r*0.55;
                        const ly = Math.sin(ang)*r*0.55;
                        ctx.beginPath(); ctx.arc(lx, ly, lr, 0, Math.PI*2); ctx.fill();
                    }
                    // Toasted shading overlay
                    ctx.fillStyle = 'rgba(255,180,60,0.35)';
                    ctx.beginPath(); ctx.arc(-r*0.15, -r*0.1, r*0.65, 0, Math.PI*2); ctx.fill();
                    // Outline
                    ctx.strokeStyle = '#E8D490';
                    ctx.lineWidth = 1.2;
                    ctx.beginPath(); ctx.arc(0,0,r*0.95,0,Math.PI*2); ctx.stroke();
                    ctx.restore();
                    if (Math.random()<0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFEFA0','spark');
                    return;
                }
                // Umbrella arc rendering (semi-transparent canopy segment)
                if (proj.umbrellaArc) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    // Draw a curved segment implying part of an overhead umbrella path.
                    const r = (proj.size||6) * 1.55;
                    const sweep = Math.PI * 0.7; // segment width
                    const start = (Date.now()/520 + (proj._arcSide||1)*0.3) % (Math.PI*2);
                    ctx.lineWidth = 2.3;
                    // canopy gradient (brighter center to pop visually)
                    const grad = ctx.createRadialGradient(0,0,r*0.10,0,0,r);
                    grad.addColorStop(0,'#FFF9E8');
                    grad.addColorStop(0.55,'#FFE5B0AA');
                    grad.addColorStop(1,'#FFAF5030');
                    ctx.strokeStyle = '#FFEDBB';
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0,0,r,start,start+sweep, proj._arcSide===-1);
                    ctx.lineTo(0,0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // shimmering rim
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(255,230,180,0.45)';
                    ctx.lineWidth = 1.1;
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.92,start,start+sweep, proj._arcSide===-1);
                    ctx.stroke();
                    ctx.restore();
                    // Core node (slightly larger)
                    ctx.fillStyle = '#FFEBCF';
                    ctx.beginPath(); ctx.arc(0,0,Math.max(3,(proj.size||6)*0.62),0,Math.PI*2); ctx.fill();
                    // motion shimmer dots
                    if (Math.random()<0.25) {
                        ctx.fillStyle = 'rgba(255,240,210,0.8)';
                        ctx.beginPath(); ctx.arc(Math.cos(start+sweep*0.5)*r*0.55, Math.sin(start+sweep*0.5)*r*0.55, r*0.07, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.restore();
                    if (Math.random()<0.14) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE5B8','spark');
                    return;
                }
                // Diarrhea ability rear clone color override
                if (proj._diarrheaBrown) {
                    // Dedicated brown oval rendering; bypass trails/auras/weapon/antimatter overlays for clarity & consistency
                    const brown = '#8B4513';
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const ang = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(ang);
                    const w = (proj.size||6) * 1.9; // horizontal stretch for oval look
                    const h = (proj.size||6) * 1.05;
                    ctx.fillStyle = brown;
                    ctx.beginPath();
                    ctx.ellipse(0,0,w,h,0,0,Math.PI*2);
                    ctx.fill();
                    // Subtle darker core
                    ctx.fillStyle = '#5A3410AA';
                    ctx.beginPath(); ctx.ellipse(-w*0.15,0,w*0.55,h*0.55,0,0,Math.PI*2); ctx.fill();
                    // Occasional splatter particle
                    if (Math.random()<0.15) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#6B3410', 'spark');
                    ctx.restore();
                    return; // skip rest of projectile rendering pipeline
                }
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(angle);
                // Motion trail: draw stretched translucent quad opposite velocity
                const speedMag = Math.max(1, Math.hypot(proj.vx, proj.vy));
                const trailLen = Math.min(60, speedMag * 4);
                ctx.save();
                ctx.rotate(0); // already aligned
                ctx.fillStyle = baseColor + '33';
                ctx.beginPath();
                ctx.moveTo(-trailLen, - (proj.size||6)*0.6);
                ctx.lineTo(0, - (proj.size||6)*0.25);
                ctx.lineTo(0,  (proj.size||6)*0.25);
                ctx.lineTo(-trailLen, (proj.size||6)*0.6);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                // Radial aura / special overlays
                const auraR = (proj.size||6) + 8;
                const aura = ctx.createRadialGradient(0,0,0,0,0,auraR);
                aura.addColorStop(0, baseColor + '55');
                aura.addColorStop(1, baseColor + '00');
                ctx.fillStyle = aura;
                ctx.beginPath();
                ctx.arc(0,0,auraR,0,Math.PI*2);
                ctx.fill();
                // Exotic overlays (skip antimatter visual override for diarrhea brown clones so they stay brown)
                if (proj.antimatter && !proj._diarrheaBrown) {
                    // dark core with bright rim
                    const ring = ctx.createRadialGradient(0,0,(proj.size||6)*0.2,0,0,(proj.size||6)+14);
                    ring.addColorStop(0,'#000000');
                    ring.addColorStop(0.5,'#5500AA88');
                    ring.addColorStop(1,'#FFEEFF11');
                    ctx.fillStyle = ring;
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+14,0,Math.PI*2); ctx.fill();
                }
                // Split child accent (golden halo & brighten core)
                if (proj._splitChild) {
                    const sr = (proj.size||6) + 6;
                    const sg = ctx.createRadialGradient(0,0,sr*0.25,0,0,sr);
                    sg.addColorStop(0,'#FFFAD2');
                    sg.addColorStop(0.45,'#FFDD66');
                    sg.addColorStop(1,'#FFDD6600');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = sg;
                    ctx.beginPath(); ctx.arc(0,0,sr,0,Math.PI*2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    // Inner bright core pulse
                    ctx.fillStyle = '#FFFFFF88';
                    ctx.beginPath(); ctx.arc(0,0,Math.max(2,(proj.size||6)*0.4),0,Math.PI*2); ctx.fill();
                }
                if (proj.dimensional) {
                    // swirling ring (animate via time)
                    const t = Date.now()/400;
                    ctx.strokeStyle = '#AA00FF';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4,4]);
                    ctx.beginPath();
                    ctx.arc(0,0,(proj.size||6)+6 + Math.sin(t)*2, t, t + Math.PI*1.2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                if (proj.realityBreak) {
                    // glitch squares
                    for (let g=0; g<3; g++) {
                        ctx.save();
                        ctx.rotate(Math.random()*Math.PI*2);
                        ctx.fillStyle = '#66FFFF' + (Math.random()<0.5?'AA':'55');
                        ctx.fillRect((proj.size||6)+4, -2, 4,4);
                        ctx.restore();
                    }
                }
                if (proj.quantum) {
                    // duplicate faint offset image
                    ctx.save();
                    ctx.globalAlpha = 0.35;
                    ctx.translate(3 * Math.sin(Date.now()/90), 3 * Math.cos(Date.now()/110));
                    ctx.scale(1.05,1.05);
                    ctx.fillStyle = '#66FFFF88';
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+2,0,Math.PI*2); ctx.fill();
                    ctx.restore();
                }
                // Multi-Infusion visual: inner core gradient blended across active infusion elements
                if (proj.infusionElements && proj.infusionElements.length) {
                    const colorsMap = { fire:'#ff6a00', ice:'#55ccff', lightning:'#ffee55', poison:'#55ff55', void:'#aa55ff', wind:'#aaffdd' };
                    const coreR = (proj.size||6) * 0.9;
                    const g = ctx.createRadialGradient(0,0,0,0,0,coreR);
                    const els = proj.infusionElements.slice(0,4); // limit stops for perf
                    els.forEach((inf, idx) => {
                        const c = colorsMap[inf.type] || '#ffffff';
                        const stop = idx/(els.length);
                        g.addColorStop(Math.min(0.98, stop*0.9), c + 'AA');
                    });
                    g.addColorStop(1, baseColor + '00');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0,0,coreR,0,Math.PI*2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                // Draw by weapon type
                if (wt === 'sword') {
                    // Blade
                    ctx.fillStyle = '#d0e4ff';
                    ctx.beginPath();
                    ctx.moveTo(-6, -2);
                    ctx.lineTo(18, -1.5);
                    ctx.lineTo(20, 0);
                    ctx.lineTo(18, 1.5);
                    ctx.lineTo(-6, 2);
                    ctx.closePath();
                    ctx.fill();
                    // Edge highlight
                    ctx.strokeStyle = '#ffffffaa';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-5, -1.2);
                    ctx.lineTo(18.5, -0.4);
                    ctx.stroke();
                    // Guard & hilt
                    ctx.fillStyle = '#c09030';
                    ctx.fillRect(-7, -3.5, 3, 7);
                    ctx.fillRect(-9, -1, 4, 2);
                } else if (wt === 'axe') {
                    // Handle
                    ctx.strokeStyle = '#8b5a2b';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-10,0);
                    ctx.lineTo(10,0);
                    ctx.stroke();
                    // Head
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.moveTo(4,-8);
                    ctx.lineTo(14,-4);
                    ctx.lineTo(14,4);
                    ctx.lineTo(4,8);
                    ctx.lineTo(6,0);
                    ctx.closePath();
                    ctx.fill();
                    // Edge
                    ctx.strokeStyle = '#ffffffdd';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(13.5,-4);
                    ctx.lineTo(13.5,4);
                    ctx.stroke();
                } else if (wt === 'spear') {
                    // Shaft
                    ctx.strokeStyle = '#b07a30';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-14,0);
                    ctx.lineTo(18,0);
                    ctx.stroke();
                    // Tip
                    ctx.fillStyle = '#e0e0e0';
                    ctx.beginPath();
                    ctx.moveTo(18,0);
                    ctx.lineTo(12,-4);
                    ctx.lineTo(12,4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffffffaa';
                    ctx.beginPath();
                    ctx.moveTo(18,0);
                    ctx.lineTo(12,-3);
                    ctx.stroke();
                } else if (wt === 'hammer') {
                    // Handle
                    ctx.strokeStyle = '#7b4a1a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-14,0);
                    ctx.lineTo(10,0);
                    ctx.stroke();
                    // Head (rectangular)
                    ctx.fillStyle = '#bbbbbb';
                    ctx.fillRect(4,-6,12,12);
                    // Face highlight
                    ctx.fillStyle = '#e6e6e6';
                    ctx.fillRect(4,-6,5,12);
                } else if (wt === 'dagger') {
                    // Represent a cluster of small daggers spinning
                    const t = (Date.now()/80)%Math.PI*2;
                    for (let i=0;i<3;i++) {
                        const a = t + i*(Math.PI*2/3);
                        ctx.save();
                        ctx.rotate(a);
                        ctx.fillStyle = '#d8eaff';
                        ctx.beginPath();
                        ctx.moveTo(0,-1.5);
                        ctx.lineTo(10,-0.8);
                        ctx.lineTo(10,0.8);
                        ctx.lineTo(0,1.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    // Central core
                    ctx.fillStyle = '#c09030';
                    ctx.beginPath();
                    ctx.arc(0,0,2.5,0,Math.PI*2);
                    ctx.fill();
                } else if (!proj.meteor) {
                    // Default (non-weapon) projectile (skip if meteor to keep it purely round)
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    const half = proj.size;
                    // Render as a rounded diamond-ish shape for slight polish vs basic square
                    ctx.moveTo(-half, 0);
                    ctx.lineTo(0, -half);
                    ctx.lineTo(half, 0);
                    ctx.lineTo(0, half);
                    ctx.closePath();
                    ctx.fill();
                }
                // Meteor custom rendering (round fiery rock with craters & flame trail)
                if (proj.meteor) {
                    const mR = (proj.size || 16);
                    // Overdraw previous shape with meteor look
                    ctx.save();
                    // Core fiery gradient (center bright, edge dark rock)
                    const g = ctx.createRadialGradient(0,0,mR*0.2,0,0,mR);
                    g.addColorStop(0,'#FFE4BB');
                    g.addColorStop(0.35,'#FFAA44');
                    g.addColorStop(0.65,'#DD5511');
                    g.addColorStop(1,'#331104');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(0,0,mR,0,Math.PI*2);
                    ctx.fill();
                    // Rim glow (slight flicker)
                    ctx.strokeStyle = 'rgba(255,180,80,' + (0.35 + Math.random()*0.35).toFixed(2) + ')';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0,0,mR-1,0,Math.PI*2); ctx.stroke();
                    // Crater / scorch marks
                    for (let c=0;c<6;c++) {
                        const ca = Math.random()*Math.PI*2;
                        const cr = Math.random()*mR*0.55;
                        const r  = mR*0.12*(0.6+Math.random()*0.8);
                        ctx.fillStyle = 'rgba(0,0,0,' + (0.25+Math.random()*0.25).toFixed(2) + ')';
                        ctx.beginPath(); ctx.arc(Math.cos(ca)*cr, Math.sin(ca)*cr, r, 0, Math.PI*2); ctx.fill();
                    }
                    // Flame tongue trail (context rotated along velocity, so draw to -X)
                    for (let f=0; f<3; f++) {
                        const fx = -mR - f*mR*0.45;
                        const ry = mR*0.35*(0.9 - f*0.25);
                        ctx.fillStyle = 'rgba(255,' + (120+Math.floor(Math.random()*100)) + ',0,' + (0.25+Math.random()*0.25).toFixed(2) + ')';
                        ctx.beginPath();
                        ctx.ellipse(fx, (Math.random()-0.5)*mR*0.4, mR*0.55*(1-f*0.15), ry, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                    // Spark / ember particles (spawn behind meteor)
                    if (Math.random() < 0.5) {
                        addParticle(proj.x - proj.vx*0.2 + (Math.random()-0.5)*mR*0.6, proj.y - proj.vy*0.2 + (Math.random()-0.5)*mR*0.6, '#FFAA55', 'spark');
                    }
                }
                // Piercing arrowhead indicator
                if (proj.piercing && !wt) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.moveTo((proj.size||6)+4,0);
                    ctx.lineTo((proj.size||6)+0, -3);
                    ctx.lineTo((proj.size||6)+0, 3);
                    ctx.closePath();
                    ctx.fill();
                }
                // Homing indicator
                if (proj.homing) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-1,-1,2,2);
                }
                if (proj.weakHoming && !proj.homing) {
                    ctx.fillStyle = '#ffffffaa';
                    ctx.fillRect(-1,-1,2,2);
                }
                // Explosive ring indicator
                if (proj.explosive) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2,2]);
                    ctx.beginPath();
                    ctx.arc(0,0,(proj.size||6)+5,0,Math.PI*2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                // Remaining quantum hits (small dots)
                if (proj.hitMultipleTimes && proj.remainingHits > 0) {
                    ctx.fillStyle = '#66FFFF';
                    for (let h=0; h<proj.remainingHits; h++) {
                        ctx.beginPath(); ctx.arc(-6 - h*5, - (proj.size||6) - 4, 2, 0, Math.PI*2); ctx.fill();
                    }
                }
                ctx.restore();
            });

            // Render Time Warp fields (under projectiles but above background)
            if (game.timeWarpFields && game.timeWarpFields.length) {
                game.timeWarpFields.forEach(f => {
                    const age = Date.now() - f.createdAt;
                    const pct = age / f.duration;
                    const baseAlpha = Math.max(0, 0.35 * (1 - pct));
                    const ringR = f.radius * (0.85 + 0.15*Math.sin(f.wave*3));
                    // Outer soft glow
                    const grad = ctx.createRadialGradient(f.x, f.y, ringR*0.15, f.x, f.y, ringR);
                    grad.addColorStop(0, 'rgba(80,200,255,' + (baseAlpha*0.8).toFixed(3) + ')');
                    grad.addColorStop(1, 'rgba(80,200,255,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(f.x, f.y, ringR, 0, Math.PI*2); ctx.fill();
                    // Pulsing ring outline
                    ctx.strokeStyle = 'rgba(120,240,255,' + (baseAlpha*0.9).toFixed(3) + ')';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6,6]);
                    ctx.beginPath(); ctx.arc(f.x, f.y, ringR * (0.55 + 0.25*Math.sin(f.wave*4)), 0, Math.PI*2); ctx.stroke();
                    ctx.setLineDash([]);
                });
            }
            
            // Draw player with enhanced graphics (sprite sheet based)
            // Terrifying Aura visual (behind player sprite)
            if (game.player && game.player.auraActive) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const t = performance.now() * 0.002;
                const baseR = 60; // matches aura contact radius
                const pulse = Math.sin(t*3) * 5;
                const rOuter = baseR + pulse;
                // Multi-layer glow for fuller circular look (less "D" shape)
                for (let layer=0; layer<3; layer++) {
                    const lr = rOuter - layer*6;
                    if (lr <= 0) continue;
                    const g = ctx.createRadialGradient(px, py, 12, px, py, lr);
                    const alphaBase = 0.22 - layer*0.06;
                    g.addColorStop(0, `rgba(185,90,255,${alphaBase})`);
                    g.addColorStop(0.5, `rgba(150,50,230,${alphaBase*0.55})`);
                    g.addColorStop(1, 'rgba(90,0,170,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(px, py, lr, 0, Math.PI*2);
                    ctx.fill();
                }
                // Soft perimeter ring
                ctx.save();
                ctx.beginPath();
                ctx.arc(px, py, rOuter-3, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(210,140,255,0.35)';
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = 14;
                ctx.shadowColor = 'rgba(200,120,255,0.6)';
                ctx.stroke();
                ctx.restore();
            }
            // Ensure player stays visible after final boss defeat (disable blink suppression)
            // forceVisibleFrames: countdown frames where player must be drawn (post-reset/death)
            if (game.player && game.player.forceVisibleFrames && game.player.forceVisibleFrames > 0) {
                game.player.forceVisibleFrames--;
            }
            const forceShowPlayer = (game._bigQuackDefeated && !game.gameOver) || (game.player && game.player.forceVisibleFrames>0);
            if (forceShowPlayer || (!game.player.invulnerable || Math.floor(Date.now() / 100) % 2)) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const meta = game.player.spriteMeta;
                const sheet = game.player.spriteSheet;
                const scale = game.player.spriteScale || 1;
                const df = game.player.directionalFrames;
                // If we are within initial forced visibility window but frames missing, retry rebuild
                if ((!df || !game.player.spriteLoaded) && game.player._pendingSpriteRetry) {
                    game.player._pendingSpriteRetry--;
                    if (typeof rebuildPlayerSprite === 'function') rebuildPlayerSprite();
                }
                let frameW, frameH, sx, sy, sourceW, sourceH, useStatic = false;
                if (df && game.player.spriteLoaded) {
                    // Choose source box based on facing
                    let facing = game.player.facing || 'down';
                    if (facing === 'left' && !df.left) facing = 'left';
                    let box = df[facing];
                    if (!box) {
                        if (facing === 'left' && df.right) {
                            box = df.right; // will mirror later
                        } else {
                            box = df.down || Object.values(df)[0];
                        }
                    }
                    if (box) {
                        sx = box.x; sy = box.y; sourceW = box.w; sourceH = box.h; frameW = sourceW; frameH = sourceH; useStatic = true;
                    }
                }
                if (!useStatic) {
                    const frameWBase = meta ? meta.frameWidth : 48;
                    const frameHBase = meta ? meta.frameHeight : 48;
                    frameW = frameWBase; frameH = frameHBase;
                }
                const drawW = frameW * scale;
                const drawH = frameH * scale;
                const yOffset = 6; // adjust to taste so feet contact ground line
                if (sheet && game.player.spriteLoaded) {
                    // Defensive: if directionalFrames lost (e.g. due to external mutation) rebuild minimal mapping once
                    if (!df && meta && !game.player._rebuildAttempted) {
                        game.player._rebuildAttempted = true;
                        // Reconstruct a single-frame fallback using first frame of sheet
                        game.player.directionalFrames = { down: { x:0, y:0, w: meta.frameWidth, h: meta.frameHeight } };
                    }
                    if (useStatic) {
                        const isLeft = (game.player.facing === 'left');
                        if (isLeft && df && df.right) {
                            // Mirror draw
                            ctx.save();
                            ctx.translate(px, py + yOffset);
                            ctx.scale(-1, 1);
                            ctx.drawImage(sheet, sx, sy, sourceW, sourceH, -drawW/2, -drawH/2, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH);
                            }
                            ctx.restore();
                        } else {
                            ctx.drawImage(sheet, sx, sy, sourceW, sourceH, px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            }
                        }
                    } else if (meta) {
                        // Fallback to grid method if directionalFrames missing
                        if (!df && forceShowPlayer) {
                            // Draw a simple placeholder circle so player is never invisible
                            ctx.save();
                            ctx.fillStyle = 'rgba(255,255,255,0.85)';
                            ctx.beginPath();
                            ctx.arc(px, py, 12, 0, Math.PI*2);
                            ctx.fill();
                            ctx.restore();
                        }
                        let rowIndex = meta.order.indexOf(game.player.facing || 'down');
                        if (rowIndex < 0) rowIndex = 0;
                        if (rowIndex >= meta.rows) rowIndex = 0;
                        let colIndex = game.player.animFrame % (meta.cols || 1);
                        if (colIndex >= meta.cols) colIndex = 0;
                        const _sx = colIndex * frameW;
                        const _sy = rowIndex * frameH;
                        if (_sx + frameW <= sheet.width && _sy + frameH <= sheet.height) {
                            ctx.drawImage(sheet, _sx, _sy, frameW, frameH, px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            }
                        } else {
                            ctx.fillStyle = '#990000';
                            ctx.fillRect(px - 12, py - 12, 24, 24);
                        }
                    }
                } else {
                    // More assertive placeholder if we're forcing visibility
                    if (forceShowPlayer) {
                        ctx.save();
                        ctx.translate(px, py);
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.55)'; // gold shimmer
                        ctx.beginPath();
                        ctx.arc(0, 0, 20, 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    } else if (!game._playerPlaceholderDrawn) {
                        // Single faint silhouette fallback (non-forced path)
                        ctx.fillStyle = 'rgba(0,0,0,0.08)';
                        ctx.beginPath();
                        ctx.arc(px, py, 18, 0, Math.PI*2);
                        ctx.fill();
                        game._playerPlaceholderDrawn = true;
                    }
                }
            }
            
            // Nuke explosion flash overlay (above scene, below damage numbers/UI)
            if (Array.isArray(game.nukes) && game.nukes.length) {
                game.nukes.forEach(n => {
                    if (!n || !n.exploded || n.flashTime <= 0 || !n._flashMax) return;
                    const p = n.flashTime / n._flashMax; // 0..1
                    const intensity = Math.pow(p, 0.6); // slower fade at start
                    const maxR = n.radius * 1.4; // expand slightly
                    const r = maxR * (1 + (1-p)*0.35);
                    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, r);
                    g.addColorStop(0, `rgba(255,255,255,${0.85*intensity})`);
                    g.addColorStop(0.25, `rgba(255,220,120,${0.55*intensity})`);
                    g.addColorStop(0.55, `rgba(255,140,0,${0.35*intensity})`);
                    g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.9*intensity;
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, r, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
            }

            // Floating damage numbers (above everything except pause/menu overlays)
            if (game.damageNumbers && game.damageNumbers.length) {
                ctx.save();
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                game.damageNumbers.forEach(dn => {
                    const alpha = Math.max(0, Math.min(1, dn.life / 60));
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = dn.color;
                    ctx.save();
                    ctx.translate(dn.x, dn.y);
                    ctx.scale(dn.scale, dn.scale);
                    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                    ctx.lineWidth = 3;
                    ctx.strokeText(dn.value, 0, 0);
                    ctx.fillText(dn.value, 0, 0);
                    ctx.restore();
                });
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            // Reality Break screen-space distortion: slice displacement & chromatic fringe
            if (game.realityBreakDistort && game.realityBreakDistort.time > 0) {
                const d = game.realityBreakDistort;
                // Create / reuse offscreen buffer
                if (!game._distortCanvas || game._distortCanvas.width !== canvas.width || game._distortCanvas.height !== canvas.height) {
                    game._distortCanvas = document.createElement('canvas');
                    game._distortCanvas.width = canvas.width; game._distortCanvas.height = canvas.height;
                }
                const off = game._distortCanvas;
                const octx = off.getContext('2d');
                octx.clearRect(0,0,off.width,off.height);
                octx.drawImage(canvas, 0, 0);
                const slices = 18;
                for (let i=0;i<slices;i++) {
                    const sliceH = Math.ceil(canvas.height / slices);
                    const sy = i * sliceH;
                    const sh = Math.min(sliceH, canvas.height - sy);
                    const offset = Math.sin((Date.now()/120)+(i*0.9)) * 12 * d.intensity + (Math.random()-0.5)*8*d.intensity;
                    ctx.globalAlpha = 0.70;
                    ctx.drawImage(off, 0, sy, canvas.width, sh, offset, sy, canvas.width, sh);
                    // subtle inverted secondary pass for extra glitch
                    if (Math.random() < 0.12*d.intensity) {
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.18;
                        ctx.drawImage(off, 0, sy, canvas.width, sh, -offset*0.5, sy, canvas.width, sh);
                        ctx.globalCompositeOperation = 'source-over';
                    }
                }
                // Chromatic radial fringe
                ctx.globalAlpha = 0.15 + 0.25*d.intensity;
                const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width*0.65);
                g.addColorStop(0,'rgba(255,255,255,0)');
                g.addColorStop(0.6,'rgba(102,255,255,0)');
                g.addColorStop(1,'rgba(102,255,255,0.5)');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.globalAlpha = 1;
                // Decay timers
                d.time--;
                d.intensity *= 0.985; if (d.time<=0) d.intensity = 0;
            }

            // Room cleared overlay
            if (game.roomCleared) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeText('STREET CLEARED!', canvas.width / 2, canvas.height / 2 - 30);
                ctx.fillText('STREET CLEARED!', canvas.width / 2, canvas.height / 2 - 30);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '18px Arial';
                ctx.strokeText('Press ENTER for next street', canvas.width / 2, canvas.height / 2 + 20);
                ctx.fillText('Press ENTER for next street', canvas.width / 2, canvas.height / 2 + 20);
                
                ctx.fillStyle = '#ffff00';
                ctx.font = '14px Arial';
                ctx.strokeText(`Score: +${50 * game.dungeon}`, canvas.width / 2, canvas.height / 2 + 50);
                ctx.fillText(`Score: +${50 * game.dungeon}`, canvas.width / 2, canvas.height / 2 + 50);
                
                ctx.textAlign = 'left';
            }
            // Game Over overlay (draw after room cleared so it supersedes)
            if (game.gameOver) {
                ctx.save();
                ctx.globalAlpha = 0.95;
                if (game.gameOverImage && game.gameOverImage.complete) {
                    const iw = game.gameOverImage.width;
                    const ih = game.gameOverImage.height;
                    const cw = canvas.width;
                    const ch = canvas.height;
                    const scale = Math.min(cw / iw, ch / ih);
                    const dw = iw * scale;
                    const dh = ih * scale;
                    const dx = (cw - dw) / 2;
                    const dy = (ch - dh) / 2;
                    ctx.drawImage(game.gameOverImage, dx, dy, dw, dh);
                } else {
                    // Fallback simple text if image not yet loaded
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.fillStyle = '#FF2222';
                    ctx.font = 'bold 64px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                }
                ctx.restore();
                // Restart hint bar
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Press SPACE to restart', canvas.width/2, canvas.height - 24);
                ctx.restore();
            }
            
            ctx.restore();
        }

        function updateStats() {
            let damage = 25;
            let projectileCount = 1;
            // Attack speed display now mirrors additive stacking logic used in gameplay.
            let attackSpeedBaseMult = 1; // will become (1 + sum of bonuses)
            let attackSpeedBonusSum = 0;
            let pierceCount = 0;
            let critChance = 0;
            let blockChance = 0;
            let multiShotCount = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect) {
                    if (abilityData.effect.damageBonus) damage += abilityData.effect.damageBonus;
                    if (abilityData.effect.projectileCount) multiShotCount += abilityData.effect.projectileCount;
                    if (abilityData.effect.attackSpeedMultiplier) attackSpeedBonusSum += (abilityData.effect.attackSpeedMultiplier - 1);
                    if (abilityData.effect.pierceCount) pierceCount = Math.max(pierceCount, abilityData.effect.pierceCount);
                    if (abilityData.effect.critChance) critChance = Math.max(critChance, abilityData.effect.critChance);
                    if (abilityData.effect.blockChance) blockChance = Math.max(blockChance, abilityData.effect.blockChance);
                }
            });
            if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.shotgunBlast)) {
                projectileCount = multiShotCount + 5;
            } else if (multiShotCount > 0) {
                projectileCount = multiShotCount;
            }
            if (game.player.abilities.includes('Rage Mode')) {
                damage += game.totalKills * 3;
            }
            // Berserker preview: show current and potential max (+50%) when active
            if (game.player.abilities.includes('Berserker')) {
                const healthPercent = game.player.health / game.player.maxHealth;
                const currentMult = 1 + (1 - healthPercent) * 0.5;
                const currentDamage = Math.floor(damage * currentMult);
                const maxDamage = Math.floor(damage * 1.5);
                document.getElementById('statDamage').textContent = `${currentDamage} (max ${maxDamage})`;
            } else {
                document.getElementById('statDamage').textContent = damage;
            }
            document.getElementById('statProjectiles').textContent = projectileCount;
            const attackSpeed = attackSpeedBaseMult + attackSpeedBonusSum; // effective multiplier
            document.getElementById('statAttackSpeed').textContent = Math.round(attackSpeed * 100) + '%';
            document.getElementById('statPierce').textContent = pierceCount === 999 ? '∞' : pierceCount;
            document.getElementById('statCrit').textContent = Math.round(critChance * 100) + '%';
            document.getElementById('statBlock').textContent = Math.round(blockChance * 100) + '%';
            document.getElementById('statKills').textContent = game.totalKills;
            document.getElementById('statRooms').textContent = game.roomsCleared;
            document.getElementById('statChests').textContent = game.chestsOpened;
        }

        function updateUI() {
            document.getElementById('health').textContent = Math.ceil(game.player.health);
            document.getElementById('maxHealth').textContent = game.player.maxHealth;
            document.getElementById('dungeon').textContent = game.dungeon;
            document.getElementById('room').textContent = game.room;
            document.getElementById('score').textContent = game.score.toLocaleString();
            
            // Update health bar
            const healthPercent = (game.player.health / game.player.maxHealth) * 100;
            document.getElementById('healthBar').style.width = Math.max(0, healthPercent) + '%';
            
            // Change health bar color based on health
            const healthBar = document.getElementById('healthBar');
            if (healthPercent > 60) {
                healthBar.style.background = 'linear-gradient(90deg, #00ff88, #00aa66)';
            } else if (healthPercent > 30) {
                healthBar.style.background = 'linear-gradient(90deg, #ffaa00, #ff8800)';
            } else {
                healthBar.style.background = 'linear-gradient(90deg, #ff4444, #aa0000)';
            }
            
            // (Ability list & minimap removed from live HUD — details in pause menu.)
            updateStats();

            // Terrifying Aura status indicator (optional HUD feedback)
            const auraEl = document.getElementById('auraStatus');
            if (auraEl && game.player.abilities.includes('Terrifying Aura')) {
                const kills = game.player.killCount || 0;
                const nextThreshold = 25 - (kills % 25);
                if (game.player.auraActive) {
                    let remainingRooms = 0;
                    if (game.player.auraExpireRoom) {
                        remainingRooms = game.player.auraExpireRoom - (game.room || 0);
                        if (remainingRooms < 0) remainingRooms = 0;
                    }
                    if (remainingRooms === 0) {
                        game.player.auraActive = false;
                        auraEl.textContent = 'Terrifying Aura: Expired';
                    } else {
                        auraEl.textContent = `Terrifying Aura ACTIVE (${remainingRooms} room${remainingRooms===1?'':'s'} left)`;
                    }
                } else {
                    auraEl.textContent = `Terrifying Aura: ${nextThreshold === 25 ? 'Ready on next 25 kills' : (nextThreshold + ' kills to activate')}`;
                }
            }
        }

        function updateMinimap() {
            const minimap = document.getElementById('minimap');
            minimap.innerHTML = '<div style="position: absolute; top: 2px; left: 2px; font-size: 8px; color: #888;">District Map</div>';
            // Inject (idempotent) cosmetic particle toggle button next to minimap if not present
            if (!document.getElementById('btnToggleCosmetic')) {
                const btn = document.createElement('button');
                btn.id = 'btnToggleCosmetic';
                btn.textContent = 'Cosmetic FX: ' + (game.disableCosmeticParticles ? 'OFF' : 'ON');
                // Position the button directly to the right of the minimap (minimap is 100x75)
                // Placing inside the minimap keeps layout stable without affecting surrounding flow.
                btn.style.cssText = 'position:absolute; top:8px; left:108px; font-size:10px; padding:3px 6px; background:#222; color:#0f0; border:1px solid #444; border-radius:4px; cursor:pointer; white-space:nowrap;';
                btn.onclick = () => toggleCosmeticParticles();
                minimap.appendChild(btn);
                // After adding cosmetic FX button, append chest legend just below it to the right.
                // We'll create a container anchored relative to minimap for tight grouping.
                const legend = document.createElement('div');
                legend.id = 'chestLegend';
                // Position the legend further right (offset 188px) so it clears audio buttons region.
                legend.style.cssText = 'position:absolute; top:8px; left:220px; display:flex; flex-direction:column; gap:4px; background:rgba(0,0,0,0.55); padding:6px 8px 6px 8px; border:1px solid #333; border-radius:6px; font-size:10px; font-family:Courier New, monospace; letter-spacing:0.5px; max-width:210px;';
                legend.innerHTML = `
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #666; background:linear-gradient(#ffffff,#d9d9d9); box-shadow:0 0 3px rgba(255,255,255,0.5);"></span>
                        <span style="color:#ccc;">Platinum <span style=\"color:#888;\">(Common)</span></span>
                    </div>
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #775f00; background:linear-gradient(#ffec8a,#d6a400); box-shadow:0 0 3px rgba(255,220,120,0.4);"></span>
                        <span style="color:#ffdc72;">Gold <span style=\"color:#bfa04a;\">(Rare)</span></span>
                    </div>
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #4a6f1e; background:linear-gradient(#d2ff7a,#5e8f18); box-shadow:0 0 4px #aaff66, 0 0 6px rgba(170,255,90,0.55);"></span>
                        <span style="color:#c9ff86;">Irradiated <span style=\"color:#86c44a;\">(Epic)</span></span>
                    </div>
                `;
                minimap.appendChild(legend);
            }
            

        // === Ability Activation Notifier ===
        // Displays a transient banner once per run when key abilities first become active.
        (function abilityNotifier(){
            const shown = {};
            function showBanner(text, color) {
                let wrap = document.getElementById('abilityNotifyWrap');
                if (!wrap) {
                    wrap = document.createElement('div');
                    wrap.id = 'abilityNotifyWrap';
                    wrap.style.cssText = 'position:fixed;top:14px;left:50%;transform:translateX(-50%);z-index:12000;display:flex;flex-direction:column;gap:6px;pointer-events:none;font-family:Courier New,monospace;';
                    document.body.appendChild(wrap);
                }
                const el = document.createElement('div');
                el.textContent = text;
                el.style.cssText = 'background:rgba(0,0,0,0.70);padding:6px 14px;border:2px solid '+color+';color:'+color+';font-size:14px;letter-spacing:1px;border-radius:6px;opacity:0;transition:opacity .35s, transform .35s;transform:translateY(-6px);text-shadow:0 0 6px '+color+'33;';
                wrap.appendChild(el);
                requestAnimationFrame(()=>{ el.style.opacity='1'; el.style.transform='translateY(0)'; });
                setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(-6px)'; }, 2600);
                setTimeout(()=>{ if (el.parentElement) el.parentElement.removeChild(el); }, 3200);
            }
            setInterval(()=>{
                if (!window.game || !game.player || !Array.isArray(game.player.abilities)) return;
                if (!shown.patternAmplify && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.patternAmplify)) {
                    shown.patternAmplify = true; showBanner('SHOOTING INTENSIFIES ONLINE','#66FFC8');
                }
                if (!shown.cascadeBurst && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.cascadeBurst)) {
                    shown.cascadeBurst = true; showBanner('CASCADE BURST ARMED','#FFB866');
                }
            }, 1000);
        })();
            // Draw minimap grid
            for (let d = 1; d <= 10; d++) {
                const x = 10 + ((d - 1) % 5) * 16;
                const y = 20 + Math.floor((d - 1) / 5) * 20;
                
                const cell = document.createElement('div');
                cell.style.cssText = `
                    position: absolute; left: ${x}px; top: ${y}px;
                    width: 12px; height: 16px; border: 1px solid #333;
                    font-size: 8px; text-align: center; line-height: 16px;
                `;
                
                if (d < game.dungeon) {
                    cell.style.background = '#004400';
                    cell.style.color = '#00ff00';
                    cell.textContent = '✓';
                } else if (d === game.dungeon) {
                    cell.style.background = '#444400';
                    cell.style.color = '#ffff00';
                    cell.textContent = game.room + '/5';
                } else {
                    cell.style.background = '#222';
                    cell.style.color = '#666';
                    cell.textContent = d;
                }
                
                minimap.appendChild(cell);
            }
        }

        // Legacy showTitleScreen block fully removed (simplified version defined earlier in file)

        // ============ Orientation Enforcement (Mobile Landscape) ============
        (function(){
            function isTouch() { return ('ontouchstart' in window) || (navigator.maxTouchPoints>0); }
            function portraitActive() { return window.matchMedia('(orientation: portrait)').matches; }
            function ensureOverlayElement() {
                let ov = document.getElementById('orientationOverlay');
                if (!ov) {
                    ov = document.createElement('div');
                    ov.id = 'orientationOverlay';
                    ov.innerHTML = '<h1>Rotate Device</h1><p>This game is optimized for landscape. Please rotate your phone or tablet to continue playing.</p>';
                    document.body.appendChild(ov);
                }
                return ov;
            }
            function applyOrientationState(){
                const ov = ensureOverlayElement();
                if (isTouch() && portraitActive()) {
                    document.body.classList.add('enforce-landscape');
                    ov.style.display = 'flex';
                    // Soft pause while portrait
                    if (!game.paused) game._wasAutoPausedForOrientation = true;
                    game.paused = true;
                } else {
                    document.body.classList.remove('enforce-landscape');
                    ov.style.display = 'none';
                    if (game._wasAutoPausedForOrientation) {
                        game._wasAutoPausedForOrientation = false;
                        game.paused = false;
                    }
                }
            }
            window.addEventListener('orientationchange', ()=> setTimeout(applyOrientationState, 120));
            window.addEventListener('resize', ()=> applyOrientationState());
            document.addEventListener('DOMContentLoaded', ()=> setTimeout(applyOrientationState, 300));
            // Expose for manual forcing after init if needed
            window.forceOrientationCheck = applyOrientationState;
        })();
        // ====================================================================
    </script>
</body>
</html>