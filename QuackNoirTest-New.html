<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quack Noir</title>
    <!-- Dev: Write-access check by assistant on 2025-10-07. Safe no-op comment. -->
    <!-- Dev: Write-access re-check by assistant on 2025-10-08: OK (no-op) -->
    <!-- Dev: HEAD write-check by assistant 2025-10-08T15:55Z | token: ekg-verify-001 -->
    <!-- Dev: Write-access re-check by assistant 2025-10-10T12:00Z | OK (no-op) -->
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            font-family: 'Courier New', monospace;
            color: white;
            display: flex;
            gap: 20px;
            min-height: 100vh;
        }
    /* Prestart state: fully hide game section so nothing shows under title even if overlay changes */
    body.prestart #gameSection { display: none !important; }
    body.prestart #resetProgressBtn { display: none !important; }
    body.title-active #resetProgressBtn { display: none !important; }
            body.title-active #resetProgressBtn { display: none !important; }
        /* Landscape enforcement helper: in narrow portrait we will overlay a rotate message */
        @media (orientation: portrait) and (max-width: 899px) {
            body.enforce-landscape #gameSection { filter: blur(3px) brightness(0.3); pointer-events: none; }
        }
        #orientationOverlay {
            position: fixed; left:0; top:0; width:100%; height:100%;
            background: rgba(0,0,0,0.92); display:none; z-index:30000;
            align-items:center; justify-content:center; flex-direction:column;
            font-family:'Courier New', monospace; text-align:center; padding:30px; box-sizing:border-box;
        }
        #orientationOverlay h1 { font-size: 26px; margin:0 0 14px; color:#00ff88; }
        #orientationOverlay p { font-size:14px; color:#ccc; line-height:1.5; max-width:480px; }
        #gameSection {
            flex-shrink: 0;
            position: relative;
        }
        #statsSection {
            width: 280px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            height: fit-content;
            backdrop-filter: blur(10px);
        }
        .ability-item {
            font-size: 10px;
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
        }
        .permanent {
            color: #ffd700 !important;
            background: rgba(255,215,0,0.2) !important;
            border: 1px solid #ffd700;
        }
        .controls {
            margin-top: 10px;
            color: #aaa;
            font-size: 11px;
            line-height: 1.4;
        }
        .tooltip {
            /* Center within the game canvas/container at the same vertical offset */
            position: absolute; /* relative to #gameContainer (which is position:relative) */
            left: 50%;
            bottom: 32px; /* raised to avoid clipping at bottom edge */
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(30,30,30,0.9), rgba(12,12,12,0.92));
            color: #fff;
            padding: 10px 18px 12px 18px;
            border-radius: 10px;
            border: 2px solid #444;
            font-size: 14px;
            text-align: center;
            z-index: 1200; /* ensure above canvas and side panels */
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.35s ease;
            pointer-events: none;
            max-width: 520px;
            width: auto;
            box-shadow: 0 6px 18px rgba(0,0,0,0.65), 0 0 10px rgba(0,255,136,0.18);
            font-family: 'Courier New', monospace;
            line-height: 1.25;
            backdrop-filter: blur(3px);
        }
        /* On shorter viewports, bump it a bit more */
        @media (max-height: 720px) {
            .tooltip { bottom: 44px; }
        }
        .tooltip.show {
            opacity: 1;
        }
        .tooltip .ability-name {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .tooltip .ability-desc {
            color: #ccc;
        }
        /* Potato/Low FX badge (inline next to Status heading) */
        #potatoBadge {
            display: none; /* toggled via JS */
            padding: 2px 6px;
            background: rgba(40, 40, 40, 0.85);
            color: #ffd27f;
            border: 1px solid #aa8844;
            border-radius: 6px;
            font: 11px 'Courier New', monospace;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 0 rgba(0,0,0,0.6);
            box-shadow: 0 0 6px rgba(0,0,0,0.35);
            user-select: none;
            white-space: nowrap;
        }
        #pauseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        #pauseMenu {
            background: rgba(20,20,20,0.95);
            border: 3px solid #666;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
        }
        .ability-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }
        .ability-card {
            background: rgba(40,40,40,0.8);
            border: 2px solid #555;
            border-radius: 6px;
            padding: 12px;
            text-align: left;
        }
        .ability-card.tier1 { border-color: #888; }
        .ability-card.tier2 { border-color: #4488ff; }
        .ability-card.tier3 { border-color: #ff44ff; }
        .ability-card.permanent { 
            border-color: #ffd700; 
            background: rgba(255,215,0,0.1);
        }
        .ability-card-name {
            font-weight: bold;
            margin-bottom: 6px;
        }
        .ability-card.tier1 .ability-card-name { color: #ffffff; }
        .ability-card.tier2 .ability-card-name { color: #4488ff; }
        .ability-card.tier3 .ability-card-name { color: #ff44ff; }
        .ability-card.permanent .ability-card-name { color: #ffd700; }
        .ability-card-desc {
            color: #ccc;
            font-size: 12px;
        }
        .minimap {
            width: 100px;
            height: 75px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            border-radius: 4px;
            margin-top: 15px;
            position: relative;
        }
        /* Stats panel rows */
    .stat-row { display:flex; justify-content:flex-start; align-items:center; gap:6px; margin:4px 0 2px; padding:1px 0 3px; border-bottom:1px solid #222; flex-wrap:wrap; }
    .stat-label { color:#ccc; font-size:11px; letter-spacing:0.5px; min-width:72px; }
    .stat-value { color:#00ff88; font-weight:bold; font-size:11px; text-shadow:0 0 3px #004422; }
        #abilities > div:first-child { font-weight:bold; margin-bottom:4px; color:#ffdd55; text-shadow:0 0 6px #664400; }
        #abilities { font-family:'Courier New', monospace; }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00aa66);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
    html, body { margin:0; padding:0; overflow-y:hidden; background:#000; }
    /* Compact mode adjustments for small scale */
    body.compact-ui #ui { padding:6px 8px !important; }
    body.compact-ui #abilities { padding:6px 8px !important; }
    body.compact-ui .stat-row { margin:4px 0 2px; }
    body.compact-ui .stat-label { font-size:10px; }
    body.compact-ui .stat-value { font-size:10px; }
    /* Allow internal scrolling of right panel when viewport height is limited */
    #statsPanelWrapper { max-height: calc(100vh - 8px); overflow-y:auto; }
    /* Allow horizontal scroll if content wider than base width */
    #statsPanelWrapper { overflow-x:hidden; }
    /* Responsive: when body has class panel-below, stack panel under canvas full width */
    body.panel-below #gameSection { flex-direction: column !important; align-items:center !important; }
    body.panel-below #statsPanelWrapper { width:100% !important; max-width:860px; display:flex; flex-direction:row; flex-wrap:wrap; justify-content:space-between; }
    body.panel-below #ui, body.panel-below #abilities { width: calc(50% - 12px); min-width:300px; }
    @media (max-width: 900px) {
        body.panel-below #ui, body.panel-below #abilities { width:100%; }
    }
    #gameSection { gap: 12px !important; }
    #gameCanvas { border: 3px solid #333; box-shadow:0 0 12px rgba(255,160,80,0.25); background:#000; border-radius:6px; }
    #gameContainer { position:relative; }
    /* Reserve space under canvas for HUD; HUD itself will sit below without causing scroll */
    #ui { margin-top:4px; }
        /* Tighten spacing under minimap/sound buttons */
        #gameSection { margin-bottom:0; }
        /* Reduce top margin on minimap to reclaim vertical space */
        .minimap { margin-top: 4px; }
    </style>
</head>
<body>
    <div id="launchCurtain"></div>
                        <div id="gameSection" style="display: flex; flex-direction: row; align-items: flex-start; gap: 2px; margin:0; padding:0;">
                            <!-- Left: Scaled game canvas column -->
                            <div id="gameOuter" style="position: relative; display: flex; flex-direction: column; align-items: flex-start;">
                                <div id="gameContainer" style="position: relative;">
                                    <canvas id="gameCanvas" width="640" height="480"></canvas>
                                    <div id="abilityTooltip" class="tooltip">
                                        <div id="tooltipName" class="ability-name"></div>
                                        <div id="tooltipDesc" class="ability-desc"></div>
                                    </div>
                                </div>
                            </div>
                            <!-- Right: Side panel (health HUD on top, stats below) -->
                            <div id="statsPanelWrapper" style="position: relative; display: flex; flex-direction: column; align-items: stretch; gap: 8px; margin-left:0; width: 210px; box-sizing:border-box; overflow-x:hidden;">
                                <div id="ui" style="background: rgba(0,0,0,0.88); padding: 8px 10px; border-radius: 8px; width:100%; box-shadow:0 0 10px rgba(0,0,0,0.65);">
                                    <div style="display:flex; align-items:center; justify-content:flex-start; gap:8px; margin-bottom:6px;">
                                        <div style="font-weight:bold; color:#ffdd55; letter-spacing:0.5px;">Status</div>
                                        <div id="potatoBadge" title="Reduced FX active">LOW FX</div>
                                    </div>
                                    <div style="margin:2px 0;">Health: <span id="health"></span> / <span id="maxHealth"></span></div>
                                    <div style="margin:2px 0;">District: <span id="dungeon"></span> | Street: <span id="room"></span></div>
                                    <div style="margin:2px 0;">Score: <span id="score"></span></div>
                                    <div class="progress-bar" style="margin-top:8px; margin-bottom:6px; height:10px;"><div id="healthBar" class="progress-fill" style="width:100%; height:100%"></div></div>
                                    <div id="chestLegend" style="margin-top:2px;font-size:11px;color:#ffdd55;letter-spacing:0.5px;">Chests: <span id="statChests" style="color:#ffd700"></span></div>
                                </div>
                                <div id="abilities" style="width:100%; background:rgba(0,0,0,0.78); padding:8px 10px; border-radius:8px; box-shadow:0 0 8px rgba(0,0,0,0.55);">
                                    <div style="font-weight:bold; margin-bottom:6px; color:#00ff88; letter-spacing:0.5px;">Stats:</div>
                                    <div class="stat-row"><span class="stat-label">Damage</span><span id="statDamage" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Projectiles</span><span id="statProjectiles" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Attack Speed</span><span id="statAttackSpeed" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Pierce</span><span id="statPierce" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Crit</span><span id="statCrit" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Block</span><span id="statBlock" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Kills</span><span id="statKills" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Rooms</span><span id="statRooms" class="stat-value"></span></div>
                                </div>
                            </div>
                        </div>
                        <!-- Pause overlay with tabbed submenus -->
                        <div id="pauseOverlay" style="display:none;">
                            <div id="pauseMenu">
                                <h2 style="margin-top:0;color:#00ff88;">Paused</h2>
                                <div style="display:flex; gap:12px; margin-bottom:14px;">
                                    <button id="tabAbilities" data-tab="abilities" style="flex:1;padding:8px 10px;background:#111;border:2px solid #00ff88;color:#00ff88;border-radius:6px;cursor:pointer;font-family:'Courier New', monospace;">Abilities</button>
                                    <button id="tabOptions" data-tab="options" style="flex:1;padding:8px 10px;background:#111;border:2px solid #444;color:#aaa;border-radius:6px;cursor:pointer;font-family:'Courier New', monospace;">Options</button>
                                </div>
                                <div id="pauseTabContent" style="width:100%; min-height:260px;">
                                    <div id="pauseAbilities" class="ability-grid" style="text-align:left; width:100%;"></div>
                                    <div id="pauseOptions" style="display:none; text-align:left; width:100%;">
                                        <div style="display:flex; flex-direction:column; gap:10px;">
                                            <button id="optToggleSfx" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle SFX</button>
                                            <button id="optToggleMusic" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle Music</button>
                                            <button id="optToggleCosmetic" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle Potato Mode</button>
                                            <button id="optResetProgress" style="padding:8px 12px;background:#330000;border:2px solid #aa4444;color:#ff8080;font-family:'Courier New', monospace;cursor:pointer;">Reset Progress</button>
                                        </div>
                                    </div>
                                </div>
                                <div style="margin-top:14px;color:#ccc;font-size:12px;">Press P to resume</div>
                            </div>
                        </div>
        <!-- ...existing HTML for game UI, canvas, etc... -->
    <script>
    // Ensure canvas visible early.
    // Dev: write-access verified 2025-10-06
    // Dev: write-access check OK (assistant) 2025-10-06
    // Dev: write-access re-verified (assistant) 2025-10-07
    document.addEventListener('DOMContentLoaded', ()=> {
            const cv = document.getElementById('gameCanvas');
            if (cv) { cv.style.display='block'; cv.style.visibility='visible'; }
            // Preload car obstacle images
            const carImgH = new Image();
            carImgH.onload = ()=>{ carImgH._ok = true; };
            carImgH.onerror = ()=>{ console.warn('[CarImage] Failed to load assets/cars/car-horizontal.png'); carImgH._broken = true; };
            carImgH.src = 'assets/cars/car-horizontal.png';
            const carImgV = new Image();
            carImgV.onload = ()=>{ carImgV._ok = true; };
            carImgV.onerror = ()=>{ console.warn('[CarImage] Failed to load assets/cars/car-front.png'); carImgV._broken = true; };
            carImgV.src = 'assets/cars/car-front.png';
            window._carObstacleImages = { h: carImgH, v: carImgV };

            // Preload barrier obstacle image (replaces procedural barrier art)
            const barrierImg = new Image();
            barrierImg.onload = ()=>{ barrierImg._ok = true; };
            barrierImg.onerror = ()=>{ console.warn('[BarrierImage] Failed to load assets/barrier.png'); barrierImg._broken = true; };
            barrierImg.src = 'assets/barrier.png';
            window._barrierImage = barrierImg;

            // Preload bullet sprites
            const toenailImg = new Image();
            toenailImg.onload = ()=>{ toenailImg._ok = true; };
            toenailImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/toenail_clibbins.png'); toenailImg._broken = true; };
            toenailImg.src = 'assets/bullets/toenail_clibbins.png';
            window._bulletImages = window._bulletImages || {};
            window._bulletImages.toenail = toenailImg;
            // Axe sprite
            const axeImg = new Image();
            axeImg.onload = ()=>{ axeImg._ok = true; };
            axeImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/axe.png'); axeImg._broken = true; };
            axeImg.src = 'assets/bullets/axe.png';
            window._bulletImages.axe = axeImg;
            // Hammer sprite
            const hammerImg = new Image();
            hammerImg.onload = ()=>{ hammerImg._ok = true; };
            hammerImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/hammer.png'); hammerImg._broken = true; };
            hammerImg.src = 'assets/bullets/hammer.png';
            window._bulletImages.hammer = hammerImg;
            // Sword sprite
            const swordImg = new Image();
            swordImg.onload = ()=>{ swordImg._ok = true; };
            swordImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sword.png'); swordImg._broken = true; };
            swordImg.src = 'assets/bullets/sword.png';
            window._bulletImages.sword = swordImg;
            // Plain default bullet sprite
            const plainBulletImg = new Image();
            plainBulletImg.onload = ()=>{ plainBulletImg._ok = true; };
            plainBulletImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/plainbullet.png'); plainBulletImg._broken = true; };
            plainBulletImg.src = 'assets/bullets/plainbullet.png';
            window._bulletImages.plain = plainBulletImg;
            // Diarrhea bullet sprite
            const diarrheaImg = new Image();
            diarrheaImg.onload = ()=>{ diarrheaImg._ok = true; };
            diarrheaImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/diarrhea.png'); diarrheaImg._broken = true; };
            diarrheaImg.src = 'assets/bullets/diarrhea.png';
            window._bulletImages.diarrhea = diarrheaImg;
            // Popcorn puff sprite
            const popcornImg = new Image();
            popcornImg.onload = ()=>{ popcornImg._ok = true; };
            popcornImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/popcorn.png'); popcornImg._broken = true; };
            popcornImg.src = 'assets/bullets/popcorn.png';
            window._bulletImages.popcorn = popcornImg;
            // Tumbleweed sprite
            const tumbleweedImg = new Image();
            tumbleweedImg.onload = ()=>{ tumbleweedImg._ok = true; };
            tumbleweedImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/tumbleweed.png'); tumbleweedImg._broken = true; };
            tumbleweedImg.src = 'assets/bullets/tumbleweed.png';
            window._bulletImages.tumbleweed = tumbleweedImg;
            // Beans sprite (Kick the Can)
            const beansImg = new Image();
            beansImg.onload = ()=>{ beansImg._ok = true; };
            beansImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/beans.png'); beansImg._broken = true; };
            beansImg.src = 'assets/bullets/beans.png';
            window._bulletImages.beans = beansImg;
            // Bread (baguette) sprite
            const breadImg = new Image();
            breadImg.onload = ()=>{ breadImg._ok = true; };
            breadImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bread.png'); breadImg._broken = true; };
            breadImg.src = 'assets/bullets/bread.png';
            window._bulletImages.bread = breadImg;
            // Time Bomb sprite
            const timebombImg = new Image();
            timebombImg.onload = ()=>{ timebombImg._ok = true; };
            timebombImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/timebomb.png'); timebombImg._broken = true; };
            timebombImg.src = 'assets/bullets/timebomb.png';
            window._bulletImages.timebomb = timebombImg;

            // Meteor sprite
            const meteorImg = new Image();
            meteorImg.onload = ()=>{ meteorImg._ok = true; };
            meteorImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/meteor.png'); meteorImg._broken = true; };
            meteorImg.src = 'assets/bullets/meteor.png';
            window._bulletImages.meteor = meteorImg;

            // Ion Cannon sprite
            const ionImg = new Image();
            ionImg.onload = ()=>{ ionImg._ok = true; };
            ionImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/ion.png'); ionImg._broken = true; };
            ionImg.src = 'assets/bullets/ion.png';
            window._bulletImages.ion = ionImg;

            // SIGMA sprites (three stages)
            const sigma1Img = new Image();
            sigma1Img.onload = ()=>{ sigma1Img._ok = true; };
            sigma1Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sigma1.png'); sigma1Img._broken = true; };
            sigma1Img.src = 'assets/bullets/sigma1.png';

            // Bloom petal variants (used by Spiral Bloom petals)
            const bloom1Img = new Image(); bloom1Img.onload = ()=>{ bloom1Img._ok = true; }; bloom1Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom1.png'); bloom1Img._broken = true; };
            bloom1Img.src = 'assets/bullets/bloom1.png'; window._bulletImages.bloom1 = bloom1Img;
            const bloom2Img = new Image(); bloom2Img.onload = ()=>{ bloom2Img._ok = true; }; bloom2Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom2.png'); bloom2Img._broken = true; };
            bloom2Img.src = 'assets/bullets/bloom2.png'; window._bulletImages.bloom2 = bloom2Img;
            const bloom3Img = new Image(); bloom3Img.onload = ()=>{ bloom3Img._ok = true; }; bloom3Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom3.png'); bloom3Img._broken = true; };
            bloom3Img.src = 'assets/bullets/bloom3.png'; window._bulletImages.bloom3 = bloom3Img;
            const bloom4Img = new Image(); bloom4Img.onload = ()=>{ bloom4Img._ok = true; }; bloom4Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom4.png'); bloom4Img._broken = true; };
            bloom4Img.src = 'assets/bullets/bloom4.png'; window._bulletImages.bloom4 = bloom4Img;
            const bloom5Img = new Image(); bloom5Img.onload = ()=>{ bloom5Img._ok = true; }; bloom5Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom5.png'); bloom5Img._broken = true; };
            bloom5Img.src = 'assets/bullets/bloom5.png'; window._bulletImages.bloom5 = bloom5Img;
            const bloom6Img = new Image(); bloom6Img.onload = ()=>{ bloom6Img._ok = true; }; bloom6Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom6.png'); bloom6Img._broken = true; };
            bloom6Img.src = 'assets/bullets/bloom6.png'; window._bulletImages.bloom6 = bloom6Img;
            window._bulletImages.sigma1 = sigma1Img;
            const sigma2Img = new Image();
            sigma2Img.onload = ()=>{ sigma2Img._ok = true; };
            sigma2Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sigma2.png'); sigma2Img._broken = true; };
            sigma2Img.src = 'assets/bullets/sigma2.png';
            window._bulletImages.sigma2 = sigma2Img;
            const sigma3Img = new Image();
            sigma3Img.onload = ()=>{ sigma3Img._ok = true; };
            sigma3Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sigma3.png'); sigma3Img._broken = true; };
            sigma3Img.src = 'assets/bullets/sigma3.png';
            window._bulletImages.sigma3 = sigma3Img;

            // Tanks Alot ability sprites
            // Primary truck sprite (driving)
            const truckImg = new Image();
            truckImg.onload = ()=>{ truckImg._ok = true; };
            truckImg.onerror = ()=>{ console.warn('[AbilityImage] Failed to load assets/bullets/truck.png'); truckImg._broken = true; };
            truckImg.src = 'assets/bullets/truck.png';
            // Secondary sprite (lingering fire loop or alt frame)
            const truckFireImg = new Image();
            truckFireImg.onload = ()=>{ truckFireImg._ok = true; };
            truckFireImg.onerror = ()=>{ console.warn('[AbilityImage] Failed to load assets/bullets/truck2.png'); truckFireImg._broken = true; };
            truckFireImg.src = 'assets/bullets/truck2.png';
            window._truckSprite = { image: truckImg, fire: truckFireImg };
            // Helper to compute tight opaque bounds from an Image
            function computeOpaqueBounds(img, alphaThreshold = 10) {
                try {
                    const iw = (img.naturalWidth != null ? img.naturalWidth : img.width) || 0;
                    const ih = (img.naturalHeight != null ? img.naturalHeight : img.height) || 0;
                    if (!iw || !ih) return { x:0, y:0, w:iw, h:ih };
                    const c = document.createElement('canvas'); c.width = iw; c.height = ih;
                    const cx = c.getContext('2d');
                    cx.drawImage(img, 0, 0);
                    const data = cx.getImageData(0, 0, iw, ih).data;
                    let minX = iw, minY = ih, maxX = -1, maxY = -1;
                    for (let y=0; y<ih; y++) {
                        for (let x=0; x<iw; x++) {
                            const a = data[(y*iw + x)*4 + 3];
                            if (a > alphaThreshold) {
                                if (x < minX) minX = x;
                                if (y < minY) minY = y;
                                if (x > maxX) maxX = x;
                                if (y > maxY) maxY = y;
                            }
                        }
                    }
                    if (maxX < 0 || maxY < 0) return { x:0, y:0, w:iw, h:ih };
                    return { x:minX, y:minY, w:(maxX - minX + 1), h:(maxY - minY + 1) };
                } catch(e) { return { x:0, y:0, w: img.width||0, h: img.height||0 }; }
            }
            // Precompute barrier opaque rect for precise collisions
            (function computeBarrierOpaqueRect(){
                const img = window._barrierImage;
                function setRect(){
                    try {
                        if (img && img.complete && !img._broken && img.naturalWidth) {
                            window._barrierOpaqueRect = computeOpaqueBounds(img, 12);
                        }
                    } catch(_) {}
                }
                if (img) {
                    if (img.complete && img.naturalWidth) setRect();
                    else img.addEventListener('load', setRect, { once: true });
                }
            })();
            // Build frames after both images attempt to load (safe if one fails)
            const finalizeTruckFrames = ()=>{
                const spr = window._truckSprite || {};
                if (!spr.frames) spr.frames = {};
                // Only auto-compute if not manually provided
                if ((!spr.frames.drive || !spr.frames.drive.length) && spr.image && spr.image.complete && !spr.image._broken && spr.image.naturalWidth) {
                    spr.frames.drive = [ computeOpaqueBounds(spr.image) ];
                }
                if ((!spr.frames.fire || !spr.frames.fire.length) && spr.fire && spr.fire.complete && !spr.fire._broken && spr.fire.naturalWidth) {
                    spr.frames.fire = [ computeOpaqueBounds(spr.fire) ];
                }
                window._truckSprite = spr;
            };
            truckImg.onload = ()=>{ truckImg._ok = true; finalizeTruckFrames(); };
            truckFireImg.onload = ()=>{ truckFireImg._ok = true; finalizeTruckFrames(); };
            // Allow manual override of frames if precise bounds are known
            window.configureTruckSprites = function configureTruckSprites(meta){
                try {
                    const spr = window._truckSprite || {};
                    spr.frames = spr.frames || {};
                    if (meta && Array.isArray(meta.drive)) spr.frames.drive = meta.drive;
                    if (meta && Array.isArray(meta.fire)) spr.frames.fire = meta.fire;
                    window._truckSprite = spr;
                } catch(e) { console.warn('configureTruckSprites failed', e); }
            };

            // Apply user-specified drive frames (sprite bounding) for truck.png immediately
            // 1) 110,0 -> 909,361  2) 110,510 -> 910,877  3) 117,939 -> 919,1522
            (function seedTruckFrames(){
                try {
                    const spr = window._truckSprite || {}; spr.frames = spr.frames || {};
                    spr.frames.drive = [
                        { x:110, y:0,   w: (909-110), h: (361-0)   },
                        { x:110, y:510, w: (910-110), h: (877-510) },
                        { x:117, y:939, w: (919-117), h: (1522-939) }
                    ];
                    // User-specified fire frames (truck2.png)
                    spr.frames.fire = [
                        { x:105, y:157, w:(913-105), h:(622-157) },
                        { x:81,  y:830, w:(936-81),  h:(1391-830) }
                    ];
                    window._truckSprite = spr;
                } catch(e) { /* noop */ }
            })();

            // Dumpster obstacle spritesheet (3 frames)
            const dumpsterImg = new Image();
            dumpsterImg.onload = ()=>{ dumpsterImg._ok = true; };
            dumpsterImg.onerror = ()=>{ console.warn('[DumpsterSprite] Failed to load assets/DumpsterFire.png'); dumpsterImg._broken = true; };
            dumpsterImg.src = 'assets/DumpsterFire.png';
            // Frames defined by bounding boxes: [ [x1,y1,x2,y2], ... ]
            window._dumpsterSprite = {
                image: dumpsterImg,
                frames: [
                    // Frame 1: 44, 258 and 312, 710
                    { x:44,  y:258, w:312-44,  h:710-258 },
                    // Frame 2: 378, 258 and 645, 712
                    { x:378, y:258, w:645-378, h:712-258 },
                    // Frame 3: 712, 258 and 975, 709
                    { x:712, y:258, w:975-712, h:709-258 }
                ],
                fps: 6 // target animation rate; derived via frame step from game.frame
            };

            // Helper: compute the current on-canvas destination rectangle for a dumpster sprite,
            // matching how we draw it (aspect fit with slight padding). Returns
            // { x, y, w, h, frame } where frame is the source frame rect used.
            window.getDumpsterSpriteRect = function getDumpsterSpriteRect(wall){
                try {
                    const spr = window._dumpsterSprite;
                    const img = spr && spr.image;
                    const frames = spr && spr.frames;
                    if (!spr || !img || !img.complete || !img.naturalWidth || !frames || !frames.length) {
                        return { x: wall.x, y: wall.y, w: (wall.width||TILE_SIZE), h: (wall.height||TILE_SIZE), frame: null };
                    }
                    const fps = spr.fps || 6;
                    const step = Math.max(1, Math.round(60 / fps));
                    const frameIdx = Math.floor(((window.game && window.game.frame) || 0) / step) % frames.length;
                    const f = frames[frameIdx];
                    const tileW = wall.width || TILE_SIZE;
                    const tileH = wall.height || TILE_SIZE;
                    const aspect = f.w / f.h;
                    // Apply same padding logic as render
                    const pad = Math.floor(Math.min(tileW, tileH) * 0.06);
                    const innerW = Math.max(1, tileW - pad * 2);
                    const innerH = Math.max(1, tileH - pad * 2);
                    const tileAspect = innerW / innerH;
                    let dw, dh, dx, dy;
                    if (aspect > tileAspect) {
                        // Wider than tile: match width, scale height
                        dw = innerW; dh = innerW / aspect;
                        dx = wall.x + pad; dy = wall.y + (tileH - dh) / 2;
                    } else {
                        // Taller than tile: match height, scale width
                        dh = innerH; dw = innerH * aspect;
                        dx = wall.x + (tileW - dw) / 2; dy = wall.y + pad;
                    }
                    return { x: dx, y: dy, w: dw, h: dh, frame: f };
                } catch (e) {
                    // Fallback to full wall rect on any error
                    return { x: wall.x, y: wall.y, w: (wall.width||TILE_SIZE), h: (wall.height||TILE_SIZE), frame: null };
                }
            };

            // Background image manager: pick and load one image from assets/streets per room
            const STREET_BG_PATHS = [
                'assets/streets/street.png',
                'assets/streets/street-night.png',
                'assets/streets/street-night-rain.png',
                'assets/streets/street-rain.png',
                'assets/streets/street-school.png',
                'assets/streets/street-trash.png',
                // Add more file names here as needed
            ];
            window._streetBackgrounds = {
                list: STREET_BG_PATHS,
                img: new Image(),
                ready: false,
                currentSrc: null,
                alpha: 1.0,
                // Fit strategy:
                //  - 'contain': shows full image (no crop), may leave borders on sides or top/bottom
                //  - 'cover'  : fills entire canvas (may crop both axes)
                //  - 'fitWidth': scales image so width matches canvas width (left/right flush) and center-crops vertically if needed
                // Default to 'fitWidth' so backgrounds are flush with the left/right canvas edges.
                fit: 'fitWidth',
                // Optional extra zoom multiplier (1 = exact fit). Use <1 to shrink further.
                zoom: 1.0
            };
            // Preload cache and helpers for zero-flash background swaps
            window._streetBackgrounds.cache = new Map(); // src -> { img, bitmap, ready, error }
            window._streetBackgrounds._preloadPromise = null;
            function injectPreloadHints(){
                try {
                    const head = document.head || document.getElementsByTagName('head')[0];
                    if (!head) return;
                    const list = window._streetBackgrounds.list || [];
                    list.forEach(src => {
                        // Avoid duplicating hints
                        if (head.querySelector(`link[rel="preload"][href="${src}"]`)) return;
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.as = 'image';
                        link.href = src;
                        head.appendChild(link);
                    });
                } catch(_) {}
            }
            function loadBgToCache(src){
                const b = window._streetBackgrounds;
                const existing = b.cache.get(src);
                if (existing && (existing.ready || existing.loading)) return existing.promise || Promise.resolve(existing);
                const img = new Image();
                // If images are same-origin, CORS is not required; harmless if left off
                img.decoding = 'async';
                img.src = src;
                const p = new Promise((resolve) => {
                    function finalize(){
                        const done = (bitmap)=>{ const entry = { img, bitmap, ready: true }; b.cache.set(src, entry); resolve(entry); };
                        try {
                            if (typeof createImageBitmap === 'function') {
                                createImageBitmap(img).then(bmp => done(bmp)).catch(()=> done(null));
                            } else {
                                done(null);
                            }
                        } catch(_) { done(null); }
                    }
                    if (img.decode) {
                        img.decode().then(finalize).catch(()=>{ img.onload = finalize; img.onerror = ()=>{ b.cache.set(src,{ error:true }); resolve(null); }; });
                    } else {
                        img.onload = finalize;
                        img.onerror = ()=>{ b.cache.set(src,{ error:true }); resolve(null); };
                    }
                });
                b.cache.set(src, { img, loading: true, promise: p });
                return p;
            }
            window.preloadStreetBackgrounds = function preloadStreetBackgrounds(){
                const b = window._streetBackgrounds;
                if (b._preloadPromise) return b._preloadPromise;
                const list = Array.isArray(b.list) ? b.list : [];
                injectPreloadHints();
                b._preloadPromise = Promise.all(list.map(loadBgToCache)).then(()=>true).catch(()=>false);
                return b._preloadPromise;
            };
            window.pickRandomBackground = function pickRandomBackground(){
                const b = window._streetBackgrounds;
                const list = Array.isArray(b.list) ? b.list : [];
                if (!list.length) { return; }
                const src = list[(Math.random() * list.length) | 0];
                const cached = b.cache && b.cache.get(src);
                if (cached && cached.ready && (cached.bitmap || cached.img)) {
                    // Instant swap from cache, no fade
                    b.currentSrc = src;
                    b.img = cached.bitmap || cached.img;
                    b.ready = true;
                    b.alpha = 1.0;
                    return;
                }
                // Start load in background, keep current image displayed until ready
                loadBgToCache(src).then((entry)=>{
                    if (!entry) return;
                    // Only switch when the requested one finishes
                    b.currentSrc = src;
                    b.img = entry.bitmap || entry.img;
                    b.ready = true;
                    b.alpha = 1.0;
                });
            };
            // Kick off preloading immediately; prioritize the first image to minimize first-room flash
            window.preloadStreetBackgrounds();
            // === Dynamic Canvas Scaling Wrapper ===
            // We render at a fixed logical resolution and scale up to fit while leaving room for HUD (right) and stats (bottom if needed) without scrollbars.
            (function initScaledCanvas(){
                // === Layout / Scaling Constants ===
                // SIDE_PANEL_WIDTH: width reserved for right column (health HUD + stats) in CSS pixels. Adjust if panel content widens.
                // LOGICAL_WIDTH/HEIGHT: fixed internal simulation resolution; gameplay, collision, spawn logic use these units.
                //   Expanding increases visible world area per room (ROOM_WIDTH / ROOM_HEIGHT derived from these values).
                // MAX_DPR: clamp on devicePixelRatio to prevent huge backing buffers that can hurt performance / memory.
                // Scaling Strategy: We scale canvas to fit available width (minus side panel) and full window height.
                //   Scale = min( (availW - SIDE_PANEL_WIDTH)/LOGICAL_WIDTH, availH/LOGICAL_HEIGHT ).
                //   This preserves aspect ratio while maximizing playfield without causing scrollbars.
                const SIDE_PANEL_WIDTH = 200; // reduced baseline width for narrower laptop fit
                // Reduced logical width to tighten horizontal span (improves performance & small-screen fit)
                // Make logical width an exact multiple of TILE_SIZE (22) so the right wall aligns to the canvas edge.
                // 22 * 52 = 1144
                const LOGICAL_WIDTH = 1144;
                // Make logical height an exact multiple of TILE_SIZE (22) so the bottom wall aligns with canvas edge.
                // 22 * 32 = 704
                const LOGICAL_HEIGHT = 704;  // was 720
                const MAX_DPR = 1.25; // lowered from 1.5 to reduce backing buffer size and fill cost
                const dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);
                const canvasCSS = cv;
                function configureBuffer(){
                    cv.width = LOGICAL_WIDTH * dpr;
                    cv.height = LOGICAL_HEIGHT * dpr;
                    canvasCSS.style.width = LOGICAL_WIDTH + 'px';
                    canvasCSS.style.height = LOGICAL_HEIGHT + 'px';
                    const ctxLocal = cv.getContext('2d');
                    ctxLocal.setTransform(dpr,0,0,dpr,0,0);
                }
                configureBuffer();
                window.__LOGICAL_CANVAS__ = { w: LOGICAL_WIDTH, h: LOGICAL_HEIGHT, dpr };
                // Apply scale so canvas + side panel fit horizontally within window while maximizing canvas height.
                function applyScale(){
                    const availW = window.innerWidth - 6; // slightly tighter outer margin
                    const availH = window.innerHeight - 6;
                    const GAP = 8;             // reduced gap between canvas and side panel
                    const SAFETY = 4;           // smaller safety margin
                    const CANVAS_BORDER = 3;    // matches CSS border thickness on #gameCanvas
                    // Measure actual side panel width if rendered (more accurate than constant)
                    const panelEl = document.getElementById('statsPanelWrapper');
                    const panelWidth = (panelEl && panelEl.offsetWidth) ? panelEl.offsetWidth : SIDE_PANEL_WIDTH;
                    let scale = availH / LOGICAL_HEIGHT; // start height-first
                    let layoutBelow = false;
                    // Predict total width requirement in side-by-side mode
                    const scaledCandidateWidth = LOGICAL_WIDTH * scale;
                    let totalProjected = scaledCandidateWidth + (2 * CANVAS_BORDER * scale) + panelWidth + GAP + SAFETY;
                    // If width insufficient even after scaling down (or viewport very narrow), switch to panel-below layout
                    if (totalProjected > availW && availW < 1000) {
                        layoutBelow = true;
                    } else if (totalProjected > availW) {
                        // Try reducing scale just enough to fit side-by-side
                        const widthBudgetWithBorder = availW - panelWidth - GAP - SAFETY - (2 * CANVAS_BORDER * scale);
                        const revised = widthBudgetWithBorder / LOGICAL_WIDTH;
                        scale = Math.min(scale, revised * 0.997);
                        totalProjected = (LOGICAL_WIDTH * scale) + (2 * CANVAS_BORDER * scale) + panelWidth + GAP + SAFETY;
                        if (totalProjected > availW * 1.02) {
                            // Still doesn't fit; fall back to below layout
                            layoutBelow = true;
                            scale = Math.min(scale, (availW - SAFETY*2) / LOGICAL_WIDTH); // re-evaluate width usage for centered canvas
                        }
                    }
                    const MIN_SCALE = 0.35; // allow smaller scale on compact laptop displays
                    scale = Math.max(Math.min(scale, 3), MIN_SCALE);
                    // Slight intentional shrink to guarantee no overflow due to fractional rounding
                    scale *= 0.993;
                    const scaledBorderTotal = 2 * CANVAS_BORDER * scale;
                    if (!layoutBelow) {
                        // Final overflow guard in side-by-side mode
                        const totalNeeded = (LOGICAL_WIDTH * scale) + scaledBorderTotal + panelWidth + GAP + SAFETY;
                        if (totalNeeded > availW) {
                            const widthBudgetWithBorder = availW - panelWidth - GAP - SAFETY - scaledBorderTotal;
                            const revised = widthBudgetWithBorder / LOGICAL_WIDTH;
                            scale = Math.max(Math.min(revised * 0.995, scale), 0.40);
                        }
                    }
                    const scaledW = LOGICAL_WIDTH * scale;
                    canvasCSS.style.transformOrigin = 'top left';
                    canvasCSS.style.transform = `scale(${scale})`;
                    const gameOuter = document.getElementById('gameOuter');
                    if (gameOuter) gameOuter.style.width = (scaledW + scaledBorderTotal) + 'px';
                    // Toggle layout mode class
                    if (layoutBelow) document.body.classList.add('panel-below'); else document.body.classList.remove('panel-below');
                    // Toggle compact UI class when scale falls below threshold
                    if (scale < 0.52) document.body.classList.add('compact-ui'); else document.body.classList.remove('compact-ui');
                }
                window.addEventListener('resize', applyScale);
                applyScale();
            })();
        });
    let canvas, ctx;
    const TILE_SIZE = 22; // slightly enlarged to make obstacles feel bigger; hitboxes adapt below
    // Derive room tile dimensions from logical canvas size (set in scaling wrapper: 1160x720)
    // If LOGICAL size changes later, these should be recomputed or made reactive.
    const LOGICAL_W = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || 1144;
    const LOGICAL_H = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || 704;
    const ROOM_WIDTH = Math.floor(LOGICAL_W / TILE_SIZE);  // dynamic width in tiles
    const ROOM_HEIGHT = Math.floor(LOGICAL_H / TILE_SIZE); // dynamic height in tiles
        
    const game = {
            player: {
                x: 320, y: 240, health: 100, maxHealth: 100,
                abilities: [], permanentAbilities: [],
                // Initial facing is down; align lastDirection so first shot matches sprite
                facing: 'down',
                lastDirection: { x: 0, y: 1 },
                invulnerable: false, invulnTime: 0,
                speed: 2.5
            },
            // User-adjustable runtime settings / visual toggles
            settings: { realityBreakOverlay: false },
            // Unified input state (keyboard/touch/gamepad)
            input: {
                gamepadEnabled: true,
                gpIndex: null,
                gpDeadzone: 0.25, // radial deadzone (0..1)
                gpMove: { x: 0, y: 0 },
                gpAim: { x: 0, y: 0 },
                gpFire: false,
                _lastButtons: null,
                _lastStartAt: 0
            },
            dungeon: 1, room: 1, score: 0,
            enemies: [], chests: [], projectiles: [], walls: [], particles: [],
            transientEffects: [], // short-lived visual cues (rings, flashes)
            duckFlocks: [], // active duck swoop entities (Duck Dynasty)
            // Active reality-distortion fields (used by Reality Break)
            activeRealityFields: [],
            keys: {}, lastAttack: 0, roomCleared: false,
            shotCounter: 0, totalKills: 0, roomsCleared: 0, chestsOpened: 0,
            screenShake: 0, screenShakeIntensity: 0, paused: false,
            sfxEnabled: true,
            musicEnabled: true,
            showFps: false,
            // Potato Mode: aggressively disable non-essential FX for performance
            potatoMode: false,
            disableCosmeticParticles: false, // legacy flag (kept for compatibility)
            // Performance / FX dynamic control
            perf: { frameTimes: [], lastFpsSample: performance.now(), fps: 60, lowFx:false, autoLowFx:true },
            // Fine-grained FX flags (toggled via F3)
            fxFlags: { hideSparks: false, hideSpokes: false, reduceRings: false, reduceBeams: false },
            fxSuppression: { particleSkip: 0 },
            _roomSpawnedEnemies: 0,
            _restartGraceFrames: 0,
            nextDuckFlockFrame: 0 // scheduling for Duck Dynasty flocks
        };
    
        // === Projectile System (Phase 2: Structure-of-Arrays) ===
        (function initProjectileSoA(){
            // Bit flag layout (8 bits for now; expand to Uint16 if needed):
            // 1<<0 SINE, 1<<1 WACKY, 1<<2 EKG, 1<<3 SPIRAL, 1<<4 TELEPORT, 1<<5 HOMING, 1<<6 BOUNCE, 1<<7 RESERVED
            const FLAG = {
                SINE:1, WACKY:2, EKG:4, SPIRAL:8, TELEPORT:16, HOMING:32, BOUNCE:64
            };
            const MAX = 6000; // increased after pooling test; adjust with perf data
            // Core numeric channels
            const x = new Float32Array(MAX);
            const y = new Float32Array(MAX);
            const vx = new Float32Array(MAX);
            const vy = new Float32Array(MAX);
            const life = new Uint16Array(MAX);      // remaining life frames
            const lifeMax = new Uint16Array(MAX);   // original life for fade calculations
            const radius = new Uint8Array(MAX);     // <= 255 px (plenty)
            const damage = new Uint16Array(MAX);    // allows big crits
            const flags = new Uint8Array(MAX);
            const colorIdx = new Uint8Array(MAX);   // index into palette
            const targetId = new Int16Array(MAX);   // -1 if none
            const type = new Uint8Array(MAX);       // generic type bucket
            // Active slots bookkeeping
            const alive = new Uint8Array(MAX); // 0 = free, 1 = active
            const freeStack = new Uint32Array(MAX);
            let freeTop = MAX; // points to next free index (stack style)
            for (let i=0;i<MAX;i++) freeStack[i]=i; // fill stack
            let activeCount = 0;
            // Palette (basic for now) - could be expanded or dynamic
            const palette = ['#fff','#ffec6a','#ff6a6a','#6affd2','#6aa8ff','#b86aff'];
            // Export references
            game.projectilesSoA = { x,y,vx,vy,life,lifeMax,radius,damage,flags,colorIdx,targetId,type,alive,FLAG,MAX };
            game.projectilePool = { max: MAX, active:()=>activeCount, free:()=>freeTop };
            // Provide a pool reset hook so room transitions/full resets can cleanly clear all indices
            game.resetProjectilePool = function(){
                for (let i=0;i<MAX;i++) { alive[i]=0; freeStack[i]=i; }
                freeTop = MAX; activeCount = 0;
                // Clear meta if present
                if (game._projMeta && game._projMeta.clear) game._projMeta.clear();
            };
            // Spawn using template
            function spawnProjectile(t){
                if (freeTop === 0) return -1; // pool exhausted
                const idx = freeStack[--freeTop];
                alive[idx]=1; activeCount++;
                // Clear any stale metadata associated with this index to avoid inheriting flags
                // like timeBomb/smartExplosive/chainExplosion from a previous occupant.
                if (game._projMeta && game._projMeta.has(idx)) {
                    try { game._projMeta.delete(idx); } catch(_) {}
                }
                x[idx] = t.x || 0; y[idx] = t.y || 0;
                vx[idx] = t.vx || 0; vy[idx] = t.vy || 0;
                const r = t.r || t.radius || 3; radius[idx] = r > 255?255:r;
                const lf = t.life || t.maxLife || 120; life[idx]=lf; lifeMax[idx]=lf;
                damage[idx] = t.damage || 1;
                // compose flags
                let f=0; if (t.sineWave) f|=FLAG.SINE; if (t.wackyZigzag) f|=FLAG.WACKY; if (t.ekgWave) f|=FLAG.EKG; if (t.spiralPattern) f|=FLAG.SPIRAL; if (t.teleporting) f|=FLAG.TELEPORT; if (t.homing) f|=FLAG.HOMING; if (t.bouncing) f|=FLAG.BOUNCE;
                flags[idx]=f;
                // naive color mapping (extend later with lookups on damageType / weaponType)
                let cIndex = 0;
                if (t.damageType === 'fire') cIndex=1; else if (t.damageType==='shadow') cIndex=2; else if (t.damageType==='void') cIndex=5; else if (t.damageType==='frost') cIndex=4;
                colorIdx[idx]= cIndex < palette.length? cIndex : 0;
                targetId[idx] = (t.targetId!=null)? t.targetId : -1;
                type[idx] = t.type || 0;
                return idx;
            }
            function recycle(idx){
                if (!alive[idx]) return;
                alive[idx]=0; freeStack[freeTop++]=idx; activeCount--; 
                // Also drop any metadata for this slot so future spawns start clean
                if (game._projMeta && game._projMeta.has(idx)) {
                    try { game._projMeta.delete(idx); } catch(_) {}
                }
            }
            // Precompute trig lookup tables to avoid repeated Math.sin/Math.cos in tight loop
            const TRIG_STEPS = 512; // power of two for cheap masking
            const SIN_TABLE = new Float32Array(TRIG_STEPS);
            const COS_TABLE = new Float32Array(TRIG_STEPS);
            for (let i=0;i<TRIG_STEPS;i++){ const a = (i/TRIG_STEPS)*Math.PI*2; SIN_TABLE[i]=Math.sin(a); COS_TABLE[i]=Math.cos(a); }
            const SIN_MASK = TRIG_STEPS - 1;
            // Helper fast sin/cos with wrapping index (expects non-negative integer input)
            function fsin(idx){ return SIN_TABLE[idx & SIN_MASK]; }
            function fcos(idx){ return COS_TABLE[idx & SIN_MASK]; }
            // Update routine (basic physics + life decrement + simple homing stub)
            function updateProjectiles(dt){
                // Adaptive degradation tiers based on active projectile count
                // Tier 0: < 800 full features
                // Tier 1: 800-1499 reduce sine/wacky amplitude
                // Tier 2: 1500-2499 skip EKG and halve spiral step
                // Tier 3: >= 2500 disable all pattern extras & homing micro-adjust
                let activeNow = activeCount;
                let tier = 0;
                if (activeNow >= 2500) tier = 3; else if (activeNow >= 1500) tier = 2; else if (activeNow >= 800) tier = 1;
                game.projectileDegradeTier = tier;
                // Make Sine Wave much more visible and wild
                // tier 0: extreme; tier 1: very strong; tier 2: strong; tier 3: disabled
                const sineScale = tier === 0 ? 7.0 : tier === 1 ? 4.0 : (tier === 2 ? 2.0 : 0.0);
                // Make Wacky Shot clearly visible; still disable at highest load (tier 3)
                const wackyScale = tier === 0 ? 1.0 : tier === 1 ? 0.65 : (tier === 2 ? 0.35 : 0.0);
                const ekgEnabled = tier < 2;
                const spiralScale = tier < 2 ? 0.5 : (tier === 2 ? 0.25 : 0);
                // Stronger homing: raise base scale significantly (still disabled at highest degradation tier)
                const baseHomingScale = tier < 3 ? 1.6 : 0.0;
                for (let i=0;i<MAX;i++){
                    if (!alive[i]) continue;
                    // Fetch metadata early for special handling
                    const meta = game._projMeta && game._projMeta.get(i);
                    // Record last-frame position for movement-based logic that can't trust vx/vy due to additive patterns
                    if (meta) { meta._lastX = x[i]; meta._lastY = y[i]; }
                    // Note: Time Bomb visuals are handled in renderProjectiles();
                    // update loop only manages physics and timers below.
                    // Indestructible projectiles (e.g., Tumbleweed, Kick the Can): never expire by life
                    if (life[i]===0){
                        if (meta && meta.indestructible) {
                            life[i] = Math.max(life[i], 60000);
                            lifeMax[i] = Math.max(lifeMax[i], 60000);
                        } else {
                            // SIGMA stage 3: detonate on expiry with a strong splash
                            if (meta && meta.sigma3) {
                                const baseDmg = (meta.baseDamage || (damage && damage[i]) || (typeof calculateDamage==='function' && calculateDamage()) || 12);
                                // Compute an explosion radius that matches the on-screen sigma3 sprite/aura
                                let expR = meta._auraRadius;
                                if (typeof expR !== 'number' || !isFinite(expR)) {
                                    // Fallback compute similar to the aura sizing (based on logical view size)
                                    const vw = (typeof LOGICAL_W !== 'undefined' ? LOGICAL_W : (ctx && ctx.canvas && ctx.canvas.width) || 800);
                                    const vh = (typeof LOGICAL_H !== 'undefined' ? LOGICAL_H : (ctx && ctx.canvas && ctx.canvas.height) || 600);
                                    const target = Math.min(vw, vh) * 0.20; // image width target
                                    expR = Math.max(24, target * 0.48);
                                }
                                // Use antimatter-style explosion with custom radius and knockback
                                explodeProjectile({ x: x[i], y: y[i], explosionRadius: expR, antimatter: true, knockback: true }, baseDmg);
                                // Small extra sparkle on detonation (perf-aware)
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                if (!lowFx) for (let p=0;p<6;p++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#BBD7FF','spark');
                            }
                            // Default expire pop cue for standard bullets (skip if beams/enemy)
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings && !(meta && (meta.beam || meta.enemy))) {
                                addParticle(x[i], y[i], '#FFE6CC','ring');
                            }
                            recycle(i); continue;
                        }
                    }
                    if (!(meta && meta.indestructible)) {
                        life[i]--;
                    } else {
                        // Keep a healthy life window to avoid edge cases
                        if (life[i] < 59000) life[i] = 60000;
                        if (lifeMax[i] < 60000) lifeMax[i] = 60000;
                    }
                    // Subtle friction for Tumbleweed/Kick the Can so it coasts to a stop unless re-kicked
                    if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                        const fr = Math.pow(0.992, dt || 1);
                        vx[i] *= fr; vy[i] *= fr;
                        const sp = Math.hypot(vx[i], vy[i]);
                        if (sp < 0.05) { vx[i] = 0; vy[i] = 0; }
                    }
                    // Decay short-lived UI/telegraph timers on metadata
                    if (meta) {
                        if (meta._pierceWarn) { meta._pierceWarn--; if (meta._pierceWarn < 0) meta._pierceWarn = 0; }
                        if (meta._pierceFlash) { meta._pierceFlash--; if (meta._pierceFlash < 0) meta._pierceFlash = 0; }
                        if (meta._bounceFlash) { meta._bounceFlash--; if (meta._bounceFlash < 0) meta._bounceFlash = 0; }
                        // SIGMA stage 3 spinner: accumulate spin and keep stationary
                        if (meta.sigma3) {
                            meta._age = (meta._age||0) + 1;
                            meta._spin = (meta._spin||0) + (meta._spinRate||0.28);
                            // Hold position (in case something injected velocity)
                            vx[i] = 0; vy[i] = 0;
                            // Periodic subtle ring cue while spinning (perf-aware)
                            if (meta._age % 20 === 0) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings && !lowFx) addParticle(x[i], y[i], '#BBD7FF','ring');
                            }
                        }
                    }
                    // Resonant Pulse Core (SoA): emit periodic expanding rings that buff nearby projectiles
                    if (meta && meta.resonantPulseCore && !meta.enemy && !meta.beam && !meta._orbital) {
                        meta._resCoreTimer = (meta._resCoreTimer||0) + 1;
                        const interval = 60; // was 90  trigger sooner
                        if (meta._resCoreTimer >= interval) {
                            meta._resCoreTimer = 0;
                            if (!meta._resActiveRings) meta._resActiveRings = [];
                            meta._resActiveRings.push({ r:0, max:150, life:38 });
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!lowFx && !hideSparks) {
                                for (let k=0;k<6;k++) addParticle(x[i] + (Math.random()-0.5)*16, y[i] + (Math.random()-0.5)*16, '#C7A4FF','spark');
                            }
                        }
                        // Update active rings and apply buffs to both SoA and object-mode projectiles
                        if (meta._resActiveRings && meta._resActiveRings.length) {
                            for (let ri=meta._resActiveRings.length-1; ri>=0; ri--) {
                                const ring = meta._resActiveRings[ri];
                                ring.r += (ring.max - ring.r) * 0.18;
                                ring.life--;
                                const rad2 = ring.r * ring.r;
                                // SoA projectiles
                                for (let j=0;j<MAX;j++) {
                                    if (!alive[j] || j===i) continue;
                                    const dxj = x[j]-x[i]; const dyj = y[j]-y[i];
                                    if (dxj*dxj + dyj*dyj <= rad2) {
                                        let m2 = game._projMeta && game._projMeta.get(j);
                                        if (!m2) { m2 = {}; if (!game._projMeta) game._projMeta = new Map(); game._projMeta.set(j, m2); }
                                        if (m2.enemy || m2.beam) continue;
                                        m2._resBuffSpeed = Math.max(m2._resBuffSpeed||0, 26);
                                        m2._resBuffDamage = Math.max(m2._resBuffDamage||0, 30);
                                        m2._resBuffHoming = Math.max(m2._resBuffHoming||0, 24);
                                        const lowFx = !!(game.perf && game.perf.lowFx);
                                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                        if (!lowFx && !hideSparks) addParticle(x[j], y[j], '#C7A4FF','spark');
                                    }
                                }
                                // Object-mode projectiles (if any)
                                if (Array.isArray(game.projectiles)) {
                                    for (let p=0;p<game.projectiles.length;p++) {
                                        const p2 = game.projectiles[p];
                                        if (!p2 || p2===meta || p2.enemy || p2.beam) continue;
                                        const dxp = p2.x - x[i]; const dyp = p2.y - y[i];
                                        if (dxp*dxp + dyp*dyp <= rad2 && !p2._resBuffedFrame) {
                                            p2._resBuffedFrame = game._frameCount || performance.now();
                                            p2._resBuffSpeed = Math.max(p2._resBuffSpeed||0, 26);
                                            p2._resBuffDamage = Math.max(p2._resBuffDamage||0, 30);
                                            p2._resBuffHoming = Math.max(p2._resBuffHoming||0, 24);
                                            const lowFx = !!(game.perf && game.perf.lowFx);
                                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                            if (!lowFx && !hideSparks) addParticle(p2.x, p2.y, '#C7A4FF','spark');
                                        }
                                    }
                                }
                                if (ring.life <= 0 || ring.r > ring.max*0.98) meta._resActiveRings.splice(ri,1);
                            }
                        }
                    }
                    // Sigma3 aura + sprite contact: visual radius is stable; hit radius is larger to ensure reliable contact
                    if (meta && meta.sigma3) {
                        // Visual radius ~ 10% of min logical dimension (width ~ 20% of screen's min side)
                        const vw = (typeof LOGICAL_W !== 'undefined' ? LOGICAL_W : (ctx && ctx.canvas && ctx.canvas.width) || 800);
                        const vh = (typeof LOGICAL_H !== 'undefined' ? LOGICAL_H : (ctx && ctx.canvas && ctx.canvas.height) || 600);
                        const minSide = Math.min(vw, vh);
                        const visualR = Math.max(24, minSide * 0.10);
                        // Expanded collision radius: substantially larger than visuals to catch edge grazes
                        const hitR = Math.floor(visualR * 2.0);
                        // Set SoA collision radius to expanded hit radius
                        if (radius && radius[i] != null) {
                            radius[i] = hitR;
                        }
                        // Persist visual radius (not hit radius) for consistent explosion sizing and sprite drawing
                        meta._auraRadius = visualR;

                        // Per-frame contact damage: light tick so brushing any part of the spinner hurts immediately
                        {
                            const base = meta.baseDamage || (damage && damage[i]) || (typeof calculateDamage==='function' && calculateDamage()) || 10;
                            const touch = Math.max(1, Math.floor(base * 0.18));
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const en = game.enemies[ei]; if (!en || en.health<=0) continue;
                                const dx = en.x - x[i]; const dy = en.y - y[i];
                                if (dx*dx + dy*dy <= hitR*hitR) {
                                    en.health -= touch;
                                    addDamageNumber(touch, en.x, en.y - en.size/2, { type: 'void' });
                                    addParticle(en.x, en.y, '#BBD7FF','impact');
                                }
                            }
                        }

                        // Aura cadence: every 8 frames apply a heavier pulse
                        meta._auraTick = (meta._auraTick||0) + 1;
                        if (meta._auraTick % 8 === 0) {
                            const base = meta.baseDamage || (damage && damage[i]) || (typeof calculateDamage==='function' && calculateDamage()) || 10;
                            const touch = Math.max(2, Math.floor(base * 0.35));
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const en = game.enemies[ei]; if (!en || en.health<=0) continue;
                                const dx = en.x - x[i]; const dy = en.y - y[i];
                                const dist2 = dx*dx + dy*dy;
                                if (dist2 <= hitR*hitR) {
                                    en.health -= touch;
                                    addDamageNumber(touch, en.x, en.y - en.size/2, { type: 'void' });
                                    addParticle(en.x, en.y, '#BBD7FF','impact');
                                }
                            }
                        }
                    }
                    let dx = vx[i];
                    let dy = vy[i];
                    const prevX = x[i];
                    const prevY = y[i];
                    const f = flags[i];
                    // Replace small-range sin calls with table lookups. We map phases by scaling counters.
                    if (sineScale && (f & FLAG.SINE)) {
                        // Stronger sinusoidal motion perpendicular to current velocity for readability
                        const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                        const px = -vy[i]/sp, py = vx[i]/sp; // perpendicular unit vector
                        // Per-projectile sine parameters for variability (seed once)
                        let m = game._projMeta && game._projMeta.get(i);
                        if (!m) { if (!game._projMeta) game._projMeta = new Map(); m = {}; game._projMeta.set(i, m); }
                        if (m._sineSeed == null) {
                            m._sineSeed = (Math.random()*1024)|0;
                            // Amplitude multiplier 0.851.35; frequency multiplier 0.71.4
                            m._sineAmp = 0.85 + Math.random()*0.50;
                            m._sineFreq = 0.70 + Math.random()*0.70;
                            // Slow amplitude drift to make motion feel organic
                            m._sineDriftRate = 0.007 + Math.random()*0.010; // radians per frame
                            m._sineDriftAmp = 0.25 + Math.random()*0.45;    // 0.250.70 of base
                        }
                        const basePhase = ( (life[i] * 41 * m._sineFreq) + m._sineSeed ) & SIN_MASK;
                        const drift = 1 + m._sineDriftAmp * fsin( ((game.frame||0) * m._sineDriftRate) & SIN_MASK );
                        const wobble = fsin(basePhase) * sineScale * m._sineAmp * drift;
                        dx += px * wobble;
                        dy += py * wobble;
                        // Crest cue (perf-aware)
                        const metaV = game._projMeta && game._projMeta.get(i);
                        if (metaV) {
                            metaV._sineCueCd = (metaV._sineCueCd||0) - 1;
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !reduceRings && Math.abs(wobble / (sineScale||1)) > 0.98 && metaV._sineCueCd <= 0) {
                                addParticle(x[i], y[i], '#AEEFFF','ring');
                                metaV._sineCueCd = 22;
                            }
                        }
                    }
                    if (wackyScale && (f & FLAG.WACKY)) {
                        // Wacky: straight segments with discrete random direction snaps (no jitter)
                        const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                        const fx = vx[i]/sp, fy = vy[i]/sp; // forward unit (for relative pivots & cue)
                        const px = -fy, py = fx;            // perpendicular unit
                        let m = game._projMeta && game._projMeta.get(i);
                        if (!m) { if (!game._projMeta) game._projMeta = new Map(); m = {}; game._projMeta.set(i, m); }
                        if (!m._wackySnapInit) {
                            m._wackySnapInit = true;
                            // Timer: ~0.3s between direction changes based on measured FPS
                            const fps = (game.perf && game.perf.fps) || 60;
                            const baseFrames = Math.max(2, Math.round(fps * 0.30));
                            m._wHold = baseFrames + ((Math.random()*4|0) - 2); // small variation 2 frames
                            m._wLocal = true;
                            m._wAngle = 0;
                        }
                        // Countdown and pivot on expiry
                        m._wHold--;
                        if (m._wHold <= 0) {
                            // Choose absolute vs relative pivot
                            m._wLocal = Math.random() >= 0.25; // 75% relative, 25% absolute for broader coverage
                            if (m._wLocal) {
                                // Relative pivot up to 150
                                const range = 2.62; // ~150 in radians
                                m._wAngle = (Math.random()*2 - 1) * range;
                            } else {
                                // Absolute new heading in full 360
                                m._wAngle = (Math.random()*Math.PI*2) - Math.PI;
                            }
                            // Reset hold to ~0.3s with tiny randomness
                            const fps = (game.perf && game.perf.fps) || 60;
                            const baseFrames = Math.max(2, Math.round(fps * 0.30));
                            m._wHold = baseFrames + ((Math.random()*4|0) - 2);

                            // Compute target direction
                            let tx, ty;
                            if (m._wLocal) {
                                const c = Math.cos(m._wAngle), s = Math.sin(m._wAngle);
                                tx = fx * c + px * s; ty = fy * c + py * s;
                            } else {
                                tx = Math.cos(m._wAngle); ty = Math.sin(m._wAngle);
                            }
                            // Normalize and snap velocity to preserve speed
                            const n = Math.hypot(tx, ty) || 1; tx /= n; ty /= n;
                            const newVx = tx * sp, newVy = ty * sp;
                            // Snap underlying velocity
                            vx[i] = newVx; vy[i] = newVy;
                            // Also override this frame's displacement so the turn is visible immediately
                            dx = newVx; dy = newVy;

                            // Visual cue only on pivots (perf-aware)
                            const metaV = game._projMeta && game._projMeta.get(i);
                            if (metaV) {
                                metaV._wackyCueCd = (metaV._wackyCueCd||0) - 1;
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!lowFx && metaV._wackyCueCd <= 0) {
                                    if (!hideSparks) addParticle(x[i], y[i], '#CCEEFF','spark');
                                    else if (!reduceRings) addParticle(x[i], y[i], '#CCEEFF','ring');
                                    metaV._wackyCueCd = 10;
                                }
                            }
                        }
                    }
                    // EKG path-relative oscillation (perpendicular to motion):
                    // - Subtle baseline jitter around centerline + occasional large spike outward on a locked side.
                    // - Spikes always go to the same perpendicular side per projectile (no large downward spikes).
                    const metaE = game._projMeta && game._projMeta.get(i);
                    const hasEkg = ((f & FLAG.EKG) || (metaE && metaE.ekgWave));
                    if (hasEkg) {
                        // Per-projectile state in meta map
                        let m = game._projMeta && game._projMeta.get(i);
                        if (!m) { if (!game._projMeta) game._projMeta = new Map(); m = {}; game._projMeta.set(i, m); }
                        if (!m._ekgSmInit) {
                            m._ekgSmInit = true;
                            m._ekgState = 'baseline'; // baseline -> pre -> asc -> desc -> recover
                            m._ekgTimer = 0;
                            m._ekgSeed = Math.random() * Math.PI * 2;
                            m._ekgLastOffset = 0;
                            // Baseline jitter and spike amplitudes
                            m._ekgJitter = 0.8;
                            m._ekgSmallAmp = 3.0 + Math.random()*1.5; // ~3.04.5px
                            m._ekgBigAmp = 12 + Math.random()*6;      // ~1218px
                            // Uniform scale-up so jitter and spikes increase equally
                            const EKG_SCALE = 3.8; // ~+27% stronger scale for jitter + spikes
                            m._ekgJitter *= EKG_SCALE;
                            m._ekgSmallAmp *= EKG_SCALE;
                            m._ekgBigAmp *= EKG_SCALE;
                            m._ekgUseAmp = m._ekgSmallAmp;
                            m._ekgPreDur = 1; // brief telegraph
                            m._ekgAscDur = 4; // longer rise for visibility
                            m._ekgDescDur = 4; // longer fall
                            m._ekgRecoverDur = 1; // one frame settle
                            m._ekgNextSpike = 6 + (Math.random()*6|0); // slightly earlier cadence
                            // Ensure at least one large spike happens early
                            m._ekgGuaranteeBigAt = 6 + ((Math.random()*8)|0);
                            m._ekgBigDone = false;
                            // Lock a perpendicular basis so the big spike has a consistent "up" side for this projectile
                            const sv = Math.hypot(vx[i], vy[i]) || 0.0001;
                            let px0 = -vy[i]/sv, py0 = vx[i]/sv;
                            // Force spikes towards screen-up side: ensure negative Y component
                            if (py0 > 0) { px0 = -px0; py0 = -py0; }
                            m._ekgPx = px0; m._ekgPy = py0;
                            // Ensure at least one spike happens soon after spawn
                            m._ekgGuaranteeAt = 8 + ((Math.random()*10)|0);
                            m._ekgSpikedOnce = false;
                        }
                        m._ekgTimer++;
                        let offset = 0; // target perpendicular offset (px)
                        const st = m._ekgState;
                        if (st === 'baseline') {
                            // Two-phase tiny jitter so it feels alive but stays near 0
                            const a = Math.sin((life[i]*3.1) + m._ekgSeed) * (m._ekgJitter*0.7);
                            const b = Math.sin((life[i]*1.7) + m._ekgSeed*0.53) * (m._ekgJitter*0.3);
                            offset = a + b;
                            if (m._ekgTimer >= m._ekgNextSpike || (!m._ekgSpikedOnce && m._ekgTimer >= m._ekgGuaranteeAt)) {
                                // Decide spike amplitude: large if guarantee window hit or random chance
                                if (!m._ekgBigDone && m._ekgTimer >= m._ekgGuaranteeBigAt) {
                                    m._ekgUseAmp = m._ekgBigAmp; m._ekgBigDone = true;
                                } else {
                                    m._ekgUseAmp = (Math.random() < 0.18 ? m._ekgBigAmp : m._ekgSmallAmp);
                                    if (m._ekgUseAmp === m._ekgBigAmp) m._ekgBigDone = true;
                                }
                                m._ekgState = 'pre'; m._ekgTimer = 0;
                            }
                        } else if (st === 'pre') {
                            // Brief, tiny telegraph
                            const t = m._ekgTimer / Math.max(1,m._ekgPreDur);
                            const teleAmp = m._ekgJitter * (0.8 + t*0.4);
                            offset = Math.sin(m._ekgTimer*3.4 + m._ekgSeed) * teleAmp;
                            if (m._ekgTimer >= m._ekgPreDur) { m._ekgState = 'asc'; m._ekgTimer = 0; }
                        } else if (st === 'asc') {
                            // Linear rise to small peak
                            const t = Math.min(1, m._ekgTimer / m._ekgAscDur);
                            // Always spike to the positive side of our locked perpendicular (screen-up)
                            offset = Math.abs(m._ekgUseAmp) * t;
                            if (m._ekgTimer >= m._ekgAscDur) { m._ekgState = 'desc'; m._ekgTimer = 0; m._ekgSpikedOnce = true; }
                        } else if (st === 'desc') {
                            // Linear fall back to baseline (no undershoot)
                            const t = Math.min(1, m._ekgTimer / m._ekgDescDur);
                            offset = Math.abs(m._ekgUseAmp) * (1 - t);
                            if (m._ekgTimer >= m._ekgDescDur) { m._ekgState = 'recover'; m._ekgTimer = 0; }
                        } else if (st === 'recover') {
                            // Snap to baseline
                            const t = Math.min(1, m._ekgTimer / Math.max(1,m._ekgRecoverDur));
                            offset = m._ekgLastOffset * (1 - t);
                            if (m._ekgTimer >= m._ekgRecoverDur) {
                                m._ekgState = 'baseline';
                                m._ekgTimer = 0;
                                m._ekgLastOffset = 0; // hard reset baseline
                                m._ekgNextSpike = 10 + (Math.random()*8|0);
                            }
                        }
                        // Apply along locked perpendicular direction to keep spikes path-relative
                        let delta = offset - (m._ekgLastOffset || 0);
                        m._ekgLastOffset = offset;
                        // Clamp per-frame step: allow larger steps during spikes for visibility
                        const isSpike = (st === 'asc' || st === 'desc');
                        // Dynamic step clamp during spikes based on target amplitude and phase duration
                        let maxStep;
                        if (isSpike) {
                            const amp = Math.abs(m._ekgUseAmp || 0);
                            const dur = Math.max(1, (st === 'asc' ? m._ekgAscDur : m._ekgDescDur));
                            maxStep = Math.min(31, Math.max(7.7, (amp / dur) * 1.4));
                        } else {
                            maxStep = 2.05; // baseline clamp scaled up ~28% to match amplitude increase
                        }
                        if (delta > maxStep) delta = maxStep; else if (delta < -maxStep) delta = -maxStep;
                        // Directly adjust position perpendicular to motion; scale spikes a bit more
                        const scale = isSpike ? 1.0 : 0.85;
                        const px = (m._ekgPx != null && m._ekgPy != null) ? m._ekgPx : (function(){ const sv=Math.hypot(vx[i],vy[i])||0.0001; return -vy[i]/sv; })();
                        const py = (m._ekgPx != null && m._ekgPy != null) ? m._ekgPy : (function(){ const sv=Math.hypot(vx[i],vy[i])||0.0001; return vx[i]/sv; })();
                        x[i] += px * delta * scale;
                        y[i] += py * delta * scale;
                        // Visual cue at spike apex for readability (fires on entering 'desc')
                        if (st === 'desc' && m._ekgTimer === 0) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx) addParticle(x[i], y[i], '#66FFCC', 'spark');
                        }
                    }
                    // Temporal Drift (SoA): significantly stronger cadence that adjusts BOTH current displacement and underlying velocity
                    if (meta && meta.temporalDrift && !meta.enemy && !meta.beam) {
                        if (!meta._tdInit) {
                            meta._tdInit = true; meta._tdPhase = 0; meta._tdTimer = 0;
                            // Capture a base speed reference for clamping during surge/slow phases
                            const sp0 = Math.hypot(vx[i], vy[i]) || 0.0001;
                            meta._tdBaseSpeed = sp0;
                            // On-spawn ripple cue (fallback to particle ring if transient system unavailable)
                            const col = '#9FE6FF';
                            if (typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:x[i], y:y[i], color: col, radius: Math.max(10, (radius[i]||6) * 1.2), life: 120 });
                            } else {
                                addParticle(x[i], y[i], col, 'ring');
                            }
                        }
                        meta._tdTimer++;
                        const phase = meta._tdPhase;
                        if (phase === 0) { // slow-stretch (heavier decel, a bit longer)
                            const f = 0.94; // was 0.975  make it clearly slower
                            dx *= f; dy *= f; vx[i] *= f; vy[i] *= f;
                            // Clamp not to stall below 55% of base speed
                            const base = meta._tdBaseSpeed || (Math.hypot(vx[i], vy[i])||0.0001);
                            const spNow = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const minSp = base * 0.55;
                            if (spNow < minSp) { const s = (minSp / spNow); vx[i]*=s; vy[i]*=s; dx*=s; dy*=s; }
                            if (meta._tdTimer > 30) { meta._tdPhase = 1; meta._tdTimer = 0; }
                        } else if (phase === 1) { // hold (shorter)
                            if (meta._tdTimer > 10) { meta._tdPhase = 2; meta._tdTimer = 0; }
                        } else if (phase === 2) { // surge (stronger accel, slightly longer)
                            const f = 1.08; // was 1.035  make it pop
                            dx *= f; dy *= f; vx[i] *= f; vy[i] *= f;
                            // Clamp to max 2.0x base speed
                            const base = meta._tdBaseSpeed || (Math.hypot(vx[i], vy[i])||0.0001);
                            const spNow = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const maxSp = base * 2.0;
                            if (spNow > maxSp) { const s = (maxSp / spNow); vx[i]*=s; vy[i]*=s; dx*=s; dy*=s; }
                            if (meta._tdTimer > 18) { meta._tdPhase = 0; meta._tdTimer = 0; }
                        }
                        // Pre-beat ring in final frames before phase swap
                        const th = phase === 0 ? 30 : (phase === 1 ? 10 : 18);
                        if (meta._tdTimer >= th - 3) {
                            // Always spawn a minimal ring and, when allowed, a brighter ramping ring
                            const col = phase===2 ? '#A4F5FF' : '#7EDCFF';
                            addParticle(x[i], y[i], col, 'ring');
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings) addParticle(x[i], y[i], col, 'ring');
                        }
                    }
                    // Pendulum swing flip detection: ring cue on sign change of lateral component
                    {
                        const metaP = game._projMeta && game._projMeta.get(i);
                        if (metaP && metaP.pendulumPattern) {
                            // Build perpendicular to spawn forward
                            const fx0 = metaP._initialFx != null ? metaP._initialFx : (vx[i]||1)/Math.hypot(vx[i]||1,vy[i]||0.0001);
                            const fy0 = metaP._initialFy != null ? metaP._initialFy : (vy[i]||0)/Math.hypot(vx[i]||1,vy[i]||0.0001);
                            const px0 = -fy0, py0 = fx0;
                            const lat = dx*px0 + dy*py0; // lateral component this frame
                            const sign = lat >= 0 ? 1 : -1;
                            const prev = metaP._pendPrevSign == null ? sign : metaP._pendPrevSign;
                            metaP._pendPrevSign = sign;
                            metaP._pendCd = (metaP._pendCd||0) - 1;
                            if (sign !== prev && metaP._pendCd <= 0) {
                                metaP._pendCue = 10; // frames to display
                                metaP._pendCd = 14;  // cooldown
                            }
                            if (metaP._pendCue>0) metaP._pendCue--;
                        }
                    }
                    // Vector Pivot: periodic 90 turns with a brief pre-telegraph; choose left/right randomly each turn
                    {
                        const metaV = game._projMeta && game._projMeta.get(i);
                        if (metaV && metaV.pivotPattern && !metaV.beam && !metaV.enemy) {
                            if (!metaV._pivotInit) {
                                metaV._pivotInit = true;
                                metaV._pivotSeg = 16;           // frames between pivots
                                metaV._pivotTimer = metaV._pivotSeg;
                                metaV._pivotDir = (Math.random() < 0.5 ? -1 : 1); // initial side
                                metaV._pivotAngle = Math.PI * 0.5; // 90
                                metaV._pivotCue = 0;
                                // Remember initial forward
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                metaV._pivotFx = vx[i]/sp; metaV._pivotFy = vy[i]/sp;
                            }
                            metaV._pivotTimer--;
                            // pre-telegraph a few frames before the turn
                            if (metaV._pivotTimer === 3) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#DDEBFF','ring');
                            }
                            if (metaV._pivotTimer <= 0) {
                                // Snap-turn velocity by +/- 90; keep speed, add slight boost for readability
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                const ang = Math.atan2(vy[i], vx[i]);
                                const newAng = ang + metaV._pivotDir * metaV._pivotAngle;
                                const newSp = sp * 1.06;
                                const nx = Math.cos(newAng), ny = Math.sin(newAng);
                                vx[i] = nx * newSp;
                                vy[i] = ny * newSp;
                                // Apply immediately to this frame's displacement so turn is visible right away
                                dx = nx; dy = ny;
                                // Visual cue
                                metaV._pivotCue = 10;
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#CFE8FF','ring');
                                // Pick a random side for the next pivot and reset timer
                                metaV._pivotDir = (Math.random() < 0.5 ? -1 : 1);
                                metaV._pivotTimer = metaV._pivotSeg;
                            } else if (metaV._pivotTimer < 0) {
                                metaV._pivotTimer = metaV._pivotSeg;
                            }
                            if (metaV._pivotCue>0) metaV._pivotCue--;
                        }
                    }
                    // Uzumaki global spiral: projectile travels in expanding spiral path centered on player position at spawn.
                    {
                        const mU = game._projMeta && game._projMeta.get(i);
                        if (mU && mU.hasUzumaki && mU._uzuCx != null && mU._uzuCy != null) {
                            if (!mU._uzuInit) {
                                mU._uzuInit = true;
                                // derive starting polar coords from current position
                                const dx0 = x[i] - mU._uzuCx, dy0 = y[i] - mU._uzuCy;
                                const r0 = Math.hypot(dx0, dy0) || (mU._uzuRadius||18);
                                mU._uzuRadius = r0;
                                mU._uzuAngle = Math.atan2(dy0, dx0);
                                // Subtle center ping (perf-aware)
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addTransientEffect({ type:'ringFlash', x:mU._uzuCx, y:mU._uzuCy, color:'#FFEEDD', radius: 22, life: 160 });
                            }
                            // evolve swirl
                            mU._uzuRadius += (mU._uzuRadialVel || 1.5);
                            if (mU._uzuDrag) mU._uzuRadialVel *= (1 - mU._uzuDrag);
                            mU._uzuAngle += (mU._uzuAngularVel || 0.2);
                            if (mU._uzuAngularVel) mU._uzuAngularVel *= 1.003;
                            let targetX = mU._uzuCx + Math.cos(mU._uzuAngle) * mU._uzuRadius;
                            let targetY = mU._uzuCy + Math.sin(mU._uzuAngle) * mU._uzuRadius;
                            // Synergy: if Pendulum is also active, apply a pendulum-style lateral swing around the Uzumaki path
                            if (mU.pendulumPattern && !mU._pendDone) {
                                if (!mU._uzuPendInit) {
                                    mU._uzuPendInit = true;
                                    mU._uzuPendAngle = (Math.random()<0.5?-1:1) * 0.65;
                                    mU._uzuPendVel = 0;
                                    mU._uzuPendLen = 32; // lateral swing extent
                                    mU._uzuPendGrav = 0.065; // swing acceleration
                                    mU._uzuPendDamp = 0.992; // damping
                                }
                                // Approximate tangent along swirl using previous target
                                const prevTx = mU._lastUzuTx != null ? mU._lastUzuTx : prevX;
                                const prevTy = mU._lastUzuTy != null ? mU._lastUzuTy : prevY;
                                const tdx = targetX - prevTx; const tdy = targetY - prevTy;
                                const tl = Math.hypot(tdx, tdy) || 1; const tfx = tdx / tl; const tfy = tdy / tl;
                                // Perpendicular to tangent
                                const px = -tfy, py = tfx;
                                // Integrate pendulum swing
                                const angAcc = -mU._uzuPendGrav * Math.sin(mU._uzuPendAngle);
                                mU._uzuPendVel += angAcc;
                                mU._uzuPendVel *= mU._uzuPendDamp;
                                mU._uzuPendAngle += mU._uzuPendVel;
                                const lateral = Math.sin(mU._uzuPendAngle) * mU._uzuPendLen;
                                targetX += px * lateral;
                                targetY += py * lateral;
                                mU._lastUzuTx = targetX; mU._lastUzuTy = targetY;
                            }
                            // Blend Uzumaki target motion additively with any existing displacement (so it can synergize with Spiral, Sine, etc.)
                            const uzDx = (targetX - prevX) / dt;
                            const uzDy = (targetY - prevY) / dt;
                            // If Spiral is also active, reduce Uzumaki authority a bit so local loops remain visible
                            const uzBlend = ((f & FLAG.SPIRAL) ? 0.40 : 0.60);
                            dx += (uzDx - dx) * uzBlend;
                            dy += (uzDy - dy) * uzBlend;
                            // occasional swirl dust (perf-aware)
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !hideSparks && Math.random() < 0.08) addParticle(x[i], y[i], '#FFAaff', 'swirl');
                        }
                    }
                    // True spiral motion: orbit around a forward-moving anchor to create large circular loops
                    if (f & FLAG.SPIRAL) {
                        // Ensure metadata bucket exists
                        if (!game._projMeta) game._projMeta = new Map();
                        let m = game._projMeta.get(i);
                        if (!m) { m = {}; game._projMeta.set(i, m); }
                        if (!m._spiralInit) {
                            m._spiralInit = true;
                            // Base drift direction from current velocity; fallback to player lastDirection for degenerate cases
                            let ang = Math.atan2(vy[i], vx[i]);
                            if (!isFinite(ang) || (Math.abs(vx[i]) < 0.0001 && Math.abs(vy[i]) < 0.0001)) {
                                const ld = (game.player && game.player.lastDirection) || {x:1,y:0};
                                ang = Math.atan2(ld.y, ld.x);
                            }
                            m._spiralBaseAngle = ang;
                            // Start phase randomized for variety between shots
                            m._spiralPhase = Math.random() * Math.PI * 2;
                            // Larger starting loop radius; allow expansion to a generous cap
                            const startR = Math.max(12, (radius[i] || 6) * 2.2);
                            // Scale radii by performance tier (smaller on high load)
                            const tierScale = (tier===0?1.0:(tier===1?0.85:(tier===2?0.7:0.55)));
                            m._spiralRadius = startR * tierScale;
                            m._spiralRadiusMax = 120 * tierScale;
                            m._spiralRadiusGrowth = 0.10 * tierScale; // px/frame growth
                            // Angular speed for visible loops
                            m._spiralAngularSpeed = (0.28 + Math.random()*0.10) * tierScale;
                            // Forward drift along base direction; damped so loops remain large and readable
                            m._spiralForwardSpeed = (Math.hypot(vx[i], vy[i]) || 2.5) * 0.70;
                            m._spiralAnchorX = x[i];
                            m._spiralAnchorY = y[i];
                            // Spawn ring at start (perf-aware)
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFBBFF','ring');
                        }
                        // Advance spiral state
                        m._spiralPhase += m._spiralAngularSpeed;
                        m._spiralRadius = Math.min(m._spiralRadiusMax, m._spiralRadius + m._spiralRadiusGrowth);
                        m._spiralAnchorX += Math.cos(m._spiralBaseAngle) * m._spiralForwardSpeed * dt;
                        m._spiralAnchorY += Math.sin(m._spiralBaseAngle) * m._spiralForwardSpeed * dt;
                        const newX = m._spiralAnchorX + Math.cos(m._spiralPhase) * m._spiralRadius;
                        const newY = m._spiralAnchorY + Math.sin(m._spiralPhase) * m._spiralRadius;
                        // Blend this frame's displacement toward the spiral path (additive, so it can coexist with Uzumaki/global swirl)
                        const spDx = (newX - prevX) / dt;
                        const spDy = (newY - prevY) / dt;
                        const spBlend = (m && m.hasUzumaki) ? 0.62 : 0.80;
                        dx += (spDx - dx) * spBlend;
                        dy += (spDy - dy) * spBlend;
                        // Rim tick at quadrant change (perf-aware)
                        {
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !reduceRings) {
                                const q = Math.floor((m._spiralPhase || 0) / (Math.PI/2));
                                if (m._spiralLastQuad == null) m._spiralLastQuad = q;
                                if (q !== m._spiralLastQuad) {
                                    m._spiralLastQuad = q;
                                    if (Math.random() < 0.18) addParticle(newX, newY, '#FFAAFF','ring');
                                }
                            }
                        }
                    }
                    // Full Homing Shot uses flag; Seeking Shot (weak homing) is carried via metadata. Both supported here.
                    if (baseHomingScale && (game.enemies && game.enemies.length)) {
                        const metaH = game._projMeta && game._projMeta.get(i);
                        const hasFullHoming = !!(f & FLAG.HOMING);
                        const hasWeakHoming = !!(metaH && metaH.weakHoming);
                        if (!(hasFullHoming || hasWeakHoming)) {
                            // Neither homing mode present  skip
                        } else {
                            // Determine effective scale (weak homing is gentler). Allow per-projectile overrides (e.g., SIGMA).
                            let homingScale = hasFullHoming ? baseHomingScale : (baseHomingScale * 0.5);
                            if (metaH && typeof metaH._sigmaHomingFactor === 'number') {
                                homingScale *= metaH._sigmaHomingFactor;
                            }
                        let bestDx=0,bestDy=0,bestD2=1e12;
                        if (game.enemyHash && game.enemyHash.buckets.size) {
                            const cs = game.enemyHash.cell;
                            const cx0 = (x[i]/cs)|0; const cy0 = (y[i]/cs)|0;
                            for (let cyOff=-1; cyOff<=1; cyOff++){
                                for (let cxOff=-1; cxOff<=1; cxOff++){
                                    const key = ((cx0+cxOff)<<16) ^ (cy0+cyOff);
                                    const bucket = game.enemyHash.buckets.get(key); if(!bucket) continue;
                                    for (let bi=0; bi<bucket.length; bi++){
                                        const e = game.enemies[bucket[bi]]; if(!e || e.dead || e.health<=0) continue;
                                        const tx = e.x - x[i]; const ty = e.y - y[i];
                                        const d2 = tx*tx+ty*ty; if (d2 < bestD2){ bestD2=d2; bestDx=tx; bestDy=ty; }
                                    }
                                }
                            }
                        } else {
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const e = game.enemies[ei]; if(!e || e.dead || e.health<=0) continue;
                                const tx = e.x - x[i]; const ty = e.y - y[i];
                                const d2 = tx*tx+ty*ty; if (d2 < bestD2){ bestD2=d2; bestDx=tx; bestDy=ty; }
                            }
                        }
                        if (bestD2 < 1e12) {
                            const len = Math.sqrt(bestD2)||1;
                            // Apply immediate steering to this frame's displacement
                            dx += (bestDx/len)*homingScale;
                            dy += (bestDy/len)*homingScale;
                            // Also gently bias the underlying velocity toward the steered direction
                            const baseSpeed = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const dlen = Math.hypot(dx, dy) || 1;
                            const dirX = dx / dlen, dirY = dy / dlen;
                            let blend = hasFullHoming ? 0.14 : 0.06; // full homing curves harder
                            if (metaH && typeof metaH._sigmaBlendBoost === 'number') {
                                blend += metaH._sigmaBlendBoost;
                            }
                            vx[i] = vx[i]*(1 - blend) + dirX * baseSpeed * blend;
                            vy[i] = vy[i]*(1 - blend) + dirY * baseSpeed * blend;
                            // Mark active homing window for rendering chevrons
                            if (!game._projMeta) game._projMeta = new Map();
                            const mHAct = metaH || game._projMeta.get(i) || {};
                            mHAct._homActive = Math.min(12, (mHAct._homActive||0) + 2); // short accumulating timer
                            game._projMeta.set(i, mHAct);
                            // Homing steer cue metadata: mark when steering angle changes abruptly
                            if (!game._projMeta) game._projMeta = new Map();
                            let mHMeta = metaH; if (!mHMeta) { mHMeta = {}; game._projMeta.set(i, mHMeta); }
                            const aNow = Math.atan2(dy, dx);
                            if (isFinite(aNow)) {
                                if (mHMeta._homLastAng == null) mHMeta._homLastAng = aNow;
                                let dAng = aNow - mHMeta._homLastAng; while (dAng > Math.PI) dAng -= Math.PI*2; while (dAng < -Math.PI) dAng += Math.PI*2;
                                mHMeta._homCd = (mHMeta._homCd||0) - 1;
                                if (Math.abs(dAng) > 0.40 && (mHMeta._homCd||0) <= 0) { // ~23
                                    mHMeta._homCue = 8; // frames to render chevron
                                    mHMeta._homCd = 14; // cooldown
                                    // Ping ring on current target (perf-aware, skip if reduceRings)
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!lowFx && !reduceRings) {
                                        // find best target again quickly (cheap reuse bestDx/bestDy we already have)
                                        const tx = x[i] + bestDx; const ty = y[i] + bestDy;
                                        addParticle(tx, ty, '#B4F5FF','ring');
                                    }
                                }
                                mHMeta._homLastAng = aNow;
                            }
                        }
                        }
                    }
                    // Decay homing steer cue timers if present
                    {
                        const mH2 = game._projMeta && game._projMeta.get(i);
                        if (mH2) {
                            if (mH2._homCue>0) mH2._homCue--;
                            if (mH2._homCd>0) mH2._homCd--;
                            if (mH2._homActive>0) mH2._homActive--;
                        }
                    }
                    // Apply Resonant Pulse buffs (SoA) just before integrating movement
                    if (meta) {
                        if (meta._resBuffSpeed && meta._resBuffSpeed>0) {
                            meta._resBuffSpeed--;
                            dx *= 1.045; dy *= 1.045;
                        }
                        if (meta._resBuffHoming && meta._resBuffHoming>0) {
                            meta._resBuffHoming--;
                            // mild steering toward nearest enemy
                            let nd2 = Infinity, bx = 0, by = 0;
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const e = game.enemies[ei]; if(!e || e.dead || e.health<=0) continue;
                                const tx = e.x - x[i]; const ty = e.y - y[i]; const d2 = tx*tx+ty*ty; if (d2<nd2){ nd2=d2; bx=tx; by=ty; }
                            }
                            if (nd2 < 1e12) {
                                const len = Math.sqrt(nd2)||1; dx += (bx/len)*0.12; dy += (by/len)*0.12;
                            }
                        }
                        if (meta._resBuffDamage && meta._resBuffDamage>0) {
                            // Apply temporary SoA damage boost while timer remains and decay timer
                            meta._resBuffDamage--;
                            if (!meta._resDmgBoostActive) {
                                meta._resDmgBoostActive = true;
                                meta._resDmgOrig = damage[i];
                            }
                            const base = meta.baseDamage || damage[i] || 1;
                            const boosted = Math.max(1, Math.floor(base * 1.15));
                            damage[i] = boosted;
                        } else if (meta._resDmgBoostActive) {
                            // Restore original damage when buff ends
                            if (typeof meta._resDmgOrig === 'number') damage[i] = meta._resDmgOrig;
                            meta._resDmgBoostActive = false;
                            delete meta._resDmgOrig;
                        }
                    }
                    x[i] += dx * dt; y[i] += dy * dt;

                    // Wall/obstacle collisions for SoA projectiles (bounce or consume)
                    // Respect phasing when present in metadata; reflect velocity on axis of collision when bouncing.
                    if (typeof isWall === 'function') {
                        const meta = game._projMeta && game._projMeta.get(i);
                        const sizeArg = Math.max(8, radius[i]);
                        const phasing = !!(meta && meta.phasing);
                        const wasInWall = !!(meta && meta._wasInWall);
                        const nowInWall = !!isWall(x[i], y[i], sizeArg);
                        // Phasing ripple: entering/exiting walls spawns a subtle ring cue (perf-aware)
                        if (phasing) {
                            if (!wasInWall && nowInWall) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#CCB8FF', 'ring');
                            } else if (wasInWall && !nowInWall) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#E6DDFF', 'ring');
                            }
                            if (meta) meta._wasInWall = nowInWall;
                        }
                        if (!phasing && nowInWall) {
                            const canBounce = (meta && meta.bouncing) || (f & FLAG.BOUNCE);
                            if (canBounce) {
                                // Determine collision axis by probing axis-separated movement from previous position
                                const hitX = isWall(prevX + dx * dt, prevY, sizeArg);
                                const hitY = isWall(prevX, prevY + dy * dt, sizeArg);
                                if (hitX) { vx[i] = -vx[i]; x[i] = prevX; }
                                if (hitY) { vy[i] = -vy[i]; y[i] = prevY; }
                                if (!hitX && !hitY) { // corner/ambiguous: invert both
                                    vx[i] = -vx[i]; vy[i] = -vy[i]; x[i] = prevX; y[i] = prevY;
                                }
                                if (meta && typeof meta.bounces === 'number') meta.bounces = Math.max(0, meta.bounces - 1);
                                if (!(game.perf && game.perf.lowFx)) {
                                    addParticle(x[i], y[i], '#AACCFF', 'spark');
                                }
                                // Bounce ring cue (respect reduceRings)
                                if (!(game.fxFlags && game.fxFlags.reduceRings)) {
                                    addParticle(x[i], y[i], '#CFE8FF', 'ring');
                                }
                                // Store a short-lived bounce telegraph (normal vector + timer) for oriented dust puff in renderer
                                if (meta) {
                                    // Approximate normal from which axis(s) collided
                                    let nx = 0, ny = 0;
                                    if (hitX && !hitY) nx = Math.sign(prevX - x[i]);
                                    else if (hitY && !hitX) ny = Math.sign(prevY - y[i]);
                                    else { // corner: derive from velocity flip
                                        const sp = Math.hypot(vx[i], vy[i])||1; nx = -vx[i]/sp; ny = -vy[i]/sp;
                                    }
                                    meta._bounceNx = nx; meta._bounceNy = ny; meta._bounceFlash = 10;
                                }
                                // If no bounces left, consume now
                                if (meta && typeof meta.bounces === 'number' && meta.bounces <= 0) { life[i]=0; recycle(i); continue; }
                            } else {
                                life[i]=0; recycle(i); continue;
                            }
                        }
                    }
                    if (x[i] < -50 || y[i] < -50 || x[i] > LOGICAL_W+50 || y[i] > LOGICAL_H+50) {
                        // Do not recycle indestructible entities; reflect and clamp instead
                        const m = meta; // alias
                        if (m && m.indestructible) {
                            // Clamp to arena bounds with a small inset and reflect velocity
                            const inset = 6;
                            if (x[i] < inset) { x[i] = inset; vx[i] = Math.abs(vx[i]); }
                            if (y[i] < inset) { y[i] = inset; vy[i] = Math.abs(vy[i]); }
                            if (x[i] > LOGICAL_W - inset) { x[i] = LOGICAL_W - inset; vx[i] = -Math.abs(vx[i]); }
                            if (y[i] > LOGICAL_H - inset) { y[i] = LOGICAL_H - inset; vy[i] = -Math.abs(vy[i]); }
                            if (!(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#EED7AA','spark');
                        } else {
                            recycle(i); continue;
                        }
                    }
                    // Metadata special behaviors (Popcorn kernel fuse -> pop spawning puffs & kernel bursts)
                    if (game._projMeta) {
                        const meta = game._projMeta.get(i);
                        // SoA Fragment Wake: emit lingering damaging sparks along path for projectiles with effect
                        if (meta && meta.fragmentWake && !meta.beam && !meta.enemy) {
                            // Initialize per-projectile emission tracking in metadata
                            if (meta._fwPrevX == null) { meta._fwPrevX = x[i]; meta._fwPrevY = y[i]; meta._fwDistAcc = 0; meta._fwRandOff = (Math.random()*6); }
                            const dxFW = x[i] - meta._fwPrevX, dyFW = y[i] - meta._fwPrevY;
                            const distFW = Math.hypot(dxFW, dyFW);
                            meta._fwDistAcc += distFW;
                            meta._fwPrevX = x[i]; meta._fwPrevY = y[i];
                            const spacing = 14 + meta._fwRandOff; // ~14-20px
                            while (meta._fwDistAcc >= spacing) {
                                meta._fwDistAcc -= spacing;
                                const baseDmg = meta.baseDamage || damage[i] || calculateDamage();
                                if (!Array.isArray(game.fragmentSparks)) game.fragmentSparks = [];
                                if (game.fragmentSparks.length > 220) game.fragmentSparks.splice(0, game.fragmentSparks.length - 220);
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                    addParticle(x[i], y[i], '#FFE6AA','spark');
                                }
                                game.fragmentSparks.push({
                                    x: x[i] + (Math.random()-0.5)*6,
                                    y: y[i] + (Math.random()-0.5)*6,
                                    r: Math.max(5, Math.min(10, 6 + Math.random()*3)),
                                    ttl: 38,
                                    maxTtl: 38,
                                    damage: Math.max(1, Math.floor(baseDmg * 0.10)),
                                    dpsTick: 0,
                                    hitMap: new Set(),
                                    pulse: Math.random()*Math.PI*2
                                });
                            }
                        }
                        // (Removed EKG velocity-impulse scheduler; spikes now handled by subtle position offsets only)
                        // SoA Growing Shot
                        if (meta && meta.growing && !meta.beam && !meta.enemy) {
                            if (!meta._growInit) {
                                meta._growInit = true; meta._growTicks = 0;
                                const start = Math.max(2, radius[i]||4);
                                // Higher cap so big growth is possible; scale slightly with pattern synergy
                                let baseCapMult = 7.0; // was 4.0
                                if (flags[i] & FLAG.SPIRAL) baseCapMult += 0.60;
                                if (flags[i] & FLAG.SINE) baseCapMult += 0.40;
                                if (flags[i] & FLAG.WACKY) baseCapMult += 0.25;
                                if (flags[i] & FLAG.EKG) baseCapMult += 0.20;
                                if (meta.infusionElements && meta.infusionElements.length) baseCapMult += Math.min(0.20, 0.06 * meta.infusionElements.length);
                                meta._growHardCap = Math.min(255, Math.floor(start * baseCapMult));
                                meta._growSoftCap = Math.floor(start * (baseCapMult * 0.80));
                            }
                            meta._growTicks++;
                            // Gradual, life-based growth: ramps up then eases as it nears cap
                            const sz = radius[i]; const hard = meta._growHardCap; const soft = meta._growSoftCap;
                            if (sz < hard) {
                                // Progress from 0..1 over most of projectile life
                                const lifeFrac = 1 - (life[i] / Math.max(1, lifeMax[i]));
                                // Base multiplicative growth per tick: slow at first, peaks mid-life, eases late
                                const curve = Math.sin(Math.min(1, lifeFrac) * Math.PI); // 0..1..0
                                // Map to small per-tick percentage; lower tiers reduce growth slightly for perf fairness
                                const tierMul = (tier===0?1.0:(tier===1?0.95:(tier===2?0.9:0.85)));
                                let pct = 0.020 + curve * 0.030; // 2%..5% multiplicative growth
                                pct *= tierMul;
                                // Ease as we pass soft cap
                                if (sz > soft) {
                                    const t = (sz - soft) / Math.max(1, (hard - soft));
                                    const damp = 1 - Math.min(1, t);
                                    pct *= 0.35 + 0.65 * damp; // reduce growth near hard cap
                                }
                                const next = Math.min(hard, Math.max(sz + 1, Math.floor(sz * (1 + pct))));
                                radius[i] = next;
                            }
                        }
                        // SoA Sawtooth Wave (with cusp telegraph)
                        if (meta && meta.sawWave && !meta.beam && !meta.enemy) {
                            if (!meta._sawInit) {
                                meta._sawInit = true; meta._sawT = 0;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._sawFx = vx[i]/sp; meta._sawFy = vy[i]/sp; meta._sawPx = -meta._sawFy; meta._sawPy = meta._sawFx;
                                // Stronger, snappier cadence
                                meta._sawPeriod = 20 + ((Math.random()*12)|0); // was 38-51, now ~20-31 frames
                                meta._sawAmp = 52 + Math.random()*24; // was ~24-34, now ~52-76
                                meta._sawLast = 0;
                            }
                            const prevT = meta._sawT;
                            meta._sawT = (meta._sawT + 1) % meta._sawPeriod;
                            // Sharper cusp segment for a more pronounced snap
                            const tSaw = meta._sawT / meta._sawPeriod; let wave = tSaw; if (tSaw > 0.96) wave = -1 + (tSaw - 0.96)/0.04;
                            const lateral = (wave - 0.46) * 2 * meta._sawAmp; const dl = lateral - (meta._sawLast||0); meta._sawLast = lateral;
                            // Heavier lateral displacement scale
                            x[i] += meta._sawPx * dl * 0.32; y[i] += meta._sawPy * dl * 0.32; // was 0.12
                            // cusp: when period wraps back to 0 (telegraph stronger)
                            if (meta._sawT === 0 && prevT !== 0) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!reduceRings) { addParticle(x[i], y[i], '#AEEBFF','ring'); addParticle(x[i], y[i], '#AEEBFF','ring'); }
                                if (!lowFx && !hideSparks) {
                                    for (let s=0;s<4;s++) addParticle(x[i] + (Math.random()-0.5)*7, y[i] + (Math.random()-0.5)*7, '#D4F3FF','spark');
                                }
                            }
                        }
                        // Drill shot support: maintain a spinning phase and emit subtle sparks.
                        // Note: Full drill sprite now only renders when weaponType === 'drill'.
                        // When meta.drilling is true with another weaponType, we keep only the overlay.
                        if (meta && (meta.drilling || meta.weaponType === 'drill') && !meta.beam && !meta.enemy) {
                            if (!meta._drillInit) { meta._drillInit = true; meta._drillPhase = 0; }
                            meta._drillPhase += 0.35; // radians/frame
                            if (!(game.perf && game.perf.lowFx) && Math.random() < 0.25) {
                                const ang = Math.atan2(vy[i], vx[i]);
                                const bx = x[i] - Math.cos(ang) * Math.max(4, radius[i]*0.6);
                                const by = y[i] - Math.sin(ang) * Math.max(4, radius[i]*0.6);
                                addParticle(bx + (Math.random()-0.5)*3, by + (Math.random()-0.5)*3, '#D0E4FF','spark');
                            }
                        }
                        // Smart Bomb (SoA): explode near enemies
                        if (meta && meta.smartExplosive && !meta.enemy && life[i] > 0) {
                            let closest = Infinity;
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const en = game.enemies[ei]; if (!en || en.health <= 0) continue;
                                const d = Math.hypot(en.x - x[i], en.y - y[i]);
                                if (d < closest) closest = d;
                            }
                            if (closest < 56) {
                                const dmg = meta.baseDamage || damage[i] || calculateDamage();
                                const projObj = { x: x[i], y: y[i], size: Math.max(6, radius[i]||6) };
                                if (meta.damageType) projObj.damageType = meta.damageType;
                                if (meta.chainExplosion) projObj.chainExplosion = true;
                                if (meta.knockback) { projObj.knockback = true; projObj.knockbackDistance = meta.knockbackDistance; }
                                if (meta.areaEffect) projObj.areaEffect = true;
                                if (meta.vortex) projObj.vortex = true;
                                if (meta.blackHole) projObj.blackHole = true;
                                if (meta.timeWarp) projObj.timeWarp = true;
                                if (meta.dimensional) projObj.dimensional = true;
                                explodeProjectile(projObj, dmg);
                                if (!(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#FFD780','explosion');
                                life[i] = 0; recycle(i); continue;
                            }
                        }
                            // Toenail Clibbins: add independent spin so the shard rotates as it flies (purely visual)
                            // Apply to explicit toenail weaponType and crescent shards (meta.toenail)
                            if (meta && (meta.weaponType === 'toenail' || meta.toenail) && !meta.beam && !meta.enemy) {
                                if (!meta._toeSpinInit) {
                                    meta._toeSpinInit = true;
                                    meta._toeSpin = 0;
                                    // Randomize spin direction/speed; scale slightly with projectile size
                                    const base = 0.12 + Math.random() * 0.20;
                                    const sizeBoost = Math.min(0.18, (radius[i] || 8) * 0.004);
                                    meta._toeSpinSpeed = (Math.random() < 0.5 ? -1 : 1) * (base + sizeBoost);
                                }
                                meta._toeSpin += meta._toeSpinSpeed;
                            }
                        // Slalom pattern (SoA): gated straight segments with sharp alternating turns (intensified)
                        if (meta && meta.slalomPattern && !meta.beam && !meta.enemy) {
                            if (!meta._slaInit) {
                                meta._slaInit = true;
                                meta._slaSeg = 0;
                                meta._slaSegLen = 12; // shorter straight gate for higher cadence
                                meta._slaTurn = 0.62; // stronger snap-turn
                                meta._slaDir = 1;     // next turn sign
                                meta._slaMax = 10;    // more turns before straightening
                                meta._slaMade = 0;
                                meta._slaPrevAng = Math.atan2(vy[i], vx[i]);
                            }
                            meta._slaSeg++;
                            // pre-turn telegraph in last few frames of the segment
                            if (meta._slaSeg >= meta._slaSegLen - 3 && !(game.perf && game.perf.lowFx)) {
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings) addParticle(x[i], y[i], '#88EEFF','ring');
                            }
                            if (meta._slaSeg >= meta._slaSegLen && meta._slaMade < meta._slaMax) {
                                meta._slaSeg = 0; meta._slaMade++;
                                // snap rotate velocity by fixed angle
                                const ang = Math.atan2(vy[i], vx[i]);
                                const newAng = ang + meta._slaDir * meta._slaTurn;
                                const spd = Math.hypot(vx[i], vy[i]) || 2.5;
                                const boost = 1.06; // slight forward boost to accent the zig
                                vx[i] = Math.cos(newAng) * spd * boost;
                                vy[i] = Math.sin(newAng) * spd * boost;
                                meta._slaDir *= -1;
                                if (!(game.perf && game.perf.lowFx)) for (let s=0;s<3;s++) addParticle(x[i], y[i], '#66D6FF','spark');
                            }
                            if (meta._slaMade >= meta._slaMax) {
                                meta.slalomPattern = false; // done zigzagging
                            }
                        }
                        // SoA beam damage ticks along a short forward segment (laser/particle)
                        if (meta && meta.beam && !meta.enemy && game.enemies && game.enemies.length) {
                            const sp = Math.hypot(vx[i], vy[i]) || 0.0001; const fx = vx[i]/sp, fy = vy[i]/sp;
                            const segLen = meta.particleBeam ? 48 : 56; const coreR = meta.particleBeam ? Math.max(7, (radius[i]||4)+3) : Math.max(3, (radius[i]||4)-1);
                            // reduceBeams: cut hit samples to reduce CPU cost
                            const reduce = !!(game.fxFlags && game.fxFlags.reduceBeams);
                            const samples = reduce ? 3 : 5; const step = segLen / (samples-1);
                            for (let sIdx=0; sIdx<samples; sIdx++){
                                const bx = x[i] + fx * (sIdx*step); const by = y[i] + fy * (sIdx*step); const rTick = coreR;
                                if (game.enemyHash && game.enemyHash.buckets && game.enemyHash.buckets.size){
                                    const csL = game.enemyHash.cell; const cx0=(bx/csL)|0, cy0=(by/csL)|0;
                                    for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){
                                        const key=((cx0+ox)<<16) ^ (cy0+oy); const bucket=game.enemyHash.buckets.get(key); if(!bucket) continue;
                                        for (let bi=0; bi<bucket.length; bi++){
                                            const e = game.enemies[bucket[bi]]; if (!e || e.dead || e.health<=0) continue;
                                            const box=getEnemyAABB(e); let hit=false; if (box) hit=circleIntersectsAABB(bx,by,rTick,box); else { const dx=bx-e.x, dy=by-e.y; hit=(dx*dx+dy*dy < (e.size/2 + rTick)**2); }
                                            if (hit) { const projObj = { x:bx, y:by, size:rTick, damage:(meta.baseDamage||damage[i]||calculateDamage()), beam:true, damageType: (meta.damageType|| (meta.particleBeam?'plasma':undefined)) }; if (meta.particleBeam) projObj.damage=Math.floor(projObj.damage*0.85); applyProjectileHit(e, projObj); if (!(game.perf && game.perf.lowFx) && Math.random()<(reduce?0.15:0.3)) addParticle(e.x, e.y, meta.particleBeam ? '#77FFEE' : '#99CCFF','spark'); }
                                        }
                                    }
                                } else {
                                    for (let ei=0; ei<game.enemies.length; ei++){
                                        const e = game.enemies[ei]; if(!e || e.dead || e.health<=0) continue;
                                        const box=getEnemyAABB(e); let hit=false; if (box) hit=circleIntersectsAABB(bx,by,rTick,box); else { const dx=bx-e.x, dy=by-e.y; hit=(dx*dx+dy*dy < (e.size/2 + rTick)**2); }
                                        if (hit) { const projObj = { x:bx, y:by, size:rTick, damage:(meta.baseDamage||damage[i]||calculateDamage()), beam:true, damageType: (meta.damageType|| (meta.particleBeam?'plasma':undefined)) }; if (meta.particleBeam) projObj.damage=Math.floor(projObj.damage*0.85); applyProjectileHit(e, projObj); if (!(game.perf && game.perf.lowFx) && Math.random()<(reduce?0.15:0.3)) addParticle(e.x, e.y, meta.particleBeam ? '#77FFEE' : '#99CCFF','spark'); }
                                    }
                                }
                            }
                        }
                        // Spiral Bloom (SoA): tighten into a corkscrew then bloom into rotating petals
                        if (meta && meta.spiralBloom && !meta.enemy && !meta.beam) {
                            if (!meta._sbInit) {
                                meta._sbInit = true;
                                meta._sbPhase = 'tighten';
                                meta._sbTimer = 0;
                                meta._sbRadius = 34;
                                meta._sbAngle = 0;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._sbFx = vx[i]/sp; meta._sbFy = vy[i]/sp;
                                meta._sbPx = -meta._sbFy; meta._sbPy = meta._sbFx;
                            }
                            meta._sbTimer++;
                            if (meta._sbTelegraph && meta._sbTelegraph>0) meta._sbTelegraph--;
                            if (meta._sbPhase === 'tighten') {
                                meta._sbAngle += 0.38;
                                meta._sbRadius *= 0.965;
                                const swirl = meta._sbRadius * 0.12;
                                const sx = Math.cos(meta._sbAngle) * swirl;
                                const sy = Math.sin(meta._sbAngle) * swirl;
                                x[i] += meta._sbPx * sx * 0.08 + meta._sbFx * sy * 0.02;
                                y[i] += meta._sbPy * sx * 0.08 + meta._sbFy * sy * 0.02;
                                // Pre-bloom telegraph shortly before detonating
                                if (!meta._sbTelegraph && (meta._sbTimer>46 || meta._sbRadius<8.5)) {
                                    meta._sbTelegraph = 12;
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                    if (!lowFx && !hideSparks) {
                                        for (let k=0;k<4;k++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFE6AA','spark');
                                    }
                                }
                                if (meta._sbTimer>52 || meta._sbRadius<5.5) { meta._sbPhase = 'bloom'; meta._sbTimer = 0; }
                                if (!(game.perf && game.perf.lowFx) && Math.random()<0.18) addParticle(x[i], y[i], '#FFE6AA','spark');
                            } else if (meta._sbPhase === 'bloom') {
                                if (!meta._sbBloomed) {
                                    meta._sbBloomed = true;
                                    const petals = 8;
                                    const base = meta.baseDamage || damage[i] || calculateDamage();
                                    for (let p=0; p<petals; p++) {
                                        const ang = (p/petals) * Math.PI * 2;
                                        const speed = 2.4 + (p%2)*0.8;
                                        const vxP = Math.cos(ang)*speed;
                                        const vyP = Math.sin(ang)*speed;
                                        const eIdx = game.spawnProjectile({
                                            x: x[i], y: y[i],
                                            vx: vxP, vy: vyP,
                                            life: 75,
                                            r: Math.max(10, Math.floor((radius[i]||6) * 1.10 * 2.0)),
                                            damage: Math.max(1, Math.floor(base*0.42))
                                        });
                                        if (eIdx>=0) {
                                            if (!game._projMeta) game._projMeta = new Map();
                                            // Pick a random bloom sprite for this petal and seed a spin angle
                                            const pick = 1 + Math.floor(Math.random()*6);
                                            const imgKey = 'bloom' + pick;
                                            game._projMeta.set(eIdx, { petal:true, petalImg: imgKey, _petalAngle: Math.random()*Math.PI*2, petalSpin: (Math.random()<0.5?1:-1) * (0.06 + Math.random()*0.04), baseDamage: Math.max(1, Math.floor(base*0.42)) });
                                        }
                                    }
                                    // central burst particles
                                    addParticle(x[i], y[i], '#FFEEAA','explosion');
                                    for (let k=0;k<10;k++) addParticle(x[i], y[i], '#FFC870','spark');
                                }
                                // Remove core projectile
                                life[i] = 0;
                            }
                        }
                        // Lissajous Shot (figure-8 / knot-like path) implemented in SoA using metadata state
                        if (meta && meta.lissajousPattern && !meta.beam) {
                            // Initialize per-projectile Lissajous state
                            if (!meta._lissaInit) {
                                meta._lissaInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                // Forward and perpendicular basis derived from current velocity
                                meta._lFx = vx[i] / sp; meta._lFy = vy[i] / sp;
                                meta._lPx = -meta._lFy; meta._lPy = meta._lFx;
                                meta._lT = 0;
                                // Amplitudes (scaled for clarity) and frequency pairs (intensified)
                                const widen = 2.05;
                                meta._lBaseA = (22 + Math.random()*9) * widen;
                                meta._lBaseB = (16 + Math.random()*6) * (widen * 0.85);
                                meta._lA = meta._lBaseA; meta._lB = meta._lBaseB;
                                meta._lFreqA = 0.16; meta._lFreqB = 0.32;
                                meta._lTargets = [ [0.21,0.31], [0.24,0.40], [0.18,0.27] ];
                                meta._lTargetIdx = 0;
                                meta._lPhase = Math.random()*Math.PI*2;
                                meta._lRot = 0;
                                meta._lLastX = 0; meta._lLastY = 0;
                                meta._lFlipTimer = 80 + (Math.random()*50|0);
                                meta._lPulseTimer = 55 + (Math.random()*40|0);
                                meta._lPulse = 0;
                            }
                            meta._lT++;
                            // Degradation scaling by tier for lateral displacement
                            const lissScale = (tier===0?1.0:(tier===1?0.75:(tier===2?0.55:0.4)));
                            // Periodic target morphing
                            if ((meta._lT % 160) === 0) meta._lTargetIdx = (meta._lTargetIdx + 1) % meta._lTargets.length;
                            const tgt = meta._lTargets[meta._lTargetIdx];
                            meta._lFreqA += (tgt[0] - meta._lFreqA) * 0.015;
                            meta._lFreqB += (tgt[1] - meta._lFreqB) * 0.015;
                            // Light amplitude breathing
                            const ampPulse = 1 + Math.sin(meta._lT*0.02)*0.08;
                            meta._lA = meta._lBaseA * ampPulse;
                            meta._lB = meta._lBaseB * (1 - Math.sin(meta._lT*0.017)*0.06);
                            // Flip/inversion events
                            if (--meta._lFlipTimer <= 0) {
                                const tmp = meta._lBaseA; meta._lBaseA = meta._lBaseB; meta._lBaseB = tmp * (0.90 + Math.random()*0.25);
                                meta._lFlipTimer = 95 + (Math.random()*70|0);
                                if (Math.random()<0.5) meta._lFreqB *= -1;
                                if (!(game.perf && game.perf.lowFx)) {
                                    const spokes = 6 + (Math.random()*3|0);
                                    for (let s=0;s<spokes;s++) addParticle(x[i] + (Math.random()-0.5)*6, y[i] + (Math.random()-0.5)*6, '#66E0FF','spark');
                                    if (!(game.fxFlags && game.fxFlags.reduceRings) && typeof addTransientEffect === 'function') {
                                        addTransientEffect({ type:'ringFlash', x:x[i], y:y[i], color:'#66E0FF', radius: 16, life: 90 });
                                    }
                                }
                            }
                            // Speed pulse event
                            if (--meta._lPulseTimer <= 0) {
                                meta._lPulseTimer = 140 + (Math.random()*70|0);
                                meta._lPulse = 26; // longer, stronger pulse
                                if (!(game.perf && game.perf.lowFx)) {
                                    addParticle(x[i], y[i], '#44F6FF','spark');
                                    // Pulse ring cue (respect reduceRings)
                                    if (!(game.fxFlags && game.fxFlags.reduceRings)) addParticle(x[i], y[i], '#8AE8FF','ring');
                                }
                            }
                            // Sample parametric curve and compute local displacement
                            const ax = Math.sin(meta._lT * meta._lFreqA + meta._lPhase) * meta._lA;
                            const ay = Math.sin(meta._lT * meta._lFreqB) * meta._lB * Math.sin(meta._lT*0.005 + meta._lPhase*0.5);
                            const ddx = ax - meta._lLastX; const ddy = ay - meta._lLastY; meta._lLastX = ax; meta._lLastY = ay;
                            // Slowly rotate local frame to twist the figure
                            meta._lRot += 0.0035;
                            const cosr = Math.cos(meta._lRot), sinr = Math.sin(meta._lRot);
                            const rPxX = meta._lPx * cosr + meta._lFx * sinr * 0.4;
                            const rPxY = meta._lPy * cosr + meta._lFy * sinr * 0.4;
                            const rFxX = meta._lFx * cosr - meta._lPx * sinr * 0.4;
                            const rFxY = meta._lFy * cosr - meta._lPy * sinr * 0.4;
                            // Apply displacement to position (scaled)
                            const pulseScale = (meta._lPulse>0 ? 1.85 : 1.0); if (meta._lPulse>0) meta._lPulse--;
                            // Intensified lateral and forward coupling for clearer motion
                            const lateralScale = 0.34 * lissScale; const forwardScale = 0.18 * lissScale;
                            x[i] += (rPxX * ddx * lateralScale + rFxX * ddy * forwardScale) * pulseScale;
                            y[i] += (rPxY * ddx * lateralScale + rFxY * ddy * forwardScale) * pulseScale;
                        }
                        // Pendulum pattern (SoA): heavy initial swing with decay and final forward boost
                        if (meta && meta.pendulumPattern && !meta._pendDone && !meta.beam && !meta.enemy) {
                            if (!meta._pendInit) {
                                meta._pendInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._pendBaseSpeed = sp;
                                meta._pendFx = vx[i]/sp; meta._pendFy = vy[i]/sp;
                                meta._pendPx = -meta._pendFy; meta._pendPy = meta._pendFx;
                                meta._pendAnchorX = x[i]; meta._pendAnchorY = y[i];
                                meta._pendAngle = (Math.random()<0.5?1:-1) * 0.85;
                                meta._pendAngVel = 0;
                                meta._pendLength = 42 + Math.random()*14;
                                meta._pendGravity = 0.07;
                                meta._pendDamp = 0.991;
                                meta._pendFrame = 0;
                                meta._pendMaxFrames = 240;
                                meta._pendMinSwingVel = 0.0022;
                                meta._pendLastSign = Math.sign(meta._pendAngle);
                                meta._pendPeaks = 0;
                                // Telegraph: brief arc ring indicating upcoming swing
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings) {
                                    const color = '#CFE8FF';
                                    if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:x[i], y:y[i], color, radius: Math.max(12, (radius[i]||6) * 1.8), life: 120 });
                                    else if (!(lowFx)) addParticle(x[i], y[i], color, 'ring');
                                }
                            }
                            meta._pendFrame++;
                            // Integrate "pendulum" angle
                            const angAcc = -meta._pendGravity * Math.sin(meta._pendAngle);
                            meta._pendAngVel += angAcc;
                            meta._pendAngVel *= meta._pendDamp;
                            meta._pendAngle += meta._pendAngVel;
                            // Detect peaks via angular velocity sign change
                            if (meta._pendLastSign !== 0) {
                                const curSign = Math.sign(meta._pendAngVel);
                                if (curSign !== 0 && curSign !== meta._pendLastSign) {
                                    meta._pendPeaks++;
                                    for (let k=0;k<5;k++) addParticle(x[i] + (Math.random()-0.5)*12, y[i] + (Math.random()-0.5)*12, '#FFD580','spark');
                                }
                                meta._pendLastSign = curSign;
                            }
                            // Advance anchor more slowly near swing peaks
                            const fScale = Math.max(0.15, Math.abs(Math.cos(meta._pendAngle)));
                            const fStep = meta._pendBaseSpeed * 0.9 * fScale;
                            meta._pendAnchorX += meta._pendFx * fStep;
                            meta._pendAnchorY += meta._pendFy * fStep;
                            // Lateral displacement + small vertical sag
                            const lateral = Math.sin(meta._pendAngle) * meta._pendLength;
                            const sag = (1 - Math.cos(meta._pendAngle)) * (meta._pendLength * 0.20);
                            x[i] = meta._pendAnchorX + meta._pendPx * lateral;
                            y[i] = meta._pendAnchorY + meta._pendPy * lateral + sag * 0.25;
                            // Instantaneous velocity approximation, update vx/vy for downstream systems
                            const latVel = Math.cos(meta._pendAngle) * meta._pendLength * meta._pendAngVel;
                            const instVx = meta._pendFx * fStep + meta._pendPx * latVel;
                            const instVy = meta._pendFy * fStep + meta._pendPy * latVel + (sag * 0.25 - (meta._pendPrevSag||0))*0.9;
                            vx[i] = instVx; vy[i] = instVy; meta._pendPrevSag = sag * 0.25;
                            // Trail more intense near center
                            const trailIntensity = 0.06 + Math.abs(Math.cos(meta._pendAngle))*0.12;
                            if (Math.random() < trailIntensity) addParticle(x[i], y[i], '#FFC899','spark');
                            // End condition: minimal swing OR time cap
                            if ((Math.abs(meta._pendAngVel) < meta._pendMinSwingVel && Math.abs(meta._pendAngle) < 0.12) || meta._pendFrame >= meta._pendMaxFrames) {
                                const boost = 1 + Math.min(0.35, meta._pendPeaks * 0.05);
                                const finalSp = meta._pendBaseSpeed * boost;
                                vx[i] = meta._pendFx * finalSp;
                                vy[i] = meta._pendFy * finalSp;
                                for (let b=0;b<8;b++) addParticle(x[i] + (Math.random()-0.5)*14, y[i] + (Math.random()-0.5)*14, '#FFD9AA','spark');
                                meta._pendDone = true; meta.pendulumPattern = false;
                            }
                        }
                        // Cascade Burst (SoA): pulsing forward micro-bursts
                        if (meta && meta.cascadeBurst && !meta.enemy && !meta.beam) {
                            if (!meta._cascInit) { meta._cascInit=true; meta._cascTimer=10; }
                            meta._cascTimer--;
                            // Pre-burst telegraph once a few frames before emission
                            if (meta._cascTimer === 3) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFE6CC','ring');
                            }
                            if (meta._cascTimer<=0) {
                                meta._cascTimer = 12; // cadence
                                const ang = Math.atan2(vy[i], vx[i]);
                                const parts = 7; const spd = Math.hypot(vx[i], vy[i]) || 0.0001;
                                const base = meta.baseDamage || damage[i] || 1;
                                const spreadStep = 0.16; // wider spread between children
                                for (let k=0;k<parts;k++) {
                                    const off = (k - (parts-1)/2)*spreadStep;
                                    const speedMul = 1.25;
                                    const nvx = Math.cos(ang+off) * (spd*speedMul + 1.2);
                                    const nvy = Math.sin(ang+off) * (spd*speedMul + 1.2);
                                    const lifeK = 70; // farther travel
                                    const radK = Math.max(3, Math.floor((radius[i]||6)*0.60));
                                    const dmgK = Math.max(1, Math.floor(base*0.34));
                                    const idxK = game.spawnProjectile({ x:x[i] + Math.cos(ang)*10, y:y[i] + Math.sin(ang)*10, vx:nvx, vy:nvy, life:lifeK, r: radK, damage: dmgK });
                                    if (idxK>=0) { if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(idxK,{ cascadeChild:true, _initialFx:Math.cos(ang+off), _initialFy:Math.sin(ang+off), baseDamage: dmgK }); }
                                }
                                // Stronger visual cue per burst (perf-aware)
                                {
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                    if (!reduceRings) addParticle(x[i], y[i], '#FFD4AA','ring');
                                    if (!lowFx && !hideSparks) {
                                        const count = 3;
                                        for (let q=0;q<count;q++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFB866','spark');
                                    }
                                }
                            }
                        }
                        if (meta && meta.isPopcornKernel && !meta._popDid) {
                            meta._popFuse--;
                            if (meta._popFuse < 10 && Math.random()<0.3 && !(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#FFF5AA','spark');
                            // Pre-pop ring cue just before detonation
                            if (meta._popFuse === 3) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFF2BB','ring');
                            }
                            if (meta._popFuse <= 0) {
                                meta._popDid = true;
                                const base = meta.baseDamage || damage[i];
                                // kernel burst mini shots (scaled)
                                const burstN = Math.max(2, Math.min(6, (meta._popBursts||2)));
                                for (let b=0;b<burstN;b++) {
                                    const angB = Math.random()*Math.PI*2;
                                    const speedB = 4.2 + Math.random()*1.6;
                                    const kbIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:Math.cos(angB)*speedB, vy:Math.sin(angB)*speedB, life:48+Math.floor(Math.random()*18), r:7, damage: Math.max(1, Math.floor(base*0.55)) });
                                    if (kbIdx>=0){ if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(kbIdx,{ popcornKernelBurst:true, baseDamage: Math.max(1, Math.floor(base*0.55)), realityBreak: !!(meta && meta.realityBreak) }); }
                                }
                                // puffs (scaled)
                                const puffN = Math.max(2, Math.min(6, (meta._popPuffs||2)));
                                for (let k=0;k<puffN;k++) {
                                    const baseAng = Math.atan2(dy, dx);
                                    const ang = (isFinite(baseAng)? baseAng : 0) + (Math.random()*0.9 - 0.45);
                                    const speed = (Math.hypot(dx,dy) * 0.85) + Math.random()*1.2;
                                    const pIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, life:40+Math.floor(Math.random()*18), r:12, damage: Math.max(1, Math.floor(base*0.75)) });
                                    if (pIdx>=0){ if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(pIdx,{ popcornPuff:true, baseDamage: Math.max(1, Math.floor(base*0.75)), _puffSpin: Math.random()*Math.PI*2, _puffDir:(Math.random()<0.5?-1:1), realityBreak: !!(meta && meta.realityBreak) }); }
                                }
                                if (!(game.perf && game.perf.lowFx)) for (let s=0;s<10;s++) addParticle(x[i] + (Math.random()-0.5)*12, y[i] + (Math.random()-0.5)*12, '#FFEFA0','spark');
                                // Remove kernel
                                life[i]=0; recycle(i); continue;
                            }
                        }
                        // Harmonic Split (SoA): split twice at set life points; parent continues after each split
                        if (meta && meta.harmonicSplit && !meta._harmDoneAll) {
                            if (!meta._harmInit) {
                                meta._harmInit = true;
                                // Define thresholds at fractions of original life (remaining life values)
                                const L = Math.max(1, lifeMax[i] || life[i] || 120);
                                // Even earlier splits: 96% and 80% of original life
                                meta._harmThresholds = [ Math.floor(L * 0.96), Math.floor(L * 0.80) ];
                                meta._harmDone = {};
                                meta._harmTele = 0;
                            }
                            // Pre-split telegraph when within a few frames above an upcoming threshold
                            if (Array.isArray(meta._harmThresholds)) {
                                for (let t=0; t<meta._harmThresholds.length; t++) {
                                    const th = meta._harmThresholds[t];
                                    if (!meta._harmDone[th] && life[i] <= th + 8 && life[i] > th) {
                                        meta._harmTele = Math.max(meta._harmTele||0, 6);
                                        const lowFx = !!(game.perf && game.perf.lowFx);
                                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                        if (!lowFx && !hideSparks && Math.random() < 0.25) addParticle(x[i], y[i], '#FFE2BB','spark');
                                        if (!reduceRings && Math.random() < 0.18) addParticle(x[i], y[i], '#FFE6CC','ring');
                                    }
                                }
                                if (meta._harmTele>0) meta._harmTele--;
                            }
                            // Perform splits whose thresholds have been reached
                            if (Array.isArray(meta._harmThresholds)) {
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                let ang = Math.atan2(vy[i], vx[i]);
                                if (!isFinite(ang)) {
                                    const fx0 = (meta._initialFx!=null?meta._initialFx:1), fy0=(meta._initialFy!=null?meta._initialFy:0);
                                    ang = Math.atan2(fy0, fx0);
                                }
                                for (let t=0; t<meta._harmThresholds.length; t++) {
                                    const th = meta._harmThresholds[t];
                                    if (life[i] <= th && !meta._harmDone[th]) {
                                        meta._harmDone[th] = true;
                                        const base = meta.baseDamage || damage[i] || 1;
                                        const childSpeed = sp * 0.92 + 0.6; // small bias so kids move out clearly
                                        const spread = 0.34; // ~19.5
                                        for (let dir=-1; dir<=1; dir+=2) {
                                            const cAng = ang + dir*spread;
                                            const idxC = game.spawnProjectile({
                                                x: x[i], y: y[i],
                                                vx: Math.cos(cAng) * childSpeed,
                                                vy: Math.sin(cAng) * childSpeed,
                                                life: Math.max(12, Math.floor(life[i] * 0.78)),
                                                r: Math.max(2, Math.floor((radius[i]||6) * 0.65)),
                                                damage: Math.max(1, Math.floor(base * 0.58)),
                                                // Propagate key motion flags
                                                sineWave: !!(flags[i] & FLAG.SINE),
                                                wackyZigzag: !!(flags[i] & FLAG.WACKY),
                                                ekgWave: !!(flags[i] & FLAG.EKG),
                                                spiralPattern: !!(flags[i] & FLAG.SPIRAL)
                                            });
                                            if (idxC>=0) {
                                                if (!game._projMeta) game._projMeta = new Map();
                                                game._projMeta.set(idxC, { harmonicChild:true, baseDamage: Math.max(1, Math.floor(base * 0.58)) });
                                            }
                                        }
                                        // Visual burst
                                        if (!(game.perf && game.perf.lowFx)) {
                                            for (let k=0;k<6;k++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFE2BB','spark');
                                        }
                                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                        if (!reduceRings) addParticle(x[i], y[i], '#FFC070','trail');
                                        // Slightly trim parent damage so total DPS doesn't overscale
                                        damage[i] = Math.max(1, Math.floor(damage[i] * 0.9));
                                        if (meta.baseDamage) meta.baseDamage = Math.max(1, Math.floor(meta.baseDamage * 0.9));
                                    }
                                }
                                // If all thresholds handled, mark done
                                let doneCount = 0; for (const th of meta._harmThresholds) if (meta._harmDone[th]) doneCount++;
                                if (doneCount === meta._harmThresholds.length) { meta._harmDoneAll = true; if (!(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#FFCC88','ambient'); }
                            }
                        }
                        // Meteor explosion cue on detonation/expiry
                        if (meta && meta.meteor && !meta._meteorCueDone) {
                            // Check for nearing detonation or just expired; add visual cue and shake
                            if ((meta._meteorDetonateAt && game.frame >= meta._meteorDetonateAt) || life[i] <= 0) {
                                meta._meteorCueDone = true;
                                // SFX: retro explosion on impact
                                try { if (typeof playMeteorExplosionSfx === 'function') playMeteorExplosionSfx(); } catch(_) {}
                                // Explosion ring and embers
                                if (!(game.perf && game.perf.lowFx)) {
                                    for (let k=0;k<12;k++) addParticle(x[i], y[i], '#FFDD88','ring');
                                    for (let s=0;s<18;s++) addParticle(x[i] + (Math.random()-0.5)*18, y[i] + (Math.random()-0.5)*18, '#FFB064','spark');
                                }
                                // Brief screen shake
                                game.screenShake = Math.max(game.screenShake || 0, 8);
                                game.screenShakeIntensity = Math.max(game.screenShakeIntensity || 0, 0.9);
                            }
                        }
                        // Umbrella core split behavior
                        if (meta && meta.umbrellaCore && !meta._umbDidSplit) {
                            // Accumulate travel distance using current velocity magnitude
                            const stepDist = Math.hypot(vx[i], vy[i]);
                            meta._umbTravel += stepDist;
                            meta._umbCoreAge = (meta._umbCoreAge||0)+1;
                            const lowLife = life[i] <= 10;
                            const forceSplit = (meta._umbCoreAge > 80) || stepDist < 0.5 || lowLife;
                            if (meta._umbTravel >= (meta._umbSplitDistance || 160) || forceSplit) {
                                meta._umbDidSplit = true;
                                const base = meta.baseDamage || damage[i];
                                let ang = Math.atan2(vy[i], vx[i]);
                                if (!isFinite(ang) || (Math.abs(vx[i]) < 0.0001 && Math.abs(vy[i]) < 0.0001)) {
                                    const ld = (game.player && game.player.lastDirection) || {x:1,y:0};
                                    ang = Math.atan2(ld.y, ld.x);
                                }
                                const arcRadius = 140;
                                for (let side=-1; side<=1; side+=2) {
                                    const aIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:0, vy:0, life:110, r: Math.max(5, radius[i]*0.9), damage: Math.max(1, Math.floor(base*0.65)) });
                                    if (aIdx>=0) {
                                        if (!game._projMeta) game._projMeta = new Map();
                                        game._projMeta.set(aIdx, {
                                            umbrellaArc:true,
                                            _arcSide:side,
                                            _arcOriginX:x[i],
                                            _arcOriginY:y[i],
                                            _arcBaseAngle: ang,
                                            _arcProgress: 0,
                                            _arcRadius: arcRadius,
                                            _arcAngularSpan: Math.PI * 0.5,
                                            _arcSpeed: 0.028,
                                            _arcDone:false,
                                            baseDamage: Math.max(1, Math.floor(base*0.65)),
                                            sineWave: !!(flags[i] & FLAG.SINE),
                                            wackyZigzag: !!(flags[i] & FLAG.WACKY),
                                            ekgWave: !!(flags[i] & FLAG.EKG),
                                            spiral: !!(flags[i] & FLAG.SPIRAL)
                                        });
                                    }
                                }
                                if (!(game.perf && game.perf.lowFx)) {
                                    for (let p=0;p<18;p++) addParticle(x[i] + (Math.random()-0.5)*24, y[i] + (Math.random()-0.5)*24, '#FFDFAA','spark');
                                    addParticle(x[i], y[i], '#FFAA55','ambient');
                                    addParticle(x[i], y[i], '#FFE8CC','trail');
                                }
                                // Remove core after splitting
                                life[i]=0; recycle(i); continue;
                            }
                        }
                        // Umbrella arc motion (advance along sweep). After 90 (half-arc), convert to tangent flight continuing past the player.
                        if (meta && meta.umbrellaArc && !meta._arcDone) {
                            meta._arcProgress += meta._arcSpeed;
                            const sweep = meta._arcAngularSpan || (Math.PI * 0.5); // 90
                            // IMPORTANT: lock arc to the original split origin, do NOT follow live player position
                            const originX = meta._arcOriginX;
                            const originY = meta._arcOriginY;
                            if (meta._arcProgress >= 1) {
                                // Finish arc exactly at 90, then convert to free-flight along tangent back across/past the player
                                meta._arcProgress = 1; meta._arcDone = true;
                                const endAng = meta._arcBaseAngle + (meta._arcSide * sweep);
                                // Tangent direction at end of arc equals baseAngle + PI, regardless of side
                                const tanAng = meta._arcBaseAngle + Math.PI;
                                const tx = Math.cos(tanAng), ty = Math.sin(tanAng);
                                const speed = 5.2; // speed after arc
                                vx[i] = tx * speed; vy[i] = ty * speed;
                                // Place at arc endpoint, then proceed along tangent
                                x[i] = originX + Math.cos(endAng) * meta._arcRadius;
                                y[i] = originY + Math.sin(endAng) * meta._arcRadius;
                                // Give it healthy life to pass the player and keep going
                                life[i] = Math.max(life[i], 90); lifeMax[i] = Math.max(lifeMax[i], life[i]);
                                // Clear arc markers so normal physics takes over
                                meta.umbrellaArc = false; delete meta._arcDone; delete meta._arcProgress;
                            } else {
                                const localAng = meta._arcBaseAngle + (meta._arcSide * (meta._arcProgress * sweep));
                                x[i] = originX + Math.cos(localAng) * meta._arcRadius;
                                y[i] = originY + Math.sin(localAng) * meta._arcRadius;
                            }
                        }
                        // Helix Pair motion: offset twin projectiles around forward axis with expanding/contracting radius
                        if (meta && meta.helixPair && meta._helixSide) {
                            // Initialize forward/perp basis once
                            if (!meta._helixInit) {
                                meta._helixInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._hFx = vx[i]/sp; meta._hFy = vy[i]/sp;
                                meta._hPx = -meta._hFy; meta._hPy = meta._hFx;
                                meta._helixPhase = meta._helixPhase || 0;
                                meta._helixRadius = meta._helixRadius || 26;
                                meta._helixTargetRadius = meta._helixTargetRadius || 42;
                            }
                            // Slightly steer basis toward current velocity to track course
                            const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const nFx = vx[i]/sp, nFy = vy[i]/sp;
                            meta._hFx = meta._hFx*0.9 + nFx*0.1; meta._hFy = meta._hFy*0.9 + nFy*0.1;
                            const nl = Math.hypot(meta._hFx, meta._hFy)||1; meta._hFx/=nl; meta._hFy/=nl;
                            meta._hPx = -meta._hFy; meta._hPy = meta._hFx;
                            // Evolve radius toward target then flip
                            meta._helixRadius += (meta._helixTargetRadius - meta._helixRadius) * 0.06;
                            if (Math.abs(meta._helixTargetRadius - meta._helixRadius) < 0.5) {
                                meta._helixTargetRadius = 26 + Math.random()*24;
                            }
                            meta._helixPhase += 0.24;
                            const swirl = Math.sin(meta._helixPhase) * meta._helixRadius;
                            const offX = meta._hPx * swirl * meta._helixSide;
                            const offY = meta._hPy * swirl * meta._helixSide;
                            x[i] += offX * 0.08; y[i] += offY * 0.08;
                        }
                        // Boomerang: outbound arc then return to player, with mild lateral curve and return acceleration
                        if (meta && meta.boomerang && !meta._boomConsumed) {
                            if (!meta._boomInit) {
                                meta._boomInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 1;
                                meta._boomFx = vx[i]/sp; meta._boomFy = vy[i]/sp;
                                meta._boomSide = (Math.random()<0.5?-1:1);
                                meta._boomMaxLat = 90 + Math.random()*30;
                                meta._boomOutboundDist = 180 + Math.random()*40;
                                meta._boomTravel = 0; meta._boomReturn=false; meta._boomChained=false; meta._boomOriginX=x[i]; meta._boomOriginY=y[i]; meta._boomAge=0;
                                // Pre-return cue state
                                meta._boomPreCue = 0; // frames remaining to show pre-return ring/arrow
                                meta._boomPreWarned = false;
                            }
                            meta._boomAge++;
                            const speed = Math.hypot(vx[i], vy[i]) || 0.01;
                            const stepForward = vx[i]*meta._boomFx + vy[i]*meta._boomFy;
                            meta._boomTravel += Math.max(0, stepForward * 0.9);
                            if (!meta._boomReturn) {
                                const ox = x[i]-meta._boomOriginX; const oy = y[i]-meta._boomOriginY;
                                const radial = Math.hypot(ox,oy);
                                if (radial > meta._boomOutboundDist*0.95) meta._boomReturn = true;
                            }
                            if (!meta._boomReturn && meta._boomTravel >= meta._boomOutboundDist) meta._boomReturn = true;
                            if (!meta._boomReturn && meta._boomAge > 90) { meta._boomReturn = true; meta._boomForced = true; }
                            // Prime pre-return cue shortly before reaching outbound limit
                            if (!meta._boomReturn && !meta._boomPreWarned) {
                                const frac = meta._boomTravel / Math.max(1, meta._boomOutboundDist);
                                if (frac >= 0.78) { // ~last 22% of outbound
                                    meta._boomPreCue = 16 + (Math.random()*8|0);
                                    meta._boomPreWarned = true;
                                }
                            }
                            // Return cue: emit a ring + a couple sparks once when switching to return state
                            if (meta._boomReturn && !meta._boomCueDid) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!reduceRings) addParticle(x[i], y[i], '#FFE6CC','ring');
                                if (!lowFx && !hideSparks) { for (let s=0;s<2;s++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFC899','spark'); }
                                meta._boomCueDid = true;
                            }
                            if (meta._boomPreCue > 0) meta._boomPreCue--;
                            let fxB = meta._boomFx, fyB = meta._boomFy;
                            if (meta._boomReturn) {
                                const dxp = (game.player?game.player.x:x[i]) - x[i];
                                const dyp = (game.player?game.player.y:y[i]) - y[i];
                                const dpl = Math.hypot(dxp,dyp)||1;
                                const tFx = dxp/dpl, tFy = dyp/dpl;
                                const blend = meta._boomForced ? 0.25 : 0.12;
                                fxB = fxB*(1-blend) + tFx*blend; fyB = fyB*(1-blend) + tFy*blend;
                                const nrm = Math.hypot(fxB,fyB)||1; fxB/=nrm; fyB/=nrm; meta._boomFx=fxB; meta._boomFy=fyB;
                                meta._boomReturnSide = (typeof meta._boomReturnSide==='number')?meta._boomReturnSide: -meta._boomSide;
                                if (!meta._boomLifeExtended) { life[i] = Math.max(life[i], 60); lifeMax[i]=Math.max(lifeMax[i], life[i]); meta._boomLifeExtended=true; }
                            }
                            const phaseFrac = Math.min(1, meta._boomTravel / Math.max(1, meta._boomOutboundDist));
                            let lateralFrac = !meta._boomReturn ? Math.sin(phaseFrac*Math.PI*0.9) : Math.sin((1-phaseFrac)*Math.PI*0.9);
                            lateralFrac = Math.max(0, lateralFrac);
                            const latMag = meta._boomMaxLat * lateralFrac;
                            const pxB = -fyB, pyB = fxB;
                            const side = meta._boomReturn ? meta._boomReturnSide : meta._boomSide;
                            meta._boomLat = latMag * side;
                            const lateralStrength = 0.12;
                            vx[i] = fxB * speed * 0.97 + pxB * (meta._boomLat/ Math.max(1, meta._boomMaxLat)) * lateralStrength * speed;
                            vy[i] = fyB * speed * 0.97 + pyB * (meta._boomLat/ Math.max(1, meta._boomMaxLat)) * lateralStrength * speed;
                            const curSp = Math.hypot(vx[i], vy[i]) || 0.01;
                            if (curSp < 2) { const boost = (meta._boomReturn?1.25:1.12); vx[i] = (vx[i]/curSp)*(curSp*boost+0.05); vy[i]=(vy[i]/curSp)*(curSp*boost+0.05); }
                            if (meta._boomReturn) { vx[i]*=1.012; vy[i]*=1.012; }
                            if (meta._boomReturn && game.player) {
                                const dxp2 = x[i]-game.player.x; const dyp2 = y[i]-game.player.y;
                                if (Math.hypot(dxp2,dyp2) < 22) { life[i]=0; recycle(i); meta._boomConsumed=true; continue; }
                            }
                        }
                        // Converge Pair: manage twin phases and fusion
                        if (meta && meta.convergePair && meta._convTwin != null && !meta._convFused) {
                            meta._convTimer = (meta._convTimer||0)+1;
                            const phase = meta._convPhase || 'diverge';
                            const j = meta._convTwin; if (j>=0 && j<MAX && alive[j]) {
                                const pm = game._projMeta.get(j);
                                // compute forward dir blend
                                const spx = (vx[i]+vx[j])*0.5; const spy = (vy[i]+vy[j])*0.5; const sp = Math.hypot(spx,spy)||0.0001;
                                const fBx = spx/sp, fBy = spy/sp;
                                if (phase === 'diverge') {
                                    if (meta._convTimer > 14) {
                                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                        if (!(game.perf && game.perf.lowFx) && !reduceRings) addParticle(x[i], y[i], '#AEEBFF','ring');
                                        meta._convPhase='curveIn'; meta._convTimer=0; }
                                } else if (phase === 'curveIn') {
                                    // steer each toward blended forward
                                    const ang = Math.atan2(vy[i], vx[i]); const targ = Math.atan2(fBy, fBx);
                                    const blend=0.08+Math.min(0.18, meta._convTimer*0.004);
                                    // normalize smallest angular difference to avoid wrap issues when aiming left
                                    let delta = targ - ang; delta = (delta + Math.PI) % (Math.PI*2); if (delta < 0) delta += Math.PI*2; delta -= Math.PI;
                                    const newAng = ang + delta*blend; const spd=Math.hypot(vx[i],vy[i])||0.0001;
                                    vx[i]=Math.cos(newAng)*spd; vy[i]=Math.sin(newAng)*spd;
                                    if (meta._convTimer > 26) { meta._convPhase='fuseCheck'; meta._convTimer=0; }
                                } else if (phase === 'fuseCheck') {
                                    if (meta._convPrimary) {
                                        const dx2 = x[j]-x[i]; const dy2 = y[j]-y[i]; const d2 = dx2*dx2+dy2*dy2;
                                        const fuseRadius = 110 - Math.min(70, meta._convTimer*2);
                                        if (d2 <= fuseRadius*fuseRadius) {
                                            if (d2 < 38*38) {
                                                const baseCombined = (meta.baseDamage||damage[i]) + ((pm&&pm.baseDamage)||damage[j]);
                                                const fuseX = (x[i]+x[j])/2; const fuseY = (y[i]+y[j])/2;
                                                const fuseVx = (vx[i]+vx[j])/2; const fuseVy = (vy[i]+vy[j])/2;
                                                const fusedDmg = Math.max(1, Math.floor(baseCombined * 0.95));
                                                const fIdx = game.spawnProjectile({ x:fuseX, y:fuseY, vx:fuseVx, vy:fuseVy, life: Math.max(life[i], life[j]) + 40, r: Math.max(radius[i], radius[j]) + 4, damage: fusedDmg });
                                                if (fIdx>=0) {
                                                    if (!game._projMeta) game._projMeta = new Map();
                                                    game._projMeta.set(fIdx, { fusedTwin:true, _fuseAuraTimer:0, baseDamage:fusedDmg });
                                                }
                                                // mark twins consumed
                                                life[i]=0; recycle(i); if (alive[j]) { life[j]=0; recycle(j); }
                                                // burst AoE
                                                const burstR=90; const burstDamage=Math.max(2, Math.floor(fusedDmg*0.45));
                                                if (game.enemies && game.enemies.length) {
                                                    for (const en of game.enemies) {
                                                        if (!en) continue; const ex=en.x-fuseX; const ey=en.y-fuseY; if (ex*ex+ey*ey <= burstR*burstR) { en.health -= burstDamage; addDamageNumber(burstDamage, en.x, en.y - en.size/2, { type:'arcane' }); }
                                                    }
                                                }
                                                addParticle(fuseX, fuseY, '#BBAAFF','explosion');
                                                meta._convFused = true;
                                                continue;
                                            }
                                        }
                                        if (!meta._convFused && meta._convTimer > 40) {
                                            const dx3 = x[j]-x[i]; const dy3 = y[j]-y[i]; const d = Math.hypot(dx3,dy3)||1; const pull = Math.min(0.35, 12/d);
                                            vx[i] += dx3/d * pull * 0.5; vy[i] += dy3/d * pull * 0.5;
                                            vx[j] -= dx3/d * pull * 0.5; vy[j] -= dy3/d * pull * 0.5;
                                        }
                                    }
                                    meta._convTimer++;
                                    if (meta._convTimer > 160) meta._convPhase='expired';
                                }
                            }
                        }
                        // Echo Bloom: staged echo spawns and converge-triggered bloom
                        if (meta && meta.echoBloom && !meta._echoDone) {
                            if (!meta._echoInit) {
                                meta._echoInit = true; meta._echoStage=0; meta._echoMaxStages=2; meta._echoNextLifePoint = Math.floor(life[i]*0.70); meta._echoTelegraph=0; meta._echoTelegraphMax=42;
                            }
                            if (life[i] <= meta._echoNextLifePoint && meta._echoStage < meta._echoMaxStages) {
                                const scale = 0.55 + meta._echoStage*0.15; const dmgScale = 0.30 + meta._echoStage*0.10;
                                const baseDmgLocal = meta.baseDamage || damage[i];
                                const eIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:vx[i]*(0.35+meta._echoStage*0.1), vy:vy[i]*(0.35+meta._echoStage*0.1), life: life[i] + 18 + meta._echoStage*6, r: Math.max(2, Math.floor((radius[i]||6)*scale)), damage: Math.max(1, Math.floor(baseDmgLocal*dmgScale)) });
                                if (eIdx>=0) { if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(eIdx,{ echoChild:true, _parentId:i, baseDamage: Math.max(1, Math.floor(baseDmgLocal*dmgScale)) }); }
                                for (let k=0;k<6;k++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFC8FF','spark');
                                meta._echoStage++; meta._echoNextLifePoint = Math.floor(life[i] * (0.55 - meta._echoStage*0.10));
                            }
                            if (meta._echoStage === meta._echoMaxStages && !meta._echoBloomed) {
                                let converged=true; let echoCount=0;
                                const { alive:al2 } = game.projectilesSoA; for (let si=0; si<MAX; si++) if (al2[si]) { const m2 = game._projMeta.get(si); if (!m2 || !m2.echoChild || m2._parentId !== i) continue; echoCount++; const dx=x[si]-x[i]; const dy=y[si]-y[i]; if (dx*dx+dy*dy>36) { converged=false; break; } }
                                if (echoCount && !meta._echoBloomed) { meta._echoTelegraph = Math.min(meta._echoTelegraph+1, meta._echoTelegraphMax); if (meta._echoTelegraph > meta._echoTelegraphMax*0.65 && Math.random()<0.25) addParticle(x[i] + (Math.random()-0.5)*20, y[i] + (Math.random()-0.5)*20, '#FFD6FF','spark'); }
                                if (echoCount && converged) {
                                    meta._echoBloomed=true; const base = meta.baseDamage || damage[i]; const burstDmg = Math.max(1, Math.floor(base*1.10));
                                    explodeProjectile({ x:x[i], y:y[i], size:radius[i], enemy:false }, burstDmg); addScreenShake(6);
                                    const petals = 10 + Math.floor(Math.random()*4);
                                    for (let p=0;p<petals;p++) { const ang=(p/petals)*Math.PI*2; game.spawnProjectile({ x:x[i], y:y[i], vx: Math.cos(ang)*(2.8 + Math.random()*0.6), vy: Math.sin(ang)*(2.8 + Math.random()*0.6), life:65, r: Math.max(2, radius[i]*0.55), damage: Math.max(1, Math.floor(base*0.42)) }); }
                                    // Tuned resonance field: slightly larger, pulses a bit faster, lasts slightly longer
                                    const field = { x:x[i], y:y[i], radius:140, createdAt:Date.now(), duration:2000, tickEvery:260, lastTick:0, baseDamage: Math.max(1, Math.floor(base*0.30)), type:'echoBloom' };
                                    if (!game.echoBloomFields) game.echoBloomFields=[]; game.echoBloomFields.push(field);
                                    for (let si=0; si<MAX; si++) if (al2[si]) { const m2=game._projMeta.get(si); if (m2 && m2.echoChild && m2._parentId === i) { life[si]=0; } }
                                }
                            }
                        }
                        // Phase Echo (SoA): spawn stationary ghost afterimages that pop on expiry
                        if (meta && meta.phaseEcho) {
                            if (!meta._echoInit) { meta._echoInit = true; meta._echoTimer = 10; meta._echoesSpawned = 0; }
                            meta._echoTimer--;
                            if (meta._echoTimer <= 0) {
                                meta._echoTimer = 26; // cadence between ghosts
                                if ((meta._echoesSpawned||0) < 3) {
                                    const baseDmgLocal = meta.baseDamage || damage[i] || calculateDamage();
                                    const gDmg = Math.max(1, Math.floor(baseDmgLocal * 0.25));
                                    const gIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:0, vy:0, life:22, r: Math.max(2, Math.floor((radius[i]||6)*0.6)), damage: gDmg });
                                    if (gIdx>=0) {
                                        if (!game._projMeta) game._projMeta = new Map();
                                        game._projMeta.set(gIdx, { phaseGhost:true, baseDamage:gDmg });
                                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) addParticle(x[i], y[i], '#DDE8FF','spark');
                                    }
                                    meta._echoesSpawned = (meta._echoesSpawned||0) + 1;
                                }
                            }
                        }
                        // Phase Echo: afterimage ghost telegraph and pop-on-expire (metadata-driven)
                        if (meta && meta.phaseGhost) {
                            // gentle ambient flicker while alive
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks) && Math.random()<0.10) addParticle(x[i] + (Math.random()-0.5)*6, y[i] + (Math.random()-0.5)*6, '#AACCFF','spark');
                            // final telegraph shortly before pop
                            if (!meta._ghostWarn && life[i] <= 6) { meta._ghostWarn = true; if(!(game.perf&&game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) for (let k=0;k<3;k++) addParticle(x[i], y[i], '#DDE8FF','ring'); }
                            // burst on expiry
                            if (!meta._ghostPopped && life[i] <= 0) {
                                meta._ghostPopped = true;
                                const base = meta.baseDamage || damage[i] || 1;
                                const burstDmg = Math.max(1, Math.floor(base * 0.40));
                                explodeProjectile({ x:x[i], y:y[i], size: Math.max(4, radius[i]||6), enemy:false }, burstDmg);
                                addScreenShake(3);
                            }
                        }
                        // Veering Fan: timed mid-flight multi-shot conversion
                        if (meta && meta.veeringFan && !meta._veered) {
                            if (meta._veeringTimer === undefined) { meta._veeringTimer = 22; meta._veerMinDist = 80; meta._spawnX = x[i]; meta._spawnY = y[i]; }
                            const dxs = x[i]-meta._spawnX; const dys = y[i]-meta._spawnY; const distSq = dxs*dxs + dys*dys;
                            if (distSq >= (meta._veerMinDist||0)*(meta._veerMinDist||0)) meta._veeringTimer--;
                            // subtle pre-split telegraph in last few frames
                            if (meta._veeringTimer !== undefined && meta._veeringTimer <= 6 && !(game.perf && game.perf.lowFx)) {
                                addParticle(x[i], y[i], '#FFF2CC','ring');
                            }
                            if (meta._veeringTimer === 0 && !meta._veered) {
                                meta._veered = true;
                                // Use last-frame displacement if available (patterns like Uzumaki may not reflect into vx/vy)
                                let mvx = (meta && typeof meta._lastX === 'number') ? (x[i] - meta._lastX) : vx[i];
                                let mvy = (meta && typeof meta._lastY === 'number') ? (y[i] - meta._lastY) : vy[i];
                                // Fallback: if movement vector is too small, derive from facing via vx/vy
                                let spd = Math.hypot(mvx, mvy);
                                if (spd < 0.001) { mvx = vx[i]; mvy = vy[i]; spd = Math.hypot(mvx, mvy) || 0.0001; }
                                const ang = Math.atan2(mvy, mvx);
                                const base=(meta.baseDamage||damage[i]);
                                const sideCount=4; const maxSpread=0.55;
                                // adjust center
                                const newDmg = Math.max(1, Math.floor(base*0.65)); damage[i]=newDmg; meta.baseDamage=newDmg; radius[i]=Math.max(2, Math.floor(radius[i]*0.75));
                                for (let k=0;k<sideCount;k++) {
                                    const t = (k/(sideCount-1))*2-1; const eased = t*Math.abs(t); const offset = eased*(maxSpread/2); if (Math.abs(offset)<0.0001) continue;
                                    const nvx = Math.cos(ang+offset) * spd*0.97; const nvy = Math.sin(ang+offset) * spd*0.97;
                                    const idxK = game.spawnProjectile({
                                        x:x[i], y:y[i],
                                        vx:nvx, vy:nvy,
                                        life: Math.floor(life[i]*0.85),
                                        r: Math.max(2, Math.floor(radius[i]*0.60)),
                                        damage: Math.max(1, Math.floor(base*0.45)),
                                        // Inherit common pattern flags so child motion matches the parent context
                                        sineWave: !!(meta && meta.sineWave),
                                        wackyZigzag: !!(meta && meta.wackyZigzag),
                                        ekgWave: !!(meta && meta.ekgWave),
                                        spiralPattern: !!(meta && (meta.spiral || meta.spiralPattern))
                                    });
                                    if (idxK>=0) {
                                        if(!game._projMeta) game._projMeta = new Map();
                                        const md = { veerChild:true, _initialFx: Math.cos(ang+offset), _initialFy: Math.sin(ang+offset) };
                                        // Propagate additive patterns
                                        if (meta && meta.pendulumPattern) md.pendulumPattern = true;
                                        if (meta && meta.pivotPattern) md.pivotPattern = true;
                                        if (meta && meta.hasUzumaki) {
                                            md.hasUzumaki = true;
                                            md._uzuCx = (meta._uzuCx!=null?meta._uzuCx:game.player.x);
                                            md._uzuCy = (meta._uzuCy!=null?meta._uzuCy:game.player.y);
                                            md._uzuAngle = ang + offset;
                                            md._uzuRadius = 16;
                                            md._uzuAngularVel = 0.18 + Math.random()*0.05;
                                            md._uzuRadialVel = 1.35 + Math.random()*0.35;
                                            md._uzuDrag = 0.000;
                                        }
                                        game._projMeta.set(idxK, md);
                                    }
                                }
                                // subtle fan guide lines (perf-aware)
                                if (!(game.perf && game.perf.lowFx)) {
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!reduceRings) addParticle(x[i], y[i], '#FFF2CC','ring');
                                }
                                addParticle(x[i], y[i], '#FFF2CC','spark');
                            }
                        }
                        // Bloom Ring: periodically emit an expanding pellet ring from this projectile
                        if (meta && meta.bloomRing && !meta._bloomDone && !meta.beam && !meta.enemy) {
                            if (!meta._bloomInit) {
                                meta._bloomInit = true;
                                meta._bloomTimer = 28;          // cadence between blooms
                                meta._bloomWarnFrames = 4;      // pre-emit telegraph
                                meta._bloomPellets = 12;        // number of pellets in ring
                                meta._bloomSpeed = 3.4;         // pellet speed
                                meta._bloomLife = 60;           // pellet life
                            }
                            meta._bloomTimer--;
                            if (meta._bloomTimer === meta._bloomWarnFrames) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFE6CC','ring');
                            }
                            if (meta._bloomTimer <= 0) {
                                meta._bloomTimer = 28;
                                const pellets = Math.max(6, meta._bloomPellets|0);
                                const base = meta.baseDamage || damage[i] || 1;
                                for (let p=0; p<pellets; p++) {
                                    const ang = (p / pellets) * Math.PI * 2;
                                    const nvx = Math.cos(ang) * meta._bloomSpeed;
                                    const nvy = Math.sin(ang) * meta._bloomSpeed;
                                    const idxB = game.spawnProjectile && game.spawnProjectile({ x:x[i], y:y[i], vx:nvx, vy:nvy, life: meta._bloomLife, r: Math.max(10, Math.floor((radius[i]||6)*1.10)), damage: Math.max(1, Math.floor(base*0.40)) });
                                    if (idxB>=0) {
                                        if (!game._projMeta) game._projMeta = new Map();
                                        game._projMeta.set(idxB, { bloomChild:true, _initialFx:Math.cos(ang), _initialFy:Math.sin(ang), baseDamage: Math.max(1, Math.floor(base*0.40)) });
                                    }
                                }
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!reduceRings) addParticle(x[i], y[i], '#FFD9AA','ring');
                                if (!lowFx && !hideSparks) for (let s=0;s<4;s++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFCC88','spark');
                            }
                        }
                        // Decay transient cue timers if present
                        if (meta && meta._pierceFlash) { meta._pierceFlash--; if (meta._pierceFlash <= 0) meta._pierceFlash = 0; }
                        if (meta && meta._bounceFlash) { meta._bounceFlash--; if (meta._bounceFlash <= 0) meta._bounceFlash = 0; }
                        // Time Bomb: mirror fuse glow intensity into SoA meta when countdown exists on meta
                        if (meta && meta.timeBomb) {
                            if (typeof meta._timeBombTimer === 'number') {
                                if (typeof meta._tbFuseMax !== 'number') meta._tbFuseMax = meta._timeBombTimer;
                                const maxF = Math.max(1, meta._tbFuseMax || 54);
                                const tLeft = Math.max(0, meta._timeBombTimer);
                                const frac = 1 - Math.min(1, tLeft / maxF);
                                meta._tbGlowI = Math.min(1, frac*frac * (meta._timeBombArmed ? 1.2 : 1));
                                meta._timeBombTimer--; // SoA countdown for SoA-based projectiles
                                if (meta._timeBombTimer <= 0 && alive[i] && !meta._timeBombExploded) {
                                    meta._timeBombExploded = true;
                                    // Compute explosion damage similar to object path
                                    const baseD = meta.baseDamage || damage[i] || calculateDamage();
                                    const dmg = Math.floor(baseD * (meta._timeBombExplosionMult || 2.0));
                                    // Trigger explosion using centralized handler; mark as timeBomb for enhanced FX/shards
                                    explodeProjectile({ x: x[i], y: y[i], size: radius[i], timeBomb: true, baseDamage: baseD, enemy: false }, dmg);
                                    life[i] = 0; // remove SoA projectile after detonation
                                }
                            }
                        }
                    }
                }
                // After iterating through active projectiles, check SIGMA sigma2 trackers for completion
                if (game._sigma && game._sigma.trackers && game._sigma.trackers.size) {
                    // Count remaining alive kids by checking SoA alive[] flags
                    for (const [token, tr] of game._sigma.trackers.entries()) {
                        if (!tr || !tr.kids || tr._spawned) continue;
                        let remaining = 0; let cx = 0, cy = 0, cnt = 0;
                        for (let k=0; k<tr.kids.length; k++) {
                            const idx = tr.kids[k];
                            if (typeof idx === 'number' && idx >= 0 && idx < MAX) {
                                if (alive[idx]) {
                                    // Validate that this alive projectile is still one of our sigma2 children (token match)
                                    const metaK = game._projMeta && game._projMeta.get(idx);
                                    if (metaK && metaK.sigma2 && metaK._sigmaToken === token) {
                                        remaining++; cx += x[idx]; cy += y[idx]; cnt++;
                                    }
                                }
                            }
                        }
                        const nowF = (typeof game.frame==='number') ? game.frame : 0;
                        // Fallback timeout: if tracker has existed > 420 frames (~7s) and still not resolved, force spawn
                        const force = tr.createdFrame != null && (nowF - tr.createdFrame > 420);
                        if (remaining === 0 || force) {
                            tr._spawned = true;
                            const sx = (tr._centroidX != null) ? tr._centroidX : (cnt>0 ? cx/cnt : tr.originX);
                            const sy = (tr._centroidY != null) ? tr._centroidY : (cnt>0 ? cy/cnt : tr.originY);
                            const power = Math.max(1, Math.floor(calculateDamage() * 1.3));
                            spawnSigma3(sx, sy, power);
                            // Clean up tracker to avoid leaks
                            game._sigma.trackers.delete(token);
                        }
                    }
                }
            }
            // Render (batched by color to reduce state churn)
            // Pre-render small circle sprites (r 1..10) for each palette color
            const spriteCache = [];
            (function buildSprites(){
                for (let c=0;c<palette.length;c++){
                    spriteCache[c] = [];
                    for (let r=1;r<=10;r++){
                        const off = document.createElement('canvas');
                        const sz = r*2; off.width = sz; off.height = sz;
                        const ictx = off.getContext('2d');
                        ictx.fillStyle = palette[c];
                        ictx.beginPath(); ictx.arc(r, r, r, 0, Math.PI*2); ictx.fill();
                        spriteCache[c][r] = off;
                    }
                }
            })();
            function renderProjectiles(ctx){
                for (let i=0;i<MAX;i++){
                    if (!alive[i]) continue;
                    const r = radius[i];
                    const cx = x[i]; const cy = y[i];
                    const cIndex = colorIdx[i];
                    const meta = game._projMeta && game._projMeta.get(i);
                    // Enemy bullets are drawn in a dedicated top-layer pass for visibility; skip here
                    if (meta && meta.enemy) {
                        continue;
                    }
                    // Void travel visuals: purple lensing aura + faint trailing ribbon
                    // Applies to any projectile marked as Void (damageType/energyType or _isVoid flag)
                    {
                        const isVoid = !!(meta && (meta._isVoid || meta.damageType === 'void' || meta.energyType === 'void'));
                        if (isVoid) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            // Subtle lensing aura (drawn beneath bodies)
                            if (!lowFx && !game.potatoMode) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const rr = Math.max(10, r * 1.6);
                                const g = ctx.createRadialGradient(cx, cy, rr*0.20, cx, cy, rr);
                                g.addColorStop(0, 'rgba(20, 0, 30, 0.70)');
                                g.addColorStop(0.55, 'rgba(136, 68, 170, 0.22)');
                                g.addColorStop(1, 'rgba(136, 68, 170, 0.00)');
                                ctx.fillStyle = g;
                                ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            // Trailing ribbon (perf-aware, respects hideSpokes)
                            const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                            if (!lowFx && !hideSpokes) {
                                // Maintain a tiny trail buffer in metadata (per projectile)
                                if (!meta._voidTrail) { meta._voidTrail = []; meta._vtLastFrame = -1; meta._vtCap = 12; }
                                const nowFrame = (game && game.frame) || 0;
                                if (meta._vtLastFrame !== nowFrame) {
                                    meta._voidTrail.push({ x: cx, y: cy });
                                    // Degrade gracefully under load
                                    const tier = (typeof game.projectileDegradeTier === 'number') ? game.projectileDegradeTier : 0;
                                    const cap = tier >= 3 ? 5 : (tier >= 2 ? 8 : meta._vtCap);
                                    while (meta._voidTrail.length > cap) meta._voidTrail.shift();
                                    meta._vtLastFrame = nowFrame;
                                }
                                const pts = meta._voidTrail;
                                if (pts && pts.length >= 2) {
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'lighter';
                                    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                                    for (let t=1; t<pts.length; t++) {
                                        const p0 = pts[t-1], p1 = pts[t];
                                        const f = t / pts.length; // older -> smaller f
                                        const alpha = 0.08 + 0.22 * f;
                                        const w = Math.max(1.0, (r * 0.22) * f + 0.6);
                                        ctx.strokeStyle = `rgba(136, 68, 170, ${alpha.toFixed(3)})`;
                                        ctx.lineWidth = w;
                                        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                                    }
                                    ctx.restore();
                                }
                            }
                        }
                    }
                    // Shadow travel visuals: dark-violet aura + wispy smoky trail
                    {
                        const isShadow = !!(meta && (meta._isShadow || meta.damageType === 'shadow' || meta.energyType === 'shadow'));
                        if (isShadow) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            // Lensing aura (darker, slightly smaller than Void to differentiate)
                            if (!lowFx && !game.potatoMode) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const rr = Math.max(10, r * 1.45);
                                const g = ctx.createRadialGradient(cx, cy, rr*0.18, cx, cy, rr);
                                g.addColorStop(0, 'rgba(5, 0, 10, 0.80)');
                                g.addColorStop(0.55, 'rgba(170, 102, 255, 0.20)');
                                g.addColorStop(1, 'rgba(170, 102, 255, 0.00)');
                                ctx.fillStyle = g;
                                ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            // Wispy trail (thinner, smokier than Void)
                            const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                            if (!lowFx && !hideSpokes) {
                                if (!meta._shadowTrail) { meta._shadowTrail = []; meta._stLastFrame = -1; meta._stCap = 10; }
                                const nowFrame = (game && game.frame) || 0;
                                if (meta._stLastFrame !== nowFrame) {
                                    meta._shadowTrail.push({ x: cx, y: cy });
                                    const tier = (typeof game.projectileDegradeTier === 'number') ? game.projectileDegradeTier : 0;
                                    const cap = tier >= 3 ? 4 : (tier >= 2 ? 7 : meta._stCap);
                                    while (meta._shadowTrail.length > cap) meta._shadowTrail.shift();
                                    meta._stLastFrame = nowFrame;
                                }
                                const pts = meta._shadowTrail;
                                if (pts && pts.length >= 2) {
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'lighter';
                                    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                                    for (let t=1; t<pts.length; t++) {
                                        const p0 = pts[t-1], p1 = pts[t];
                                        const f = t / pts.length;
                                        const alpha = 0.06 + 0.18 * f;
                                        const w = Math.max(0.8, (r * 0.18) * f + 0.5);
                                        ctx.strokeStyle = `rgba(170, 102, 255, ${alpha.toFixed(3)})`;
                                        ctx.lineWidth = w;
                                        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                                    }
                                    ctx.restore();
                                }
                            }
                            // Vignette pulse (darken surroundings)  multiply blend, stronger than before
                            if (!lowFx && !game.potatoMode) {
                                const t = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const pulse = 0.65 + 0.35 * Math.sin((t + (cx*0.3 + cy*0.2)) * 0.12);
                                const rrV = Math.max(16, r * 2.2);
                                ctx.save();
                                ctx.globalCompositeOperation = 'multiply';
                                // Outer vignette
                                let vg = ctx.createRadialGradient(cx, cy, rrV*0.50, cx, cy, rrV);
                                vg.addColorStop(0, 'rgba(0,0,0,0)');
                                vg.addColorStop(1, `rgba(0,0,0,${(0.22 * pulse).toFixed(3)})`);
                                ctx.fillStyle = vg;
                                ctx.beginPath(); ctx.arc(cx, cy, rrV, 0, Math.PI*2); ctx.fill();
                                // Inner dark core for shadow (subtle)
                                const innerR = Math.max(8, r * 1.0);
                                const ig = ctx.createRadialGradient(cx, cy, 0, cx, cy, innerR);
                                ig.addColorStop(0, 'rgba(0,0,0,0.25)');
                                ig.addColorStop(1, 'rgba(0,0,0,0)');
                                ctx.fillStyle = ig;
                                ctx.beginPath(); ctx.arc(cx, cy, innerR, 0, Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            // Animated shadow tendrils curling around/behind projectile
                            if (!lowFx && !(game.fxFlags && game.fxFlags.hideSpokes)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const ang = Math.atan2(vy[i], vx[i]);
                                const baseLen = Math.max(14, r * 1.4);
                                const tendrils = 2; // keep light
                                for (let td=0; td<tendrils; td++) {
                                    const seed = (i*37 + td*97);
                                    const tNow = (game && typeof game.frame==='number') ? game.frame : Math.floor(Date.now()/16);
                                    const wave = Math.sin((tNow + seed) * 0.08 + td) * 0.6;
                                    const curl = 0.6 + 0.4 * Math.sin((tNow + seed*0.5) * 0.05);
                                    const len = baseLen * (1.0 + 0.35 * Math.sin((tNow + seed) * 0.06 + td*0.7));
                                    const width = Math.max(1.0, r * 0.18);
                                    // Control points create a slight S-curve behind the projectile
                                    const back = Math.max(4, r * 0.6);
                                    const p0x = cx - Math.cos(ang) * back;
                                    const p0y = cy - Math.sin(ang) * back;
                                    const p1x = p0x - Math.cos(ang + 0.6 + wave*0.3) * (len * 0.5);
                                    const p1y = p0y - Math.sin(ang + 0.6 + wave*0.3) * (len * 0.5);
                                    const p2x = p0x - Math.cos(ang + 1.4 * curl + wave*0.2) * len;
                                    const p2y = p0y - Math.sin(ang + 1.4 * curl + wave*0.2) * len;
                                    ctx.strokeStyle = 'rgba(170, 102, 255, 0.22)';
                                    ctx.lineWidth = width;
                                    ctx.beginPath();
                                    ctx.moveTo(p0x, p0y);
                                    ctx.quadraticCurveTo(p1x, p1y, p2x, p2y);
                                    ctx.stroke();
                                }
                                ctx.restore();
                            }
                            // Emit occasional shadow wisp particles behind projectile
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!lowFx && !hideSparks) {
                                const sp = Math.hypot(vx[i], vy[i]);
                                const baseProb = 0.06 + Math.min(0.10, sp * 0.01); // faster -> slightly more wisps
                                if (Math.random() < baseProb) {
                                    const ang = Math.atan2(vy[i], vx[i]);
                                    const back = Math.max(4, r * 0.6);
                                    const px = cx - Math.cos(ang) * back + (Math.random()-0.5)*2;
                                    const py = cy - Math.sin(ang) * back + (Math.random()-0.5)*2;
                                    // Prefer 'swirl' for wispy look; fall back to 'dust' occasionally
                                    if (Math.random() < 0.75) addParticle(px, py, '#B07AFF', 'swirl');
                                    else addParticle(px, py, '#A46BFF', 'dust');
                                }
                            }
                        }
                    }
                    // Spiral Bloom petals: render with random bloom sprites and independent spin
                    if (meta && meta.petal && !meta.enemy && !meta.beam) {
                        // Initialize spin angle storage
                        if (typeof meta._petalAngle !== 'number') meta._petalAngle = 0;
                        const spin = (typeof meta.petalSpin === 'number') ? meta.petalSpin : 0.08;
                        meta._petalAngle += spin;
                        // Resolve image key (random at spawn or fallback now)
                        const key = meta.petalImg || ('bloom' + (1 + Math.floor(Math.random()*6)));
                        meta.petalImg = key; // persist choice
                        const img = window._bulletImages && window._bulletImages[key];
                        const ang = meta._petalAngle || 0;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Scale sprite so the larger drawn dimension has half-size equal to r
                            // This keeps collision radius (r) matched to the sprites max side.
                            const iw = img.naturalWidth, ih = img.naturalHeight;
                            const maxSide = Math.max(iw, ih) || 1;
                            const s = Math.max(0.1, (r * 2) / maxSide);
                            const w = iw * s;
                            const h = ih * s;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                        } else {
                            // Fallback simple petal: small rotated ellipse
                            const rx = Math.max(4, r * 1.4);
                            const ry = Math.max(3, r * 0.9);
                            ctx.fillStyle = '#FFE6AA';
                            ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        // Optional faint glow for petals (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx && !game.potatoMode) {
                            ctx.save(); ctx.globalCompositeOperation = 'lighter';
                            const rr = Math.max(8, r * 1.2);
                            const g = ctx.createRadialGradient(cx, cy, rr*0.25, cx, cy, rr);
                            g.addColorStop(0, 'rgba(255, 220, 160, 0.12)');
                            g.addColorStop(1, 'rgba(255, 220, 160, 0)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        continue;
                    }
                    // SIGMA sprites rendering
                    if (meta && (meta.sigma1 || meta.sigma2 || meta.sigma3)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save();
                        ctx.translate(cx, cy);
                        if (meta.sigma3) {
                            // Spinner rotates in place; use meta._spin for rotation
                            const img = window._bulletImages && window._bulletImages.sigma3;
                            const rot = typeof meta._spin === 'number' ? meta._spin : 0;
                            ctx.rotate(rot);
                            if (img && img._ok && img.complete && img.naturalWidth) {
                                // Draw size based on stored visual radius (meta._auraRadius), not collision radius
                                const vr = (meta && typeof meta._auraRadius === 'number') ? meta._auraRadius : (Math.min((ctx.canvas&&ctx.canvas.width)||800,(ctx.canvas&&ctx.canvas.height)||600) * 0.10);
                                const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                                let w = vr * 2, h = w / aspect;
                                ctx.imageSmoothingEnabled = true;
                                ctx.drawImage(img, -w/2, -h/2, w, h);
                            } else {
                                // Fallback: bright rotating star
                                const rr = Math.max(12, ((meta && meta._auraRadius) ? meta._auraRadius : r) * 1.0);
                                ctx.fillStyle = '#BBD7FF';
                                ctx.beginPath(); ctx.arc(0,0,rr,0,Math.PI*2); ctx.fill();
                            }
                        } else if (meta.sigma1) {
                            // Large, strong-homing stage 1
                            const img = window._bulletImages && window._bulletImages.sigma1;
                            if (isFinite(ang)) ctx.rotate(ang);
                            if (img && img._ok && img.complete && img.naturalWidth) {
                                const base = Math.max(22, r * 2.2);
                                const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                                let w = base * 1.1, h = w / aspect;
                                ctx.imageSmoothingEnabled = true;
                                ctx.drawImage(img, -w*0.1, -h/2, w, h);
                            } else {
                                // Fallback ellipse
                                const rr = Math.max(8, r * 1.1);
                                ctx.fillStyle = '#CCE6FF';
                                ctx.beginPath(); ctx.ellipse(0, 0, rr*1.4, rr*0.9, 0, 0, Math.PI*2); ctx.fill();
                            }
                        } else if (meta.sigma2) {
                            // Smaller homing fragments
                            const img = window._bulletImages && window._bulletImages.sigma2;
                            if (isFinite(ang)) ctx.rotate(ang);
                            if (img && img._ok && img.complete && img.naturalWidth) {
                                const base = Math.max(14, r * 1.8);
                                const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                                let w = base, h = w / aspect;
                                ctx.imageSmoothingEnabled = true;
                                ctx.drawImage(img, -w*0.1, -h/2, w, h);
                            } else {
                                const rr = Math.max(6, r * 0.9);
                                ctx.fillStyle = '#DDEBFF';
                                ctx.beginPath(); ctx.ellipse(0, 0, rr*1.2, rr*0.8, 0, 0, Math.PI*2); ctx.fill();
                            }
                        }
                        ctx.restore();
                        // Subtle glow for all SIGMA projectiles (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx && !game.potatoMode) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            const glowR = meta.sigma3 ? Math.max(20, (Math.min((ctx.canvas&&ctx.canvas.width)||800,(ctx.canvas&&ctx.canvas.height)||600) * 0.11)) : Math.max(12, r * 1.2);
                            const g = ctx.createRadialGradient(cx, cy, glowR*0.25, cx, cy, glowR);
                            g.addColorStop(0, meta.sigma3 ? 'rgba(180,210,255,0.22)' : 'rgba(200,230,255,0.18)');
                            g.addColorStop(1, 'rgba(180,210,255,0)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        continue;
                    }
                    // EKG trail: leave a short trailing polyline to sell motion during spikes
                    if ((flags[i] & FLAG.EKG) || (meta && meta.ekgWave)) {
                        if (meta) {
                            // Initialize or append to a small ring buffer of previous positions
                            const nowFrame = (game && game.frame) || 0;
                            if (!meta._ekgTrail) { meta._ekgTrail = []; meta._ekgTrailMax = 14; meta._ekgTrailLast = nowFrame; }
                            // Add a point every 1-2 frames to avoid overdraw
                            if (nowFrame !== meta._ekgTrailLast) {
                                meta._ekgTrail.push({ x: cx, y: cy });
                                if (meta._ekgTrail.length > meta._ekgTrailMax) meta._ekgTrail.shift();
                                meta._ekgTrailLast = nowFrame;
                            }
                            // Also emit damaging trail segments from recent path points
                            if (meta._ekgTrail && meta._ekgTrail.length >= 2) {
                                const pts = meta._ekgTrail;
                                const p0 = pts[pts.length-2], p1 = pts[pts.length-1];
                                if (!Array.isArray(game.ekgTrailSegments)) game.ekgTrailSegments = [];
                                if (game.ekgTrailSegments.length > 160) game.ekgTrailSegments.splice(0, game.ekgTrailSegments.length - 160);
                                const baseDmg = (meta.baseDamage || damage && damage[i]) || calculateDamage && calculateDamage() || 8;
                                game.ekgTrailSegments.push({ x1:p0.x, y1:p0.y, x2:p1.x, y2:p1.y, ttl: 28, maxTtl: 28, w: Math.max(4, r*0.35), dps: Math.max(1, Math.floor(baseDmg*0.15)), hitMap: new Map() });
                            }
                            // Render trail as a tapered green line (lighter compositing)
                            if (meta._ekgTrail && meta._ekgTrail.length >= 2) {
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                if (!(lowFx && reduceRings)) {
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'lighter';
                                    ctx.lineCap = 'round';
                                    ctx.lineJoin = 'round';
                                    // Draw segments with decreasing alpha and width
                                    const pts = meta._ekgTrail;
                                    for (let t=1; t<pts.length; t++) {
                                        const p0 = pts[t-1], p1 = pts[t];
                                        const f = t / pts.length; // older -> smaller f
                                        const alpha = 0.10 + 0.35 * f;
                                        const w = Math.max(1.2, (r*0.22) * f + 0.8);
                                        ctx.strokeStyle = `rgba(120, 255, 180, ${alpha.toFixed(3)})`;
                                        ctx.lineWidth = w;
                                        ctx.beginPath();
                                        ctx.moveTo(p0.x, p0.y);
                                        ctx.lineTo(p1.x, p1.y);
                                        ctx.stroke();
                                    }
                                    ctx.restore();
                                }
                            }
                        }
                    }
                    // Time Bomb: sprite + fuse glow
                    if (meta && meta.timeBomb) {
                        const img = window._bulletImages && window._bulletImages.timebomb;
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save();
                        ctx.translate(cx, cy);
                        if (isFinite(ang)) ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(18, r * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base, h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                            // Fuse-tip spark: place a small glow near front/top-right of the sprite along facing
                            const tbI = (meta._tbGlowI != null ? meta._tbGlowI : 0);
                            const fuseOff = Math.max(6, w * 0.28);
                            const fx = Math.cos(0) * fuseOff; // after rotation, (1,0) points forward
                            const fy = -Math.max(2, h * 0.08);
                            const sparkAlpha = 0.35 + 0.45 * Math.min(1, tbI * 1.2);
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = sparkAlpha;
                            const sR = Math.max(1.8, Math.min(4.0, w * 0.08 + tbI * 2));
                            const grad = ctx.createRadialGradient(fx, fy, 0, fx, fy, sR);
                            grad.addColorStop(0, 'rgba(255,220,140,0.95)');
                            grad.addColorStop(1, 'rgba(255,160,60,0)');
                            ctx.fillStyle = grad;
                            ctx.beginPath(); ctx.arc(fx, fy, sR, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        } else {
                            // Fallback: dark shell circle
                            const rr = Math.max(10, r * 1.2);
                            ctx.fillStyle = '#443322';
                            ctx.beginPath(); ctx.arc(0,0,rr,0,Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#AA7744'; ctx.lineWidth = Math.max(1.2, rr*0.12);
                            ctx.beginPath(); ctx.arc(0,0,rr*0.7,0,Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                        // Fuse glow overlay (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx && !game.potatoMode) {
                            const tbI = (meta._tbGlowI != null ? meta._tbGlowI : 0.0);
                            const intensity = Math.max(0, Math.min(1, tbI));
                            if (intensity > 0.02) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const glowR = Math.max(12, r * (1.4 + 0.9*intensity));
                                const g = ctx.createRadialGradient(cx, cy, glowR*0.25, cx, cy, glowR);
                                g.addColorStop(0, `rgba(255, 210, 120, ${(0.10 + 0.28*intensity).toFixed(3)})`);
                                g.addColorStop(1, 'rgba(255, 210, 120, 0)');
                                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();
                                if (intensity > 0.55) {
                                    ctx.globalAlpha = 0.25 + 0.45*(intensity - 0.55);
                                    ctx.strokeStyle = '#FFB366'; ctx.lineWidth = 2;
                                    ctx.beginPath(); ctx.arc(cx, cy, Math.max(r+5, glowR*0.55), 0, Math.PI*2); ctx.stroke();
                                }
                                ctx.restore();
                            }
                            // Ambient micro-sparks cadence speeds up near detonation
                            if (meta._tbGlowI && Math.random() < (0.06 + meta._tbGlowI * 0.12)) {
                                addParticle(cx + (Math.random()-0.5)*6, cy + (Math.random()-0.5)*6, '#FFD98A','spark');
                            }
                        }
                        continue;
                    }
                    // Tumbleweed / Kick the Can: sprite-based rolling with spin proportional to speed
                    if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                        const img = (window._bulletImages && (meta.kickTheCan ? window._bulletImages.beans : window._bulletImages.tumbleweed));
                        const sp = Math.hypot(vy[i], vx[i]);
                        if (typeof meta._rollAngle !== 'number') meta._rollAngle = 0;
                        // roll speed scaled by pixel speed and radius; clamp to avoid excessive spin
                        const spinRate = Math.min(0.45, 0.06 + sp * 0.025);
                        meta._rollAngle += spinRate;
                        const ang = meta._rollAngle;
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(22, r * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base, h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                        } else {
                            // Fallback: simple textured circle
                            const rr = Math.max(10, r * 1.15);
                            const g = ctx.createRadialGradient(0, 0, rr*0.2, 0, 0, rr);
                            g.addColorStop(0, 'rgba(230,200,150,0.9)');
                            g.addColorStop(1, 'rgba(180,140,90,0.95)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,rr,0,Math.PI*2); ctx.fill();
                            ctx.strokeStyle = 'rgba(120,90,60,0.45)'; ctx.lineWidth = Math.max(1, rr*0.12);
                            ctx.beginPath(); ctx.arc(0,0, rr*0.65, 0, Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                        // Optional subtle dust puffs when rolling fast (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!lowFx && !hideSparks && sp > 2.8 && Math.random()<0.08) {
                            addParticle(cx - Math.sign(vx[i]) * r*0.4 + (Math.random()-0.5)*4, cy - Math.sign(vy[i]) * r*0.4 + (Math.random()-0.5)*4, '#EFDDBF','dust');
                        }
                        continue;
                    }
                    // Ion Cannon: initial release ring (first few frames after spawn)
                    if (meta && meta.energyType === 'ion') {
                        // Draw the ion projectile sprite aligned to travel
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.ion;
                        const ch = Math.max(0, Math.min(1, (meta.charge||0))); // 0..1
                        ctx.save(); ctx.translate(cx, cy); if (isFinite(ang)) ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Base scales with radius and increases further with charge
                            const base = Math.max(18, r * 2.0) * (1.0 + ch * 0.8);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base * 1.15; let h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            // Slight forward offset so the sprite nose leads
                            ctx.drawImage(img, -w*0.1, -h/2, w, h);
                        } else {
                            // Fallback: small cyan capsule
                            const rr = Math.max(6, r * 0.9);
                            ctx.fillStyle = '#B3EEFF';
                            ctx.beginPath(); ctx.ellipse(0, 0, rr*1.3, rr*0.9, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        const age = (lifeMax[i] - life[i]) | 0; // frames since spawn
                        if (age < 8) {
                            const fade = 1 - age / 8;
                            const baseR = Math.max(10, r * 1.2);
                            const rr = baseR + ch * 10;
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            // Outer white ring
                            ctx.strokeStyle = 'rgba(255,255,255,' + (0.55 * fade).toFixed(3) + ')';
                            ctx.lineWidth = 2.5;
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.stroke();
                            // Soft cyan glow
                            const g = ctx.createRadialGradient(cx, cy, rr*0.35, cx, cy, rr);
                            g.addColorStop(0, 'rgba(180,245,255,' + (0.12 + 0.25 * fade).toFixed(3) + ')');
                            g.addColorStop(1, 'rgba(180,245,255,0)');
                            ctx.fillStyle = g;
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        // Done rendering Ion Cannon; skip default projectile draw
                        continue;
                    }
                    // Resonant Pulse overlay rings (SoA)  expanding/fading ring at pulse; perf-gated
                    if (meta && meta._resActiveRings && meta._resActiveRings.length && !(game.perf && game.perf.lowFx)) {
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        for (let ri=0; ri<meta._resActiveRings.length; ri++) {
                            const ring = meta._resActiveRings[ri];
                            const rr = Math.max(4, ring.r || 0);
                            const lifeNorm = Math.max(0, Math.min(1, (ring.life != null ? ring.life : 0) / 38));
                            const alpha = 0.60 * lifeNorm;
                            ctx.strokeStyle = `rgba(199,164,255,${alpha.toFixed(3)})`;
                            ctx.lineWidth = 2 + 1.4 * lifeNorm;
                            if (!reduceRings && ctx.setLineDash) ctx.setLineDash([6, 6]);
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.stroke();
                            if (!reduceRings && ctx.setLineDash) ctx.setLineDash([]);
                        }
                        ctx.restore();
                    }
                    // Slalom visual cue: alternating chevrons when pattern active (skip for Diarrhea to keep brown-only)
                    if (meta && meta.slalomPattern && !(meta && meta._diarrheaBrown)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const chevronLen = Math.max(8, r * 1.6);
                        const chevronW = Math.max(1.5, r * 0.35);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        ctx.strokeStyle = 'rgba(120,220,255,0.7)'; ctx.lineWidth = Math.max(1, chevronW*0.5);
                        // draw two chevrons offset on either side
                        ctx.beginPath();
                        ctx.moveTo(-chevronLen*0.8, -chevronW);
                        ctx.lineTo(-chevronLen*0.4, 0);
                        ctx.lineTo(-chevronLen*0.8, chevronW);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-chevronLen*0.3, -chevronW);
                        ctx.lineTo(chevronLen*0.1, 0);
                        ctx.lineTo(-chevronLen*0.3, chevronW);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // Sawtooth wave overlay: small jagged tick ahead of travel (perf-gated)
                    if (meta && meta.sawWave && !(game.perf && game.perf.lowFx)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const len = Math.max(8, r * 1.4);
                        const amp = Math.max(2, r * 0.35);
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!hideSpokes) {
                            ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                            ctx.strokeStyle = 'rgba(255,220,140,0.75)'; ctx.lineWidth = 1.2;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(len*0.35, -amp);
                            ctx.lineTo(len*0.7, amp);
                            ctx.lineTo(len, 0);
                            ctx.stroke();
                            ctx.restore();
                        } else if (!reduceRings) {
                            addParticle(cx, cy, '#FFD280','ring');
                        }
                    }
                    // Pendulum arc cue: brief inner arc when swing flips (perf-gated by reduceRings)
                    if (meta && meta.pendulumPattern && meta._pendCue > 0) {
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!reduceRings && !lowFx) {
                            const ang = Math.atan2(vy[i], vx[i]);
                            const arcR = Math.max(8, r * 1.4);
                            ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                            ctx.strokeStyle = 'rgba(200,235,255,0.8)'; ctx.lineWidth = 1.6;
                            ctx.beginPath();
                            ctx.arc(0, 0, arcR, -0.6, 0.6);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                    // Vector Pivot cue: quick tick perpendicular to velocity when large pivot detected
                    if (meta && meta.pivotPattern && meta._pivotCue > 0 && !(game.perf && game.perf.lowFx)) {
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const ang = Math.atan2(vy[i], vx[i]);
                        if (!hideSpokes) {
                            const len = Math.max(6, r * 1.2);
                            ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + Math.PI/2);
                            ctx.strokeStyle = 'rgba(180,245,255,0.9)'; ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.moveTo(0, -len*0.5); ctx.lineTo(0, len*0.5); ctx.stroke();
                            ctx.restore();
                        } else if (!reduceRings) {
                            addParticle(cx, cy, '#B4F5FF','ring');
                        }
                    }
                    // Void projectile aura/trail: subtle purple lensing + short back trail
                    if (meta && (meta._isVoid || meta.damageType === 'void' || meta.energyType === 'void')) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const ang = Math.atan2(vy[i], vx[i]);
                        // Soft lensing aura
                        if (!lowFx && !game.potatoMode) {
                            const col = getDamageTypeColor('void') || '#8844AA';
                            const rr = Math.max(10, r * 1.5);
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            const g = ctx.createRadialGradient(cx, cy, rr*0.15, cx, cy, rr);
                            g.addColorStop(0, 'rgba(20, 0, 30, 0.45)');
                            g.addColorStop(0.55, 'rgba(136, 68, 170, 0.22)');
                            g.addColorStop(1, 'rgba(136, 68, 170, 0)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        // Short faint trail behind
                        if (!hideSpokes && !lowFx) {
                            const len = Math.max(8, r * 1.6);
                            const wid = Math.max(1.2, r * 0.22);
                            const alpha = 0.18 + Math.min(0.35, Math.hypot(vx[i], vy[i]) * 0.03);
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.translate(cx, cy); ctx.rotate(ang + Math.PI);
                            ctx.strokeStyle = `rgba(160,120,200,${alpha.toFixed(3)})`;
                            ctx.lineWidth = wid;
                            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.stroke();
                            ctx.restore();
                        } else if (!reduceRings && !lowFx) {
                            addParticle(cx, cy, '#C7A4FF','ring');
                        }
                    }
                    // Temporal Drift visual overlays (SoA): stronger pre-beat rings and surge glow/afterimage
                    if (meta && meta.temporalDrift) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const phase = meta._tdPhase || 0;
                        const timer = meta._tdTimer || 0;
                        // thresholds synced with logic
                        const th = phase === 0 ? 30 : (phase === 1 ? 10 : 18);
                        if (timer >= th - 4) {
                            ctx.save();
                            ctx.globalAlpha = 0.45;
                            ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                            ctx.lineWidth = 2.2;
                            ctx.beginPath(); ctx.arc(cx, cy, Math.max(8, r + 4), 0, Math.PI*2); ctx.stroke();
                            ctx.restore();
                            if (!lowFx && !reduceRings) {
                                const tight = Math.max(0, Math.min(1, (timer - (th - 4)) / 4));
                                ctx.save();
                                ctx.globalAlpha = 0.30 + 0.65 * tight;
                                ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                                ctx.lineWidth = 2.6;
                                ctx.beginPath(); ctx.arc(cx, cy, Math.max(10, r + 6), 0, Math.PI*2); ctx.stroke();
                                ctx.restore();
                            }
                        }
                        if (!lowFx && phase === 2) {
                            const t = (performance.now()/220) + (cx+cy)*0.002;
                            const pulse = 0.5 + 0.5*Math.sin(t*2*Math.PI);
                            const rr = Math.max(10, r * (1.35 + 0.35*pulse));
                            ctx.save();
                            const g = ctx.createRadialGradient(cx, cy, rr*0.10, cx, cy, rr);
                            g.addColorStop(0, 'rgba(170,250,255,' + (0.58 + 0.30*pulse).toFixed(3) + ')');
                            g.addColorStop(1, 'rgba(170,250,255,0)');
                            ctx.fillStyle = g;
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                            // Afterimage trail
                            meta._tdTrail = meta._tdTrail || [];
                            const buf = meta._tdTrail; buf.push({ x: cx, y: cy, t: performance.now() });
                            while (buf.length > 8) buf.shift();
                            ctx.save(); ctx.globalCompositeOperation = 'lighter';
                            for (let k=1; k<buf.length; k++) {
                                const p0 = buf[k-1], p1 = buf[k];
                                const ageMs = performance.now() - p0.t; const a = Math.max(0, 1 - ageMs/140);
                                if (a <= 0) continue;
                                ctx.strokeStyle = `rgba(164,245,255,${(0.20*a).toFixed(3)})`;
                                ctx.lineWidth = Math.max(1.2, r * 0.22 * a);
                                ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                            }
                            ctx.restore();
                        }
                    }
                    // Boomerang pre-return cue: faint ring + arrow toward player just before flip
                    if (meta && meta.boomerang && !meta._boomReturn && meta._boomPreCue > 0) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!lowFx && !reduceRings) {
                            const angToPlayer = (game.player ? Math.atan2(game.player.y - cy, game.player.x - cx) : Math.atan2(-vy[i], -vx[i]));
                            ctx.save();
                            ctx.translate(cx, cy);
                            // subtle ring
                            ctx.globalAlpha = 0.35;
                            ctx.strokeStyle = '#FFE6CC';
                            ctx.lineWidth = Math.max(1.2, r * 0.22);
                            ctx.beginPath(); ctx.arc(0, 0, Math.max(8, r*1.2), 0, Math.PI*2); ctx.stroke();
                            // arrow facing predicted return vector (toward player)
                            ctx.rotate(angToPlayer);
                            ctx.strokeStyle = 'rgba(255, 230, 180, 0.85)';
                            ctx.lineWidth = Math.max(1.2, r * 0.2);
                            const len = Math.max(8, r * 1.5);
                            ctx.beginPath();
                            ctx.moveTo(len*0.2, 0);
                            ctx.lineTo(len*0.8, 0);
                            ctx.moveTo(len*0.8, 0);
                            ctx.lineTo(len*0.55, -len*0.25);
                            ctx.moveTo(len*0.8, 0);
                            ctx.lineTo(len*0.55, len*0.25);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                    // Boomerang return chevrons: small inwards chevrons to indicate it's heading back
                    if (meta && meta.boomerang && meta._boomReturn && !(game.perf && game.perf.lowFx)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + Math.PI);
                        ctx.strokeStyle = 'rgba(255, 230, 180, 0.8)';
                        ctx.lineWidth = Math.max(1, r * 0.18);
                        const len = Math.max(6, r * 1.3);
                        // draw two inward-pointing small chevrons behind the projectile
                        ctx.beginPath();
                        ctx.moveTo(-len*0.2, -r*0.3);
                        ctx.lineTo(-len*0.6, 0);
                        ctx.lineTo(-len*0.2, r*0.3);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-len*0.6, -r*0.25);
                        ctx.lineTo(-len*0.95, 0);
                        ctx.lineTo(-len*0.6, r*0.25);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // Orbitals: no leash/spoke lines  keep the view clean while circling
                    // (intentionally no-op for meta._orbital)
                    // Teleport Shot shimmer: brief portal outline after spawn (perf-aware)
                    if (meta && meta.teleporting) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const age = (lifeMax[i] - life[i]) | 0; // frames since spawn/teleport
                        if (age >= 0 && age < 10) {
                            if (lowFx || hideSpokes) {
                                // Lightweight fallback: a couple of quick rings in the first few frames
                                if (!reduceRings && (age === 0 || age === 2)) {
                                    addParticle(cx, cy, '#FFE4AA', 'ring');
                                }
                            } else {
                                // Subtle portal ring + two rotating arc dashes with fading alpha
                                const fade = 1 - age / 10;
                                const rr = Math.max(10, r * 1.5);
                                ctx.save();
                                ctx.translate(cx, cy);
                                ctx.globalCompositeOperation = 'lighter';
                                // Outer soft ring
                                ctx.strokeStyle = `rgba(255, 230, 180, ${ (0.5 * fade).toFixed(3) })`;
                                ctx.lineWidth = Math.max(1.2, r * 0.25);
                                ctx.beginPath(); ctx.arc(0, 0, rr, 0, Math.PI*2); ctx.stroke();
                                // Rotating short arcs for shimmer feel
                                const t = (((window.game && window.game.frame) || 0) * 0.22 + i * 0.37);
                                ctx.rotate(t);
                                ctx.strokeStyle = `rgba(255, 215, 150, ${ (0.7 * fade).toFixed(3) })`;
                                ctx.lineWidth = Math.max(1.0, r * 0.2);
                                ctx.beginPath(); ctx.arc(0, 0, rr * 0.85, -0.55, -0.20); ctx.stroke();
                                ctx.beginPath(); ctx.arc(0, 0, rr * 0.85, 0.20, 0.55); ctx.stroke();
                                ctx.restore();
                            }
                        }
                    }
                    // Homing steer chevron: brief forward tick when homing makes a sharp turn
                    if (meta && meta._homCue > 0) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx) {
                            const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const ang = Math.atan2(vy[i], vx[i]);
                            if (!hideSpokes) {
                                const len = Math.max(6, r * 1.3);
                                ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                                ctx.strokeStyle = 'rgba(170,235,255,0.9)'; ctx.lineWidth = 1.8;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(len, 0);
                                ctx.stroke();
                                ctx.restore();
                            } else if (!reduceRings) {
                                addParticle(cx, cy, '#AEEBFF','ring');
                            }
                        }
                    }
                    // EKG spike overlay (draw early so it appears with any base shape). Skip for Diarrhea so it stays brown-only.
                    if (((flags[i] & FLAG.EKG) || (meta && meta.ekgWave)) && meta && meta._ekgSpikeVis > 0 && !(meta && meta._diarrheaBrown)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const len = Math.max(34, r * 5.2);
                        const w = Math.max(4.2, r * 0.92);
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(ang);
                        // Neon spike triangle pointing ahead of travel
                        const grd = ctx.createLinearGradient(0, -len, 0, 0);
                        grd.addColorStop(0, 'rgba(120,255,180,1.0)');
                        grd.addColorStop(1, 'rgba(120,255,180,0.22)');
                        ctx.fillStyle = grd;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(w, -len);
                        ctx.lineTo(-w, -len*0.75);
                        ctx.closePath();
                        ctx.fill();
                        // subtle outline for readability
                        ctx.strokeStyle = 'rgba(100,240,170,0.92)';
                        ctx.lineWidth = Math.max(2.2, w*0.24);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // BIG EKG spike overlay: larger and brighter glyph
                    if (((flags[i] & FLAG.EKG) || (meta && meta.ekgWave)) && meta && meta._ekgBigVis > 0 && !(meta && meta._diarrheaBrown)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const len = Math.max(46, r * 6.4);
                        const w = Math.max(4.8, r * 1.10);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const grd = ctx.createLinearGradient(0, -len, 0, 0);
                        grd.addColorStop(0, 'rgba(160,255,215,1.0)');
                        grd.addColorStop(1, 'rgba(160,255,215,0.28)');
                        ctx.fillStyle = grd;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(w, -len);
                        ctx.lineTo(-w, -len*0.86);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(120,255,190,0.98)';
                        ctx.lineWidth = Math.max(2.8, w*0.26);
                        ctx.stroke();
                        // Small inner core line to sell the sharp peak
                        ctx.strokeStyle = 'rgba(255,255,255,0.80)';
                        ctx.lineWidth = Math.max(1.8, w*0.16);
                        ctx.beginPath();
                        ctx.moveTo(0, -len*0.97);
                        ctx.lineTo(0, -len*0.60);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // Special beam rendering: draw elongated capsule along velocity
                    if (meta && meta.beam && !meta.enemy) {
                        const sp = Math.hypot(vx[i], vy[i]) || 0.0001; const fx=vx[i]/sp, fy=vy[i]/sp;
                        const len = meta.particleBeam ? 42 : 56; const core = meta.particleBeam ? Math.max(6, r+2) : Math.max(4, r);
                        const reduce = !!(game.fxFlags && game.fxFlags.reduceBeams);
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(Math.atan2(fy, fx));
                        // outer glow
                        const glowAlpha = reduce ? 0.12 : 0.20;
                        ctx.fillStyle = meta.particleBeam ? `rgba(255,200,80,${glowAlpha})` : `rgba(120,220,255,${glowAlpha})`;
                        const glowH = core * (reduce ? 1.4 : 1.9);
                        ctx.fillRect(0, -core*0.70, len, glowH);
                        // inner core
                        ctx.fillStyle = meta.particleBeam ? '#FFD466' : '#B3EEFF';
                        const coreH = core * (reduce ? 0.8 : 1.1);
                        ctx.fillRect(0, -coreH*0.5, len, coreH);
                        // Laser heat gradient accents (non-particle beams): subtle hot spots along beam
                        if (!meta.particleBeam) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            ctx.globalCompositeOperation = 'lighter';
                            if (lowFx || reduce) {
                                // Simple linear gradient overlay across beam height
                                const lg = ctx.createLinearGradient(0, -core, 0, core);
                                const g0 = reduce ? 0.04 : 0.06;
                                const g1 = reduce ? 0.12 : 0.18;
                                lg.addColorStop(0, `rgba(255,255,255,${g0})`);
                                lg.addColorStop(0.5, `rgba(255,255,255,${g1})`);
                                lg.addColorStop(1, `rgba(255,255,255,${g0})`);
                                ctx.fillStyle = lg;
                                ctx.fillRect(0, -core, len, core*2);
                            } else {
                                // A few small radial "hot cores" that flicker slightly
                                const t = performance.now() * 0.002;
                                const hotspots = reduce ? 2 : 4;
                                for (let h=0; h<hotspots; h++) {
                                    const frac = (h + 0.5) / hotspots;
                                    const hx = frac * len;
                                    const pulse = 0.8 + 0.2 * Math.sin(t + h*1.7);
                                    const rr = core * ((reduce?0.28:0.35) + 0.15 * pulse);
                                    const g = ctx.createRadialGradient(hx, 0, rr*0.15, hx, 0, rr);
                                    g.addColorStop(0, 'rgba(255,255,255,0.28)');
                                    g.addColorStop(0.5, `rgba(170,235,255,${reduce?0.12:0.18})`);
                                    g.addColorStop(1, 'rgba(170,235,255,0)');
                                    ctx.fillStyle = g;
                                    ctx.beginPath(); ctx.arc(hx, 0, rr, 0, Math.PI*2); ctx.fill();
                                }
                            }
                        }
                        ctx.restore();
                        continue;
                    }
                    // Diarrhea: always brown; render using sprite if available, else fallback to ellipse
                    if (meta && meta._diarrheaBrown) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const img = window._bulletImages && window._bulletImages.diarrhea;
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Base size derived from radius; slight forward stretch
                            const base = Math.max(14, r * 2.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                            let w = base * 1.15; let h = w / aspect;
                            // Draw centered, pointing forward
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w*0.15, -h/2, w, h);
                        } else {
                            // Fallback brown ellipse
                            const stretch = Math.max(1.0, Math.min(1.8, r * 0.12 + 1.0));
                            ctx.fillStyle = '#8B4513';
                            const rx = Math.max(4, r * stretch);
                            const ry = Math.max(3, r * 0.85);
                            ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2); ctx.fill();
                            ctx.fillStyle = '#6F3A11';
                            ctx.beginPath(); ctx.ellipse(-rx*0.12, 0, rx*0.55, ry*0.55, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Popcorn puff sprite (SoA)  draw if metadata marks this projectile as a puff
                    if (meta && meta.popcornPuff) {
                        const ang = (meta._puffSpin||0);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const img = window._bulletImages && window._bulletImages.popcorn;
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(14, r * 2.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                            let w = base; let h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                        } else {
                            // Fallback vector puff
                            const rr = Math.max(6, r * 0.9);
                            ctx.fillStyle = '#FFF9D6';
                            for (let l=0;l<5;l++) {
                                const a = l/5 * Math.PI*2;
                                const lr = rr * (0.55 + ((l%2)*0.15));
                                const lx = Math.cos(a)*rr*0.55;
                                const ly = Math.sin(a)*rr*0.55;
                                ctx.beginPath(); ctx.arc(lx, ly, lr, 0, Math.PI*2); ctx.fill();
                            }
                            ctx.fillStyle = 'rgba(255,180,60,0.35)';
                            ctx.beginPath(); ctx.arc(-rr*0.15, -rr*0.1, rr*0.65, 0, Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#E8D490'; ctx.lineWidth = 1.2;
                            ctx.beginPath(); ctx.arc(0,0,rr*0.95,0,Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Sword throw: sprite-based; points blade-first (no spin)
                    if (meta && meta.weaponType === 'sword') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.sword;
                        ctx.save(); ctx.translate(cx, cy); if (isFinite(ang)) ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(20, r * 3.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            // Slight forward offset so the blade tip leads
                            ctx.drawImage(img, -drawW * 0.05, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to previous vector sword if sprite not ready
                            const bladeLen = Math.max(18, r * 3.0);
                            const bladeW = Math.max(3, r * 0.5);
                            ctx.fillStyle = '#E6EEF8';
                            ctx.fillRect(0, -bladeW*0.5, bladeLen, bladeW);
                            ctx.fillStyle = '#C9D6E8';
                            ctx.fillRect(0, -bladeW*0.5, bladeLen, Math.max(1, bladeW*0.18));
                            ctx.beginPath();
                            ctx.moveTo(bladeLen, -bladeW*0.5);
                            ctx.lineTo(bladeLen + bladeW*0.9, 0);
                            ctx.lineTo(bladeLen, bladeW*0.5);
                            ctx.closePath();
                            ctx.fillStyle = '#F2F7FF';
                            ctx.fill();
                            const guardW = bladeW * 2.2; const guardH = Math.max(2, bladeW * 0.5);
                            ctx.fillStyle = '#C89B3C';
                            ctx.fillRect(-bladeW*0.4, -guardH*0.5, guardW, guardH);
                            const gripLen = bladeW * 1.8; ctx.fillStyle = '#6B4E28';
                            ctx.fillRect(-bladeW*0.4 - gripLen, -bladeW*0.25, gripLen, Math.max(2, bladeW*0.5));
                            ctx.fillStyle = '#C89B3C'; ctx.beginPath();
                            ctx.arc(-bladeW*0.4 - gripLen - bladeW*0.2, 0, Math.max(1.5, bladeW*0.3), 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Toenail Clibbins: sprite-based rendering
                    if (meta && (meta.weaponType === 'toenail' || meta.toenail)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const spin = meta && typeof meta._toeSpin === 'number' ? meta._toeSpin : 0;
                        const img = window._bulletImages && window._bulletImages.toenail;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + spin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Scale sprite by projectile radius; tune multipliers to taste
                            const baseSize = Math.max(14, r * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight;
                            const aspect = iw / ih;
                            let drawW = baseSize;
                            let drawH = baseSize / aspect;
                            // Slight stretch along travel to accent motion
                            drawW *= 1.05;
                            // Draw centered, pointing forward (rotate already applied)
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW * 0.1, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to vector crescent if image not ready
                            const baseR = Math.max(8, r * 1.2);
                            const innerR = baseR * 0.55;
                            const arcSweep = Math.PI * 1.05;
                            const cutX = baseR * 0.38;
                            ctx.beginPath();
                            const startA = -arcSweep/2; const endA = arcSweep/2;
                            ctx.arc(0,0,baseR,startA,endA,false);
                            ctx.arc(cutX,0, innerR, endA, startA, true);
                            ctx.closePath();
                            const grad = ctx.createLinearGradient(-baseR, -baseR, baseR, baseR);
                            grad.addColorStop(0,'#FFF8D7');
                            grad.addColorStop(0.45,'#FFE684');
                            grad.addColorStop(0.8,'#F3D266');
                            grad.addColorStop(1,'#D8B850');
                            ctx.fillStyle = grad; ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Dagger: short triangular blade + small guard and grip
                    if (meta && meta.weaponType === 'dagger') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const bladeLen = Math.max(12, r * 2.2);
                        const bladeW = Math.max(2, r * 0.45);
                        ctx.fillStyle = '#F1F6FF';
                        ctx.beginPath();
                        ctx.moveTo(0, -bladeW*0.5);
                        ctx.lineTo(bladeLen, 0);
                        ctx.lineTo(0, bladeW*0.5);
                        ctx.closePath(); ctx.fill();
                        // Tiny cross-guard
                        ctx.fillStyle = '#B3954A';
                        ctx.fillRect(-bladeW*0.25, -bladeW*0.35, bladeW*1.2, bladeW*0.7);
                        // Grip
                        const gripLen = bladeW * 1.2;
                        ctx.fillStyle = '#5A3E20';
                        ctx.fillRect(-bladeW*0.25 - gripLen, -bladeW*0.25, gripLen, bladeW*0.5);
                        ctx.restore();
                        continue;
                    }
                    // Drill: spinning bit with ring and motion streaks
                    // Only render the full drill sprite when weaponType is explicitly 'drill'.
                    // If meta.drilling is true but another weaponType is set (e.g., bread),
                    // we skip this replacement and add a light overlay after that weapon's draw.
                    if (meta && meta.weaponType === 'drill') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const phase = meta._drillPhase || 0;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        // core body
                        ctx.fillStyle = '#B8C7E0';
                        ctx.beginPath(); ctx.ellipse(0, 0, r*0.9, r*0.6, 0, 0, Math.PI*2); ctx.fill();
                        // dark tip wedge
                        ctx.fillStyle = '#6E7A8C';
                        ctx.beginPath();
                        ctx.moveTo(r*1.2, 0);
                        ctx.lineTo(r*0.2, -r*0.45);
                        ctx.lineTo(r*0.2,  r*0.45);
                        ctx.closePath(); ctx.fill();
                        // rotating ring
                        const ringR = r*1.2; const wob = Math.sin(phase)*0.4;
                        ctx.strokeStyle = 'rgba(200,230,255,0.85)'; ctx.lineWidth = Math.max(1.1, r*0.16);
                        ctx.beginPath(); ctx.ellipse(-r*0.2, 0, ringR*0.95, ringR*0.55, wob, 0, Math.PI*2); ctx.stroke();
                        // motion streaks behind
                        ctx.strokeStyle = 'rgba(160,190,235,0.7)'; ctx.lineWidth = Math.max(1, r*0.14);
                        ctx.beginPath();
                        ctx.moveTo(-r*1.0, -r*0.7);
                        ctx.lineTo(-r*2.0, -r*0.2);
                        ctx.moveTo(-r*1.0,  r*0.7);
                        ctx.lineTo(-r*2.0,  r*0.2);
                        ctx.stroke();
                        ctx.restore();
                        continue;
                    }
                    // Drilling overlay (non-replacing): if drilling flag is set but another weaponType already rendered,
                    // add a faint rotating ring and occasional spark to suggest drilling without changing the sprite.
                    if (meta && meta.drilling && meta.weaponType && meta.weaponType !== 'drill') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const phase = meta._drillPhase || 0;
                        // faint ring around the projectile
                        ctx.save();
                        ctx.translate(cx, cy);
                        const rr = Math.max(10, r * 1.0);
                        ctx.rotate(ang + phase*0.15);
                        ctx.strokeStyle = 'rgba(190,220,255,0.35)';
                        ctx.lineWidth = Math.max(1, r*0.12);
                        ctx.beginPath(); ctx.ellipse(0, 0, rr*0.95, rr*0.60, 0.25*Math.sin(phase*0.5), 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                        // occasional back-spark
                        if (!(game.perf && game.perf.lowFx) && Math.random() < 0.18) {
                            const bx = cx - Math.cos(ang) * Math.max(4, r*0.6);
                            const by = cy - Math.sin(ang) * Math.max(4, r*0.6);
                            addParticle(bx + (Math.random()-0.5)*3, by + (Math.random()-0.5)*3, '#D0E4FF','spark');
                        }
                        // do not continue; allow other overlays to run
                    }
                    // Spear: long shaft with metal tip and small rear feather
                    if (meta && meta.weaponType === 'spear') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const shaftLen = Math.max(26, r * 3.6);
                        const shaftW = Math.max(2, r * 0.35);
                        // Shaft
                        ctx.fillStyle = '#8B5E3B';
                        ctx.fillRect(-shaftLen*0.6, -shaftW*0.5, shaftLen, shaftW);
                        // Metal tip
                        ctx.fillStyle = '#DDE6F2';
                        ctx.beginPath();
                        ctx.moveTo(shaftLen*0.4, -shaftW*0.7);
                        ctx.lineTo(shaftLen*0.7, 0);
                        ctx.lineTo(shaftLen*0.4, shaftW*0.7);
                        ctx.closePath(); ctx.fill();
                        // Rear feather
                        ctx.fillStyle = 'rgba(255,240,180,0.9)';
                        ctx.beginPath();
                        ctx.moveTo(-shaftLen*0.6, 0);
                        ctx.lineTo(-shaftLen*0.75, -shaftW*1.0);
                        ctx.lineTo(-shaftLen*0.45, 0);
                        ctx.lineTo(-shaftLen*0.75, shaftW*1.0);
                        ctx.closePath(); ctx.fill();
                        ctx.restore();
                        continue;
                    }
                    // Axe: sprite-based; spins as it flies
                    if (meta && meta.weaponType === 'axe') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.axe;
                        // Maintain a spin angle on meta
                        if (typeof meta._axeSpin !== 'number') meta._axeSpin = 0;
                        const spinSpeed = meta._axeSpinSpeed || (0.22 + Math.min(0.18, (r||8) * 0.01));
                        meta._axeSpin += spinSpeed;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + meta._axeSpin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(22, r * 3.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to previous vector axe if sprite not ready
                            const handleLen = Math.max(20, r * 3.0);
                            const handleW = Math.max(2, r * 0.35);
                            ctx.strokeStyle = '#8B5A2B'; ctx.lineWidth = handleW; ctx.lineCap = 'round';
                            ctx.beginPath(); ctx.moveTo(-handleLen*0.6, 0); ctx.lineTo(handleLen*0.35, 0); ctx.stroke();
                            const headL = Math.max(10, r*1.2); const headH = Math.max(8, r*0.9);
                            ctx.fillStyle = '#D0D6E0'; ctx.beginPath();
                            ctx.moveTo(handleLen*0.2, -headH*0.7);
                            ctx.lineTo(handleLen*0.2 + headL*0.9, -headH*0.35);
                            ctx.lineTo(handleLen*0.2 + headL*0.9, headH*0.35);
                            ctx.lineTo(handleLen*0.2, headH*0.7);
                            ctx.lineTo(handleLen*0.12, 0); ctx.closePath(); ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Hammer: sprite-based; spins as it flies
                    if (meta && meta.weaponType === 'hammer') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.hammer;
                        if (typeof meta._hammerSpin !== 'number') meta._hammerSpin = 0;
                        const spinSpeed = meta._hammerSpinSpeed || (0.18 + Math.min(0.16, (r||8) * 0.009));
                        meta._hammerSpin += spinSpeed;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + meta._hammerSpin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(22, r * 2.8);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to previous vector hammer if sprite not ready
                            const handleLen = Math.max(18, r * 2.8);
                            const handleW = Math.max(2, r * 0.38);
                            ctx.strokeStyle = '#7B4A1A'; ctx.lineWidth = handleW; ctx.lineCap = 'round';
                            ctx.beginPath(); ctx.moveTo(-handleLen*0.6, 0); ctx.lineTo(handleLen*0.25, 0); ctx.stroke();
                            const headW = Math.max(12, r*1.4); const headH = Math.max(10, r*1.0);
                            ctx.fillStyle = '#BFC8D4'; ctx.fillRect(handleLen*0.10, -headH*0.5, headW, headH);
                            ctx.fillStyle = '#E6ECF4'; ctx.fillRect(handleLen*0.10, -headH*0.5, Math.max(4, headW*0.35), headH);
                        }
                        ctx.restore();
                        continue;
                    }
                    // Bread: sprite-based; spins as it flies (baguette)
                    if (meta && meta.weaponType === 'bread') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.bread;
                        if (typeof meta._breadSpin !== 'number') meta._breadSpin = 0;
                        // Slower spin for a weightier feel
                        const spinSpeed = meta._breadSpinSpeed || (0.11 + Math.min(0.10, (r||8) * 0.006));
                        meta._breadSpin += spinSpeed;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + meta._breadSpin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(26, r * 3.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback: elongated brown ellipse with lighter scoring lines
                            const stretch = Math.max(1.0, Math.min(2.0, r * 0.18 + 1.2));
                            const rx = Math.max(6, r * stretch);
                            const ry = Math.max(4, r * 0.6);
                            ctx.fillStyle = '#9C6B3E';
                            ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#D9B384'; ctx.lineWidth = Math.max(1, r*0.1);
                            ctx.beginPath();
                            ctx.moveTo(-rx*0.6, -ry*0.2); ctx.lineTo(rx*0.6, ry*0.2);
                            ctx.moveTo(-rx*0.6, 0); ctx.lineTo(rx*0.6, 0);
                            ctx.moveTo(-rx*0.6, ry*0.2); ctx.lineTo(rx*0.6, -ry*0.2);
                            ctx.stroke();
                        }
                        ctx.restore();
                        // Crumb trail: subtle dust puffs with warm bread color
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduce = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!lowFx && Math.random() < (reduce ? 0.06 : 0.12)) {
                            const bx = cx - Math.cos(ang) * (r * 0.6 + 4);
                            const by = cy - Math.sin(ang) * (r * 0.6 + 4);
                            const hue = 35 + Math.random()*8; // warm golden crumb
                            const col = `hsl(${hue}, 70%, ${70 + Math.random()*10}%)`;
                            addParticle(bx + (Math.random()-0.5)*3, by + (Math.random()-0.5)*3, col, 'dust');
                        }
                        continue;
                    }
                    // Antimatter aura overlay: dark core with bright rim (skip if Diarrhea to avoid color tint)
                    if (meta && meta.antimatter && !(meta && meta._diarrheaBrown)) {
                        ctx.save();
                        const inner = Math.max(1, r*0.6);
                        const g = ctx.createRadialGradient(cx, cy, inner*0.2, cx, cy, r*1.2);
                        g.addColorStop(0, 'rgba(10,10,10,0.95)');
                        g.addColorStop(0.6, 'rgba(40,0,60,0.35)');
                        g.addColorStop(1, 'rgba(160,100,240,0.25)');
                        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, r*1.2, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                    // Meteor custom rendering (rocky body + fiery trail)
                    if (meta && meta.meteor) {
                        // Ground reticle in final 350ms before impact (approx ~21 frames at 60fps)
                        if (typeof meta._meteorDetonateAt==='number' && typeof game.frame==='number') {
                            const framesLeft = meta._meteorDetonateAt - game.frame;
                            if (framesLeft <= 21 && framesLeft >= 0 && !(game.perf && game.perf.lowFx)) {
                                const aoe = meta._meteorAoeRadius || 80;
                                const t = 1 - framesLeft / 21; // 0 -> 1 as we approach impact
                                const alpha = 0.2 + 0.3 * t;
                                const rr = Math.max(aoe, r*1.2) * (0.95 + 0.1*Math.sin((21-framesLeft)/2));
                                ctx.save();
                                ctx.translate(meta._meteorTargetX || cx, meta._meteorTargetY || cy);
                                ctx.globalAlpha = Math.max(0, Math.min(0.6, alpha));
                                ctx.strokeStyle = '#FFCF40';
                                ctx.lineWidth = Math.max(2, aoe * 0.05);
                                ctx.beginPath(); ctx.arc(0, 0, rr, 0, Math.PI*2); ctx.stroke();
                                // Crosshair ticks
                                const tick = Math.max(6, aoe*0.15);
                                ctx.beginPath();
                                ctx.moveTo(-rr, 0); ctx.lineTo(-rr + tick, 0);
                                ctx.moveTo(rr, 0); ctx.lineTo(rr - tick, 0);
                                ctx.moveTo(0, -rr); ctx.lineTo(0, -rr + tick);
                                ctx.moveTo(0, rr); ctx.lineTo(0, rr - tick);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.meteor;
                        const bodyR = Math.max(8, r * 1.4);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Draw meteor sprite with slight forward stretch
                            const base = Math.max(22, bodyR * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base * 1.05; let h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w*0.4, -h/2, w, h);
                        } else {
                            // Fallback: simple ellipse body if image not ready
                            ctx.fillStyle = '#6A5548';
                            ctx.beginPath(); ctx.ellipse(0, 0, bodyR*1.1, bodyR*0.85, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        // Optional ember particles behind
                        if (!(game.perf && game.perf.lowFx)) {
                            const emberChance = 0.5;
                            if (Math.random()<emberChance) addParticle(cx - Math.cos(ang)*bodyR*0.8 + (Math.random()-0.5)*6, cy - Math.sin(ang)*bodyR*0.8 + (Math.random()-0.5)*6, '#FFC064','spark');
                        }
                        continue;
                    }
                    // Default projectile: draw using plain bullet sprite if available; fallback to simple circle
                    {
                        const img = window._bulletImages && window._bulletImages.plain;
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const ang = Math.atan2(vy[i], vx[i]);
                            ctx.save();
                            ctx.translate(cx, cy);
                            if (isFinite(ang)) ctx.rotate(ang);
                            // Scale sprite relative to projectile radius; modest forward stretch for motion feel
                            const base = Math.max(10, r * 2.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight;
                            const aspect = iw / ih || 1;
                            let w = base * 1.10; // slight stretch along travel
                            let h = w / aspect;
                            // Expiry blink: fade and slight scale pulse in the last few frames of life (skip very high lifeMax like indestructibles)
                            const lm = lifeMax[i];
                            const lf = life[i];
                            let alpha = 1.0; let scalePulse = 1.0;
                            if (lm > 0 && lm < 10000 && lf <= Math.min(14, Math.floor(lm * 0.12))) {
                                const t = Math.max(0, lf) / Math.max(1, Math.min(14, Math.floor(lm * 0.12)));
                                // Blink faster as it nears zero
                                const blink = (Math.sin(((1-t)*10 + i*0.3)) * 0.5 + 0.5);
                                alpha = 0.55 + 0.45 * blink;
                                scalePulse = 1.0 + 0.12 * (1 - t) * blink;
                            }
                            // Growing shot soft aura: subtle glow proportional to radius growth flag
                            if (meta && meta.growing && !(game.perf && game.perf.lowFx)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.globalAlpha = 0.16;
                                const gr = Math.max(base*0.8, r*1.6);
                                const g = ctx.createRadialGradient(0,0,gr*0.25,0,0,gr);
                                g.addColorStop(0, 'rgba(255,220,160,0.55)');
                                g.addColorStop(1, 'rgba(255,220,160,0)');
                                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,gr,0,Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            ctx.globalAlpha = Math.max(0.1, Math.min(1, alpha));
                            ctx.scale(scalePulse, scalePulse);
                            // Draw centered, pointing forward (+X after rotate)
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w * 0.1, -h/2, w, h);
                            // Pierce streak flash: quick forward chevron when _pierceFlash is active
                            if (meta && meta._pierceFlash > 0 && !(game.perf && game.perf.lowFx)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const len = Math.max(10, r * 1.8);
                                const fade = meta._pierceFlash / 9;
                                ctx.strokeStyle = `rgba(170, 255, 220, ${ (0.6 * fade).toFixed(3) })`;
                                ctx.lineWidth = Math.max(1.2, r * 0.22);
                                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.stroke();
                                ctx.restore();
                            }
                            ctx.restore();
                            // Pierce-last-hit warning aura: faint ring when only one pierce remains
                            if (meta && meta._pierceWarn > 0 && !(game.perf && game.perf.lowFx)) {
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings) {
                                    const warnA = Math.min(0.85, meta._pierceWarn / 18);
                                    const rr = Math.max(12, r * 1.6);
                                    ctx.save();
                                    ctx.globalAlpha = 0.20 + 0.35 * warnA;
                                    ctx.strokeStyle = '#CFF8EE';
                                    ctx.lineWidth = Math.max(1.2, r * 0.20);
                                    ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.stroke();
                                    ctx.restore();
                                }
                            }
                            // Bounce oriented dust puff near impact side when _bounceFlash is active
                            if (meta && meta._bounceFlash > 0 && !(game.perf && game.perf.lowFx)) {
                                const nx = meta._bounceNx||0, ny = meta._bounceNy||0;
                                const off = Math.max(2, r*0.6);
                                const px = cx - nx * off; const py = cy - ny * off;
                                addParticle(px + (Math.random()-0.5)*2, py + (Math.random()-0.5)*2, '#E6F2FF', 'dust');
                            }
                            // Speed streaks for very fast shots (perf-aware)
                            const sp = Math.hypot(vx[i], vy[i]);
                            if (sp > 6.5 && !(game.perf && game.perf.lowFx)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.globalAlpha = Math.min(0.45, (sp - 6.5) * 0.06);
                                const len = Math.min(28, 8 + (sp - 6.5) * 3);
                                const wid = Math.max(1, r * 0.25);
                                const ang = Math.atan2(vy[i], vx[i]);
                                ctx.translate(cx, cy); ctx.rotate(ang + Math.PI); // point backward
                                ctx.strokeStyle = 'rgba(200,230,255,0.8)';
                                ctx.lineWidth = wid;
                                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.stroke();
                                ctx.restore();
                            }
                        } else {
                            if (r <= 10){
                                const sImg = spriteCache[cIndex][r];
                                ctx.drawImage(sImg, cx - r, cy - r);
                            } else {
                                ctx.fillStyle = palette[cIndex];
                                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
                            }
                        }
                    }
                }
            }
            // Top-most pass: render enemy bullets bright red above all other scene elements
            function renderEnemyProjectilesTop(ctx){
                if (!ctx) return;
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                for (let i=0;i<MAX;i++){
                    if (!alive[i]) continue;
                    const meta = game._projMeta && game._projMeta.get(i);
                    if (!meta || !meta.enemy) continue;
                    const cx = x[i], cy = y[i];
                    const baseR = Math.max(2, radius[i] || 3);
                    // Inflate visual size for readability without touching collision radius
                    const drawR = Math.max(7, baseR + 4);
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const glowR = drawR * (lowFx || game.potatoMode ? 1.6 : 2.2);
                    // Outer glow (lighter composite)  soft, wide red bloom
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const g = ctx.createRadialGradient(cx, cy, drawR*0.2, cx, cy, glowR);
                    g.addColorStop(0, 'rgba(255, 80, 80, 0.65)');
                    g.addColorStop(0.6, 'rgba(255, 40, 40, 0.25)');
                    g.addColorStop(1, 'rgba(255, 20, 20, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                    // Core bright red body
                    ctx.fillStyle = '#FF2A2A';
                    ctx.beginPath(); ctx.arc(cx, cy, drawR, 0, Math.PI*2); ctx.fill();
                    // Small hot core highlight to pop against busy backgrounds
                    if (!lowFx) {
                        ctx.fillStyle = 'rgba(255,255,255,0.30)';
                        ctx.beginPath(); ctx.arc(cx, cy, Math.max(1.5, drawR * 0.35), 0, Math.PI*2); ctx.fill();
                    }
                    // Thin dark outline for contrast
                    ctx.strokeStyle = '#300000';
                    ctx.lineWidth = Math.max(1, Math.min(2.5, drawR * 0.22));
                    ctx.beginPath(); ctx.arc(cx, cy, Math.max(1, drawR - ctx.lineWidth*0.5), 0, Math.PI*2); ctx.stroke();
                }
                ctx.restore();
            }
            // Legacy compatibility proxy removed: direct object iteration deprecated.
            // Provide defensive getter that logs once (optional) to help catch stale uses.
            let _projWarned = false;
            Object.defineProperty(game, 'projectiles', {
                get(){
                    if (!_projWarned) { _projWarned = true; console.warn('[SoA] game.projectiles proxy removed  migrate logic to SoA arrays or metadata.'); }
                    return [];
                },
                set(v){}
            });
            game._markProjectilesDirty = ()=>{};
            game.spawnProjectile = (t)=>{ 
                const idx = spawnProjectile(t); 
                // Attach basic metadata for element typing so render/logic can query it reliably
                try {
                    if (idx >= 0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        let m = game._projMeta.get(idx);
                        if (!m) { m = {}; game._projMeta.set(idx, m); }
                        if (t && (t.damageType || t.energyType)) {
                            // Persist damage/energy type markers
                            if (t.damageType) m.damageType = t.damageType;
                            if (t.energyType) m.energyType = t.energyType;
                            if (t.damageType === 'void' || t.energyType === 'void') m._isVoid = true;
                            if (t.damageType === 'shadow' || t.energyType === 'shadow') m._isShadow = true;
                        }
                    }
                } catch(_) {}
                // Spawn-time standardized elemental cue (perf-aware) + Void-specific telegraph
                try {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                    const dmgType = t && (t.damageType || t.energyType);
                    const hex = getDamageTypeColor(dmgType) || null;
                    if (hex && !hideSparks) {
                        // small back-trail spark and optional faint ring
                        addParticle((t.x||0) - (t.vx||0)*0.5, (t.y||0) - (t.vy||0)*0.5, hex, 'spark');
                        if (!lowFx && !reduceRings) addParticle((t.x||0), (t.y||0), hex, 'ring');
                    }
                    // Distinct Void spawn flash: brief ringFlash/lensing pulse
                    if (dmgType === 'void') {
                        const col = getDamageTypeColor('void') || '#8844AA';
                        // Favor transient effect if available and not heavily reduced
                        if (typeof addTransientEffect === 'function' && !lowFx && !reduceRings) {
                            const baseR = Math.max(10, (t.r || t.radius || t.size || 6) * 1.8);
                            addTransientEffect({ type:'ringFlash', x:(t.x||0), y:(t.y||0), color: col, radius: baseR, life: 120 });
                        } else if (!reduceRings) {
                            addParticle((t.x||0), (t.y||0), col, 'ring');
                        }
                    }
                    // Distinct Shadow spawn flash: darker pulse to differentiate from Void
                    if (dmgType === 'shadow') {
                        const col = getDamageTypeColor('shadow') || '#AA66FF';
                        if (typeof addTransientEffect === 'function' && !lowFx && !reduceRings) {
                            const baseR = Math.max(10, (t.r || t.radius || t.size || 6) * 1.6);
                            addTransientEffect({ type:'ringFlash', x:(t.x||0), y:(t.y||0), color: col, radius: baseR, life: 110 });
                        } else if (!reduceRings) {
                            addParticle((t.x||0), (t.y||0), col, 'ring');
                        }
                    }
                } catch(_) {}
                game._markProjectilesDirty(); 
                return idx; 
            };
            game.recycleProjectile = (objOrIndex)=>{ const idx = (typeof objOrIndex === 'number')? objOrIndex : objOrIndex._i; recycle(idx); game._markProjectilesDirty(); };
            game.updateProjectilesSoA = updateProjectiles;
            game.renderProjectilesSoA = renderProjectiles;
            game.renderEnemyProjectilesTop = renderEnemyProjectilesTop;
            // --- Spatial Hash (shared for projectiles & enemies) ---
            const HASH_CELL = 64; // tune later
            game._spatial = { buckets:new Map(), cell:HASH_CELL };
            function hashKey(cx,cy){ return (cx<<16) ^ cy; }
            function rebuildProjectileHash(){
                const buckets = game._spatial.buckets; buckets.clear();
                for (let i=0;i<MAX;i++) if (alive[i]) {
                    const cx = (x[i]/HASH_CELL)|0; const cy = (y[i]/HASH_CELL)|0;
                    const key = hashKey(cx,cy);
                    let arr = buckets.get(key); if (!arr){ arr = []; buckets.set(key,arr);} 
                    arr.push(i);
                }
            }
            game.rebuildProjectileHash = rebuildProjectileHash;
            game.queryProjectilesRadius = function(qx,qy,r,out){
                out = out || [];
                const cellR = ((r/HASH_CELL)|0)+1;
                const baseCx = (qx/HASH_CELL)|0; const baseCy = (qy/HASH_CELL)|0;
                const r2 = r*r;
                for (let cyOff=-cellR; cyOff<=cellR; cyOff++){
                    for (let cxOff=-cellR; cxOff<=cellR; cxOff++){
                        const key = hashKey(baseCx+cxOff, baseCy+cyOff);
                        const bucket = game._spatial.buckets.get(key); if (!bucket) continue;
                        for (let b=0;b<bucket.length;b++){ const i=bucket[b];
                            const dx = x[i]-qx; const dy = y[i]-qy; if (dx*dx+dy*dy<=r2) out.push(i);
                        }
                    }
                }
                return out;
            };
            // Hook hash rebuild after projectile update (lightweight; can throttle later)
            const prevUpdate = game.updateProjectilesSoA;
            let _hashFrameToggle = 0;
            game.updateProjectilesSoA = function(dt){
                prevUpdate(dt);
                // Adaptive hash rebuild throttling: if projectile count is modest, rebuild every other frame.
                const active = game.projectilePool.active();
                if (active < 400) {
                    _hashFrameToggle ^= 1;
                    if (_hashFrameToggle) return; // skip this frame
                } else if (active < 1200) {
                    // Rebuild 2/3 frames: skip 1 in 3
                    _hashFrameToggle = (_hashFrameToggle + 1) % 3;
                    if (_hashFrameToggle === 0) return;
                }
                rebuildProjectileHash();
            };
            // High-performance iteration helper (avoids proxy object creation)
            game.eachProjectile = function(cb){
                for (let i=0;i<MAX;i++) if (alive[i]) cb(i, x[i], y[i]);
            };
            game.getProjectileData = function(i){
                return { x:x[i], y:y[i], vx:vx[i], vy:vy[i], r:radius[i], life:life[i], damage:damage[i], flags:flags[i] };
            };
        })();
        // === End Projectile System Phase 2 ===
    // Expose globally so external debug or delayed handlers can access before start
    window.game = game;

    // Unified guarded start to prevent double init / double RAF loops.
    game._started = false;
    game._loopStarted = false;
    function safeStartGame(source='manual') {
        if (game._started) return; // already started
        game._started = true;
        document.body.classList.remove('title-active');
        // Defensive: remove title overlay if still present (e.g., alternate start trigger)
        const to = document.getElementById('titleOverlay');
        if (to && to.parentElement) try { to.parentElement.removeChild(to); } catch(e) {}
        if (typeof init === 'function') init();
        // Attempt music start (safe if already playing)
        ensureBackgroundMusic();
        // Title overlay removal (if still present)
        const existingTitle = document.getElementById('titleOverlay');
        if (existingTitle) existingTitle.parentElement.removeChild(existingTitle);
        console.info('[Game Start] source=' + source);
    }
    // Removed auto-start watchdog so title screen persists until fire (space) pressed.

// Load stored audio prefs immediately so title screen & auto-start reflect choices
loadAudioPreferences();

// ===== Input Preference Persistence (Gamepad) =====
function loadInputPreferences() {
    try {
        const gp = localStorage.getItem('pref_gamepad_enabled');
        const dz = localStorage.getItem('pref_gamepad_deadzone');
        if (gp !== null) game.input.gamepadEnabled = gp === '1';
        if (dz !== null) {
            const v = parseFloat(dz);
            if (isFinite(v)) game.input.gpDeadzone = Math.min(0.6, Math.max(0.05, v));
        }
        // Load optional manual mapping
        const mapStr = localStorage.getItem('pref_gp_map');
        if (mapStr) {
            try {
                const m = JSON.parse(mapStr);
                if (m && typeof m === 'object') game.input.gpMap = m;
            } catch(_) {}
        }
    } catch(_) {}
}
function saveInputPreferences() {
    try {
        localStorage.setItem('pref_gamepad_enabled', game.input.gamepadEnabled ? '1' : '0');
        localStorage.setItem('pref_gamepad_deadzone', String(game.input.gpDeadzone));
        if (game.input && game.input.gpMap) {
            try { localStorage.setItem('pref_gp_map', JSON.stringify(game.input.gpMap)); } catch(_) {}
        }
    } catch(_) {}
}
loadInputPreferences();

// ===== Gamepad: connect/disconnect + per-frame polling =====
window.addEventListener('gamepadconnected', (e)=>{
    // Prefer the first connected pad if none selected
    if (game && game.input && (game.input.gpIndex === null || game.input.gpIndex === undefined)) {
        game.input.gpIndex = e.gamepad.index;
    }
});
window.addEventListener('gamepaddisconnected', (e)=>{
    if (!game || !game.input) return;
    if (game.input.gpIndex === e.gamepad.index) {
        game.input.gpIndex = null;
        game.input.gpMove.x = game.input.gpMove.y = 0;
        game.input.gpAim.x = game.input.gpAim.y = 0;
        game.input.gpFire = false;
    }
});

function _applyDeadzone(ax, ay, deadzone) {
    // radial deadzone, then rescale to 0..1 beyond dz
    const mag = Math.hypot(ax, ay);
    if (mag < deadzone) return { x: 0, y: 0 };
    const n = (mag - deadzone) / (1 - deadzone);
    const scale = n / (mag || 1);
    return { x: ax * scale, y: ay * scale };
}

// ===== Manual Mapping Helpers =====
// Mapping entry format examples:
// { type:'button', index:0 } => button index
// { type:'axis', index:9, dir:'hat' } => POV hat axis, use __gp_hatToVec
// { type:'axis', index:6, threshold:0.5, sign:1 } => axis to digital (e.g., dpadRight)
// { type:'buttons', any:[0,1] } => pressed if any of listed
function __gp_mappingPressed(pad, entry) {
    try {
        if (!entry || !pad) return false;
        if (entry.any && Array.isArray(entry.any)) {
            return entry.any.some(e => __gp_mappingPressed(pad, e));
        }
        if (entry.type === 'button') {
            const i = entry.index|0; const b = pad.buttons && pad.buttons[i];
            return !!(b && (b.pressed || ((b.value||0) > 0.5)));
        }
        if (entry.type === 'axis') {
            const i = entry.index|0; const v = (pad.axes && typeof pad.axes[i] === 'number') ? pad.axes[i] : 0;
            if (entry.dir === 'hat') {
                const vec = __gp_hatToVec(v);
                if (!vec) return false;
                const want = entry.want || 'any'; // 'up','down','left','right','any'
                if (want === 'any') return (vec.x!==0 || vec.y!==0);
                if (want === 'up') return vec.y < 0;
                if (want === 'down') return vec.y > 0;
                if (want === 'left') return vec.x < 0;
                if (want === 'right') return vec.x > 0;
                return false;
            }
            const thr = (typeof entry.threshold==='number') ? Math.abs(entry.threshold) : 0.5;
            const sign = (entry.sign===-1)?-1:1;
            return sign>0 ? (v > thr) : (v < -thr);
        }
    } catch(_) {}
    return false;
}
function __gp_hatToVec(hat) {
    if (typeof hat !== 'number' || !isFinite(hat)) return null;
    // Ignore invalid range
    if (hat < -1.1 || hat > 1.1) return null;
    // Treat small as neutral
    if (Math.abs(hat) <= 0.08) return { x:0, y:0 };
    // Bin to 8-way values seen on Windows/Firefox
    const bins = [ -1.00, -0.71, -0.43, -0.14, 0.14, 0.43, 0.71, 1.00 ];
    const dir8 = [ [0,-1], [1,-1], [1,0], [1,1], [0,1], [-1,1], [-1,0], [-1,-1] ];
    const idx = bins.reduce((best, v, i) => (Math.abs(hat - v) < Math.abs(hat - bins[best]) ? i : best), 0);
    const v = dir8[idx] || [0,0];
    return { x: v[0], y: v[1] };
}

// Controller fixes applied 2025-10-10: D-Pad override, A-only fire, Start pause toggle, ignore stick clicks
function updateGamepadInput() {
    const inp = game.input;
    if (!inp || !inp.gamepadEnabled) return;
    const get = (navigator.getGamepads && navigator.getGamepads()) || [];
    let pad = null;
    if (inp.gpIndex != null && get[inp.gpIndex]) {
        pad = get[inp.gpIndex];
    }
    if (!pad) {
        // pick first connected standard-mapped pad
        for (let i=0;i<get.length;i++) { if (get[i] && get[i].connected) { pad = get[i]; inp.gpIndex = i; break; } }
    }
    if (!pad) return;
    // Axes: standard mapping: 0=LX,1=LY, 2=RX,3=RY
    const ax0 = pad.axes[0] || 0, ay0 = pad.axes[1] || 0;
    const ax1 = pad.axes[2] || 0, ay1 = pad.axes[3] || 0;
    const dz = Math.min(0.6, Math.max(0.05, inp.gpDeadzone||0.25));
    const mv = _applyDeadzone(ax0, ay0, dz);
    const av = _applyDeadzone(ax1, ay1, dz);
    // Clamp to [-1,1] to avoid rare >1 magnitudes from browser quirks
    function clamp1(v){ return v>1?1:(v<-1?-1:v); }
    mv.x = clamp1(mv.x); mv.y = clamp1(mv.y);
    av.x = clamp1(av.x); av.y = clamp1(av.y);
    // Some pads (e.g., MOGA XP5-A Plus) report right-stick Y as -1 at rest; treat this as invalid aim so movement can control facing
    if (Math.abs(av.x) < 0.2 && (Math.abs(av.y + 1) < 0.12 || Math.abs(av.y) > 0.98)) {
        // If aim appears pegged vertically with near-zero X, ignore it
        av.x = 0; av.y = 0;
    }
    inp.gpMove.x = mv.x; inp.gpMove.y = mv.y;
    inp.gpAim.x = av.x; inp.gpAim.y = av.y;
    // Buttons: 0=A, 1=B, 2=X, 3=Y, 4=LB, 5=RB, 6=LT, 7=RT, 8=Back, 9=Start, 10=LS, 11=RS
    const btn = (i)=>{ const b = pad.buttons[i]; return !!(b && (b.pressed || (b.value!=null && b.value>0.5))); };
    // Manual mapping support
    const map = (game.input && game.input.gpMap) || null;
    // Resolve D-Pad state either via mapping or fallbacks
    let dpx = 0, dpy = 0;
    if (map && (map.dpadUp || map.dpadDown || map.dpadLeft || map.dpadRight)) {
        const up = __gp_mappingPressed(pad, map.dpadUp);
        const down = __gp_mappingPressed(pad, map.dpadDown);
        const left = __gp_mappingPressed(pad, map.dpadLeft);
        const right = __gp_mappingPressed(pad, map.dpadRight);
        dpx = (right?1:0) - (left?1:0);
        dpy = (down?1:0) - (up?1:0);
    } else {
        // D-Pad digital movement (12=Up, 13=Down, 14=Left, 15=Right)
        const dUp = btn(12), dDown = btn(13), dLeft = btn(14), dRight = btn(15);
        dpx = (dRight?1:0) - (dLeft?1:0);
        dpy = (dDown?1:0) - (dUp?1:0);
    }
    // Fallback: D-Pad via POV "hat" (axis 9)
    if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length > 9) {
        const hat = pad.axes[9];
        const vec = __gp_hatToVec(hat);
        if (vec) { dpx = vec.x; dpy = vec.y; }
    }
    // Fallback 2: older/alt mappings use separate axes 6 (horizontal) and 7 (vertical) for the D-Pad
    if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length >= 8) {
        const dax = pad.axes[6] || 0, day = pad.axes[7] || 0;
        if (Math.abs(dax) > 0.5) dpx = dax > 0 ? 1 : -1;
        if (Math.abs(day) > 0.5) dpy = day > 0 ? 1 : -1; // +1 down, -1 up (matches standard)
    }
    if (dpx !== 0 || dpy !== 0) {
        // Override analog move when D-Pad is pressed for crisp digital control (no deadzone)
        inp.gpMove.x = dpx;
        inp.gpMove.y = dpy;
    }
    // Clamp tiny drift post-deadzone
    if (Math.abs(inp.gpMove.x) < 0.001) inp.gpMove.x = 0;
    if (Math.abs(inp.gpMove.y) < 0.001) inp.gpMove.y = 0;
    if (Math.abs(inp.gpAim.x) < 0.001) inp.gpAim.x = 0;
    if (Math.abs(inp.gpAim.y) < 0.001) inp.gpAim.y = 0;
    // Fire: manual mapping takes precedence; else A (0) only
    let fireNow = false;
    if (map && map.fire) fireNow = __gp_mappingPressed(pad, map.fire);
    else fireNow = btn(0);
    inp.gpFire = !!fireNow;
    // Start toggles pause on rising edge; ignore if a modal is open.
    // Also guard against triggers mistakenly toggling by checking their raw values and mapping.
    const trigBtnL = btn(6), trigBtnR = btn(7);
    const trigValL = (pad.buttons[6] && typeof pad.buttons[6].value === 'number') ? pad.buttons[6].value : 0;
    const trigValR = (pad.buttons[7] && typeof pad.buttons[7].value === 'number') ? pad.buttons[7].value : 0;
    const startNow = (map && map.pause) ? __gp_mappingPressed(pad, map.pause) : btn(9);
    const last = inp._lastButtons || {};
    if (startNow && !last.start && trigValL < 0.1 && trigValR < 0.1 && !trigBtnL && !trigBtnR) {
        const now = performance.now ? performance.now() : Date.now();
        if (!inp._lastStartAt || now - inp._lastStartAt > 250) {
            if (!(typeof isAnyAbilityModalOpen === 'function' && isAnyAbilityModalOpen())) {
                if (typeof togglePause === 'function') togglePause();
            }
            inp._lastStartAt = now;
        }
    }
    // Snapshot for edge detection; explicitly track LS/RS to filter accidental actions
    inp._lastButtons = {
        start: startNow,
        ls: btn(10),
        rs: btn(11),
        lt: trigBtnL,
        rt: trigBtnR
    };
}

// --- Permanent Ability System ---
function loadPermanentAbilities() {
    const saved = localStorage.getItem('permanentAbilities');
    if (saved) {
        try {
            const arr = JSON.parse(saved);
            if (Array.isArray(arr)) {
                game.player.permanentAbilities = arr;
            }
        } catch (e) {}
    }
}

function grantPermanentAbilities() {
    if (game.player.permanentAbilities && Array.isArray(game.player.permanentAbilities)) {
        game.player.permanentAbilities.forEach(ability => {
            if (!game.player.abilities.includes(ability)) {
                game.player.abilities.push(ability);
            }
        });
    }
}

// ===== Audio Preference Persistence =====
function loadAudioPreferences() {
    try {
        const sfx = localStorage.getItem('pref_sfx');
        const music = localStorage.getItem('pref_music');
        // Potato mode (new) and legacy cosmetic toggle (old)
        const potato = localStorage.getItem('pref_potato_mode');
        const cosmeticOff = localStorage.getItem('pref_disable_cosmetic');
        if (sfx !== null) game.sfxEnabled = sfx === '1';
        if (music !== null) game.musicEnabled = music === '1';
        if (potato !== null) game.potatoMode = potato === '1';
        // Back-compat: if new key missing, fall back to old cosmetic flag
        if (potato === null && cosmeticOff !== null) {
            game.potatoMode = cosmeticOff === '1';
        }
        // Keep legacy flag in sync for any older checks
        game.disableCosmeticParticles = !!game.potatoMode;
        // Apply FX clamps immediately based on loaded state
    if (game.potatoMode) applyPotatoFxClamps(true); else applyPotatoFxClamps(false);
    updatePotatoBadge();
    } catch(e) {}
}
function saveAudioPreferences() {
    try {
        localStorage.setItem('pref_sfx', game.sfxEnabled ? '1' : '0');
        localStorage.setItem('pref_music', game.musicEnabled ? '1' : '0');
        // Persist both keys for compatibility; new UI reads pref_potato_mode
        localStorage.setItem('pref_potato_mode', game.potatoMode ? '1' : '0');
        localStorage.setItem('pref_disable_cosmetic', game.potatoMode ? '1' : '0');
    } catch(e) {}
    applyMusicPreference(false);
}

// Apply or clear FX clamps when Potato Mode changes
function applyPotatoFxClamps(on){
    try {
        // Clamp particle/transient emission and simplify special FX
        game.disableCosmeticParticles = !!on; // legacy path
        if (game.perf) {
            game.perf.lowFx = !!on;
            // When user explicitly sets potato, freeze autoLowFx
            game.perf.autoLowFx = !on ? game.perf.autoLowFx : false;
        }
        if (game.fxFlags) {
            game.fxFlags.hideSparks = !!on;
            game.fxFlags.hideSpokes = !!on;
            game.fxFlags.reduceRings = !!on;
            game.fxFlags.reduceBeams = !!on;
        }
    } catch(_) {}
}

// Keep the LOW FX badge in sync with current settings
function updatePotatoBadge() {
    try {
        const el = document.getElementById('potatoBadge');
        if (!el) return;
        const active = !!(game && (game.potatoMode || (game.perf && game.perf.lowFx)));
        el.style.display = active ? 'block' : 'none';
        // Label priority: explicit Potato Mode overrides wording
        el.textContent = game && game.potatoMode ? 'POTATO MODE' : 'LOW FX';
        // Soften color when auto low FX vs explicit potato
        el.style.color = game && game.potatoMode ? '#ffd27f' : '#d6e8ff';
        el.style.borderColor = game && game.potatoMode ? '#aa8844' : '#6688aa';
    } catch(_) {}
}

// Idempotent background music starter
function ensureBackgroundMusic() {
    if (!game.musicEnabled) return; // respect preference
    try {
        if (!game.bgMusic) {
            const m = new Audio('assets/audio/QuackshotChronicles.mp3');
            m.loop = true; m.volume = 0.55; game.bgMusic = m;
        }
        if (game.bgMusic.paused) {
            game.bgMusic.play().catch(()=>{});
        }
    } catch(e) {}
}
// Manual Low FX toggle: press 'L' to toggle, Shift+L to re-enable auto mode
window.addEventListener('keydown', (e)=>{
    if (e.key === 'l' || e.key === 'L') {
        if (game && game.perf) {
            if (e.shiftKey) {
                game.perf.autoLowFx = true; // re-enable auto management
            } else {
                game.perf.lowFx = !game.perf.lowFx;
                game.perf.autoLowFx = false; // manual override
            }
            updatePotatoBadge();
        }
    }
});

// =============================================================
// DEV: Starting Ability Picker (press '0')  temporary, easily removable
// To remove: delete this block or set ENABLE_STARTING_ABILITY_PICKER = false
window.ENABLE_STARTING_ABILITY_PICKER = true;

// Apply the chosen starting ability to the current player, keeping permanent abilities
function applyStartingAbility(abName) {
    if (!game || !game.player) return;
    try {
        const perms = Array.isArray(game.player.permanentAbilities) ? game.player.permanentAbilities.slice() : [];
        const next = [];
        // Keep permanents first
        perms.forEach(a => { if (ABILITIES[a]) next.push(a); });
        // Then add the chosen ability (if valid and not duplicate)
        if (abName && ABILITIES[abName] && !next.includes(abName)) next.push(abName);
        game.player.abilities = next;
        // Persist clean state (filter out any removed/unknown abilities defensively)
        game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
        // Small visual cue in console
        console.info('[Start Ability] Set to:', abName, 'Abilities:', game.player.abilities);
        // Refresh any UI that lists abilities
        if (typeof updatePauseMenu === 'function') {
            try { updatePauseMenu(); } catch(_) {}
        }
    } catch (err) {
        console.warn('[Start Ability] Failed to apply ability', abName, err);
    }
}

function showStartingAbilityMenu() {
    if (!window.ENABLE_STARTING_ABILITY_PICKER) return;
    // Prevent multiple overlays
    const existing = document.getElementById('startAbilityOverlay');
    if (existing) { try { existing.remove(); } catch(_) {} }

    const wasPaused = !!game.paused;
    game.paused = true;

    const overlay = document.createElement('div');
    overlay.id = 'startAbilityOverlay';
    overlay.style.cssText = [
        'position:fixed', 'inset:0', 'z-index:10050', 'display:flex', 'align-items:center', 'justify-content:center',
        'background:rgba(0,0,0,0.82)', 'font-family:Courier New,monospace'
    ].join(';');

    const panel = document.createElement('div');
    panel.style.cssText = [
        'width:min(1000px,92vw)', 'max-height:min(85vh,900px)', 'background:#1b1b1b', 'border:2px solid #555', 'border-radius:10px',
        'box-shadow:0 12px 34px rgba(0,0,0,0.6)', 'padding:16px', 'display:flex', 'flex-direction:column', 'gap:12px'
    ].join(';');

    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;';
    header.innerHTML = '<div style="color:#fff;font-weight:700;letter-spacing:1px">Pick Starting Ability</div>'+
        '<button id="startAbClose" data-gp-focus="1" style="background:#222;color:#ddd;border:1px solid #666;padding:6px 10px;border-radius:6px;cursor:pointer">Close (Esc)</button>';

    const controls = document.createElement('div');
    controls.style.cssText = 'display:flex;gap:10px;align-items:center;flex-wrap:wrap;';
    const search = document.createElement('input');
    search.type = 'text';
    search.placeholder = 'Search abilities...';
    search.style.cssText = 'flex:1;min-width:240px;padding:8px 10px;border:1px solid #555;border-radius:6px;background:#111;color:#eee;outline:none';
    const onlyWeapons = document.createElement('label');
    onlyWeapons.style.cssText = 'display:flex;align-items:center;gap:6px;color:#bbb;font-size:12px;user-select:none;';
    const onlyWeaponsChk = document.createElement('input');
    onlyWeaponsChk.type = 'checkbox';
    onlyWeapons.appendChild(onlyWeaponsChk);
    onlyWeapons.appendChild(document.createTextNode('Weapon-type only'));
    controls.appendChild(search);
    controls.appendChild(onlyWeapons);

    const grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px;overflow:auto;flex:1;padding-right:4px;';

    function tierStyle(tier){
        if (tier === 3) return { border:'#c68b1a', bg:'#2a1d05', name:'#ffd37a' };
        if (tier === 2) return { border:'#3d7dd9', bg:'#0a1d33', name:'#aaccff' };
        return { border:'#5aa84d', bg:'#0d2a0d', name:'#b9e8b2' };
    }

    function buildItem(name, meta){
        const t = (meta && meta.tier) || 1; const st = tierStyle(t);
        const owned = Array.isArray(game?.player?.abilities) && game.player.abilities.includes(name);
        const d = document.createElement('div');
        d.style.cssText = [
            'border:2px solid '+st.border, 'background:'+st.bg, 'border-radius:8px', 'padding:10px',
            'display:flex', 'flex-direction:column', 'gap:6px', 'box-shadow:inset 0 0 8px #000, 0 0 8px rgba(0,0,0,0.35)'
        ].join(';');
        if (!owned) {
            d.style.cursor = 'pointer';
            d.onmouseenter = ()=> d.style.transform = 'translateY(-2px)';
            d.onmouseleave = ()=> d.style.transform = 'none';
        } else {
            d.style.cursor = 'not-allowed';
            d.style.filter = 'grayscale(0.6) opacity(0.65)';
            d.setAttribute('aria-disabled','true');
            d.title = 'Already owned';
        }
        const title = document.createElement('div');
        title.textContent = name;
        title.style.cssText = 'font-weight:700;color:'+st.name+';text-shadow:0 0 6px rgba(0,0,0,.6)';
        const desc = document.createElement('div');
        desc.textContent = meta && meta.desc ? meta.desc : '';
        desc.style.cssText = 'color:#ddd;font-size:12px;min-height:32px;line-height:1.25';
        d.appendChild(title);
        if (owned) {
            const badge = document.createElement('div');
            badge.textContent = 'OWNED';
            badge.style.cssText = 'align-self:flex-start;background:#2a2a2a;color:#bbb;border:1px solid #555;border-radius:4px;padding:2px 6px;font-size:11px;letter-spacing:0.5px;';
            d.appendChild(badge);
        }
        d.appendChild(desc);
        if (!owned) {
            d.setAttribute('data-gp-focus','1');
            d.onclick = () => {
                applyStartingAbility(name);
                try { document.body.removeChild(overlay); } catch(_) {}
                game.paused = wasPaused;
            };
        }
        return d;
    }

    function getAllAbilityKeys(){
        return Object.keys(ABILITIES);
    }

    function filterAndRender(){
        const q = (search.value || '').trim().toLowerCase();
        const wantWeapons = !!onlyWeaponsChk.checked;
        grid.innerHTML = '';
        const keys = getAllAbilityKeys().filter(k => {
            if (q && !(k.toLowerCase().includes(q) || (ABILITIES[k].desc||'').toLowerCase().includes(q))) return false;
            if (wantWeapons && !(ABILITIES[k] && ABILITIES[k].effect && ABILITIES[k].effect.weaponType)) return false;
            return true;
        }).sort((a,b)=>{
            const ta = (ABILITIES[a].tier||1), tb=(ABILITIES[b].tier||1);
            if (ta!==tb) return ta-tb; // tier asc
            return a.localeCompare(b);
        });
        if (keys.length === 0) {
            const empty = document.createElement('div');
            empty.textContent = 'No abilities match your filter.';
            empty.style.cssText = 'color:#aaa;font-size:13px;padding:8px;grid-column:1/-1';
            grid.appendChild(empty);
        } else {
            keys.forEach(k => grid.appendChild(buildItem(k, ABILITIES[k])));
        }
    }

    panel.appendChild(header);
    panel.appendChild(controls);
    panel.appendChild(grid);
    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    // Wire events
    document.getElementById('startAbClose').onclick = () => { try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; };
    search.oninput = filterAndRender;
    onlyWeaponsChk.onchange = filterAndRender;
    // Do not auto-focus the search input so controller can immediately navigate

    // ESC to close
    const escHandler = (ev)=>{ if (ev.key === 'Escape') { ev.preventDefault(); try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; window.removeEventListener('keydown', escHandler, true);} };
    window.addEventListener('keydown', escHandler, true);

    filterAndRender();
    // Default controller focus to the first selectable card (skip owned/disabled); fall back to Close
    try {
        setTimeout(() => {
            const cont = document.getElementById('startAbilityOverlay');
            if (!cont) return;
            const items = gatherFocusables(cont);
            if (items && items.length) {
                game.uiNav = game.uiNav || {};
                game.uiNav.container = cont;
                game.uiNav.items = items;
                let idx = 0;
                for (let i=0;i<items.length;i++) {
                    const el = items[i];
                    if (el.getAttribute && el.getAttribute('data-gp-focus')==='1' && grid.contains(el)) { idx=i; break; }
                }
                game.uiNav.index = idx;
                applyGpFocus();
            }
        }, 0);
    } catch(_) {}
}

// Bind global hotkey: '0' opens the starting ability picker
window.addEventListener('keydown', (e) => {
    if (!window.ENABLE_STARTING_ABILITY_PICKER) return;
    // Use e.key so numpad 0 also works if it reports '0'
    if (e.key === '0') {
        e.preventDefault();
        try { showStartingAbilityMenu(); } catch(_) {}
    }
});

// FX toggle: Press F3 to cycle visual intensity presets
window.addEventListener('keydown', (e)=>{
    if (e.key === 'F3') {
        const f = game.fxFlags || (game.fxFlags = { hideSparks:false, hideSpokes:false, reduceRings:false, reduceBeams:false });
        // Sequence: Full FX -> Reduced Rings/Spokes -> Hide Sparks -> Low FX (global) -> Full FX
        if (!game.perf.lowFx && !f.reduceRings && !f.hideSpokes && !f.hideSparks) {
            f.reduceRings = true; f.hideSpokes = true; console.info('[FX] Reduced rings/spokes');
        } else if (f.reduceRings && f.hideSpokes && !f.hideSparks) {
            f.hideSparks = true; console.info('[FX] Hide sparks');
        } else if (!game.perf.lowFx) {
            game.perf.lowFx = true; console.info('[FX] Low FX mode ON'); updatePotatoBadge();
        } else {
            // reset to full
            game.perf.lowFx = false; f.reduceRings=false; f.hideSpokes=false; f.hideSparks=false; console.info('[FX] Full FX restored'); updatePotatoBadge();
        }
    }
});

function toggleCosmeticParticles() {
    game.disableCosmeticParticles = !game.disableCosmeticParticles;
    saveAudioPreferences();
    updateAudioButtons();
}

// ================= Simplified Title Screen =================
function showTitleScreen() {
    if (document.getElementById('titleOverlay') || game._started) return;
    document.body.classList.add('title-active');
    const overlay = document.createElement('div');
    overlay.id = 'titleOverlay';
    Object.assign(overlay.style, {
        position:'fixed', inset:'0', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center',
        background:'radial-gradient(circle at center,#111 0%,#000 70%)', zIndex:9999, gap:'32px',
        fontFamily:'Courier New,monospace', transition:'opacity 380ms ease', opacity:'1'
    });
    overlay.innerHTML = `
        <img id="titleLogo" src="assets/title.png" alt="Quack Noir" style="width:clamp(300px,60vw,780px);max-height:70vh;object-fit:contain;image-rendering:pixelated;filter:drop-shadow(0 0 12px #400060);" />
        <div id="pressStartPrompt" style="color:#bbb;font-size:22px;letter-spacing:2px;animation:pulsePrompt 2.8s ease-in-out infinite;">PRESS SPACE / CLICK TO START</div>
        <div style="position:absolute;bottom:12px;right:16px;font-size:11px;color:#444;">Build: Simplified Title v4</div>`;
    if (!document.getElementById('pulsePromptStyle')) {
        const st = document.createElement('style'); st.id='pulsePromptStyle';
        st.textContent='@keyframes pulsePrompt{0%{opacity:.35}50%{opacity:1}100%{opacity:.35}}';
        document.head.appendChild(st);
    }
    document.body.appendChild(overlay);
    // Try autoplay (may be blocked; we'll retry on input)
    ensureBackgroundMusic();
    let started = false;
    function begin(source){
        if (started) return; started = true;
        overlay.style.opacity='0';
        // Kick music again explicitly on gesture for browsers that require it
        ensureBackgroundMusic();
        setTimeout(()=> safeStartGame(source), 360);
    }
    function keyHandler(ev){
        if (ev.code==='Space') { ev.preventDefault(); cleanup(); begin('title-space'); }
    }
    function clickHandler(){ cleanup(); begin('title-click'); }
    function gamepadHandler(){
        try {
            const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
            for (let i=0;i<pads.length;i++){
                const p = pads[i];
                if (!p || !p.connected) continue;
                const a = p.buttons && p.buttons[0];
                const start = p.buttons && p.buttons[9];
                if ((a && (a.pressed || (a.value>0.5))) || (start && (start.pressed || (start.value>0.5)))) {
                    cleanup(); begin('title-gamepad'); return;
                }
            }
        } catch(_){ }
    }
    function cleanup(){
        window.removeEventListener('keydown', keyHandler);
        overlay.removeEventListener('click', clickHandler);
        overlay.removeEventListener('touchstart', clickHandler);
    }
    window.addEventListener('keydown', keyHandler);
    overlay.addEventListener('click', clickHandler, { passive:true });
    overlay.addEventListener('touchstart', clickHandler, { passive:true });
    // Allow A/Start to begin on title screen (polling while overlay visible)
    const gpInterval = setInterval(()=>{
        const to = document.getElementById('titleOverlay');
        if (!to) { clearInterval(gpInterval); return; }
        try {
            const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
            for (let i=0; i<pads.length; i++) {
                const p = pads[i];
                if (!p || !p.connected) continue;
                const a = p.buttons && p.buttons[0];
                const start = p.buttons && p.buttons[9];
                if ((a && (a.pressed || (a.value>0.5))) || (start && (start.pressed || (start.value>0.5)))) {
                    cleanup(); begin('title-gamepad'); return;
                }
            }
        } catch(_) {}
    }, 120);
    // Also react to a newly connected pad (poller above will handle the input)
    window.addEventListener('gamepadconnected', ()=>{});
}
window.addEventListener('load', showTitleScreen);

// ================= Touch Controls (Adaptive) =================
// Provide an on-screen joystick + fire button if the user is on a touch-capable device
// and no keyboard / mouse input has been detected yet. Hides automatically on first
// hardware keyboard/mouse interaction to avoid clutter for desktop users.
(() => {
    game._hardwareInputDetected = false;
    game._touchControlsInitialized = false;
    game._touchFireInterval = null; // legacy (no longer used)
    // Removed game.touchFireActive flag; touch fire now directly toggles the spacebar key state for unified cooldown logic.
    const hwHandler = () => {
        game._hardwareInputDetected = true;
        // If touch controls are visible, hide them (user clearly has hardware input)
        const tc = document.getElementById('touchControlsContainer');
        if (tc) tc.style.display = 'none';
        window.removeEventListener('keydown', hwHandler, { passive: true });
    };
    // Only key presses count as hardware (keyboard) input now; mouse movement/clicks no longer disable touch controls.
    // This prevents normal screen taps (which some engines surface as synthetic mouse events) from hiding the overlay.
    window.addEventListener('keydown', hwHandler, { passive: true });

    function shouldUseTouchControls() {
        const touchCapable = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
        return touchCapable && !game._hardwareInputDetected;
    }

    // Removed ensureTouchFireLoop & per-frame touchFireActive polling; we now just set game.keys[' '] on press/release.

    function setDirectionalKeys(dx, dy) {
        // Reset movement keys
        const k = game.keys;
        k['w'] = k['a'] = k['s'] = k['d'] = false;
        if (Math.abs(dy) > 0.25) { if (dy < 0) k['w'] = true; else k['s'] = true; }
        if (Math.abs(dx) > 0.25) { if (dx < 0) k['a'] = true; else k['d'] = true; }
    }

    function initTouchControls() {
        if (game._touchControlsInitialized) return;
        game._touchControlsInitialized = true;
        const container = document.createElement('div');
        container.id = 'touchControlsContainer';
        container.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:12000;';

        // Joystick base
        const joyBase = document.createElement('div');
        joyBase.id = 'touchJoyBase';
        joyBase.style.cssText = 'position:absolute;left:24px;bottom:24px;width:110px;height:110px;border:2px solid #444;background:rgba(0,0,0,0.35);border-radius:50%;pointer-events:auto;touch-action:none;';
        const joyStick = document.createElement('div');
        joyStick.id = 'touchJoyStick';
        joyStick.style.cssText = 'position:absolute;left:50%;top:50%;width:48px;height:48px;transform:translate(-50%,-50%);background:rgba(0,255,136,0.55);border:2px solid #0f8;border-radius:50%;box-shadow:0 0 6px #0f8;';
        joyBase.appendChild(joyStick);

        // Fire button
        const fireBtn = document.createElement('div');
        fireBtn.id = 'touchFireBtn';
        fireBtn.textContent = 'FIRE';
        fireBtn.style.cssText = 'position:absolute;right:34px;bottom:40px;width:100px;height:100px;border:2px solid #aa2222;border-radius:50%;background:rgba(255,40,40,0.4);display:flex;align-items:center;justify-content:center;font:700 16px Courier New,monospace;color:#fff;box-shadow:0 0 8px #f33;pointer-events:auto;touch-action:none;user-select:none;';

        container.appendChild(joyBase);
        container.appendChild(fireBtn);
        document.body.appendChild(container);

        let activeJoyId = null;
        let joyCenter = { x: 0, y: 0 };

        function handleJoyStart(e) {
            const touch = (e.changedTouches ? e.changedTouches[0] : e);
            activeJoyId = touch.identifier !== undefined ? touch.identifier : 'mouse';
            const rect = joyBase.getBoundingClientRect();
            joyCenter.x = rect.left + rect.width/2;
            joyCenter.y = rect.top + rect.height/2;
            updateJoy(touch);
            e.preventDefault();
        }
        function updateJoy(touch) {
            const dx = touch.clientX - joyCenter.x;
            const dy = touch.clientY - joyCenter.y;
            const maxR = 44; // radius limit for stick movement
            let dist = Math.sqrt(dx*dx + dy*dy);
            let nx = 0, ny = 0;
            if (dist > 0) {
                nx = dx / dist; ny = dy / dist;
                if (dist > maxR) dist = maxR;
            }
            joyStick.style.left = (50 + (dist * nx) / maxR * 50) + '%';
            joyStick.style.top  = (50 + (dist * ny) / maxR * 50) + '%';
            setDirectionalKeys(nx, ny);
        }
        function handleJoyMove(e) {
            if (activeJoyId === null) return;
            const touches = e.changedTouches ? Array.from(e.changedTouches) : [e];
            for (const t of touches) {
                const id = t.identifier !== undefined ? t.identifier : 'mouse';
                if (id === activeJoyId) { updateJoy(t); break; }
            }
            e.preventDefault();
        }
        function handleJoyEnd(e) {
            const touches = e.changedTouches ? Array.from(e.changedTouches) : [e];
            for (const t of touches) {
                const id = t.identifier !== undefined ? t.identifier : 'mouse';
                if (id === activeJoyId) {
                    activeJoyId = null;
                    joyStick.style.left = '50%';
                    joyStick.style.top = '50%';
                    setDirectionalKeys(0,0);
                    break;
                }
            }
        }

        // Attach joystick listeners
        joyBase.addEventListener('touchstart', handleJoyStart, { passive: false });
        joyBase.addEventListener('touchmove', handleJoyMove, { passive: false });
        joyBase.addEventListener('touchend', handleJoyEnd, { passive: false });
        joyBase.addEventListener('touchcancel', handleJoyEnd, { passive: false });
        // (Optional mouse support for debugging on desktop)
        joyBase.addEventListener('mousedown', handleJoyStart);
        window.addEventListener('mousemove', handleJoyMove);
        window.addEventListener('mouseup', handleJoyEnd);

    function fireStart(e) { game.keys[' '] = true; e.preventDefault(); }
    function fireEnd(e) { game.keys[' '] = false; e.preventDefault(); }
        fireBtn.addEventListener('touchstart', fireStart, { passive: false });
        fireBtn.addEventListener('touchend', fireEnd, { passive: false });
        fireBtn.addEventListener('touchcancel', fireEnd, { passive: false });
        fireBtn.addEventListener('mousedown', fireStart);
        window.addEventListener('mouseup', fireEnd);
    }

    // Defer initialization slightly so hardware inputs can register first.
    document.addEventListener('DOMContentLoaded', () => {
           const cv = document.getElementById('gameCanvas');
           if (cv) { cv.style.display='block'; cv.style.visibility='visible'; }
    });

    // Public hook if we ever need to re-evaluate after a reset
    window.__maybeInitTouch = () => { if (shouldUseTouchControls()) initTouchControls(); };
})();
// =============================================================

// Apply current preference to an existing or newly created bgMusic element without flipping state
function applyMusicPreference(autoPlayIfEnabled=true) {
    if (!game.bgMusic) return;
    game.bgMusic.muted = !game.musicEnabled;
    if (game.musicEnabled && autoPlayIfEnabled) {
        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
    } else if (!game.musicEnabled) {
        try { game.bgMusic.pause(); } catch(e) {}
    }
}

/*
 Attributions:
 Powerup 10.wav by LilMati -- https://freesound.org/s/523654/ -- License: Creative Commons 0
*/
function ensurePowerupSfx() {
    try {
        if (!game._powerupSfx) {
            const a = new Audio('assets/audio/523654__lilmati__powerup-10.wav');
            a.preload = 'auto';
            a.volume = 0.85;
            game._powerupSfx = a;
        }
    } catch(_) {}
}
function playPowerupSfx() {
    if (!game.sfxEnabled) return;
    try {
        ensurePowerupSfx();
        const a = game._powerupSfx;
        if (!a) return;
        // Restart from beginning for rapid successive pickups
        try { a.currentTime = 0; } catch(_) {}
        a.play().catch(()=>{});
    } catch(_) {}
}

/*
 Attributions:
 Retro, Explosion 07.wav by LilMati -- https://freesound.org/s/521105/ -- License: Creative Commons 0
*/
function ensureNukeExplosionSfx() {
    try {
        if (!game._sfxNukeExplosion) {
            const a = new Audio('assets/audio/521105__lilmati__retro-explosion-07.wav');
            a.preload = 'auto';
            a.volume = 0.95;
            game._sfxNukeExplosion = a;
        }
    } catch(_) {}
}
function playNukeExplosionSfx() {
    if (!game.sfxEnabled) return;
    try {
        ensureNukeExplosionSfx();
        const a = game._sfxNukeExplosion;
        if (!a) return;
        try { a.currentTime = 0; } catch(_) {}
        a.play().catch(()=>{});
    } catch(_) {}
}
/*
 Attributions:
 retro explosion by EtherAudio -- https://freesound.org/s/815348/ -- License: Attribution 4.0
*/
function ensureMeteorExplosionSfx() {
    try {
        if (!game._sfxMeteorExplosion) {
            const a = new Audio('assets/audio/815348__etheraudio__retro-explosion.wav');
            a.preload = 'auto';
            a.volume = 0.9;
            game._sfxMeteorExplosion = a;
        }
    } catch(_) {}
}
function playMeteorExplosionSfx() {
    if (!game.sfxEnabled) return;
    try {
        ensureMeteorExplosionSfx();
        const a = game._sfxMeteorExplosion;
        if (!a) return;
        try { a.currentTime = 0; } catch(_) {}
        a.play().catch(()=>{});
    } catch(_) {}
}

// Unified UI sync for any audio controls present (legacy + pause menu)
function updateAudioButtons() {
    try {
        // Legacy top-level buttons (if any)
        const bs = document.getElementById('btnToggleSfx');
        const bm = document.getElementById('btnToggleMusic');
        if (bs) bs.textContent = (game.sfxEnabled ? 'SFX: ON' : 'SFX: OFF');
        if (bm) bm.textContent = (game.musicEnabled ? 'Music: ON' : 'Music: OFF');
        // Pause overlay options buttons
        const sfxBtn = document.getElementById('optToggleSfx');
        const musicBtn = document.getElementById('optToggleMusic');
        const cosBtn = document.getElementById('optToggleCosmetic');
        if (sfxBtn) sfxBtn.textContent = 'SFX: ' + (game.sfxEnabled ? 'ON' : 'OFF');
        if (musicBtn) musicBtn.textContent = 'Music: ' + (game.musicEnabled ? 'ON' : 'OFF');
        if (cosBtn) cosBtn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF');
        // Also reuse the more detailed reflect method if present (updates gamepad labels, too)
        if (typeof reflectOptionStates === 'function') {
            try { reflectOptionStates(); } catch(_) {}
        }
    } catch(_) {}
}

// Toggle helpers for Options UI
function toggleSfx() {
    game.sfxEnabled = !game.sfxEnabled;
    saveAudioPreferences();
    updateAudioButtons();
}

function toggleMusic() {
    game.musicEnabled = !game.musicEnabled;
    saveAudioPreferences();
    // Apply immediately; allow autoplay when enabling from a user gesture
    if (game.musicEnabled) {
        // Ensure bgMusic exists when turning music ON mid-session
        try { ensureBackgroundMusic(); } catch(_) {}
    }
    applyMusicPreference(true);
    updateAudioButtons();
}

function showAbilityChoiceUI(options) {
    const overlay = document.createElement('div');
    overlay.id = 'abilityChoiceOverlay';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center;
        z-index: 1001; font-family: 'Courier New', monospace;
    `;

    const container = document.createElement('div');
    container.style.cssText = `
        display: flex; gap: 20px; background: #222; padding: 20px; border-radius: 10px;
        border: 2px solid #666;
    `;

    const tierStyles = {
        1: { border:'#5aa84d', glow:'#5aa84d88', bg:'#0d2a0d', label:'Tier I' },
        2: { border:'#3d7dd9', glow:'#3d7dd988', bg:'#0a1d33', label:'Tier II' },
        3: { border:'#c68b1a', glow:'#c68b1acc', bg:'#2a1d05', label:'Tier III' }
    };
    // Inject one-time keyframe styles if not present
    if (!document.getElementById('permAbilityFXStyles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'permAbilityFXStyles';
        styleEl.textContent = `@keyframes badgePop {0%{transform:scale(.4) translateY(-8px);opacity:0}60%{transform:scale(1.08) translateY(0);opacity:1}100%{transform:scale(1) translateY(0);opacity:1}}
        @keyframes flairFloat {0%{transform:translateY(0) scale(.6);opacity:0}20%{opacity:1}80%{opacity:1}100%{transform:translateY(-38px) scale(1.1);opacity:0}}
        .synergy-tip {position:absolute;left:50%;top:100%;transform:translate(-50%,12px);background:#111;padding:8px 10px;border:1px solid #555;border-radius:6px;color:#eee;font:11px/1.3 'Courier New',monospace;width:220px;pointer-events:none;opacity:0;transition:opacity .18s;z-index:40;box-shadow:0 0 6px #000}
        .ability-card.permanent:hover .synergy-tip {opacity:1}
        `;
        document.head.appendChild(styleEl);
    }
    // Simple synergy hint generator (lightweight heuristic)
    function buildSynergyHint(ab){
        const meta = ABILITIES[ab]; if(!meta||!meta.effect) return 'Passive enhancement.';
        const eff = meta.effect; const tips = [];
        if (eff.damageType) tips.push(`Combines with other ${eff.damageType} sources for amplified status.`);
        if (eff.projectileCount) tips.push('Stacks with multi-shot to flood patterns.');
        if (eff.spiralPattern || eff.sineWave || eff.wackyZigzag || eff.ekgWave) tips.push('Motion pattern contributes to resonance combos.');
        if (eff.explosive || eff.chainExplosion || eff.novaBlast) tips.push('Explosion effects can trigger combust synergies.');
        if (eff.dimensional) tips.push('Rifts manipulate and duplicate passing projectiles.');
        if (eff.timeWarp) tips.push('Time Warp can extend airborne telegraphs (meteors / bombs).');
        if (!tips.length) return 'General utility ability.';
        return tips.slice(0,3).join(' ');
    }
    const flairIntervals = [];
    options.forEach((ability, idx) => {
        const meta = ABILITIES[ability];
        const tier = meta && meta.tier || 1;
        const style = tierStyles[tier] || tierStyles[1];
        const card = document.createElement('div');
        card.className = 'ability-card permanent';
        card.style.cssText = `min-width:200px;max-width:240px;padding:14px 16px;background:${style.bg};`+
            `border:3px solid ${style.border};border-radius:10px;position:relative;`+
            `box-shadow:0 0 10px ${style.glow}, inset 0 0 8px #000;display:flex;flex-direction:column;gap:8px;`+
            `transition:transform .15s, box-shadow .2s;`;
        card.onmouseenter = ()=>{ card.style.transform='translateY(-4px)'; card.style.boxShadow=`0 0 16px ${style.glow}, 0 0 4px ${style.border}`; };
        card.onmouseleave = ()=>{ card.style.transform='none'; card.style.boxShadow=`0 0 10px ${style.glow}, inset 0 0 8px #000`; };

    const badge = document.createElement('div');
        badge.textContent = style.label;
        badge.style.cssText = `position:absolute;top:-12px;left:12px;padding:2px 8px;`+
            `background:${style.border};color:#fff;font:600 11px 'Courier New',monospace;`+
            `border-radius:4px;text-shadow:0 0 4px #000;letter-spacing:1px;`+
            `animation:badgePop .42s cubic-bezier(.25,1.4,.45,1) ${idx*0.08}s both;`;
        card.appendChild(badge);

        const nameDiv = document.createElement('div');
        nameDiv.className = 'ability-card-name';
        nameDiv.textContent = ability;
        nameDiv.style.cssText = 'font:700 18px Courier New,monospace;color:#fff;text-shadow:0 0 6px '+style.glow+';';
        const descDiv = document.createElement('div');
        descDiv.className = 'ability-card-desc';
        descDiv.textContent = meta ? meta.desc : '';
        descDiv.style.cssText = 'font:13px/1.3 Courier New,monospace;color:#ddd;min-height:48px;';

        card.appendChild(nameDiv);
        card.appendChild(descDiv);
        // Synergy tooltip
        const tip = document.createElement('div');
        tip.className = 'synergy-tip';
        tip.textContent = buildSynergyHint(ability);
        card.appendChild(tip);
        // Tier III flair particles (ambient floating sparks)
        if (tier === 3) {
            const flairLayer = document.createElement('div');
            flairLayer.style.cssText = 'position:absolute;inset:0;overflow:visible;pointer-events:none;';
            card.appendChild(flairLayer);
            const spawnFlair = () => {
                if (!document.body.contains(card)) return; // stop if overlay gone
                const f = document.createElement('div');
                const size = 4 + Math.random()*4;
                f.style.cssText = `position:absolute;bottom:4px;left:${6+Math.random()* (card.clientWidth-14)}px;`+
                    `width:${size}px;height:${size}px;border-radius:50%;background:radial-gradient(circle,#ffd37a,#c68b1a);`+
                    `opacity:0;animation:flairFloat ${2.6+Math.random()*1.4}s linear forwards;box-shadow:0 0 6px #c68b1a,0 0 2px #fff inset;`;
                flairLayer.appendChild(f);
                // Auto remove after animation
                setTimeout(()=>{ if(f.parentElement) f.parentElement.removeChild(f); }, 4000);
            };
            // Initial burst
            for (let i=0;i<3;i++) setTimeout(spawnFlair, i*160 + Math.random()*120);
            const intId = setInterval(spawnFlair, 650 + Math.random()*400);
            flairIntervals.push(intId);
        }
    card.style.cursor = 'pointer';
    card.setAttribute('data-gp-focus','1');
        card.onclick = () => {
            if (!game.player.permanentAbilities.includes(ability)) {
                game.player.permanentAbilities.push(ability);
                localStorage.setItem('permanentAbilities', JSON.stringify(game.player.permanentAbilities));
            }
            document.body.removeChild(overlay);
            // Clear intervals
            flairIntervals.forEach(id=>clearInterval(id));
            if (game && game._bigQuackDefeated) {
                if (!document.getElementById('postFinalPlayAgain')) {
                    const btn = document.createElement('button');
                    btn.id = 'postFinalPlayAgain';
                    btn.textContent = 'Play Again';
                    btn.style.cssText = 'position:fixed;bottom:40px;left:50%;transform:translateX(-50%);padding:12px 28px;font-size:18px;background:#222;color:#fff;border:2px solid #666;border-radius:6px;z-index:30010;cursor:pointer;';
                    btn.onclick = () => { btn.remove(); resetGame(); };
                    btn.setAttribute('data-gp-focus','1');
                    document.body.appendChild(btn);
                }
            }
        };
        container.appendChild(card);
    });

    overlay.appendChild(container);
    document.body.appendChild(overlay);
    // Ensure flair intervals are cleared if overlay removed externally
    const obs = new MutationObserver(()=>{ if(!document.body.contains(overlay)) { flairIntervals.forEach(id=>clearInterval(id)); obs.disconnect(); }});
    obs.observe(document.body,{childList:true});
}

// Rainbow Chest: full ability picker (choose any ability; does not remove existing ones)
function showRainbowAbilityPicker(onSelect) {
    // Prevent duplicates
    const existing = document.getElementById('rainbowAbilityOverlay');
    if (existing) { try { existing.remove(); } catch(_) {} }
    const wasPaused = !!game.paused; game.paused = true;
    const overlay = document.createElement('div');
    overlay.id = 'rainbowAbilityOverlay';
    overlay.style.cssText = 'position:fixed;inset:0;z-index:20000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);font-family:Courier New,monospace;';
    const panel = document.createElement('div');
    panel.style.cssText = 'width:min(1100px,94vw);max-height:min(86vh,940px);background:#121212;border:2px solid #666;border-radius:10px;padding:14px;display:flex;flex-direction:column;gap:10px;box-shadow:0 0 18px rgba(255,255,255,0.15), 0 0 60px rgba(180,120,255,0.25) inset;';
    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;';
    header.innerHTML = '<div style="color:#fff;font-weight:800;letter-spacing:1px;text-shadow:0 0 10px #fff, 0 0 20px #f0f;">Rainbow Chest  Choose Any Ability</div>'+
        '<button id="rainbowCloseBtn" data-gp-focus="1" style="background:#222;color:#ddd;border:1px solid #666;padding:6px 10px;border-radius:6px;cursor:pointer">Close (Esc)</button>';
    const controls = document.createElement('div');
    controls.style.cssText = 'display:flex;gap:10px;align-items:center;flex-wrap:wrap;';
    const search = document.createElement('input');
    search.type = 'text'; search.placeholder = 'Search abilities...';
    search.style.cssText = 'flex:1;min-width:260px;padding:8px 10px;border:1px solid #555;border-radius:6px;background:#0b0b0b;color:#eee;outline:none';
    const onlyNewLabel = document.createElement('label');
    onlyNewLabel.style.cssText = 'display:flex;align-items:center;gap:6px;color:#bbb;font-size:12px;user-select:none;';
    const onlyNewChk = document.createElement('input');
    onlyNewChk.type = 'checkbox'; onlyNewChk.checked = true;
    onlyNewLabel.appendChild(onlyNewChk);
    onlyNewLabel.appendChild(document.createTextNode('Hide owned'));
    controls.appendChild(search); controls.appendChild(onlyNewLabel);
    const grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px;overflow:auto;flex:1;padding-right:4px;';
    function tierStyle(tier){ if (tier===3) return { border:'#c68b1a', bg:'#2a1d05', name:'#ffd37a' }; if (tier===2) return { border:'#3d7dd9', bg:'#0a1d33', name:'#aaccff' }; return { border:'#5aa84d', bg:'#0d2a0d', name:'#b9e8b2' }; }
    function buildItem(name, meta){
        const t = (meta && meta.tier) || 1; const st = tierStyle(t);
        const owned = Array.isArray(game?.player?.abilities) && game.player.abilities.includes(name);
        const d = document.createElement('div');
        d.style.cssText = 'border:2px solid '+st.border+';background:'+st.bg+';border-radius:8px;padding:10px;display:flex;flex-direction:column;gap:6px;box-shadow:inset 0 0 8px #000, 0 0 8px rgba(0,0,0,0.35)';
        // Hover/interactive affordances only if not owned
        if (!owned) {
            d.style.cursor = 'pointer';
            d.onmouseenter = ()=> d.style.transform = 'translateY(-2px)';
            d.onmouseleave = ()=> d.style.transform = 'none';
        } else {
            d.style.cursor = 'not-allowed';
            d.style.filter = 'grayscale(0.6) opacity(0.65)';
            d.setAttribute('aria-disabled','true');
            d.title = 'Already owned';
        }
        const title = document.createElement('div'); title.textContent = name; title.style.cssText = 'font-weight:700;color:'+st.name+';text-shadow:0 0 6px rgba(0,0,0,.6)';
        const desc = document.createElement('div'); desc.textContent = meta && meta.desc ? meta.desc : ''; desc.style.cssText = 'color:#ddd;font-size:12px;min-height:32px;line-height:1.25';
        d.appendChild(title);
        // Owned badge
        if (owned) {
            const badge = document.createElement('div');
            badge.textContent = 'OWNED';
            badge.style.cssText = 'align-self:flex-start;background:#2a2a2a;color:#bbb;border:1px solid #555;border-radius:4px;padding:2px 6px;font-size:11px;letter-spacing:0.5px;';
            d.appendChild(badge);
        }
        d.appendChild(desc);
        // Controller focus and click only when selectable
        if (!owned) {
            d.setAttribute('data-gp-focus','1');
            d.onclick = () => {
                try { document.body.removeChild(overlay); } catch(_) {}
                game.paused = wasPaused;
                if (typeof onSelect === 'function') onSelect(name);
            };
        }
        return d;
    }
    function filterAndRender(){
        const q = (search.value||'').trim().toLowerCase();
        grid.innerHTML='';
        let keys = Object.keys(ABILITIES);
        if (onlyNewChk.checked) keys = keys.filter(k => !game.player.abilities.includes(k));
        keys = keys.filter(k => {
            if (!q) return true; const meta = ABILITIES[k]; const d = (meta && meta.desc)||''; return k.toLowerCase().includes(q) || d.toLowerCase().includes(q);
        }).sort((a,b)=>{
            const ta=(ABILITIES[a].tier||1), tb=(ABILITIES[b].tier||1); if (ta!==tb) return ta-tb; return a.localeCompare(b);
        });
        if (keys.length===0){ const empty=document.createElement('div'); empty.textContent='No abilities match your filter.'; empty.style.cssText='color:#aaa;font-size:13px;padding:8px;grid-column:1/-1'; grid.appendChild(empty); }
        else { keys.forEach(k => grid.appendChild(buildItem(k, ABILITIES[k]))); }
    }
    panel.appendChild(header); panel.appendChild(controls); panel.appendChild(grid);
    overlay.appendChild(panel); document.body.appendChild(overlay);
    document.getElementById('rainbowCloseBtn').onclick = () => { try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; };
    search.oninput = filterAndRender; onlyNewChk.onchange = filterAndRender;
    const escHandler = (ev)=>{ if (ev.key==='Escape'){ ev.preventDefault(); try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; window.removeEventListener('keydown', escHandler, true);} };
    window.addEventListener('keydown', escHandler, true);
    filterAndRender();
    // Default controller focus to the first selectable card (skip owned/disabled); fall back to Close
    try {
        setTimeout(() => {
            const cont = document.getElementById('rainbowAbilityOverlay');
            if (!cont) return;
            const items = gatherFocusables(cont);
            if (items && items.length) {
                game.uiNav = game.uiNav || {};
                game.uiNav.container = cont;
                game.uiNav.items = items;
                let idx = 0;
                // Prefer a grid card that is selectable (has data-gp-focus and lives in grid)
                for (let i=0;i<items.length;i++) {
                    const el = items[i];
                    if (el.getAttribute && el.getAttribute('data-gp-focus')==='1' && grid.contains(el)) { idx = i; break; }
                }
                game.uiNav.index = idx;
                applyGpFocus();
            }
        }, 0);
    } catch(_) {}
}

function offerPermanentAbilityChoice() {
    if (!game || !game.player) return;
    let pool = game.player.abilities.filter(a => !game.player.permanentAbilities.includes(a));
    // If fewer than 3 unique non-permanent, fallback to include permanent ones (still avoid duplicates in display)
    if (pool.length < 3) {
        const extras = game.player.abilities.filter(a => !pool.includes(a));
        pool = pool.concat(extras);
    }
    // Still not enough? Show whatever exists (13). If none, show informational overlay.
    if (pool.length === 0) {
        console.info('[Permanent Ability Choice] No abilities available to offer.');
        const msg = document.createElement('div');
        msg.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:18px 26px;color:#fff;font:14px Courier New;border:2px solid #555;z-index:35000;';
        msg.textContent = 'No abilities to make permanent. Press Play Again to restart.';
        document.body.appendChild(msg);
        return;
    }
    const shuffled = [...pool].sort(() => Math.random() - 0.5);
    const options = shuffled.slice(0, Math.min(3, shuffled.length));
    console.info('[Permanent Ability Choice] Offering options:', options);
    showAbilityChoiceUI(options);
}

        const ABILITIES = {
            /*
             * Synergy Notes (pattern stacking system):
             *  - Projectile motion patterns (sineWave, wackyZigzag, ekgWave, spiralPattern, teleporting, orbital, growing, homing/weakHoming, bouncing/ricochet, omni/radial, crossPattern, boomerang) now coexist. (Split Shot removed)
             *  - updateProjectiles aggregates lateral deltas from sine + wacky + ekg instead of making them mutually exclusive.
             *  - Dampening rules: when multiple patterns active, each pattern's amplitude is slightly reduced to prevent runaway speed inflation.
             *  - Spiral still applies its own loop motion; if also sine/wacky/ekg, their offsets add on top.
             *  - Orbitals inherit pattern flags on spawn and animate with radial/tangential modulation.
             *  - Split projectiles propagate pattern flags so child fragments maintain complex motion.
             *  - Teleport Shot synergy: additional portal particle styles appear based on which pattern flags the projectile has (spiral / sine / wacky / ekg).
             *  - Speed capping & normalization keeps composite velocity within ~1.85x original forward speed.
             *  - Resonance Combos: 2+ core motion patterns (sine, wacky, ekg, spiral) grant escalating damage multiplier (8%/15%/22%) and at 3+ patterns periodic resonance pulses (AoE % base damage) emanate; all 4 patterns trigger occasional hypersurge speed burst.
             *  - Elemental Amplifiers: Fire+Wind (burn tick +15%, burn duration +40f), Ice+Lightning (12% shatter proc for bonus burst), Poison+Void (poison tick +25%, duration +90f), Fire+Poison (magma combustion: +10% burn tick, +12% poison tick), Ice+Wind (slow duration +60f).
             *  - Beam Pattern Blending: Laser/Particle beams inherit pattern flags for visual modulation (oscillation, jitter, spikes, mini-spiral); movement unaffected for fairness; particles tint by dominant pattern.
             *  - DOT Scaling: Elemental amplifiers modify per-tick burn/poison damage dynamically based on active ability sets.
             *  - Elemental Infusions: Temporary stacked overlays (up to 3 via Elemental Conduit) add bonus partial damage + status effects; strongest infusion selects primary damageType if projectile neutral; diminishing returns on multi stack.
             */
            // Shooting Abilities
            'Fire Shot': { desc: 'Fire damage + burning DoT', effect: { damageBonus: 8, damageType: 'fire' }, tier: 1 },
            'Ice Shot': { desc: 'Slows enemies by 60%', effect: { damageType: 'ice' }, tier: 1 },
            'Lightning Shot': { desc: 'Chains to 3 enemies', effect: { damageType: 'lightning' }, tier: 1 },
            'Poison Shot': { desc: 'Poison damage over time', effect: { damageType: 'poison' }, tier: 1 },
            'Explosive Shot': { desc: 'Bullet go boom', effect: { explosive: true }, tier: 2 },
            'Double Shot': { desc: 'Fire 2 projectiles', effect: { projectileCount: 2 }, tier: 1 },
            'Triple Shot': { desc: 'Fire 3 projectiles', effect: { projectileCount: 3 }, tier: 2 },
            'Quad Shot': { desc: 'Fire 4 projectiles', effect: { projectileCount: 4 }, tier: 2 }, // Rebalanced: was tier 3
            'Machine Gun': { desc: 'Fire rate +100%', effect: { attackSpeedMultiplier: 2.0 }, tier: 2 },
            'Laser Cannon': { desc: 'Fire rate +200%', effect: { attackSpeedMultiplier: 3.0 }, tier: 2 }, // Rebalanced: was tier 3
            'Pierce Shot': { desc: 'Pierce through 3 enemies', effect: { piercing: true, pierceCount: 3 }, tier: 2 },
            'Multi-Pierce': { desc: 'Pierce unlimited enemies', effect: { piercing: true, pierceCount: 999 }, tier: 3 },
            'Homing Shot': { desc: 'Auto-target nearest enemy', effect: { homing: true }, tier: 1 }, // Rebalanced: was tier 2
            'Bouncing Shot': { desc: 'Bounce off walls 3 times', effect: { bouncing: true }, tier: 1 }, // Rebalanced: was tier 2
            'Growing Shot': { desc: 'Size increases over time', effect: { growing: true }, tier: 1 },
            'Shotgun Blast': { desc: '5 wide spread shots', effect: { shotgunBlast: true }, tier: 2 },
            'Sniper Shot': { desc: '3x larger, faster shots', effect: { projectileSize: 3, projectileSpeed: 2 }, tier: 2 },
            // Advanced Projectile Abilities
            'Plasma Cannon': { desc: 'Super heated plasma bolts', effect: { damageBonus: 15, damageType: 'plasma' }, tier: 2 },
            'Acid Shot': { desc: 'Melts through armor', effect: { damageType: 'acid', armorPiercing: true }, tier: 2 },
            'Shadow Bolt': { desc: 'Dark energy projectiles that deal bonus shadow damage and slightly ignore ambient lightpairs well with armor shredding and void/poison synergies', effect: { damageBonus: 12, damageType: 'shadow' }, tier: 2 },
            'Solar Flare': { desc: 'Blinding solar energy', effect: { damageType: 'solar', blinds: true }, tier: 2 },
            'Frost Shard': { desc: 'Freezing ice projectiles', effect: { damageType: 'frost', freezes: true }, tier: 2 },
            'Wind Blade': { desc: 'Razor sharp air currents  massively pushes enemies back', effect: { damageBonus: 10, damageType: 'wind', knockback: true, knockbackDistance: 120 }, tier: 1 }, // Added strong knockback
            // Newly re-added base Earth element so Earth combos (e.g., Magma) have a source ability when combo card not yet offered.
            'Earth Spike': { desc: 'Stone spikes with impact shock (minor stun & knockback)', effect: { damageType: 'earth', knockback: true, knockbackDistance: 48 }, tier: 1 },
            'Void Shot': { desc: 'Reality-tearing projectiles', effect: { damageBonus: 25, damageType: 'void' }, tier: 3 },
            'Crystal Shot': { desc: 'Prismatic energy bolts', effect: { damageBonus: 18, damageType: 'crystal' }, tier: 2 },
            // Multi-Shot Abilities
            'Penta Shot': { desc: 'Fire 5 projectiles', effect: { projectileCount: 5 }, tier: 2 }, // Rebalanced: was tier 3
            'Hexa Shot': { desc: 'Fire 6 projectiles', effect: { projectileCount: 6 }, tier: 3 },
            'Octa Shot': { desc: 'Fire 8 projectiles', effect: { projectileCount: 8 }, tier: 3 },
            'Deca Shot': { desc: 'Fire 10 projectiles', effect: { projectileCount: 10 }, tier: 3 },
            'Storm Barrage': { desc: 'Fire 15 random projectiles', effect: { projectileCount: 15, randomSpread: true }, tier: 3 },
            'Bullet Hell': { desc: 'Fire 20 chaotic shots', effect: { projectileCount: 20, randomSpread: true }, tier: 3 },
            'Omni Shot': { desc: 'Fire in all 8 directions', effect: { omniDirectional: true }, tier: 3 },
            'Radial Burst': { desc: 'Fire 16 shots in circle', effect: { radialBurst: true }, tier: 3 },
            'Spiral Shot': { desc: 'Spinning projectile pattern  shots curve in local swirling loops for a tight spiral motion', effect: { spiralPattern: true }, tier: 2 },
            'Uzumaki': { desc: 'Expanding outward swirl  shots emit in a continuously rotating spiral stream from you (global spiral path)', effect: { uzumaki: true }, tier: 2 },
            'Sine Wave': { desc: 'Shots follow a sine wave pattern', effect: { sineWave: true }, tier: 2 },
            'Wacky Shot': { desc: 'Bullets zigzag unpredictably with rapid direction changes', effect: { wackyZigzag: true }, tier: 2 },
            'EKG': { desc: 'Shots follow an erratic cardiogram spike pattern (flatline pulses then sharp vertical spikes)', effect: { ekgWave: true }, tier: 2 },
            'Cross Shot': { desc: 'Fire in + pattern', effect: { crossPattern: true }, tier: 2 },
            // Rate of Fire Abilities
            'Rapid Fire': { desc: 'Fire rate +50%', effect: { attackSpeedMultiplier: 1.5 }, tier: 1 },
            'Burst Fire': { desc: 'Fire rate +75%', effect: { attackSpeedMultiplier: 1.75 }, tier: 2 },
            'Auto Cannon': { desc: 'Fire rate +150%', effect: { attackSpeedMultiplier: 2.5 }, tier: 2 },
            'Gatling Gun': { desc: 'Fire rate +250%', effect: { attackSpeedMultiplier: 3.5 }, tier: 3 },
            'Chain Gun': { desc: 'Fire rate +300%', effect: { attackSpeedMultiplier: 4.0 }, tier: 3 },
            'Minigun': { desc: 'Fire rate +400%', effect: { attackSpeedMultiplier: 5.0 }, tier: 3 },
            'Vulcan Cannon': { desc: 'Fire rate +500%', effect: { attackSpeedMultiplier: 6.0 }, tier: 3 },
            // Damage Boost Abilities
            'Power Shot': { desc: 'Damage +10', effect: { damageBonus: 10 }, tier: 1 },
            'Heavy Shot': { desc: 'Damage +15', effect: { damageBonus: 15 }, tier: 1 },
            'Mega Damage': { desc: 'Damage +20', effect: { damageBonus: 20 }, tier: 2 },
            'Ultra Damage': { desc: 'Damage +40', effect: { damageBonus: 40 }, tier: 2 }, // Rebalanced: was tier 3
            'Supreme Damage': { desc: 'Damage +60', effect: { damageBonus: 60 }, tier: 3 },
            'Divine Power': { desc: 'Damage +80', effect: { damageBonus: 80 }, tier: 3 },
            'Apocalypse': { desc: 'Damage +100', effect: { damageBonus: 100 }, tier: 3 },
            // Projectile Behavior Abilities
            'Seeking Shot': { desc: 'Weak homing behavior', effect: { weakHoming: true }, tier: 1 },
            'Smart Bomb': { desc: 'Explodes near enemies', effect: { smartExplosive: true }, tier: 2 },
            'Ricochet': { desc: 'Bounce between enemies', effect: { ricochet: true }, tier: 2 },
            'Boomerang': { desc: 'Returns to player', effect: { boomerang: true }, tier: 1 }, // Rebalanced: was tier 2
            'Orbital': { desc: 'Orbits around player', effect: { orbital: true }, tier: 2 },
            'Drill Shot': { desc: 'Spins while moving', effect: { drilling: true }, tier: 1 }, // Rebalanced: was tier 2
            'Phasing Shot': { desc: 'Passes through walls', effect: { phasing: true }, tier: 2 },
            'Teleport Shot': { desc: 'Each fired projectile instantly teleports to a random nearby location around you (within ~140px) before flying forward', effect: { teleporting: true }, tier: 2 }, // Rebalanced: was tier 3
            // Area Effect Abilities
            'Nova Blast': { desc: 'Explosion on impact', effect: { novaBlast: true }, tier: 2 },
            'Chain Explosion': { desc: 'Explosions spread', effect: { chainExplosion: true }, tier: 2 }, // Rebalanced: was tier 3
            'Shockwave': { desc: 'Ground-traveling wave', effect: { shockwave: true }, tier: 2 },
            'Meteor': { desc: 'Falls from sky', effect: { meteor: true }, tier: 3 },
            'Black Hole': { desc: 'Pulls enemies inward', effect: { blackHole: true }, tier: 3 },
            'Vortex': { desc: 'Creates a lingering void spiral that pulls enemies inward, deals periodic damage, and ignites them', effect: { vortex: true }, tier: 3 },
            'Time Bomb': { desc: 'Delayed massive explosion', effect: { timeBomb: true }, tier: 3 },
            // Status Effect Abilities
            'Stun Shot': { desc: 'Paralyzes enemies briefly', effect: { damageType: 'stun' }, tier: 2 },
            // Removed status shots (blind, silence, curse, weakness, doom) per design trim
            'Fear Shot': { desc: 'Makes enemies flee', effect: { damageType: 'fear' }, tier: 2 },
            'Charm Shot': { desc: 'Turns enemies friendly', effect: { damageType: 'charm' }, tier: 3 },
            // Elemental Combinations
            'Steam Shot': { desc: 'Fire + Ice combo damage', effect: { damageType: 'steam', damageBonus: 20 }, tier: 2 },
            'Magma Shot': { desc: 'Fire + Earth combo', effect: { damageType: 'magma', damageBonus: 25 }, tier: 2 }, // Rebalanced: was tier 3
            'Storm Shot': { desc: 'Lightning + Wind combo', effect: { damageType: 'storm', damageBonus: 22 }, tier: 2 },
            'Toxic Cloud': { desc: 'Poison gas area', effect: { damageType: 'toxic', areaEffect: true }, tier: 2 }, // Rebalanced: was tier 3
            'Blizzard': { desc: 'Ice + Wind storm', effect: { damageType: 'blizzard', areaEffect: true }, tier: 3 },
            'Inferno': { desc: 'Spreading fire damage', effect: { damageType: 'inferno', spreading: true }, tier: 3 },
            // New multi-stage special
            'SIGMA': { desc: 'Its so Sigma', effect: { sigma: true }, tier: 3 },
            // Weapon Types
            'Sword Throw': { desc: 'Throw a sword that flies blade-first', effect: { weaponType: 'sword' }, tier: 1 }, // Rebalanced: was tier 2
            'Axe Hurl': { desc: 'Heavy axe projectile  slow, large axe that deals high impact damage and knocks enemies back on hit', effect: { weaponType: 'axe', damageBonus: 30 }, tier: 2 },
            'Spear Thrust': { desc: 'Long-range piercing  fast spear that pierces multiple enemies for extended reach', effect: { weaponType: 'spear', piercing: true }, tier: 2 },
            'Hammer Slam': { desc: 'Crushing blunt damage  heavy hammer shot that stuns or briefly incapacitates enemies on impact', effect: { weaponType: 'hammer', crushDamage: true }, tier: 2 },
            'Dagger Rain': { desc: 'Multiple small blades', effect: { weaponType: 'dagger', projectileCount: 8 }, tier: 3 },
            // Culinary Weapon
            'Crusty Bread': { desc: 'Feed the ducks...with a vengeance', effect: { weaponType: 'bread', damageBonus: 20 }, tier: 2 },
            // Energy Weapons
            'Laser Beam': { desc: 'Continuous energy beam (adds persistent beam ticks while you fire; does NOT block normal shots)', effect: { energyType: 'laser', continuous: true }, tier: 3 },
            'Particle Beam': { desc: 'High-energy particles  thick beam segments with AoE ticks; hold to deal sustained area damage along the beam', effect: { energyType: 'particle', damageBonus: 35 }, tier: 3 },
            'Ion Cannon': { desc: 'Charged ion blast  hold to charge and release a massive piercing blast; charge increases size and damage', effect: { energyType: 'ion', chargeShot: true }, tier: 3 },
            'Pulse Rifle': { desc: 'Energy pulse bursts  fires short 3-round bursts (micro-projectiles) for rapid close damage', effect: { energyType: 'pulse', burstFire: true }, tier: 2 },
            'Photon Torpedo': { desc: 'Light-speed projectile  instantly strikes the nearest enemy when fired (instant-travel strike)', effect: { energyType: 'photon', instantTravel: true }, tier: 3 },
            // Exotic Abilities
            'Quantum Shot': { desc: 'Bullets strike twice', effect: { quantum: true, hitMultipleTimes: true }, tier: 3 },
            'Dimensional Rift': { desc: 'Tears through space  creates a rift field that manipulates projectiles and can teleport or refract shots; ignores armor', effect: { dimensional: true, ignoresArmor: true }, tier: 3 },
            'Time Warp': { desc: 'Slows time around impact', effect: { timeWarp: true }, tier: 3 },
            'Reality Break': { desc: 'Breaks physics rules  spawns an unstable field that disrupts projectile paths and weakens enemy resistances', effect: { realityBreak: true, ignoresEverything: true }, tier: 3 },
            'Antimatter': { desc: 'Pure destruction', effect: { antimatter: true, massiveExplosion: true }, tier: 3 },
            // Unique/Utility
            'Tumbleweed': { desc: 'You know you want to shoot it.', effect: { tumbleweed: true }, tier: 2 },
            'Kick the Can': { desc: 'Gotta kick it! Spawns a rollable can you can keep kicking around.', effect: { kickTheCan: true }, tier: 2 },
            // Core / Meta Abilities (previously system placeholders)
            'Auto-Aim': { desc: 'Automatically targets the nearest enemy when firing (no manual aim needed).', effect: { autoAim: true }, tier: 1 },
            'Treasure Hunter': { desc: 'Higher chance for rooms to spawn a chest (+30%) and health bread drops are 50% more likely.', effect: { chestChanceBonus: 0.3, breadDropBonus: 0.5 }, tier: 1 },
            'Rage Mode': { desc: 'Gain +3 damage for every enemy you have slain this run (scales endlessly).', effect: { rageScaling: true }, tier: 2 },
            'Berserker': { desc: 'Damage increases up to +50% as your health gets lower (scales with missing HP).', effect: { berserker: true }, tier: 2 },
            // Removed Death Touch per design trim
            'Terrifying Aura': { desc: 'Every 25 kills create a purple aura; enemies touching it are Feared for 3s and flee.', effect: { terrifyingAura: true }, tier: 2 },
            'Diarrhea': { desc: 'Oh God!', effect: { diarrhea: true }, tier: 2 },
            'Carb it up!': { desc: 'Bread drops magnetize and glide to you for instant pickup.', effect: { breadMagnet: true }, tier: 1 },
            'Beartrap': { desc: 'Every 5s drop a beartrap; first enemy to step on it takes heavy damage and is immobilized for 5s.', effect: { beartrap: true }, tier: 2 },
            'Punji Pit': { desc: 'Every 5s leave a poison spike pit; enemies touching it take damage and are poisoned.', effect: { punjiPit: true }, tier: 2 },
            'Oppemheimer': { desc: 'Every 10s a massive nuke strikes a random area  huge blast radius dealing catastrophic damage.', effect: { nukeStrike: true }, tier: 3 },
            'Silent But Deadly': { desc: 'Cropdust your enemies!', effect: { poisonTrail: true }, tier: 2 },
            'Spontaneous Combustion': { desc: 'Enemies you kill erupt into an omni blast of burning shards', effect: { combustOnKill: true }, tier: 2 },
            // Infusion / Overlay Systems
            'Elemental Conduit': { desc: 'Periodically channels random elemental infusions (can stack up to 3 simultaneous; each adds partial damage + status to shots).', effect: { elementalConduit: true }, tier: 3 },
            
            // --- New Bullet Pattern / Behavior Abilities ---
            'Lissajous Shot': { desc: 'Figure-8 oscillation path (compound wave)', effect: { lissajousPattern: true }, tier: 2 },
            'Helix Pair': { desc: 'Fires twin helix-winding partners', effect: { helixPair: true }, tier: 2 },
            'Bloom Ring': { desc: 'Periodically emits expanding pellet ring', effect: { bloomRing: true }, tier: 3 },
            'Cascade Burst': { desc: 'Pulsing forward micro-bursts', effect: { cascadeBurst: true }, tier: 2 },
            'Pendulum Shot': { desc: 'Swinging arc that settles', effect: { pendulumPattern: true }, tier: 1 },
            'Sawtooth Wave': { desc: 'Jagged saw lateral motion', effect: { sawWave: true }, tier: 2 },
            'Phase Echo': { desc: 'Afterimage echoes re-impact', effect: { phaseEcho: true }, tier: 3 },
            'Resonant Pulse Core': { desc: 'Periodic buff pulse for nearby shots', effect: { resonantPulseCore: true }, tier: 3 },
            'Vector Pivot': { desc: 'Quarter-turn pivot arcs', effect: { pivotPattern: true }, tier: 2 },
            'Converging Twins': { desc: 'Diverge then fuse for burst', effect: { convergePair: true }, tier: 2 },
            'Fragment Wake': { desc: 'Leaves a lingering trail of flickering sparks that rapidly ping nearby enemies (stacking contact DPS).', effect: { fragmentWake: true }, tier: 1 },
            'Spiral Bloom': { desc: 'Tightens then blooms outward', effect: { spiralBloom: true }, tier: 3 },
            'Harmonic Split': { desc: 'Splits twice at set life points', effect: { harmonicSplit: true }, tier: 3 },
            
            'Temporal Drift': { desc: 'Cycles slow stretch & surge', effect: { temporalDrift: true }, tier: 3 },
            'Veering Fan': { desc: 'Fans into arc mid-flight', effect: { veeringFan: true }, tier: 2 },
            'Echo Bloom': { desc: 'Echo catches up & bursts', effect: { echoBloom: true }, tier: 2 },
            'Toenail Clibbins': { desc: 'Thats a biggin', effect: { toenailClibbins: true }, tier: 2 },
            'Popcorn': { desc: 'Fires a kernel that pops into 2 flying puffs', effect: { popcornKernel: true }, tier: 1 },
            'Umbrella Shot': { desc: 'Primary shot splits forward into two arcing halves that curve overhead then return past you', effect: { umbrellaShot: true }, tier: 2 },
            'Duck Dynasty': { desc: 'Summon your ancestors', effect: { duckDynasty: true }, tier: 2 },
            // Crowd Control / Utility
            'Rizz': { desc: 'Every 5s magnetically gathers enemies near you then Fears them for 3s', effect: { rizzAbility: true }, tier: 3 },
            'SHOOTING INTENSIFIES': { desc: 'Amplifies ALL projectile motion patterns (waves, spirals, zigzags, helix, etc.) for +40% pattern amplitude & special speed; stacks after normal dampening.', effect: { patternAmplify: true }, tier: 3 },
            // Environmental havoc
            'Tanks Alot': { desc: 'A runaway truck barrels leftright. If it hits a dumpster, it explodes and ignites the street for 5s.', effect: { tanksAlot: true }, tier: 3 },
        };
        // (Removed placeholder system ability injection; all core meta abilities now have proper entries.)

    // Enemy type definitions (restored after recent update)
        const ENEMY_TYPES = {
            'Thug':      { health: 60,  speed: 1.2, damage: 10, color: '#FF8888', size: 24, xp: 10,  ranged: false, armor: 0 },
            'Street Dog':{ health: 40,  speed: 1.1, damage: 8,  color: '#AA6644', size: 20, xp: 8,   ranged: false, armor: 0 },
            'Punk':      { health: 55,  speed: 1.05, damage: 12, color: '#FF44FF', size: 22, xp: 12,  ranged: false, armor: 1 },
            'Gangster':  { health: 90,  speed: 0.9, damage: 18, color: '#8888FF', size: 30, xp: 20,  ranged: true, rangedCooldown: 2500, armor: 2 },
            'Dealer':    { health: 70,  speed: 1.0, damage: 14, color: '#FFFF00', size: 26, xp: 15,  ranged: true, armor: 1 },
            'Enforcer':  { health: 130, speed: 0.7, damage: 25, color: '#FF4444', size: 34, xp: 35,  ranged: false, armor: 3 },
            'Boss Thug': { health: 350, speed: 0.6, damage: 40, color: '#FFD700', size: 52, xp: 200, ranged: false, armor: 5 },
            'Boss Gangster': { health: 520, speed: 0.65, damage: 50, color: '#4444FF', size: 56, xp: 260, ranged: true, rangedCooldown: 2000, armor: 6 },
            'The Big Quack': { health: 10000, speed: 0.55, damage: 50, color: '#111111', size: 104, xp: 4000, ranged: true, rangedCooldown: 1600, armor: 10, bossFinal: true }
        };

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

                    // Floating damage numbers storage
                        game.damageNumbers = []; // Initialize damage numbers array

                        // Initialize reality break distortion state for rendering
                        game.realityBreakDistort = { time: 0, intensity: 0.15 };

            // World pickups (health bread, etc.)
            game.pickups = [];
            // Beartraps (ability-based deployables)
            game.traps = [];
            game._lastTrapDrop = 0;
            // Punji pits (poison spike fields)
            game.pits = [];
            game._lastPitDrop = 0;
            // Nuke strike markers (Oppemheimer ability)
            game.nukes = [];
            game._lastNuke = 0;
            // Poison cloud trail (Silent But Deadly ability)
            game.poisonClouds = [];
            // Fragment Wake sparks (lingering damaging embers)
            game.fragmentSparks = [];
            // EKG damaging trail segments (lingering hazardous line pieces)
            game.ekgTrailSegments = [];
            game._lastPoisonCloud = 0;
            // Photon strike visual records
            game.photonStrikes = [];
            // Traveling shockwaves (Shockwave ability)
            game.shockwaves = [];

            // Tanks Alot state
            game.trucks = [];
            game.truckFires = [];
            game._lastTruckSpawn = 0;

            // Small util: darken/lighten hex color (amount negative to darken)
            window.shadeColor = function(col, amt) {
                try {
                    if (!col || col[0] !== '#') return col;
                    let num = parseInt(col.slice(1), 16);
                    let r = (num >> 16) & 255;
                    let g = (num >> 8) & 255;
                    let b = num & 255;
                    r = Math.min(255, Math.max(0, r + amt));
                    g = Math.min(255, Math.max(0, g + amt));
                    b = Math.min(255, Math.max(0, b + amt));
                    return '#' + (r.toString(16).padStart(2,'0')) + (g.toString(16).padStart(2,'0')) + (b.toString(16).padStart(2,'0'));
                } catch(e) { return col; }
            };

            // Background music now created in title screen start() to ensure autoplay eligibility.
            // (Previously created here, causing some browsers to require a second click to play.)
            if (!game.bgMusic) {
                // placeholder reference; real Audio object assigned on start
                game.bgMusic = null;
            }

            // Prevent spacebar from scrolling the page
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    // Prevent page scroll AND suppress normal firing when ending overlay is active
                    e.preventDefault();
                    if (game && game._bigQuackDefeated && !game._finalAbilityOffered) {
                        const overlay = document.getElementById('endingOverlay');
                        if (overlay) overlay.remove();
                        offerPermanentAbilityChoice();
                        game._finalAbilityOffered = true;
                        return; // stop propagation to any firing logic
                    }
                }
                // Dev: toggle sprite bounds with F3
                if (e.code === 'F3') {
                    game._debugSpriteBounds = !game._debugSpriteBounds;
                    console.info('[Debug] Sprite bounds:', game._debugSpriteBounds ? 'ON' : 'OFF');
                }
                if (e.code === 'F1') {
                    console.info('[Sprite Debug]', {
                        meta: game.player && game.player.spriteMeta,
                        scale: game.player && game.player.spriteScale,
                        loaded: game.player && game.player.spriteLoaded,
                        directionalFrames: game.player && game.player.directionalFrames,
                        facing: game.player && game.player.facing
                    });
                }
                if (e.code === 'F2') {
                    game.perfHud = !game.perfHud;
                    console.info('[Perf HUD]', game.perfHud ? 'ON' : 'OFF');
                }
                if (e.code === 'F4') {
                    console.info('[ThugSprite Debug]', game.enemySprites && game.enemySprites.thug);
                }
                if (e.code === 'F5') {
                    console.info('[StreetDogSprite Debug]', game.enemySprites && game.enemySprites.streetDog);
                }
                if (e.code === 'F6') {
                    console.info('[PunkSprite Debug]', game.enemySprites && game.enemySprites.punk);
                }
                if (e.code === 'F7') {
                    console.info('[DealerSprite Debug]', game.enemySprites && game.enemySprites.dealer);
                }
                if (e.code === 'F8') {
                    console.info('[EnforcerSprite Debug]', game.enemySprites && game.enemySprites.enforcer);
                }
                if (e.code === 'F9') {
                    console.info('[BossThugSprite Debug]', game.enemySprites && game.enemySprites.bossThug);
                }
                if (e.code === 'F10') {
                    console.info('[BossGangsterSprite Debug]', game.enemySprites && game.enemySprites.bossGangster);
                }
                if (e.code === 'F11') {
                    console.info('[BigQuackSprite Debug]', game.enemySprites && game.enemySprites.bigQuack);
                }
                if (e.code === 'F12') {
                    console.info('[GangsterSprite Debug]', game.enemySprites && game.enemySprites.gangster);
                }
            });
            // Also allow mouse primary click on ending overlay to proceed (mobile / desktop convenience)
            window.addEventListener('mousedown', (e) => {
                if (game && game._bigQuackDefeated && !game._finalAbilityOffered) {
                    const overlay = document.getElementById('endingOverlay');
                    if (overlay) {
                        overlay.remove();
                        offerPermanentAbilityChoice();
                        game._finalAbilityOffered = true;
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            // Removed pointer fallback to match original spec (FIRE key only)

            // --- Permanent Ability Integration ---
            loadPermanentAbilities();
            grantPermanentAbilities();
            // Cleanup removed abilities post-reset
            if (game.player && Array.isArray(game.player.abilities)) {
                game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
            }
            if (game.player && Array.isArray(game.player.permanentAbilities)) {
                game.player.permanentAbilities = game.player.permanentAbilities.filter(a => ABILITIES[a]);
            }
            // Clean up any abilities that were removed from the design set
            if (game.player && Array.isArray(game.player.abilities)) {
                game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
            }
            if (game.player && Array.isArray(game.player.permanentAbilities)) {
                game.player.permanentAbilities = game.player.permanentAbilities.filter(a => ABILITIES[a]);
            }

            // Player sprite sheet (replaces separate SVG sprites). Assumes a 4x4 grid: rows = facing (down,left,right,up), cols = animation frames.
            // Adjust frame size or mapping if your sheet differs.
            game.player = game.player || {};
            game.player.spriteSheet = new Image();
            game.player.spriteSheet.src = 'assets/player.png';
            game.player.spriteMeta = { rows: 4, cols: 4, frameWidth: 48, frameHeight: 48, order: ['down','left','right','up'] };
            game.player.facing = game.player.facing || 'down';
            game.player.animFrame = 0;
            game.player.animTimer = 0;
            game.player.animSpeed = 7; // lower = faster animation
            game.player.moving = false;

            // Legacy sprite flags kept for fallback detection
            game.sprites = game.sprites || {};
            game.spritesLoaded = { front:false, rear:false, side:false };

            // Game Over assets & state
            game.gameOverImage = new Image();
            game.gameOverImage.src = 'assets/gameover.png';
            game.gameOver = false;
            game._gameOverSound = null;

            // Track when sheet loads
            game.player.spriteSheet.onload = () => {
                game.player.spriteLoaded = true;
                const iw = game.player.spriteSheet.naturalWidth || game.player.spriteSheet.width;
                const ih = game.player.spriteSheet.naturalHeight || game.player.spriteSheet.height;
                const meta = game.player.spriteMeta;
                // Provide manual override hook before inference (user can call window.configurePlayerSheet prior to sheet load).
                if (typeof window.configurePlayerSheet === 'function') {
                    try { window.configurePlayerSheet(meta, iw, ih); } catch(e) { console.warn('configurePlayerSheet error', e); }
                }
                // Heuristic: attempt to find a reasonable frame size if current values consume whole sheet.
                // If default frame equals entire sheet OR cols/rows come out as 1x1, try factoring.
                function factors(n) { const out=[]; for (let i=1;i*i<=n;i++){ if(n%i===0){ out.push(i); if(i!==n/i) out.push(n/i);} } return out.sort((a,b)=>a-b); }
                if (meta) {
                    // If the assumed size is the whole sheet, attempt to split into up to 4 columns.
                    if ((meta.frameWidth === iw && meta.frameHeight === ih) || (meta.cols===1 && meta.rows===1)) {
                        // Try to pick a frame width close to 48 or 32.
                        const candW = factors(iw).filter(f=>f>=24 && f<=128);
                        const targetPref = [48,32,64];
                        let chosenW = iw;
                        for (const pref of targetPref) { const m = candW.find(c=>c===pref); if (m){ chosenW = m; break; } }
                        if (chosenW === iw && candW.length>1) chosenW = candW[Math.floor(candW.length/2)];
                        const candH = factors(ih).filter(f=>f>=24 && f<=128);
                        let chosenH = ih;
                        for (const pref of targetPref) { const m = candH.find(c=>c===pref); if (m){ chosenH = m; break; } }
                        if (chosenH === ih && candH.length>1) chosenH = candH[Math.floor(candH.length/2)];
                        meta.frameWidth = chosenW;
                        meta.frameHeight = chosenH;
                    }
                    // Recompute cols/rows with new size (guard against division by zero)
                    if (meta.frameWidth > 0 && meta.frameHeight > 0) {
                        meta.cols = Math.max(1, Math.floor(iw / meta.frameWidth));
                        meta.rows = Math.max(1, Math.floor(ih / meta.frameHeight));
                    } else {
                        meta.cols = 1; meta.rows = 1; meta.frameWidth = iw; meta.frameHeight = ih;
                    }
                    // Build facing order based on rows count
                    if (meta.rows === 1) meta.order = ['down'];
                    else if (meta.rows === 2) meta.order = ['down','up'];
                    else if (meta.rows === 3) meta.order = ['down','left','right'];
                    else meta.order = ['down','left','right','up'];
                }
                // Apply a render scale so on-screen size approximates 54px tall unless otherwise specified.
                if (!game.player.spriteScale) {
                    const targetHeight = 54;
                    game.player.spriteScale = targetHeight / (meta ? meta.frameHeight : ih);
                    if (!isFinite(game.player.spriteScale) || game.player.spriteScale <= 0) game.player.spriteScale = 1;
                }
                console.info('[SpriteSheet] Loaded', { iw, ih, meta, scale: game.player.spriteScale });

                // Explicit single-frame directional bounding boxes (static images)
                // Provided bounds (inclusive start, end). We'll compute width/height.
                // Front (down): 95,113 -> 508,883
                // Back (up):   567,106 -> 964,877
                // Side (right):1022,115 -> 1534,879
                // We'll store as {x,y,w,h}. Assume coordinates are top-left (x1,y1) and bottom-right (x2,y2).
                function makeBox(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                game.player.directionalFrames = {
                    down: makeBox(95,113,508,883),
                    up: makeBox(567,106,964,877),
                    right: makeBox(1022,115,1534,879)
                    // left will mirror right
                };
                // Compute scale to fit target on-screen height ~54
                const targetH = 54;
                const ref = game.player.directionalFrames.down;
                if (ref) {
                    game.player.spriteScale = targetH / ref.h;
                }
                console.info('[SpriteSheet] Directional static frames set', game.player.directionalFrames, 'scale', game.player.spriteScale);
            };

            // Helper: rebuild player directional frames if lost or on reset
            function rebuildPlayerSprite() {
                try {
                    if (!game || !game.player) return;
                    // If we lost the spriteSheet reference (e.g. after reset) but it previously existed, abort quietly
                    if (!game.player.spriteSheet) return;
                    // If the sheet already finished loading but spriteLoaded got lost, restore it
                    if (game.player.spriteSheet.complete && !game.player.spriteLoaded) {
                        game.player.spriteLoaded = true;
                    }
                    function makeBox(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.player.directionalFrames = {
                        down: makeBox(95,113,508,883),
                        up: makeBox(567,106,964,877),
                        right: makeBox(1022,115,1534,879)
                    };
                    const ref = game.player.directionalFrames.down;
                    const targetH = 48;
                    if (ref) game.player.spriteScale = targetH / ref.h;
                    // Reset blink/visibility timers when rebuilding explicitly
                    game.player.blinkTimer = 0;
                    game.player.wasHitTimer = 0;
                    // Ensure visibility and loaded flags so render path draws immediately
                    game.player.spriteLoaded = true;
                    if (!game.player.forceVisibleFrames || game.player.forceVisibleFrames < 30) {
                        game.player.forceVisibleFrames = 45; // extend a bit after rebuild
                    }
                } catch(e) { console.warn('rebuildPlayerSprite failed', e); }
            }
            // Expose globally in case resetGame fires in a scope where local function not yet hoisted
            if (typeof window !== 'undefined') window.rebuildPlayerSprite = rebuildPlayerSprite;

            // === Thug enemy sprite sheet (static directional frames) ===
            game.enemySprites = game.enemySprites || {};
            if (!game.enemySprites.thug) {
                const thugImg = new Image();
                thugImg.src = 'assets/KnifeDuck1.png';
                game.enemySprites.thug = { image: thugImg, loaded: false };
                thugImg.onload = () => {
                    game.enemySprites.thug.loaded = true;
                    // Provided bounding boxes (front=down, back=up, side=right) one frame each
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.thug.frames = {
                        down: box(130,200,477,857),
                        up: box(574,203,943,859),
                        right: box(1090,214,1425,859)
                        // left mirrored from right
                    };
                    // Derive scale so on-screen matches original circle size (~ enemy.size*2 tall). We'll aim height ~= enemy.size*2 baseline (size is radius). Use reference: down frame height.
                    const refH = game.enemySprites.thug.frames.down.h;
                    game.enemySprites.thug.baseScaleForSize = (enemySize)=> ( (enemySize*2) / refH );
                    // Provide a hitbox derivation function: returns {w,h,ox,oy} relative to center.
                    game.enemySprites.thug.computeHitbox = (enemy)=> {
                        const size = enemy.size;
                        const scale = game.enemySprites.thug.baseScaleForSize(size);
                        const f = game.enemySprites.thug.frames.down; // use front frame as baseline
                        const w = f.w * scale;
                        const h = f.h * scale;
                        // Slight trimming to tighten collision vs visual edges
                        // Expand hitbox to better match visible sprite silhouette
                        const hitW = w * 0.68;
                        const hitH = h * 0.72;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                    };
                    console.info('[ThugSprite] Loaded KnifeDuck1.png', game.enemySprites.thug.frames);
                };
            }
            // === Enforcer enemy sprite sheet ===
            if (!game.enemySprites.enforcer) {
                const enfImg = new Image();
                enfImg.src = 'assets/Enforcer.png';
                game.enemySprites.enforcer = { image: enfImg, loaded: false };
                enfImg.onload = () => {
                    game.enemySprites.enforcer.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    // Provided bounding boxes (front=down, back=up, side=right)
                    // Front (down): 78,119 -> 529,858
                    // Back (up):   541,120 -> 957,863
                    // Side (right):1074,120 -> 1459,858
                    game.enemySprites.enforcer.frames = {
                        down: box(78,119,529,858),
                        up: box(541,120,957,863),
                        right: box(1074,120,1459,858)
                    };
                    const refH = game.enemySprites.enforcer.frames.down.h;
                    game.enemySprites.enforcer.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.enforcer.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.enforcer.baseScaleForSize(size);
                        const f = game.enemySprites.enforcer.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        // Armor bulk: widen/tall to match visible bulk
                        const hitW = w * 0.72;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                    };
                    console.info('[EnforcerSprite] Loaded Enforcer.png', game.enemySprites.enforcer.frames);
                };
            }

            // === Street Dog enemy sprite sheet ===
            if (!game.enemySprites.streetDog) {
                const dogImg = new Image();
                dogImg.src = 'assets/KnifeDuck2.png';
                game.enemySprites.streetDog = { image: dogImg, loaded: false };
                dogImg.onload = () => {
                    game.enemySprites.streetDog.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.streetDog.frames = {
                        down: box(49,141,557,917),
                        up: box(565,141,978,921),
                        right: box(1041,141,1515,922)
                    };
                    const refH = game.enemySprites.streetDog.frames.down.h;
                    game.enemySprites.streetDog.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.streetDog.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.streetDog.baseScaleForSize(size);
                        const f = game.enemySprites.streetDog.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    console.info('[StreetDogSprite] Loaded KnifeDuck2.png', game.enemySprites.streetDog.frames);
                };
            }

            // === Punk enemy sprite sheet ===
            if (!game.enemySprites.punk) {
                const punkImg = new Image();
                punkImg.src = 'assets/KnifeDuck3.png';
                game.enemySprites.punk = { image: punkImg, loaded: false };
                punkImg.onload = () => {
                    game.enemySprites.punk.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.punk.frames = {
                        down: box(0,164,411,887),
                        up: box(510,166,873,883),
                        right: box(1011,164,1467,883)
                    };
                    const refH = game.enemySprites.punk.frames.down.h;
                    game.enemySprites.punk.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.punk.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.punk.baseScaleForSize(size);
                        const f = game.enemySprites.punk.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.72;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                    };
                    console.info('[PunkSprite] Loaded KnifeDuck3.png', game.enemySprites.punk.frames);
                };
            }

            // === Gangster enemy sprite sheet ===
            if (!game.enemySprites.gangster) {
                const gangsterImg = new Image();
                gangsterImg.src = 'assets/GunDuck1.png';
                game.enemySprites.gangster = { image: gangsterImg, loaded: false };
                gangsterImg.onload = () => {
                    game.enemySprites.gangster.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    // Provided bounding boxes
                    // Front (down): 131,209 -> 482,861
                    // Back (up):   588,203 -> 941,861
                    // Side (right):1056,215 -> 1428,854
                    game.enemySprites.gangster.frames = {
                        down: box(131,209,482,861),
                        up: box(588,203,941,861),
                        right: box(1056,215,1428,854)
                    };
                    const refH = game.enemySprites.gangster.frames.down.h;
                    game.enemySprites.gangster.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.gangster.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.gangster.baseScaleForSize(size);
                        const f = game.enemySprites.gangster.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        // Trim similar to other humanoids; adjust if gameplay feel off
                        const hitW = w * 0.55;
                        const hitH = h * 0.60;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.10 };
                    };
                    console.info('[GangsterSprite] Loaded GunDuck1.png', game.enemySprites.gangster.frames);
                };
            }

            // === Dealer enemy sprite sheet ===
            if (!game.enemySprites.dealer) {
                const dealerImg = new Image();
                dealerImg.src = 'assets/Dealer.png';
                game.enemySprites.dealer = { image: dealerImg, loaded: false };
                dealerImg.onload = () => {
                    game.enemySprites.dealer.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.dealer.frames = {
                        down: box(76,120,514,867),
                        up: box(555,122,982,864),
                        right: box(1045,120,1513,866)
                    };
                    const refH = game.enemySprites.dealer.frames.down.h;
                    game.enemySprites.dealer.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.dealer.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.dealer.baseScaleForSize(size);
                        const f = game.enemySprites.dealer.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.66; // dealer slimmer torso but still fuller coverage
                        const hitH = h * 0.70;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                    };
                    console.info('[DealerSprite] Loaded Dealer.png', game.enemySprites.dealer.frames);
                };
            }

            // === Boss Thug enemy sprite sheet ===
            if (!game.enemySprites.bossThug) {
                const bossImg = new Image();
                bossImg.src = 'assets/KnifeBoss.png';
                game.enemySprites.bossThug = { image: bossImg, loaded: false };
                bossImg.onload = () => {
                    game.enemySprites.bossThug.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.bossThug.frames = {
                        down: box(0,146,520,880),
                        up: box(523,152,963,872),
                        right: box(965,150,1533,873)
                    };
                    const refH = game.enemySprites.bossThug.frames.down.h;
                    game.enemySprites.bossThug.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.bossThug.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.bossThug.baseScaleForSize(size);
                        const f = game.enemySprites.bossThug.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.72; // bigger boss core
                        const hitH = h * 0.76; // taller torso hit area
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    console.info('[BossThugSprite] Loaded KnifeBoss.png', game.enemySprites.bossThug.frames);
                };
            }

            // === Boss Gangster enemy sprite sheet ===
            if (!game.enemySprites.bossGangster) {
                const bossGImg = new Image();
                // NOTE: Asset filename contains a space before .png (GunBoss.png); match exact to load correctly
                bossGImg.src = 'assets/GunBoss.png';
                game.enemySprites.bossGangster = { image: bossGImg, loaded: false };
                bossGImg.onload = () => {
                    game.enemySprites.bossGangster.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.bossGangster.frames = {
                        down: box(0,150,503,874),
                        up: box(508,154,960,867),
                        right: box(966,150,1534,870)
                    };
                    const refH = game.enemySprites.bossGangster.frames.down.h;
                    game.enemySprites.bossGangster.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.bossGangster.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.bossGangster.baseScaleForSize(size);
                        const f = game.enemySprites.bossGangster.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.70; // moderate torso width -> fuller coverage
                        const hitH = h * 0.74; // similar to other bosses
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    console.info('[BossGangsterSprite] Loaded GunBoss .png', game.enemySprites.bossGangster.frames);
                };
            }

            // === The Big Quack final boss sprite sheet ===
            if (!game.enemySprites.bigQuack) {
                const bqImg = new Image();
                bqImg.src = 'assets/BigQuack.png';
                game.enemySprites.bigQuack = { image: bqImg, loaded: false };
                bqImg.onload = () => {
                    game.enemySprites.bigQuack.loaded = true;
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    game.enemySprites.bigQuack.frames = {
                        down: box(0,161,539,866),
                        up: box(541,159,1004,869),
                        right: box(1011,161,1535,875)
                    };
                    const refH = game.enemySprites.bigQuack.frames.down.h;
                    game.enemySprites.bigQuack.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    game.enemySprites.bigQuack.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = game.enemySprites.bigQuack.baseScaleForSize(size);
                        const f = game.enemySprites.bigQuack.frames.down;
                        const w = f.w * scale; const h = f.h * scale;
                        const hitW = w * 0.76; // large core closer to sprite
                        const hitH = h * 0.80; // taller torso hit area
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.04 };
                    };
                    console.info('[BigQuackSprite] Loaded BigQuack.png', game.enemySprites.bigQuack.frames);
                };
            }

            // (Rolled back) Removed procedural enemy & wall sprite generation.

            // Try to decode a first background early; non-blocking to avoid parse/runtime issues
            try {
                const b = window._streetBackgrounds;
                if (b && Array.isArray(b.list) && b.list.length) {
                    const initialSrc = b.list[(Math.random() * b.list.length) | 0];
                    if (window.preloadStreetBackgrounds) { try { window.preloadStreetBackgrounds(); } catch(_) {} }
                    if (typeof loadBgToCache === 'function') {
                        loadBgToCache(initialSrc).then(entry => {
                            if (entry) {
                                b.currentSrc = initialSrc;
                                b.img = entry.bitmap || entry.img;
                                b.ready = true;
                                b.alpha = 1.0; // draw immediately at full opacity
                            }
                        }).catch(()=>{});
                    }
                }
            } catch (e) { console.warn('[BG] Initial preload kick failed', e); }

            generateRoom();
            setupControls();
            updateUI();
            gameLoop();
            // Add particle effects
            setInterval(addAmbientParticles, 2000);
            // Track guaranteed chest logic per district cycle (rooms 1-5)
            game.chestsThisCycle = 0;

            // Initialize audio buttons & listeners
            updateAudioButtons();
            const bs = document.getElementById('btnToggleSfx');
            const bm = document.getElementById('btnToggleMusic');
            if (bs) bs.addEventListener('click', toggleSfx);
            if (bm) bm.addEventListener('click', toggleMusic);
            // Apply initial music mute state if bgMusic already created
            if (game.bgMusic) {
                game.bgMusic.muted = !game.musicEnabled;
                if (game.musicEnabled) { try { game.bgMusic.play().catch(()=>{}); } catch(e) {} }
            }
        }

        // ================= Elemental Infusion System =================
        // Supports multiple concurrent temporary elemental overlays that augment outgoing projectiles.
        // Each infusion tracked as { type, remaining, potency }. potency: scalar applied to bonus damage (% of base) and status strength.
        function ensureInfusionState() {
            if (!game.player) return;
            if (!game.player.infusions) {
                game.player.infusions = []; // array of active infusions
                game.player.maxInfusions = 3;
            }
        }

        // Add (or refresh/stack) an infusion. duration in frames. If same type exists, refresh to max of existing/added and slightly increase potency (capped).
        function addElementalInfusion(type, duration = 600, potency = 0.25) {
            ensureInfusionState();
            if (!game.player) return;
            const existing = game.player.infusions.find(i => i.type === type);
            if (existing) {
                existing.remaining = Math.max(existing.remaining, duration);
                existing.potency = Math.min(0.6, existing.potency + potency * 0.5); // soft cap
            } else {
                if (game.player.infusions.length >= game.player.maxInfusions) {
                    // Replace the one with least remaining time to keep system from silently failing
                    let worstIndex = 0; let worst = Infinity;
                    game.player.infusions.forEach((i, idx) => { if (i.remaining < worst) { worst = i.remaining; worstIndex = idx; } });
                    game.player.infusions.splice(worstIndex, 1);
                }
                game.player.infusions.push({ type, remaining: duration, potency });
            }
            // Visual: infusion gain pulse (perf-aware)
            try {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx) {
                    const colorMap = { fire:'#FFAA55', ice:'#AAE6FF', lightning:'#FFF277', poison:'#88FFAA', void:'#CC88FF', wind:'#AEEFFF' };
                    const col = colorMap[type] || '#FFE6AA';
                    if (!reduceRings) addParticle(game.player.x, game.player.y, col, 'ring');
                    for (let s=0;s<3;s++) addParticle(game.player.x + (Math.random()-0.5)*14, game.player.y + (Math.random()-0.5)*14, col, 'spark');
                }
            } catch(_) {}
        }

        // Randomly roll an element not already active (or refresh one if all taken)
        function rollRandomInfusion() {
            ensureInfusionState();
            if (!game.player) return;
            const pool = ['fire','ice','lightning','poison','void','wind'];
            const inactive = pool.filter(t => !game.player.infusions.some(i => i.type === t));
            const pick = inactive.length ? inactive[Math.floor(Math.random()*inactive.length)] : pool[Math.floor(Math.random()*pool.length)];
            addElementalInfusion(pick, 600, 0.25);
        }

        // Update infusion timers; remove expired.
        function updateInfusions() {
            if (!game.player || !game.player.infusions) return;
            for (let i = game.player.infusions.length - 1; i >= 0; i--) {
                const inf = game.player.infusions[i];
                inf.remaining--;
                if (inf.remaining <= 0) game.player.infusions.splice(i,1);
            }
        }

        // Visual helper: blend colors for infusion overlay (simple average)
        function getInfusionColorBlend() {
            if (!game.player || !game.player.infusions || game.player.infusions.length === 0) return null;
            const colors = { fire:'#ff6a00', ice:'#55ccff', lightning:'#ffee55', poison:'#55ff55', void:'#aa55ff', wind:'#aaffdd' };
            let r=0,g=0,b=0,n=0;
            game.player.infusions.forEach(i => { const c = colors[i.type]; if (!c) return; const v=parseInt(c.slice(1),16); r+=(v>>16)&255; g+=(v>>8)&255; b+=v&255; n++; });
            if (!n) return '#ffffff';
            r=Math.min(255,Math.round(r/n)); g=Math.min(255,Math.round(g/n)); b=Math.min(255,Math.round(b/n));
            return '#'+r.toString(16).padStart(2,'0')+g.toString(16).padStart(2,'0')+b.toString(16).padStart(2,'0');
        }
        // =================================================================

        // Add a floating damage number at world position (x,y). Options can include
        // {crit:true, type:'fire'|'ice'|..., armor:true, heal:true, color:'#rrggbb', big:true, scale:number}
        function addDamageNumber(amount, x, y, opts={}) {
            if (amount == null) return;
            // Avoid flooding: cap active numbers
            if (game.damageNumbers.length > 120) game.damageNumbers.splice(0, game.damageNumbers.length - 120);
            const typeColors = {
                fire:'#ff7933', ice:'#66ccff', lightning:'#ffee55', poison:'#66ff55', void:'#aa66ff',
                shadow:'#8855ff', earth:'#c2934b', wind:'#aaffdd', plasma:'#ff4455', crystal:'#88e6ff',
                solar:'#ffd966', // bright golden hue for Solar Flare
                storm:'#d7f542', magma:'#ff5522', blizzard:'#d0f0ff', inferno:'#ff2200', toxic:'#99ff66',
                bleed:'#ff3355', doom:'#ffffff', weakness:'#cccccc', stun:'#ffee88'
            };
            let color = '#ffffff';
            if (opts.heal) color = '#66ff88';
            else if (opts.crit) color = '#ffdd55';
            else if (opts.type && typeColors[opts.type]) color = typeColors[opts.type];
            if (opts.armor) color = '#888888';
            // Allow explicit color override
            if (opts.color) color = opts.color;
            const floatAngle = (Math.random()*0.8) - 0.4;
            let scale = 1.0;
            if (opts.scale && typeof opts.scale === 'number') scale = opts.scale;
            else if (opts.big) scale = 1.3;
            else if (opts.crit) scale = 1.4;
            game.damageNumbers.push({
                value: amount,
                x, y,
                vx: Math.sin(floatAngle) * 0.4,
                vy: -1.4 - Math.random()*0.4,
                life: 60, // frames
                color,
                scale,
                crit: !!opts.crit,
                heal: !!opts.heal
            });
        }

        function generateRoom() {
            game.walls = [];
            game.enemies = [];
            game.chests = [];
            game.projectiles = [];
            game.particles = [];
            game.pickups = [];
            game.traps = [];
            game.pits = [];
            game.nukes = [];
            game.poisonClouds = [];
            game.shockwaves = [];
            // Active vortex fields (persistent spinning damage zones)
            game.vortexFields = [];
            // Active transient lightning arcs for visual chain effects
            game.lightningArcs = [];
            // Mark the start time of the room for gating early ranged attacks
            game.roomStartTime = Date.now();
            game.roomCleared = false;
            
            // Select / update theme for this room
            game.currentTheme = pickTheme(game.dungeon, game.room);

            // Pick a background image for this room
            if (typeof window.pickRandomBackground === 'function') {
                window.pickRandomBackground();
            }

            // Create perimeter walls
            // Build perimeter walls spanning full logical canvas area
            for (let x = 0; x < ROOM_WIDTH; x++) {
                game.walls.push({ x: x * TILE_SIZE, y: 0, type: 'building' }); // top
                game.walls.push({ x: x * TILE_SIZE, y: (ROOM_HEIGHT - 1) * TILE_SIZE, type: 'building' }); // bottom
            }
            for (let y = 1; y < ROOM_HEIGHT - 1; y++) {
                game.walls.push({ x: 0, y: y * TILE_SIZE, type: 'building' }); // left
                game.walls.push({ x: (ROOM_WIDTH - 1) * TILE_SIZE, y: y * TILE_SIZE, type: 'building' }); // right
            }
            
            // Add varied obstacles (streetlight removed per design request)
            const baseObstacleTypes = ['car', 'dumpster', 'barrier'];
            // Expand obstacle list according to theme weights (simple duplication weighting)
            let obstacleTypes = [];
            const ow = game.currentTheme.obstacleWeights || {};
            baseObstacleTypes.forEach(t => {
                const weight = Math.max(0.1, ow[t] || 1);
                const copies = Math.round(weight * 5); // scale factor for variety; 1 => 5 copies
                for (let c=0;c<copies;c++) obstacleTypes.push(t);
            });
            if (!obstacleTypes.length) obstacleTypes = baseObstacleTypes.slice();
            const obstacleCount = 5 + Math.floor(game.dungeon / 2);
            const OBSTACLE_MIN_GAP = TILE_SIZE * 1.25; // minimum pixel gap between obstacle bounding boxes (excluding perimeter walls)
            
            for (let i = 0; i < obstacleCount; i++) {
                let x, y, attempts = 0;
                do {
                    x = (2 + Math.floor(Math.random() * (ROOM_WIDTH - 4))) * TILE_SIZE;
                    y = (2 + Math.floor(Math.random() * (ROOM_HEIGHT - 4))) * TILE_SIZE;
                    attempts++;
                } while ((Math.abs(x - (LOGICAL_W/2)) < 100 && Math.abs(y - (LOGICAL_H/2)) < 100) && attempts < 50);
                
                if (attempts < 50) {
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    if (type === 'car') {
                        // Larger car footprint: treat horizontal as wider, vertical as taller.
                        const orientation = Math.random() < 0.55 ? 'horizontal' : 'vertical';
                        // Base tile to pixel conversions
                        const tile = TILE_SIZE;
                        let widthPx, heightPx;
                        if (orientation === 'horizontal') {
                            widthPx = tile * 3; // spans 3 tiles wide
                            heightPx = tile * 2; // 2 tiles tall
                        } else {
                            widthPx = tile * 2; // 2 tiles wide
                            heightPx = tile * 3; // 3 tiles tall
                        }
                        // Re-center placement so original (x,y) acts as top-left snapped to tile grid
                        // Ensure it doesn't overlap perimeter (simple clamp)
                        if (x + widthPx > (ROOM_WIDTH-1)*tile) x = Math.max(tile, (ROOM_WIDTH-1)*tile - widthPx - tile);
                        if (y + heightPx > (ROOM_HEIGHT-1)*tile) y = Math.max(tile, (ROOM_HEIGHT-1)*tile - heightPx - tile);
                        // Check overlap with existing walls to avoid stacking
                        const overlaps = game.walls.some(w => {
                            const wW = w.width || tile; const wH = w.height || tile;
                            // Expand tested car bounds by negative margin (gap) so we enforce distance.
                            const ax1 = x - OBSTACLE_MIN_GAP, ay1 = y - OBSTACLE_MIN_GAP;
                            const ax2 = x + widthPx + OBSTACLE_MIN_GAP, ay2 = y + heightPx + OBSTACLE_MIN_GAP;
                            const bx1 = w.x, by1 = w.y, bx2 = w.x + wW, by2 = w.y + wH;
                            return !(ax2 <= bx1 || ax1 >= bx2 || ay2 <= by1 || ay1 >= by2);
                        });
                        if (overlaps) {
                            // Skip placing this car; continue loop without decrementing obstacleCount
                            continue;
                        }
                        // Car theme tint adjustment range overrides random per-car variance if theme supplies range
                        const carRange = game.currentTheme.carTintRange;
                        let tint = null;
                        if (carRange && carRange.length === 2) {
                            tint = carRange[0] + Math.random()*(carRange[1]-carRange[0]);
                        }
                        game.walls.push({ x, y, type, orientation, width: widthPx, height: heightPx, tint });
                        // Placing a large object counts as two obstacles to keep density reasonable
                        if (i < obstacleCount - 1) i++;
                    } else {
                        // Enforce spacing for non-car obstacles too; dumpsters are up-scaled to a larger footprint
                        const tile = TILE_SIZE;
                        let widthPx = tile, heightPx = tile;
                        if (type === 'dumpster') {
                            // At least 5x bigger in both dimensions
                            const SCALE = 5;
                            widthPx = tile * SCALE;
                            heightPx = tile * SCALE;
                            // Clamp within room bounds leaving one tile perimeter similar to cars
                            if (x < tile) x = tile;
                            if (y < tile) y = tile;
                            if (x + widthPx > (ROOM_WIDTH-1)*tile) x = Math.max(tile, (ROOM_WIDTH-1)*tile - widthPx - tile);
                            if (y + heightPx > (ROOM_HEIGHT-1)*tile) y = Math.max(tile, (ROOM_HEIGHT-1)*tile - heightPx - tile);
                            // Avoid player start zone: exclude a rectangle around the logical center
                            const startZoneW = 260; // width of exclusion zone
                            const startZoneH = 220; // height of exclusion zone
                            const sx1 = (LOGICAL_W/2) - startZoneW/2;
                            const sy1 = (LOGICAL_H/2) - startZoneH/2;
                            const sx2 = sx1 + startZoneW;
                            const sy2 = sy1 + startZoneH;
                            const ax1 = x, ay1 = y, ax2 = x + widthPx, ay2 = y + heightPx;
                            const overlapsStart = !(ax2 <= sx1 || ax1 >= sx2 || ay2 <= sy1 || ay1 >= sy2);
                            if (overlapsStart) {
                                // Skip placing this dumpster and try another position by continuing outer loop
                                continue;
                            }
                        } else if (type === 'barrier') {
                            // Enlarge barrier: spans multiple tiles wide, modest height
                            const W_TILES = 3; // width in tiles
                            const H_TILES = 2; // height in tiles
                            widthPx = tile * W_TILES;
                            heightPx = tile * H_TILES;
                            // Clamp within room bounds leaving one tile perimeter margin
                            if (x < tile) x = tile;
                            if (y < tile) y = tile;
                            if (x + widthPx > (ROOM_WIDTH-1)*tile) x = Math.max(tile, (ROOM_WIDTH-1)*tile - widthPx - tile);
                            if (y + heightPx > (ROOM_HEIGHT-1)*tile) y = Math.max(tile, (ROOM_HEIGHT-1)*tile - heightPx - tile);
                        }
                        const overlaps = game.walls.some(w => {
                            const wW = w.width || tile; const wH = w.height || tile;
                            const ax1 = x - OBSTACLE_MIN_GAP, ay1 = y - OBSTACLE_MIN_GAP;
                            const ax2 = x + widthPx + OBSTACLE_MIN_GAP, ay2 = y + heightPx + OBSTACLE_MIN_GAP;
                            const bx1 = w.x, by1 = w.y, bx2 = w.x + wW, by2 = w.y + wH;
                            return !(ax2 <= bx1 || ax1 >= bx2 || ay2 <= by1 || ay1 >= by2);
                        });
                        if (overlaps) continue;
                        if (type === 'dumpster') {
                            game.walls.push({ x, y, type, width: widthPx, height: heightPx });
                            // Large dumpster counts as two obstacles to keep density reasonable
                            if (i < obstacleCount - 1) i++;
                        } else if (type === 'barrier') {
                            game.walls.push({ x, y, type, width: widthPx, height: heightPx });
                            // Larger barrier also counts as two obstacles for density control
                            if (i < obstacleCount - 1) i++;
                        } else {
                            game.walls.push({ x, y, type });
                        }
                    }
                }
            }
            
            // Spawn enemies with scaling difficulty
            const baseEnemyCount = 4;
            const enemyCount = baseEnemyCount + Math.floor(game.dungeon / 2) + Math.floor(game.room / 2);
            console.info('[RoomGen] Begin', { dungeon: game.dungeon, room: game.room, enemyCount });
            // Build theme-weighted enemy pool (fallback to legacy logic if needed)
            const enemyTypesAll = Object.keys(ENEMY_TYPES);
            const themeEnemyWeights = (game.currentTheme && game.currentTheme.enemyWeights) || {};
            let themeWeightedPool = [];
            enemyTypesAll.forEach(t => {
                const w = Math.max(0.05, themeEnemyWeights[t] || 1);
                const copies = Math.round(w * 10);
                for (let c=0;c<copies;c++) themeWeightedPool.push(t);
            });
            if (!themeWeightedPool.length) themeWeightedPool = enemyTypesAll.slice();
            
            // Add boss enemy every 5th room. Final boss only appears in district 10 room 5.
            const hasBoss = game.room === 5;
            
            for (let i = 0; i < enemyCount; i++) {
                let x, y, attempts = 0;
                do {
                    x = 60 + Math.random() * (LOGICAL_W - 120);
                    y = 60 + Math.random() * (LOGICAL_H - 120);
                    attempts++;
                } while ((Math.abs(x - (LOGICAL_W/2)) < 120 || Math.abs(y - (LOGICAL_H/2)) < 120 || isWall(x, y)) && attempts < 50);
                
                if (attempts < 50) {
                    let typeName;
                    if (hasBoss && i === 0) {
                        if (game.dungeon === 10) {
                            typeName = 'The Big Quack';
                        } else if (game.dungeon >= 5) {
                            typeName = 'Boss Gangster';
                        } else {
                            typeName = 'Boss Thug';
                        }
                    } else {
                        // Use theme weighted pool then modulate by dungeon progression similarly to legacy weighting (soft gating)
                        // Filter pool for enemies whose legacy weight would be >0 to avoid early access to late-game types.
                        const legacyWeights = {
                            'Thug': Math.max(1, 4 - game.dungeon),
                            'Street Dog': Math.max(1, 4 - game.dungeon),
                            'Punk': Math.max(1, 3 - game.dungeon + 2),
                            'Gangster': Math.max(0, game.dungeon - 1),
                            'Dealer': Math.max(0, game.dungeon - 3),
                            'Enforcer': Math.max(0, game.dungeon - 6)
                        };
                        const filtered = themeWeightedPool.filter(t => (legacyWeights[t] || 0) > 0);
                        const pool = filtered.length ? filtered : themeWeightedPool;
                        typeName = pool[Math.floor(Math.random() * pool.length)];
                    }
                    const baseType = ENEMY_TYPES[typeName];
                    // Compounding 35% health increase per completed district: multiplier = 1.35^(dungeon-1)
                    const healthMult = Math.pow(1.35, (game.dungeon - 1));
                    // Elite determination (skip for final boss)
                    const themeMult = (game.currentTheme && game.currentTheme.eliteMult) || 1;
                    const baseEliteChance = 0.05 + game.dungeon * 0.004 + game.room * 0.002;
                    // District-specific bump: D9 and D10 get noticeably higher elite rates
                    let eliteChance = baseEliteChance;
                    if (game.dungeon === 9) eliteChance *= 1.75;
                    else if (game.dungeon === 10) eliteChance *= 2.25;
                    eliteChance *= themeMult;
                    eliteChance = Math.min(0.65, eliteChance); // cap to avoid overwhelming all spawns
                    const isElite = (!hasBoss || i > 0) && Math.random() < eliteChance;
                    const enemyObj = {
                        x, y, type: typeName,
                        health: Math.floor(baseType.health * healthMult),
                        maxHealth: Math.floor(baseType.health * healthMult),
                        speed: baseType.speed,
                        baseSpeed: baseType.speed, // store unmodified original for later recovery
                        // Damage no longer scales per district; only health scales to avoid late-game one-shots.
                        damage: baseType.damage,
                        color: baseType.color,
                        size: baseType.size,
                        xp: baseType.xp,
                        ranged: baseType.ranged || false,
                        lastAttack: 0,
                        poisoned: false, poisonTime: 0,
                        slowed: false, slowTime: 0,
                        burning: false, burnTime: 0,
                        elite: isElite
                    };
                    if (isElite) {
                        // Elite stat scaling updated: 5x health, modest speed & damage buffs
                        enemyObj.health = Math.floor(enemyObj.health * 5.0);
                        enemyObj.maxHealth = enemyObj.health;
                        enemyObj.speed *= 1.10;
                        enemyObj.damage = Math.ceil(enemyObj.damage * 1.4);
                        enemyObj.eliteGlow = 1.0; // visual state tracker
                    }
                    if (typeName === 'The Big Quack') {
                        enemyObj.finalBoss = true;
                        // Music swap to boss theme
                        try {
                            if (!game._bossMusicPlaying) {
                                if (game.bgMusic) { game._prevMusicSrc = game.bgMusic.src; try { game.bgMusic.pause(); } catch(e) {} }
                                game.bgMusic = new Audio('assets/audio/PixelShowdown.mp3');
                                game.bgMusic.loop = true;
                                applyMusicPreference();
                                updateAudioButtons();
                                game._bossMusicPlaying = true;
                            }
                        } catch(e) {}
                    }
                    game.enemies.push(enemyObj);
                    if (typeof game._roomSpawnedEnemies === 'number') game._roomSpawnedEnemies++;
                    if (i === 0) console.info('[RoomGen] First enemy', { type: typeName, x: +enemyObj.x.toFixed(1), y: +enemyObj.y.toFixed(1) });
                }
            }
            if (game.enemies.length === 0) {
                console.warn('[RoomGen] No enemies spawned; injecting fallback.');
                const fallback = { x: (LOGICAL_W/2)+(Math.random()*160-80), y: (LOGICAL_H/2)+(Math.random()*160-80), type:'Thug', health:40, maxHealth:40, speed:1.1, baseSpeed:1.1, damage:5, color:'#884400', size:20, xp:5, ranged:false, lastAttack:0, poisoned:false, slowed:false, burning:false };
                game.enemies.push(fallback);
                if (typeof game._roomSpawnedEnemies === 'number') game._roomSpawnedEnemies++;
            }
            // Clamp any enemies that may have landed outside logical bounds due to future logic changes.
            for (const en of game.enemies) {
                if (!en) continue;
                const margin = 40;
                if (en.x < margin) en.x = margin + Math.random()*30;
                if (en.y < margin) en.y = margin + Math.random()*30;
                if (en.x > LOGICAL_W - margin) en.x = LOGICAL_W - margin - Math.random()*30;
                if (en.y > LOGICAL_H - margin) en.y = LOGICAL_H - margin - Math.random()*30;
            }
            console.info('[RoomGen] Done', { spawned: game.enemies.length, counter: game._roomSpawnedEnemies });
            
            // Spawn chests
            let chestSpawnChance = 0.5;
            if (game.player.abilities.includes('Treasure Hunter')) chestSpawnChance = 0.8;
            // Guaranteed minimum chest logic: ensure at least 2 chests every district (rooms 1-5)
            // Strategy: If still below quota and nearing end of cycle, force spawn.
            const roomsPerDistrict = 5;
            const minChestsPerDistrict = 2;
            const roomIndexInCycle = game.room; // 1..5
            let forceChest = false;
            if (typeof game.chestsThisCycle !== 'number') game.chestsThisCycle = 0;
            const remainingRooms = roomsPerDistrict - roomIndexInCycle + 1;
            const needed = minChestsPerDistrict - game.chestsThisCycle;
            if (needed > 0) {
                // If number of remaining rooms equals needed, we must force spawn now.
                if (needed >= remainingRooms) {
                    forceChest = true;
                } else {
                    // Soft pity: slightly boost chance proportional to deficit
                    chestSpawnChance += 0.15 * needed; // each missing chest adds 15% chance
                }
            }
            if (forceChest || Math.random() < chestSpawnChance) {
                let x, y, attempts = 0;
                const startX = LOGICAL_W/2, startY = LOGICAL_H/2; // player spawn center (dynamic)
                const startExclusionR = 90; // radius within which chests may not spawn
                const startExclusionR2 = startExclusionR * startExclusionR;
                do {
                    x = 60 + Math.random() * (LOGICAL_W - 120);
                    y = 60 + Math.random() * (LOGICAL_H - 120);
                    attempts++;
                    const dxs = x - startX; const dys = y - startY;
                    var tooCloseToStart = (dxs*dxs + dys*dys) < startExclusionR2;
                } while ((tooCloseToStart || game.enemies.some(e => Math.abs(e.x - x) < 60) || isWall(x, y)) && attempts < 50);
                
                if (attempts < 50) {
                    // Rare rainbow chest: 2% baseline chance per spawn (before Treasure Hunter etc.)
                    const isRainbow = Math.random() < 0.02;
                    // Preselect an ability for this chest now so variant can reflect rarity.
                    // Choose from abilities the player does NOT yet have.
                    const pool = Object.keys(ABILITIES).filter(a => !game.player.abilities.includes(a));
                    let chosenAbility = null;
                    if (pool.length > 0) {
                        // Weight by inverse tier (common more likely) but with slight bias for variety.
                        const weighted = [];
                        pool.forEach(a => {
                            const tier = ABILITIES[a].tier || 1;
                            const base = Math.max(1, 4 - tier); // 3 for T1,2 for T2,1 for T3
                            for (let i=0;i<base;i++) weighted.push(a);
                        });
                        chosenAbility = weighted[Math.floor(Math.random()*weighted.length)];
                    }
                    // Map tier to can variant: tier1 -> platinum (common / white), tier2 -> gold (rare / blue), tier3 -> irradiated (epic / purple)
                    // Rainbow overrides these and ignores preselected ability (player will pick from all)
                    let variant = 'gold';
                    if (chosenAbility) {
                        const tier = ABILITIES[chosenAbility].tier || 1;
                        if (tier === 1) variant = 'platinum';
                        else if (tier === 2) variant = 'gold';
                        else if (tier >= 3) variant = 'irradiated';
                    } else {
                        // No ability available (player owns everything) keep neutral gold appearance
                        variant = 'gold';
                    }
                    if (isRainbow) {
                        variant = 'rainbow';
                    }
                    game.chests.push({ x, y, opened: false, variant, jigglePhase: 0, ability: isRainbow ? null : chosenAbility, rainbow: !!isRainbow });
                    game.chestsThisCycle = (game.chestsThisCycle || 0) + 1;
                }
            }
            
            // Center player based on dynamic logical size
            game.player.x = LOGICAL_W / 2;
            game.player.y = LOGICAL_H / 2;
            // Spawn room-unique Tumbleweed / Kick the Can if player has the abilities
            try {
                const hasTw = game.player && Array.isArray(game.player.abilities) && game.player.abilities.includes('Tumbleweed');
                const hasCan = game.player && Array.isArray(game.player.abilities) && game.player.abilities.includes('Kick the Can');
                if (hasTw || hasCan) {
                    // Pick a spot away from center/start and not inside walls/obstacles
                    const startX = LOGICAL_W/2, startY = LOGICAL_H/2;
                    const exclusionR = 120; const exclusionR2 = exclusionR*exclusionR;
                    // Plan spawn order to reduce overlap: try placing Tumbleweed first, then Can with separation from TW.
                    let twPos = null;
                    let canPos = null;
                    if (hasTw) {
                        let tx, ty, attempts = 0;
                        do {
                            tx = 60 + Math.random() * (LOGICAL_W - 120);
                            ty = 60 + Math.random() * (LOGICAL_H - 120);
                            attempts++;
                            const dxs = tx - startX, dys = ty - startY;
                            var tooClose = (dxs*dxs + dys*dys) < exclusionR2;
                        } while ((tooClose || isWall(tx, ty, 18)) && attempts < 80);
                        if (attempts < 80) twPos = { x: tx, y: ty };
                    }
                    if (hasCan) {
                        const sep = 80; const sep2 = sep*sep;
                        let cx, cy, attempts = 0;
                        do {
                            cx = 60 + Math.random() * (LOGICAL_W - 120);
                            cy = 60 + Math.random() * (LOGICAL_H - 120);
                            attempts++;
                            const dxs = cx - startX, dys = cy - startY;
                            var tooClose = (dxs*dxs + dys*dys) < exclusionR2;
                            var tooNearTw = false;
                            if (twPos) { const dxt = cx - twPos.x, dyt = cy - twPos.y; tooNearTw = (dxt*dxt + dyt*dyt) < sep2; }
                        } while ((tooClose || tooNearTw || isWall(cx, cy, 18)) && attempts < 100);
                        if (attempts < 100) canPos = { x: cx, y: cy };
                        // If we didn't place TW earlier but will place Can, and later we place TW, ensure separation too
                        if (!twPos && hasTw) {
                            let tx, ty, tries = 0; const sep3 = 80*80;
                            do {
                                tx = 60 + Math.random() * (LOGICAL_W - 120);
                                ty = 60 + Math.random() * (LOGICAL_H - 120);
                                tries++;
                                const dxs = tx - startX, dys = ty - startY;
                                var tooClose = (dxs*dxs + dys*dys) < exclusionR2;
                                var tooNearCan = false;
                                if (canPos) { const dxc = tx - canPos.x, dyc = ty - canPos.y; tooNearCan = (dxc*dxc + dyc*dyc) < sep3; }
                            } while ((tooClose || tooNearCan || isWall(tx, ty, 18)) && tries < 100);
                            if (tries < 100) twPos = { x: tx, y: ty };
                        }
                    }
                    // Now spawn whichever positions are valid
                    if (twPos && hasTw) {
                        const baseDmg = Math.max(6, Math.floor((typeof calculateDamage === 'function' ? calculateDamage() : 22) * 0.70));
                        const idx = game.spawnProjectile({
                            x: twPos.x, y: twPos.y,
                            vx: (Math.random()*2-1) * 0.25,
                            vy: (Math.random()*2-1) * 0.25,
                            life: 60000,
                            radius: 14,
                            damage: baseDmg,
                            bouncing: true
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        if (idx >= 0) {
                            game._projMeta.set(idx, { tumbleweed: true, bouncing: true, piercing: true, pierceCount: 999, pierceHits: 0, indestructible: true, baseDamage: baseDmg, _rollAngle: 0 });
                            game._tumbleweedIndex = idx;
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:twPos.x, y:twPos.y, color:'#EED7AA', radius: 18, life: 90 });
                        }
                    } else {
                        game._tumbleweedIndex = -1;
                    }
                    if (canPos && hasCan) {
                        const baseDmg = Math.max(6, Math.floor((typeof calculateDamage === 'function' ? calculateDamage() : 22) * 0.70));
                        const idx = game.spawnProjectile({
                            x: canPos.x, y: canPos.y,
                            vx: (Math.random()*2-1) * 0.25,
                            vy: (Math.random()*2-1) * 0.25,
                            life: 60000,
                            radius: 14,
                            damage: baseDmg,
                            bouncing: true
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        if (idx >= 0) {
                            game._projMeta.set(idx, { kickTheCan: true, bouncing: true, piercing: true, pierceCount: 999, pierceHits: 0, indestructible: true, baseDamage: baseDmg, _rollAngle: 0 });
                            game._kickCanIndex = idx;
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:canPos.x, y:canPos.y, color:'#EED7AA', radius: 18, life: 90 });
                        }
                    } else {
                        game._kickCanIndex = -1;
                    }
                } else {
                    game._tumbleweedIndex = -1;
                    game._kickCanIndex = -1;
                }
            } catch(_) {}
        }

        function isWall(x, y, size = 25) {
            // Supports variable-sized walls (cars, dumpsters, barriers) and aligns hitboxes with their sprite draw rects
            return game.walls.some(wall => {
                let wx = wall.x, wy = wall.y, w = wall.width || TILE_SIZE, h = wall.height || TILE_SIZE;
                if (wall.type === 'dumpster' && typeof window.getDumpsterSpriteRect === 'function') {
                    const rect = window.getDumpsterSpriteRect(wall);
                    if (rect && rect.w && rect.h) { wx = rect.x; wy = rect.y; w = rect.w; h = rect.h; }
                } else if (wall.type === 'barrier') {
                    // Map opaque image bounds to on-canvas footprint for tighter collisions
                    const img = window._barrierImage;
                    const opaque = window._barrierOpaqueRect;
                    if (img && opaque && opaque.w && opaque.h) {
                        const iw = img.naturalWidth || img.width;
                        const ih = img.naturalHeight || img.height;
                        const sx = wall.x, sy = wall.y; // destination top-left
                        const sw = w, sh = h;           // destination size
                        // Scale opaque rect from image space to dest space
                        const scaleX = sw / iw;
                        const scaleY = sh / ih;
                        wx = sx + opaque.x * scaleX;
                        wy = sy + opaque.y * scaleY;
                        w = Math.max(1, opaque.w * scaleX);
                        h = Math.max(1, opaque.h * scaleY);
                    }
                }
                return (x > wx - size && x < wx + w + size && y > wy - size && y < wy + h + size);
            });
        }

        // Move an enemy along a vector in small steps, stopping before hitting walls.
        // dx,dy is the normalized direction vector; distance is how far to attempt to push.
        function pushEnemy(enemy, dx, dy, distance, step = 4) {
            const steps = Math.max(1, Math.ceil(distance / step));
            let moved = 0;
            for (let i = 0; i < steps; i++) {
                const nx = enemy.x + dx * step;
                const ny = enemy.y + dy * step;
                // If the next step would be inside a wall, stop early
                if (isWall(nx, ny, enemy.size/2)) break;
                enemy.x = nx;
                enemy.y = ny;
                moved += step;
            }
            // Failsafe clamp so enemies never leave playable bounds
            const margin = 40;
            enemy.x = Math.max(margin, Math.min(enemy.x, canvas.width - margin));
            enemy.y = Math.max(margin, Math.min(enemy.y, canvas.height - margin));
            return moved;
        }

        // Unified knockback impulse application (velocity-based) replacing instantaneous pushEnemy usage for knockback effects.
        // forceDist approximates desired travel distance; direction provided via normalized (dx,dy) or computed from sx,sy vector.
        function applyKnockback(enemy, forceDist, sx, sy) {
            if (!enemy) return;
            // Derive direction from sx,sy
            const mag = Math.hypot(sx, sy) || 1;
            const dx = sx / mag; const dy = sy / mag;
            // Parameters: decay & initial velocity mapping (reuse smooth knockback math but allow independent tuning)
            const decay = 0.9; // slightly higher decay (slower) vs applySmoothKnockback for layered pushes
            const v0 = Math.min(30, forceDist * (1 - decay));
            enemy._kbDecay = decay;
            enemy.kbVX = (enemy.kbVX || 0) + dx * v0;
            enemy.kbVY = (enemy.kbVY || 0) + dy * v0;
            // Extend kbFrames proportionally; layering multiple impulses increases duration modestly
            const addFrames = Math.min(40, Math.floor(forceDist * 0.4));
            enemy.kbFrames = Math.max(enemy.kbFrames || 0, addFrames);
            enemy._knockbacking = true;
        }

        // Smooth knockback: apply an initial velocity and let updateEnemies integrate it over several frames.
        // distance roughly correlates with the total displacement we want. We translate that into an initial
        // speed and decay factor. This avoids the "teleport" look of large instantaneous pushes (e.g., Wind Blade 120px).
        function applySmoothKnockback(enemy, dx, dy, distance) {
            // Normalize direction (defensive)
            const mag = Math.hypot(dx, dy) || 1;
            const ndx = dx / mag; const ndy = dy / mag;
            // If enemy already has knockback velocity, blend (add) the new impulse.
            const decay = 0.88; // stored for reference if we later want per-enemy tuning
            enemy._kbDecay = decay;
            // Convert desired travel distance into initial speed; geometric series sum S = v0 / (1-decay)
            // => v0  distance * (1 - decay). We clamp to avoid absurd speeds on gigantic values.
            const baseV0 = distance * (1 - decay); // e.g. distance 120, decay .88 -> ~14.4
            const v0 = Math.min(28, baseV0);
            enemy.kbVX = (enemy.kbVX || 0) + ndx * v0;
            enemy.kbVY = (enemy.kbVY || 0) + ndy * v0;
            // Duration in frames: allow enough frames for displacement. Use log threshold: v * decay^n < 0.25 => n  log(0.25/v)/log(decay)
            // Approximate with linear scale for simplicity.
            enemy.kbFrames = Math.max(enemy.kbFrames || 0, Math.min(50, Math.floor(distance * 0.5))); // 120 -> 60 (capped 50)
            // Flag so other movement AI can skip while sliding.
            enemy._knockbacking = true;
        }

        // Returns true if any ability selection modal/overlay is currently visible
        function isAnyAbilityModalOpen() {
            const ids = ['startAbilityOverlay', 'rainbowAbilityOverlay', 'abilityChoiceOverlay', 'confirmOverlay'];
            for (let i = 0; i < ids.length; i++) {
                const el = document.getElementById(ids[i]);
                if (!el) continue;
                const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
                const visible = cs ? (cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0') : (el.style.display !== 'none');
                if (visible) return true;
            }
            return false;
        }

        // --- Gamepad helpers (controller fixes 2025-10-10) ---
        function _applyDeadzone(ax, ay, deadzone) {
            const mag = Math.hypot(ax, ay);
            if (mag < deadzone) return { x: 0, y: 0 };
            const n = (mag - deadzone) / (1 - deadzone);
            const scale = n / (mag || 1);
            return { x: ax * scale, y: ay * scale };
        }

        function updateGamepadInput() {
            const inp = game.input;
            if (!inp || !inp.gamepadEnabled) return;
            const get = (navigator.getGamepads && navigator.getGamepads()) || [];
            let pad = null;
            if (inp.gpIndex != null && get[inp.gpIndex]) {
                pad = get[inp.gpIndex];
            }
            if (!pad) {
                // pick first connected standard-mapped pad
                for (let i=0;i<get.length;i++) { if (get[i] && get[i].connected) { pad = get[i]; inp.gpIndex = i; break; } }
            }
            if (!pad) return;
            // Axes: standard mapping: 0=LX,1=LY, 2=RX,3=RY
            const ax0 = pad.axes[0] || 0, ay0 = pad.axes[1] || 0;
            const ax1 = pad.axes[2] || 0, ay1 = pad.axes[3] || 0;
            const dz = Math.min(0.6, Math.max(0.05, inp.gpDeadzone||0.25));
            const mv = _applyDeadzone(ax0, ay0, dz);
            const av = _applyDeadzone(ax1, ay1, dz);
            // Clamp to [-1,1] to avoid rare >1 magnitudes from browser quirks
            function clamp1(v){ return v>1?1:(v<-1?-1:v); }
            mv.x = clamp1(mv.x); mv.y = clamp1(mv.y);
            av.x = clamp1(av.x); av.y = clamp1(av.y);
            // Some pads (e.g., MOGA XP5-A Plus) report right-stick Y as -1 at rest; treat this as invalid aim so movement can control facing
            if (Math.abs(av.x) < 0.2 && (Math.abs(av.y + 1) < 0.12 || Math.abs(av.y) > 0.98)) {
                // If aim appears pegged vertically with near-zero X, ignore it
                av.x = 0; av.y = 0;
            }
            inp.gpMove.x = mv.x; inp.gpMove.y = mv.y;
            inp.gpAim.x = av.x; inp.gpAim.y = av.y;
            // Buttons: 0=A, 1=B, 2=X, 3=Y, 4=LB, 5=RB, 6=LT, 7=RT, 8=Back, 9=Start, 10=LS, 11=RS
            const btn = (i)=>{ const b = pad.buttons[i]; return !!(b && (b.pressed || (b.value!=null && b.value>0.5))); };
            // Manual mapping support
            const map = (game.input && game.input.gpMap) || null;
            // Resolve D-Pad state either via mapping or fallbacks
            let dpx = 0, dpy = 0;
            if (map && (map.dpadUp || map.dpadDown || map.dpadLeft || map.dpadRight)) {
                const up = __gp_mappingPressed(pad, map.dpadUp);
                const down = __gp_mappingPressed(pad, map.dpadDown);
                const left = __gp_mappingPressed(pad, map.dpadLeft);
                const right = __gp_mappingPressed(pad, map.dpadRight);
                dpx = (right?1:0) - (left?1:0);
                dpy = (down?1:0) - (up?1:0);
            } else {
                // D-Pad digital movement (12=Up, 13=Down, 14=Left, 15=Right)
                const dUp = btn(12), dDown = btn(13), dLeft = btn(14), dRight = btn(15);
                dpx = (dRight?1:0) - (dLeft?1:0);
                dpy = (dDown?1:0) - (dUp?1:0);
            }
            // Fallback: D-Pad via POV "hat" (axis 9)
            if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length > 9) {
                const hat = pad.axes[9];
                const vec = __gp_hatToVec(hat);
                if (vec) { dpx = vec.x; dpy = vec.y; }
            }
            // Fallback 2: older/alt mappings use separate axes 6 (horizontal) and 7 (vertical) for the D-Pad
            if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length >= 8) {
                const dax = pad.axes[6] || 0, day = pad.axes[7] || 0;
                if (Math.abs(dax) > 0.5) dpx = dax > 0 ? 1 : -1;
                if (Math.abs(day) > 0.5) dpy = day > 0 ? 1 : -1; // +1 down, -1 up (matches standard)
            }
            if (dpx !== 0 || dpy !== 0) {
                // Override analog move when D-Pad is pressed for crisp digital control (no deadzone)
                inp.gpMove.x = dpx;
                inp.gpMove.y = dpy;
            }
            // Clamp tiny drift post-deadzone
            if (Math.abs(inp.gpMove.x) < 0.001) inp.gpMove.x = 0;
            if (Math.abs(inp.gpMove.y) < 0.001) inp.gpMove.y = 0;
            if (Math.abs(inp.gpAim.x) < 0.001) inp.gpAim.x = 0;
            if (Math.abs(inp.gpAim.y) < 0.001) inp.gpAim.y = 0;
            // Fire: manual mapping takes precedence; else A (0) only
            let fireNow = false;
            if (map && map.fire) fireNow = __gp_mappingPressed(pad, map.fire);
            else fireNow = btn(0);
            inp.gpFire = !!fireNow;
            // Start toggles pause on rising edge; ignore if a modal is open.
            // Also guard against triggers mistakenly toggling by checking their raw values and mapping.
            const trigBtnL = btn(6), trigBtnR = btn(7);
            const trigValL = (pad.buttons[6] && typeof pad.buttons[6].value === 'number') ? pad.buttons[6].value : 0;
            const trigValR = (pad.buttons[7] && typeof pad.buttons[7].value === 'number') ? pad.buttons[7].value : 0;
            const startNow = (map && map.pause) ? __gp_mappingPressed(pad, map.pause) : btn(9);
            const last = inp._lastButtons || {};
            if (startNow && !last.start && trigValL < 0.1 && trigValR < 0.1 && !trigBtnL && !trigBtnR) {
                const now = performance.now ? performance.now() : Date.now();
                if (!inp._lastStartAt || now - inp._lastStartAt > 250) {
                    if (!(typeof isAnyAbilityModalOpen === 'function' && isAnyAbilityModalOpen())) {
                        if (typeof togglePause === 'function') togglePause();
                    }
                    inp._lastStartAt = now;
                }
            }
            // Snapshot for edge detection; explicitly track LS/RS to filter accidental actions
            inp._lastButtons = {
                start: startNow,
                ls: btn(10),
                rs: btn(11),
                lt: trigBtnL,
                rt: trigBtnR
            };
        }

        function setupControls() {
            document.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                game.keys[key] = true;
                // Toggle gamepad debug overlay with F6 (diagnostics)
                if (e.key === 'F6') {
                    const dbg = document.getElementById('gpDebug');
                    if (dbg) dbg.style.display = (dbg.style.display === 'none' || !dbg.style.display) ? 'block' : 'none';
                }
                
                // Handle pause
                if (key === 'p') {
                    // If typing in an input/textarea/contentEditable or an ability modal is open,
                    // do NOT toggle pause so 'p' can be used in search fields.
                    const ae = document.activeElement;
                    const tag = ae && ae.tagName ? String(ae.tagName).toUpperCase() : '';
                    const isTypingField = (tag === 'INPUT' || tag === 'TEXTAREA') || (ae && ae.isContentEditable === true);
                    if (isTypingField || isAnyAbilityModalOpen()) {
                        return; // let default typing behavior occur
                    }
                    togglePause();
                    e.preventDefault();
                }
                if (key === 'f') {
                    game.showFps = !game.showFps;
                }
            });
            
            document.addEventListener('keyup', e => {
                game.keys[e.key.toLowerCase()] = false;
            });
        }

        function gameLoop() {
            if (!game._loopStarted) game._loopStarted = true; // mark loop engaged once
            // Defensive: if multiple RAF chains somehow created, abort duplicates
            if (game._cancelExtraLoop) return;
            // Always poll gamepad so Start can unpause and inputs are fresh even when paused (controller fixes 2025-10-10)
            try { updateGamepadInput(); } catch(_) {}
            // Allow menu navigation with D-Pad/left stick and confirm with A when overlays are open
            try { handleGamepadMenuNavigation(); } catch(_) {}
            // Update debug overlay if visible
            try { updateGpDebug(); } catch(_) {}
            if (!game.paused && !game.gameOver) {
                update();
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            game.paused = !game.paused;
            const overlay = document.getElementById('pauseOverlay');
            
            if (game.paused) {
                overlay.style.display = 'flex';
                initPauseTabs();
                switchPauseTab('abilities');
                updatePauseMenu();
            } else {
                overlay.style.display = 'none';
            }
        }

        // Update pause menu to show ability descriptions
        function updatePauseMenu() {
            const pauseAbilities = document.getElementById('pauseAbilities');
            if (game.player.abilities.length === 0) {
                pauseAbilities.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #666; font-style: italic;">No abilities acquired yet</div>';
                return;
            }
            let html = '';
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                const tier = abilityData ? abilityData.tier || 1 : 1;
                const isPermanent = game.player.permanentAbilities.includes(ability);
                let cardClass = `ability-card tier${tier}` + (isPermanent ? ' permanent' : '');
                let color = '#ffffff';
                if (tier === 2) color = '#4488ff';
                else if (tier >= 3) color = '#c855ff';
                const permaBadge = isPermanent ? `<span style="display:inline-block;margin-left:8px;padding:1px 6px;border:1px solid #ffd700;border-radius:10px;color:#ffd700;font-size:10px;letter-spacing:0.5px;vertical-align:middle;">PERMANENT</span>` : '';
                html += `<div class="${cardClass}" style="margin-bottom:8px; position:relative;">
                    <div class="ability-card-name" style="color:${isPermanent ? '#ffd700' : color}">${ability}${permaBadge}</div>
                    <div class="ability-card-desc">${abilityData ? abilityData.desc : 'Unknown ability'}</div>
                </div>`;
            });
            pauseAbilities.innerHTML = html;
        }

        // --- Minimal gamepad debug overlay ---
        (function ensureGpDebug(){
            if (document.getElementById('gpDebug')) return;
            const el = document.createElement('div');
            el.id = 'gpDebug';
            el.style.cssText = 'position:fixed;left:6px;top:6px;z-index:20000;background:rgba(0,0,0,0.6);color:#0f0;padding:6px 8px;border:1px solid #0a4;border-radius:6px;font:11px Courier New,monospace;white-space:pre;display:none;max-width:50vw;';
            el.textContent = 'GP Debug';
            document.body.appendChild(el);
        })();
        function updateGpDebug(){
            const box = document.getElementById('gpDebug'); if (!box || box.style.display==='none') return;
            const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
            const idx = game && game.input ? game.input.gpIndex : null;
            const p = (idx!=null && pads[idx]) ? pads[idx] : pads.find(x=>x && x.connected);
            const m = p ? (p.mapping||'') : '';
            const bStates = [];
            if (p && p.buttons) {
                for (let i=0;i<Math.min(16,p.buttons.length);i++) {
                    const b = p.buttons[i]; bStates.push((b && (b.pressed||((b.value||0)>0.5)))?1:0);
                }
            }
            const mv = game.input ? game.input.gpMove : {x:0,y:0};
            const av = game.input ? game.input.gpAim : {x:0,y:0};
            const facing = game.player ? game.player.facing : '?';
            const axesLen = p && p.axes ? p.axes.length : 0;
            const a6 = p && p.axes && p.axes.length>6 ? p.axes[6] : 0;
            const a7 = p && p.axes && p.axes.length>7 ? p.axes[7] : 0;
            const a9 = p && p.axes && p.axes.length>9 ? p.axes[9] : 0;
            // Mapped state preview
            let mappedLine = '';
            try {
                const mp = game.input && game.input.gpMap;
                if (mp) {
                    const pressed = (ent)=>__gp_mappingPressed(p, ent) ? '1':'0';
                    const up = mp.dpadUp?pressed(mp.dpadUp):'-';
                    const dn = mp.dpadDown?pressed(mp.dpadDown):'-';
                    const lf = mp.dpadLeft?pressed(mp.dpadLeft):'-';
                    const rt = mp.dpadRight?pressed(mp.dpadRight):'-';
                    const fire = mp.fire?pressed(mp.fire):'-';
                    const pause = mp.pause?pressed(mp.pause):'-';
                    mappedLine = `\nmapped: U${up} D${dn} L${lf} R${rt} F${fire} P${pause}`;
                }
            } catch(_) {}
            box.textContent = `map:${m}\nbtn[0..15]: ${bStates.join('')}\nmove: ${mv.x.toFixed(2)}, ${mv.y.toFixed(2)}  aim: ${av.x.toFixed(2)}, ${av.y.toFixed(2)}\naxes(len=${axesLen}): a6=${(+a6).toFixed(2)} a7=${(+a7).toFixed(2)} a9=${(+a9).toFixed(2)}${mappedLine}\nfacing: ${facing}`;
        }

        // Expose mapping overlay at top-level scope
        function startManualGamepadMapping() {
            const existing = document.getElementById('gpMapOverlay'); if (existing) try { existing.remove(); } catch(_) {}
            const ov = document.createElement('div'); ov.id='gpMapOverlay';
            ov.style.cssText = 'position:fixed;inset:0;z-index:30000;background:rgba(0,0,0,0.86);display:flex;align-items:center;justify-content:center;font-family:Courier New,monospace;';
            const panel = document.createElement('div');
            panel.style.cssText = 'width:min(720px,92vw);background:#141414;border:2px solid #666;border-radius:10px;padding:16px;color:#eee;display:flex;flex-direction:column;gap:10px;';
            const title = document.createElement('div'); title.style.cssText='font-weight:800;letter-spacing:1px;color:#fff'; title.textContent='Controller Mapping';
            const info = document.createElement('div'); info.style.cssText='color:#bbb;font-size:12px'; info.textContent='Follow the prompts. Press the requested button/direction. Press Esc to cancel.';
            const prompt = document.createElement('div'); prompt.id='gpMapPrompt'; prompt.style.cssText='background:#0c0c0c;border:1px solid #555;border-radius:8px;padding:10px;color:#aaffaa;min-height:46px;display:flex;align-items:center;';
            const actions = document.createElement('div'); actions.style.cssText='display:flex;gap:8px;justify-content:flex-end;';
            const btnCancel = document.createElement('button'); btnCancel.textContent='Cancel'; btnCancel.style.cssText='padding:6px 10px;background:#222;border:1px solid #777;color:#ddd;border-radius:6px;cursor:pointer;'; btnCancel.setAttribute('data-gp-focus','1');
            const btnClear = document.createElement('button'); btnClear.textContent='Clear Mapping'; btnClear.style.cssText='padding:6px 10px;background:#222;border:1px solid #777;color:#ddd;border-radius:6px;cursor:pointer;'; btnClear.setAttribute('data-gp-focus','1');
            panel.appendChild(title); panel.appendChild(info); panel.appendChild(prompt); actions.appendChild(btnClear); actions.appendChild(btnCancel); panel.appendChild(actions); ov.appendChild(panel); document.body.appendChild(ov);

            let steps = [
                { key:'pause', label:'Press the PAUSE button (Start)' },
                { key:'fire', label:'Press the FIRE button (A)' },
                { key:'dpadUp', label:'Press D-Pad UP' },
                { key:'dpadDown', label:'Press D-Pad DOWN' },
                { key:'dpadLeft', label:'Press D-Pad LEFT' },
                { key:'dpadRight', label:'Press D-Pad RIGHT' }
            ];
            const result = {};
            let idx = 0;
            let lastSnapshot = null;
            let paused = false;
            try { paused = !!game.paused; game.paused = true; } catch(_) {}

            function setPrompt(text, color='#aaffaa') { prompt.textContent = text; prompt.style.color = color; }
            function snapshotPad(p) {
                if (!p) return null;
                const s = { buttons:[], axes:[] };
                for (let i=0;i<Math.min(24, (p.buttons?p.buttons.length:0)); i++) {
                    const b = p.buttons[i]; s.buttons[i] = { pressed: !!(b && (b.pressed || ((b.value||0)>0.5))), value: (b && typeof b.value==='number') ? b.value : 0 };
                }
                for (let i=0;i<Math.min(16, (p.axes?p.axes.length:0)); i++) {
                    s.axes[i] = typeof p.axes[i] === 'number' ? p.axes[i] : 0;
                }
                return s;
            }
            function diffPad(prev, curr) {
                if (!prev || !curr) return null;
                // Buttons first
                for (let i=0;i<Math.min(prev.buttons.length, curr.buttons.length); i++) {
                    if (!prev.buttons[i].pressed && curr.buttons[i].pressed) {
                        return { type:'button', index:i };
                    }
                }
                // Axes: detect hat axis changes and strong digital pushes
                for (let i=0;i<Math.min(prev.axes.length, curr.axes.length); i++) {
                    const a0 = prev.axes[i], a1 = curr.axes[i];
                    if (i === 9) {
                        const v = __gp_hatToVec(a1);
                        const v0 = __gp_hatToVec(a0);
                        if (v && (!v0 || v.x !== v0.x || v.y !== v0.y)) {
                            return { type:'axis', index:9, dir:'hat' };
                        }
                    } else {
                        const thr = 0.6;
                        // Rising over threshold in either direction
                        if (Math.abs(a1) >= thr && Math.abs(a0) < thr) {
                            return { type:'axis', index:i, threshold:thr, sign: (a1>0)?1:-1 };
                        }
                    }
                }
                return null;
            }
            function saveAndClose(ok=true) {
                try { if (!paused) game.paused = false; else game.paused = paused; } catch(_) {}
                window.removeEventListener('keydown', escHandler, true);
                try { document.body.removeChild(ov); } catch(_) {}
                if (ok) { saveInputPreferences(); reflectOptionStates(); }
            }
            function escHandler(e){ if (e.key==='Escape'){ e.preventDefault(); saveAndClose(false);} }
            window.addEventListener('keydown', escHandler, true);
            btnCancel.onclick = () => saveAndClose(false);
            btnClear.onclick = () => { try { delete game.input.gpMap; localStorage.removeItem('pref_gp_map'); } catch(_) {} setPrompt('Mapping cleared. Close this overlay.', '#ffcc88'); };

            function nextStep() {
                if (idx >= steps.length) {
                    game.input.gpMap = result;
                    try { saveInputPreferences(); } catch(_) {}
                    try { console.info('[Gamepad Mapping] Saved:', result); } catch(_) {}
                    setPrompt('Saved mapping. You can close this overlay.', '#aaccff');
                    return;
                }
                setPrompt(steps[idx].label + ' ');
                // capture initial snapshot for edge detection
                const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
                const p = pads.find(x=>x && x.connected);
                lastSnapshot = snapshotPad(p);
            }

            const interval = setInterval(()=>{
                if (!document.body.contains(ov)) { clearInterval(interval); return; }
                const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
                const p = pads.find(x=>x && x.connected);
                if (!p) return;
                const curr = snapshotPad(p);
                if (!lastSnapshot) { lastSnapshot = curr; return; }
                const change = diffPad(lastSnapshot, curr);
                if (change) {
                    const key = steps[idx].key;
                    if (key === 'dpadUp') {
                        result.dpadUp = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'up' } : change;
                    } else if (key === 'dpadDown') {
                        result.dpadDown = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'down' } : change;
                    } else if (key === 'dpadLeft') {
                        result.dpadLeft = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'left' } : change;
                    } else if (key === 'dpadRight') {
                        result.dpadRight = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'right' } : change;
                    } else if (key === 'pause') {
                        result.pause = change;
                    } else if (key === 'fire') {
                        result.fire = change;
                    }
                    idx++;
                    lastSnapshot = curr;
                    nextStep();
                }
            }, 60);

            // Kick it off
            nextStep();
        }
        try { window.startManualGamepadMapping = startManualGamepadMapping; } catch(_) {}

        function initPauseTabs() {
            const btnA = document.getElementById('tabAbilities');
            const btnO = document.getElementById('tabOptions');
            if (!btnA || !btnO) return;
            try { btnA.setAttribute('data-gp-focus','1'); btnO.setAttribute('data-gp-focus','1'); } catch(_) {}
            btnA.onclick = () => { switchPauseTab('abilities'); };
            btnO.onclick = () => { switchPauseTab('options'); };
            // Option buttons
            const sfxBtn = document.getElementById('optToggleSfx');
            const musicBtn = document.getElementById('optToggleMusic');
            const cosBtn = document.getElementById('optToggleCosmetic');
            const resetBtn = document.getElementById('optResetProgress');
            // Inject gamepad controls into options panel if not present
            const pauseOptions = document.getElementById('pauseOptions');
            if (pauseOptions && !document.getElementById('optToggleGamepad')) {
                const gpToggle = document.createElement('button');
                gpToggle.id = 'optToggleGamepad';
                gpToggle.textContent = 'Gamepad: ON';
                gpToggle.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:\'Courier New\', monospace;cursor:pointer;';
                gpToggle.setAttribute('data-gp-focus','1');
                const gpDead = document.createElement('div');
                gpDead.id = 'optGpDeadzoneRow';
                gpDead.style.cssText = 'display:flex;align-items:center;gap:8px;color:#ccc;font-family:Courier New,monospace;';
                const gpDeadLbl = document.createElement('span'); gpDeadLbl.id='optGpDeadzoneLabel'; gpDeadLbl.textContent = 'Deadzone: 25%';
                const gpDec = document.createElement('button'); gpDec.id='optGpDeadDec'; gpDec.textContent='-'; gpDec.style.cssText='padding:4px 8px;background:#222;border:2px solid #555;color:#0f0;cursor:pointer;';
                gpDec.setAttribute('data-gp-focus','1');
                const gpInc = document.createElement('button'); gpInc.id='optGpDeadInc'; gpInc.textContent='+'; gpInc.style.cssText='padding:4px 8px;background:#222;border:2px solid #555;color:#0f0;cursor:pointer;';
                gpInc.setAttribute('data-gp-focus','1');
                gpDead.appendChild(gpDeadLbl); gpDead.appendChild(gpDec); gpDead.appendChild(gpInc);
                // Manual mapping button
                const gpMapBtn = document.createElement('button');
                gpMapBtn.id = 'optGpManualMap';
                gpMapBtn.textContent = 'Controller Mapping';
                gpMapBtn.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #888;color:#fff;font-family:\'Courier New\', monospace;cursor:pointer;';
                gpMapBtn.setAttribute('data-gp-focus','1');
                const gpMapNote = document.createElement('div');
                gpMapNote.id = 'optGpMapNote';
                gpMapNote.style.cssText = 'color:#aaa;font:11px Courier New,monospace;margin-top:6px;';
                gpMapNote.textContent = 'Configure A/Start/D-Pad if auto-detect fails.';
                // Insert into panel
                const container = pauseOptions.querySelector('div');
                if (container) { container.appendChild(gpToggle); container.appendChild(gpDead); container.appendChild(gpMapBtn); container.appendChild(gpMapNote); }
            }
            if (sfxBtn) sfxBtn.onclick = () => { toggleSfx(); reflectOptionStates(); };
            if (musicBtn) musicBtn.onclick = () => { toggleMusic(); reflectOptionStates(); };
            if (cosBtn) cosBtn.onclick = () => {
                game.potatoMode = !game.potatoMode;
                applyPotatoFxClamps(game.potatoMode);
                saveAudioPreferences();
                reflectOptionStates();
                updatePotatoBadge();
            };
            if (resetBtn) resetBtn.onclick = () => {
                showConfirmOverlay('Reset progress and clear permanent abilities?', () => {
                    try { localStorage.removeItem('permanentAbilities'); } catch(_) {}
                    // Keep pause overlay visible state predictable across reloads
                    location.reload();
                }, () => { /* canceled */ });
            };
            // Gamepad handlers
            const gpBtn = document.getElementById('optToggleGamepad');
            const gpDec = document.getElementById('optGpDeadDec');
            const gpInc = document.getElementById('optGpDeadInc');
            if (gpBtn) gpBtn.onclick = () => { game.input.gamepadEnabled = !game.input.gamepadEnabled; saveInputPreferences(); reflectOptionStates(); };
            if (gpDec) gpDec.onclick = () => { game.input.gpDeadzone = Math.max(0.05, (game.input.gpDeadzone||0.25) - 0.05); saveInputPreferences(); reflectOptionStates(); };
            if (gpInc) gpInc.onclick = () => { game.input.gpDeadzone = Math.min(0.6, (game.input.gpDeadzone||0.25) + 0.05); saveInputPreferences(); reflectOptionStates(); };
            // Ensure mapping button exists even if gamepad toggle section was already inserted previously
            (function ensureGpMapButton(){
                const pauseOptions = document.getElementById('pauseOptions');
                if (!pauseOptions) return;
                let gpMapBtn = document.getElementById('optGpManualMap');
                if (!gpMapBtn) {
                    const container = pauseOptions.querySelector('div');
                    if (container) {
                        gpMapBtn = document.createElement('button');
                        gpMapBtn.id = 'optGpManualMap';
                        gpMapBtn.textContent = 'Controller Mapping';
                        gpMapBtn.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #888;color:#fff;font-family:\'Courier New\', monospace;cursor:pointer;';
                        const note = document.createElement('div');
                        note.id = 'optGpMapNote';
                        note.style.cssText = 'color:#aaa;font:11px Courier New,monospace;margin-top:6px;';
                        note.textContent = 'Configure A/Start/D-Pad if auto-detect fails.';
                        container.appendChild(gpMapBtn); container.appendChild(note);
                    }
                }
                gpMapBtn = document.getElementById('optGpManualMap');
                if (gpMapBtn) gpMapBtn.onclick = () => { try { startManualGamepadMapping(); } catch(e) { console.warn('Mapping overlay failed', e); } };
            })();
            reflectOptionStates();
        }

        function reflectOptionStates() {
            const sfxBtn = document.getElementById('optToggleSfx');
            const musicBtn = document.getElementById('optToggleMusic');
            const cosBtn = document.getElementById('optToggleCosmetic');
            if (sfxBtn) sfxBtn.textContent = 'SFX: ' + (game.sfxEnabled ? 'ON' : 'OFF');
            if (musicBtn) musicBtn.textContent = 'Music: ' + (game.musicEnabled ? 'ON' : 'OFF');
            if (cosBtn) cosBtn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF');
            const gpBtn = document.getElementById('optToggleGamepad');
            const gpLbl = document.getElementById('optGpDeadzoneLabel');
            if (gpBtn) gpBtn.textContent = 'Gamepad: ' + (game.input && game.input.gamepadEnabled ? 'ON' : 'OFF');
            if (gpLbl) {
                const pct = Math.round( ( (game.input && game.input.gpDeadzone) || 0.25) * 100 );
                gpLbl.textContent = 'Deadzone: ' + pct + '%';
            }
        }

        // === In-game confirmation modal (controller-friendly) ===
        function showConfirmOverlay(message, onYes, onCancel) {
            // Prevent duplicates
            const old = document.getElementById('confirmOverlay');
            if (old) { try { old.remove(); } catch(_) {} }
            const overlay = document.createElement('div');
            overlay.id = 'confirmOverlay';
            overlay.style.cssText = 'position:fixed;inset:0;z-index:25000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.82);font-family:Courier New,monospace;';
            const panel = document.createElement('div');
            panel.style.cssText = 'min-width:300px;max-width:520px;background:#141414;border:2px solid #666;border-radius:10px;padding:16px;display:flex;flex-direction:column;gap:12px;box-shadow:0 10px 24px rgba(0,0,0,0.6)';
            const text = document.createElement('div');
            text.textContent = message || 'Are you sure?';
            text.style.cssText = 'color:#eee;font-size:14px;line-height:1.4;';
            const actions = document.createElement('div');
            actions.style.cssText = 'display:flex;gap:10px;justify-content:flex-end;';
            const btnYes = document.createElement('button');
            btnYes.textContent = 'Yes';
            btnYes.style.cssText = 'padding:8px 14px;background:#222;border:2px solid #5a5;color:#bfb;color:#bfb;border-radius:6px;cursor:pointer;';
            btnYes.setAttribute('data-gp-focus','1');
            const btnNo = document.createElement('button');
            btnNo.textContent = 'Cancel';
            btnNo.style.cssText = 'padding:8px 14px;background:#222;border:2px solid #777;color:#ddd;border-radius:6px;cursor:pointer;';
            btnNo.setAttribute('data-gp-focus','1');
            actions.appendChild(btnNo); actions.appendChild(btnYes);
            panel.appendChild(text); panel.appendChild(actions);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);

            const close = () => { try { overlay.remove(); } catch(_) {} };
            btnYes.onclick = () => { try { onYes && onYes(); } catch(_) {} close(); };
            btnNo.onclick = () => { try { onCancel && onCancel(); } catch(_) {} close(); };
            // ESC to cancel
            const esc = (e)=>{ if (e.key==='Escape') { e.preventDefault(); btnNo.click(); window.removeEventListener('keydown', esc, true);} };
            window.addEventListener('keydown', esc, true);

            // Ensure gamepad nav targets the confirm overlay immediately
            try {
                game.uiNav = game.uiNav || {};
                game.uiNav.container = overlay;
                game.uiNav.items = [btnNo, btnYes];
                game.uiNav.index = 1; // default to Yes
                applyGpFocus();
            } catch(_) {}

            return overlay;
        }

        function switchPauseTab(which) {
            const tabA = document.getElementById('tabAbilities');
            const tabO = document.getElementById('tabOptions');
            const contentA = document.getElementById('pauseAbilities');
            const contentO = document.getElementById('pauseOptions');
            if (!tabA || !tabO || !contentA || !contentO) return;
            const activeStyles = { borderColor:'#00ff88', color:'#00ff88' };
            const idleStyles = { borderColor:'#444', color:'#aaa' };
            function applyStyles(btn, styles) { Object.assign(btn.style, styles); }
            if (which === 'abilities') {
                contentA.style.display = 'grid';
                contentO.style.display = 'none';
                applyStyles(tabA, activeStyles); applyStyles(tabO, idleStyles);
            } else {
                contentA.style.display = 'none';
                contentO.style.display = 'block';
                applyStyles(tabO, activeStyles); applyStyles(tabA, idleStyles);
            }
        }

        // === Gamepad UI Navigation (menus/overlays) ===
        (function ensureGpFocusStyle(){
            if (document.getElementById('gpFocusStyle')) return;
            const st = document.createElement('style');
            st.id = 'gpFocusStyle';
            st.textContent = `
                .gpFocus {
                    outline: 2px solid #00ff88 !important;
                    outline-offset: 2px !important;
                    box-shadow: 0 0 0 2px rgba(0,255,136,0.3) !important;
                    border-color: #00ff88 !important;
                }
            `;
            document.head.appendChild(st);
        })();

        function isOverlayVisible(el){
            if (!el) return false;
            const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
            return cs ? (cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0') : (el.style.display !== 'none');
        }

        function getActiveUiContainer(){
            // Preference order: mapping overlay, ability picker, pause overlay
            const mapOv = document.getElementById('gpMapOverlay');
            if (mapOv && document.body.contains(mapOv)) return mapOv;
            const confirmOv = document.getElementById('confirmOverlay');
            if (confirmOv && document.body.contains(confirmOv)) return confirmOv;
            const abilOv = document.getElementById('startAbilityOverlay');
            if (abilOv && document.body.contains(abilOv)) return abilOv;
            // Permanent ability choice overlay
            const permOv = document.getElementById('abilityChoiceOverlay');
            if (permOv && document.body.contains(permOv)) return permOv;
            // Rainbow ability picker overlay
            const rbOv = document.getElementById('rainbowAbilityOverlay');
            if (rbOv && document.body.contains(rbOv)) return rbOv;
            const pauseOv = document.getElementById('pauseOverlay');
            if (game.paused && pauseOv && isOverlayVisible(pauseOv)) return pauseOv;
            // Fallback: if a standalone Play Again button is visible (post-final), treat it as the active container
            const playAgainBtn = document.getElementById('postFinalPlayAgain');
            if (playAgainBtn && document.body.contains(playAgainBtn)) return playAgainBtn; // gatherFocusables will include container if button
            return null;
        }

        function gatherFocusables(container){
            if (!container) return [];
            const arr = [];
            // If the container itself is a button, include it
            if (container.tagName && container.tagName.toUpperCase() === 'BUTTON') {
                arr.push(container);
            }
            // Always include buttons
            container.querySelectorAll('button').forEach(b=>arr.push(b));
            // Include explicit gp-focus markers (used in grids)
            container.querySelectorAll('[data-gp-focus="1"]').forEach(el=>arr.push(el));
            // Include pause tab buttons explicitly if present
            const tabA = document.getElementById('tabAbilities');
            const tabO = document.getElementById('tabOptions');
            if (tabA && container.contains(tabA)) arr.unshift(tabA);
            if (tabO && container.contains(tabO)) arr.unshift(tabO);
            // Filter visible, unique
            const seen = new Set();
            const vis = arr.filter(el=>{
                if (!el || !container.contains(el)) return false;
                const key = el.tagName+"#"+(el.id||'')+"@"+(el.getAttribute('data-gp-focus')||'')+"@"+(el.textContent||'');
                if (seen.has(key)) return false; seen.add(key);
                const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
                if (cs && (cs.display==='none' || cs.visibility==='hidden')) return false;
                if (el.offsetParent === null && cs && cs.position !== 'fixed') return false;
                return true;
            });
            return vis;
        }

        function gpUiNavReset(){
            game.uiNav = game.uiNav || {};
            const cont = getActiveUiContainer();
            const items = gatherFocusables(cont);
            game.uiNav.container = cont;
            game.uiNav.items = items;
            game.uiNav.index = items.length ? 0 : -1;
            game.uiNav.lastDX = 0; game.uiNav.lastDY = 0; game.uiNav.lastMoveAt = 0; game.uiNav.lastFire = false; game.uiNav.lastFireAt = 0;
            applyGpFocus();
        }

        function applyGpFocus(){
            if (!game.uiNav) return;
            // Clear old
            document.querySelectorAll('.gpFocus').forEach(el=>el.classList.remove('gpFocus'));
            const items = game.uiNav.items || [];
            const i = game.uiNav.index|0;
            if (i >= 0 && i < items.length) {
                const el = items[i];
                el.classList.add('gpFocus');
                try { el.scrollIntoView({block:'nearest', inline:'nearest'}); } catch(_) {}
            }
        }

        function moveGpFocus(delta){
            if (!game.uiNav || !game.uiNav.items || !game.uiNav.items.length) return;
            const n = game.uiNav.items.length;
            game.uiNav.index = ( (game.uiNav.index|0) + delta + n ) % n;
            applyGpFocus();
        }

        function handleGamepadMenuNavigation(){
            const cont = getActiveUiContainer();
            if (!cont) return; // no active UI
            // Skip if typing
            const ae = document.activeElement;
            const tag = ae && ae.tagName ? String(ae.tagName).toUpperCase() : '';
            if (tag === 'INPUT' || tag === 'TEXTAREA' || (ae && ae.isContentEditable === true)) return;
            // Ensure state container matches
            if (!game.uiNav || game.uiNav.container !== cont) gpUiNavReset();
            // Refresh items in case menu changed
            const items = gatherFocusables(cont);
            game.uiNav.items = items;
            if (items.length && (game.uiNav.index == null || game.uiNav.index < 0 || game.uiNav.index >= items.length)) game.uiNav.index = 0;
            applyGpFocus();

            const inp = game.input;
            if (!inp || !inp.gamepadEnabled) return;
            // Digitalize nav from gpMove (supports dpad or stick)
            const dx = (inp.gpMove.x > 0.5) ? 1 : (inp.gpMove.x < -0.5) ? -1 : 0;
            const dy = (inp.gpMove.y > 0.5) ? 1 : (inp.gpMove.y < -0.5) ? -1 : 0; // down is +1 visually, but we use that as next
            const now = performance.now ? performance.now() : Date.now();
            const repeatDelay = 200; // ms between repeats

            // Special case: when pause overlay Abilities tab is active, use left stick to scroll the list
            // rather than moving focus vertically (so you can read long lists easily)
            const pauseMenuEl = document.getElementById('pauseMenu');
            const pauseAbilitiesEl = document.getElementById('pauseAbilities');
            const inPauseAbilities = !!(game.paused && pauseMenuEl && pauseAbilitiesEl && pauseAbilitiesEl.style.display !== 'none' && cont && (cont.id === 'pauseOverlay'));
            let consumedVertical = false;
            if (inPauseAbilities) {
                // Analog scroll for smoothness; fallback to digital step with repeat
                const ay = inp.gpMove.y || 0;
                if (Math.abs(ay) > 0.28) {
                    // Scale speed with magnitude; smaller on low FX devices
                    const base = 16;
                    const speed = base + Math.min(1, Math.abs(ay)) * 24;
                    pauseMenuEl.scrollTop += ay * speed;
                    consumedVertical = true;
                } else if (dy !== 0) {
                    const canRepeat = (game.uiNav.lastDY === dy) ? (now - (game.uiNav.lastMoveAt||0) > repeatDelay) : true;
                    if (canRepeat) {
                        pauseMenuEl.scrollTop += dy * 64; // discrete step per repeat
                        game.uiNav.lastMoveAt = now;
                    }
                    game.uiNav.lastDY = dy;
                    consumedVertical = true;
                } else {
                    game.uiNav.lastDY = 0;
                }
            }

            // Vertical has priority for typical lists
            if (!consumedVertical && dy !== 0) {
                const canRepeat = (game.uiNav.lastDY === dy) ? (now - (game.uiNav.lastMoveAt||0) > repeatDelay) : true;
                if (canRepeat) {
                    moveGpFocus(dy); // down -> +1, up -> -1
                    game.uiNav.lastMoveAt = now;
                }
                game.uiNav.lastDY = dy;
            } else if (!consumedVertical) {
                game.uiNav.lastDY = 0;
            }
            // Horizontal navigation for rows/grids
            if (dx !== 0 && dy === 0) {
                const canRepeat = (game.uiNav.lastDX === dx) ? (now - (game.uiNav.lastMoveAt||0) > repeatDelay) : true;
                if (canRepeat) {
                    moveGpFocus(dx);
                    game.uiNav.lastMoveAt = now;
                }
                game.uiNav.lastDX = dx;
            } else if (dx === 0) {
                game.uiNav.lastDX = 0;
            }

            // Confirm with A (gpFire) rising edge
            const fireNow = !!inp.gpFire;
            if (fireNow && !game.uiNav.lastFire) {
                const i = game.uiNav.index|0; const target = (items && items[i]) || null;
                if (target && typeof target.click === 'function') {
                    try { target.click(); } catch(_) {}
                }
                game.uiNav.lastFireAt = now;
            }
            game.uiNav.lastFire = fireNow;
        }

        // Position the ability tooltip centered over the canvas and fully within the viewport
        function positionAbilityTooltip() {
            const tip = document.getElementById('abilityTooltip');
            const canvasEl = document.getElementById('gameCanvas');
            if (!tip || !canvasEl) return;
            const rect = canvasEl.getBoundingClientRect();
            // Force fixed positioning so we can clamp to viewport
            tip.style.position = 'fixed';
            tip.style.left = (rect.left + rect.width / 2) + 'px';
            tip.style.transform = 'translateX(-50%)';
            tip.style.right = 'auto';
            tip.style.bottom = 'auto';
            // Measure height after content is applied
            const tipH = tip.offsetHeight || 0;
            const margin = 56; // desired gap from canvas bottom
            let top = rect.bottom - margin - tipH;
            // Clamp within viewport
            const minTop = 8;
            const maxTop = Math.max(minTop, (window.innerHeight || document.documentElement.clientHeight) - tipH - 8);
            if (top > maxTop) top = maxTop;
            if (top < minTop) top = minTop;
            // Also avoid overlapping too far above the canvas
            const canvasTopClamp = rect.top + 8;
            if (top < canvasTopClamp) top = canvasTopClamp;
            tip.style.top = Math.round(top) + 'px';
        }

        function showAbilityTooltip(abilityName) {
            const tooltip = document.getElementById('abilityTooltip');
            const nameEl = document.getElementById('tooltipName');
            const descEl = document.getElementById('tooltipDesc');
            const abilityData = ABILITIES[abilityName];
            
            if (!abilityData) return;
            
            nameEl.textContent = abilityName;
            descEl.textContent = abilityData.desc;
            
            // Apply tier coloring
            const tier = abilityData.tier || 1;
            switch (tier) {
                case 1:
                    nameEl.style.color = '#ffffff';
                    break;
                case 2:
                    nameEl.style.color = '#4488ff';
                    break;
                case 3:
                    nameEl.style.color = '#ff44ff';
                    break;
            }
            
            // If a prior hide timer exists, clear it so rapid acquisitions refresh visibility.
            if (tooltip._hideTimer) {
                clearTimeout(tooltip._hideTimer);
                tooltip._hideTimer = null;
            }
            tooltip.classList.add('show');
            // Defer positioning to ensure correct measured height
            try {
                requestAnimationFrame(() => {
                    positionAbilityTooltip();
                });
            } catch(_) { positionAbilityTooltip(); }
            // Auto-hide after 3.5s unless retriggered; extend slightly from previous 3s for readability.
            tooltip._hideTimer = setTimeout(() => {
                tooltip.classList.remove('show');
                tooltip._hideTimer = null;
            }, 3500);
        }

        // Maintain correct placement on viewport changes
        window.addEventListener('resize', () => { try { positionAbilityTooltip(); } catch(_) {} });

        // ================= Rizz Ability (Animated Pull) =================
        // Replaces previous teleport version: enemies are smoothly pulled into a ring.
        const RIZZ_INTERVAL_MS = 5000;       // Trigger cadence
        const RIZZ_PULL_DURATION = 900;      // ms for interpolation
        const RIZZ_RING_RADIUS = 90;         // Distance from player center
        const RIZZ_FEAR_FRAMES = 180;        // 3s fear after arrival

        function triggerRizzPull() {
            if (!game.player || !game.player.abilities || !game.player.abilities.includes('Rizz')) return;
            const now = performance.now();
            if (!game._lastRizz) game._lastRizz = now;
            // Pre-telegraph window before pull triggers: emit faint rings near player
            const until = RIZZ_INTERVAL_MS - (now - game._lastRizz);
            if (until > 0 && until < 700) {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!reduceRings) {
                    if (!game._lastRizzTele || now - game._lastRizzTele > (lowFx? 260 : 160)) {
                        game._lastRizzTele = now;
                        const t = 1 - (until / 700);
                        const rad = 40 + t * 60;
                        const col = '#C89AFF';
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x: game.player.x, y: game.player.y, color: col, radius: rad, life: 180 });
                        } else {
                            addParticle(game.player.x, game.player.y, col, 'ring');
                        }
                    }
                }
            }
            if (now - game._lastRizz < RIZZ_INTERVAL_MS) return; // not time yet
            if (!Array.isArray(game.enemies) || game.enemies.length === 0) return;
            game._lastRizz = now;
            const px = game.player.x, py = game.player.y;
            const angleStep = (Math.PI * 2) / Math.max(1, game.enemies.length);
            let idx = 0;
            // Center pulse (perf-aware)
            const lowFx = !!(game.perf && game.perf.lowFx);
            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
            if (!hideSparks) {
                const burst = lowFx ? 12 : 28;
                for (let p=0;p<burst;p++) addParticle(px + (Math.random()-0.5)*30, py + (Math.random()-0.5)*30, '#B066FF', 'spark');
            }
            addScreenShake(3);
            game.enemies.forEach(enemy => {
                if (!enemy || enemy.health <= 0) return;
                const ang = angleStep * idx + Math.random()*0.18;
                const tx = px + Math.cos(ang) * RIZZ_RING_RADIUS;
                const ty = py + Math.sin(ang) * RIZZ_RING_RADIUS;
                enemy._rizzPull = {
                    active: true,
                    startX: enemy.x,
                    startY: enemy.y,
                    targetX: tx,
                    targetY: ty,
                    startTime: now,
                    duration: RIZZ_PULL_DURATION,
                    appliedFear: false
                };
                if (!hideSparks) {
                    const prob = lowFx ? 0.45 : 0.9;
                    if (Math.random() < prob) addParticle(enemy.x, enemy.y - (enemy.size||20)/2, '#D080FF', 'spark');
                }
                idx++;
            });
        }

        function advanceRizzPull() {
            if (!game.enemies || game.enemies.length === 0) return;
            const now = performance.now();
            game.enemies.forEach(enemy => {
                const st = enemy && enemy._rizzPull;
                if (!st || !st.active) return;
                if (enemy.health <= 0) { st.active = false; return; }
                const tRaw = (now - st.startTime) / st.duration;
                const t = Math.min(1, Math.max(0, tRaw));
                const ease = 1 - Math.pow(1 - t, 3); // cubic out
                enemy.x = st.startX + (st.targetX - st.startX) * ease;
                enemy.y = st.startY + (st.targetY - st.startY) * ease;
                {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                    if (!hideSparks) {
                        let prob = (0.25 * (1 - t) + 0.05);
                        if (lowFx) prob *= 0.5;
                        if (Math.random() < prob) addParticle(enemy.x, enemy.y - (enemy.size||20)/2, '#C070FF', 'spark');
                    }
                }
                if (t >= 1) {
                    st.active = false;
                    if (!st.appliedFear) {
                        enemy.fearTime = Math.max(enemy.fearTime || 0, RIZZ_FEAR_FRAMES);
                        enemy.feared = true;
                        st.appliedFear = true;
                        {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!hideSparks) {
                                const prob = lowFx ? 0.45 : 0.85;
                                if (Math.random() < prob) addParticle(enemy.x, enemy.y, '#EEAAFF', 'spark');
                            }
                        }
                    }
                }
            });
            // Gentle separation to prevent enemies from stacking during pull
            // Small, cheap pass across actively pulled enemies
            const pulled = [];
            for (let i=0;i<game.enemies.length;i++) {
                const e = game.enemies[i];
                if (!e || !e._rizzPull || !e._rizzPull.active) continue;
                pulled.push(e);
            }
            const minBase = 20; // minimal spacing baseline
            for (let i=0;i<pulled.length;i++) {
                const a = pulled[i];
                let checks = 0;
                for (let j=i+1;j<pulled.length;j++) {
                    const b = pulled[j];
                    const dx = a.x - b.x; const dy = a.y - b.y;
                    const dist2 = dx*dx + dy*dy;
                    const minDist = Math.max(minBase, ((a.size||20) + (b.size||20)) * 0.45);
                    if (dist2 < minDist*minDist) {
                        const d = Math.sqrt(dist2) || 0.0001;
                        const push = (minDist - d) * 0.35; // gentle, avoids visible jitter
                        const nx = dx / d, ny = dy / d;
                        // distribute push equally
                        a.x += nx * (push*0.5);
                        a.y += ny * (push*0.5);
                        b.x -= nx * (push*0.5);
                        b.y -= ny * (push*0.5);
                        checks++;
                        if (checks > 10) break; // cap work per enemy
                    }
                }
            }
        }

        function updateRizz() {
            triggerRizzPull();
            advanceRizzPull();
        }

        // Safety: Rizz should never directly cause explosive kills. Add a lightweight guard.
        if (!game._rizzExplosionGuardInstalled) {
            game._rizzExplosionGuardInstalled = true;
            const originalExplode = explodeProjectile;
            window.explodeProjectile = function(proj, dmg){
                // If the only relevant source flag is a Rizz pull marker (no explosive / chain / nova / smartExplosive / meteor / timeBomb)
                // then skip explosion side effects.
                if (proj && proj._rizzPullSource && !proj.explosive && !proj.chainExplosion && !proj.novaBlast && !proj.smartExplosive && !proj.meteor && !proj.timeBomb) {
                    if (!game._rizzWarned) { console.warn('[Rizz] Prevented unintended explosion during Rizz pull.'); game._rizzWarned = true; }
                    return; // swallow
                }
                return originalExplode(proj, dmg);
            };
        }

        function update() {
            // Global frame counter (needed for timed mechanics like meteor detonation)
            if (typeof game.frame !== 'number') game.frame = 0;
            game.frame++;
            // Performance sampling (FPS + auto low FX)
            if (!game._lastFrameStamp) game._lastFrameStamp = performance.now();
            const nowPerf = performance.now();
            const dtFrame = nowPerf - game._lastFrameStamp; game._lastFrameStamp = nowPerf;
            if (game.perf) {
                const perf = game.perf;
                perf.frameTimes.push(dtFrame);
                if (perf.frameTimes.length > 90) perf.frameTimes.shift();
                if (nowPerf - perf.lastFpsSample >= 500) {
                    const avg = perf.frameTimes.reduce((a,b)=>a+b,0)/perf.frameTimes.length;
                    perf.fps = 1000/avg;
                    perf.lastFpsSample = nowPerf;
                    if (perf.autoLowFx) {
                        const before = !!perf.lowFx;
                        if (!perf.lowFx && perf.fps < 52) perf.lowFx = true;
                        else if (perf.lowFx && perf.fps > 58) perf.lowFx = false;
                        if (before !== !!perf.lowFx) updatePotatoBadge();
                    }
                    game.fxSuppression.particleSkip = perf.lowFx ? 0.55 : 0;
                }
            }
            updatePlayer();
            updateEnemies();
            // Rebuild enemy spatial hash (throttle if low enemy count)
            if (game.rebuildEnemyHash) {
                const enemyCnt = game.enemies ? game.enemies.length : 0;
                // Skip every other frame if very low enemy count to save a bit of CPU
                if (!(enemyCnt < 12 && (game.frame & 1))) {
                    game.rebuildEnemyHash();
                }
            }
            // Spawn/adjust orbitals BEFORE projectile update so they get a fresh position tick this frame
            if (typeof ensureOrbitals === 'function') ensureOrbitals();
            // NEW: SoA projectile update (dt approximation: assume 1 frame ~ 1 for legacy logic; adapt if real dt available)
            if (game.updateProjectilesSoA) game.updateProjectilesSoA(1);
            // Legacy call kept temporarily if other subsystems still depend on side effects
            // updateProjectiles(); // commented out after SoA migration
            if (game.projectilePool) game._lastProjActive = game.projectilePool.active();
            if (typeof updateShockwaves === 'function') updateShockwaves();
            if (typeof updateVortexFields === 'function') updateVortexFields();
            if (typeof updateEchoBloomFields === 'function') updateEchoBloomFields();
            if (typeof updateBloomRings === 'function') updateBloomRings();
            if (typeof updateFrostAura === 'function') updateFrostAura();
            // Failsafe: re-anchor any orbitals to current player position in case other logic modified them after projectile update
            if (game.projectilesSoA && game._projMeta && game.player) {
                const so = game.projectilesSoA; const xArr=so.x, yArr=so.y, alive=so.alive, MAX=so.MAX;
                for (let i=0;i<MAX;i++) if (alive[i]) {
                    const meta = game._projMeta.get(i); if (!meta || !meta._orbital) continue;
                    if (meta._orbitRadius != null && meta._orbitAngle != null) {
                        const dx = xArr[i] - game.player.x;
                        const dy = yArr[i] - game.player.y;
                        const dist = Math.hypot(dx, dy);
                        if (Math.abs(dist - meta._orbitRadius) > 8) {
                            xArr[i] = game.player.x + Math.cos(meta._orbitAngle) * meta._orbitRadius;
                            yArr[i] = game.player.y + Math.sin(meta._orbitAngle) * meta._orbitRadius;
                        }
                    }
                }
            }
            // Dimensional rifts update
            if (typeof updateDimensionalRifts === 'function') updateDimensionalRifts();
            // Elemental infusion timers & periodic conduit proc
            if (typeof updateInfusions === 'function') updateInfusions();
            if (typeof updateTimeWarpFields === 'function') updateTimeWarpFields();
            if (typeof updateBlackHoles === 'function') updateBlackHoles();
            if (typeof updateRizz === 'function') updateRizz();
            // Touch fire now routed through standard spacebar key handling; no separate per-frame polling needed.
            // Terrifying Aura room-based expiration (in addition to level)
            if (game.player && game.player.auraActive) {
                if (game.player.auraExpireRoom && game.room >= game.player.auraExpireRoom) {
                    game.player.auraActive = false;
                }
            }
            if (game.player && game.player.abilities && game.player.abilities.includes('Elemental Conduit')) {
                const nowC = Date.now();
                if (!game._lastConduitRoll) game._lastConduitRoll = nowC;
                const conduitInterval = 4500; // ms between new infusions
                if (nowC - game._lastConduitRoll >= conduitInterval) {
                    rollRandomInfusion();
                    game._lastConduitRoll = nowC;
                    // Small visual pulse at player
                    for (let p=0;p<14;p++) addParticle(game.player.x + (Math.random()-0.5)*40, game.player.y + (Math.random()-0.5)*40, getInfusionColorBlend() || '#FFFFFF', 'spark');
                }
            }
            updateParticles();
            updateDamageNumbers();
            if (typeof updateEkgTrailSegments === 'function') updateEkgTrailSegments();
            if (typeof updateTraps === 'function') updateTraps();
            if (typeof updatePits === 'function') updatePits();
            if (typeof updateNukes === 'function') updateNukes();
            if (typeof updatePoisonClouds === 'function') updatePoisonClouds();
            if (typeof updateFragmentSparks === 'function') updateFragmentSparks();
            if (typeof updateAcidPools === 'function') updateAcidPools();
            if (typeof updateTrucks === 'function') updateTrucks();
            if (typeof updateTruckFires === 'function') updateTruckFires();
            checkCollisions();
            checkRoomComplete();

            // Animate toenail crescents (rotate phase)
            if (game.projectilesSoA && game._projMeta) {
                const so = game.projectilesSoA; const alive=so.alive, MAX=so.MAX;
                for (let i=0;i<MAX;i++) if (alive[i]) {
                    const meta = game._projMeta.get(i); if (!meta) continue;
                    if (meta.toenail) meta._crescentPhase = (meta._crescentPhase||0) + 0.22 * (meta._crescentDir||1);
                    if (meta.popcornPuff) meta._puffSpin = (meta._puffSpin||0) + 0.18 * (meta._puffDir||1);
                    if (meta.isPopcornKernel) meta._kernelWobble = (meta._kernelWobble||0) + 0.4;
                }
            }

            // Pickup collection (bread health)
            if (game.pickups && game.pickups.length) {
                for (let i = game.pickups.length - 1; i >= 0; i--) {
                    const p = game.pickups[i];
                    if (p.collected) { game.pickups.splice(i,1); continue; }
                    let dx = p.x - game.player.x;
                    let dy = p.y - game.player.y;
                    // Bread magnetization (Carb it up!)  gently pull bread toward player
                    if (p.type === 'bread' && game.player.abilities.includes('Carb it up!')) {
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        // If outside auto-pick radius, move it closer
                        if (dist > 8) {
                            const speed = Math.min(6, 1.5 + dist * 0.05); // faster if farther, capped
                            const nx = p.x - (dx / dist) * speed;
                            const ny = p.y - (dy / dist) * speed;
                            p.x = nx;
                            p.y = ny;
                            // Recompute delta after movement for pickup radius test
                            dx = p.x - game.player.x;
                            dy = p.y - game.player.y;
                        }
                    }
                    if (dx*dx + dy*dy < 34*34) { // collection radius ~34px
                        // Only heal if not already full
                        if (game.player.health < game.player.maxHealth) {
                            const before = game.player.health;
                            game.player.health = Math.min(game.player.maxHealth, game.player.health + 25);
                            const healed = game.player.health - before;
                            if (healed > 0) {
                                addDamageNumber(healed, game.player.x, game.player.y - 28, { heal:true });
                                addParticle(game.player.x, game.player.y - 18, '#66FF88', 'heal');
                                updateUI();
                            }
                        }
                        p.collected = true;
                        game.pickups.splice(i,1);
                    }
                }
            }
            
            if (game.screenShake > 0) {
                game.screenShake--;
            }
            // Enforce hard boundary for all enemies after every frame of motion/effects
            clampEnemiesToBounds();
            // Lightweight rescue: if any enemy somehow drifts far outside bounds ( > logical + 200 ), teleport near center.
            if (game.enemies && game.enemies.length) {
                for (const en of game.enemies) {
                    if (!en) continue;
                    if (en.x < -200 || en.y < -200 || en.x > LOGICAL_W + 200 || en.y > LOGICAL_H + 200) {
                        en.x = LOGICAL_W/2 + (Math.random()*240 - 120);
                        en.y = LOGICAL_H/2 + (Math.random()*240 - 120);
                    }
                }
            }
            // Terrifying Aura: removed level-based expiry; room-based handled elsewhere.
            // Beartrap periodic deployment
            if (game.player && game.player.abilities && game.player.abilities.includes('Beartrap')) {
                const now = Date.now();
                if (!game._lastTrapDrop) game._lastTrapDrop = now;
                const interval = 5000; // 5 seconds
                if (now - game._lastTrapDrop >= interval) {
                    dropBeartrap();
                    game._lastTrapDrop = now;
                }
            }
            // Punji Pit periodic deployment
            if (game.player && game.player.abilities && game.player.abilities.includes('Punji Pit')) {
                const now2 = Date.now();
                if (!game._lastPitDrop) game._lastPitDrop = now2;
                const interval2 = 5000;
                if (now2 - game._lastPitDrop >= interval2) {
                    dropPunjiPit();
                    game._lastPitDrop = now2;
                }
            }
            // Oppemheimer periodic nuke strike spawner
            if (game.player && game.player.abilities && game.player.abilities.includes('Oppemheimer')) {
                const nowN = Date.now();
                if (!game._lastNuke) game._lastNuke = nowN;
                const nukeInterval = 10000; // 10 seconds
                if (nowN - game._lastNuke >= nukeInterval) {
                    if (!Array.isArray(game.nukes)) game.nukes = [];
                    // Cap active pending nukes to prevent stacking abuse
                    const pending = game.nukes.filter(n => !n.exploded);
                    if (pending.length < 3) {
                        const margin = 80;
                        const nx = margin + Math.random() * (LOGICAL_W - margin*2);
                        const ny = margin + Math.random() * (LOGICAL_H - margin*2);
                        const radius = Math.min(LOGICAL_W, LOGICAL_H) / 4; // quarter logical playfield radius
                        game.nukes.push({
                            x: nx,
                            y: ny,
                            radius,
                            spawnAt: nowN,
                            impactAt: nowN + 1500, // warning duration 1.5s
                            exploded: false,
                            flashTime: 0
                        });
                        game._lastNuke = nowN;
                    } else {
                        // Delay slightly if too many pending so it retries soon
                        game._lastNuke = nowN - (nukeInterval - 1500);
                    }
                }
            }

            // Tanks Alot: periodic runaway truck spawner
            if (game.player && game.player.abilities && game.player.abilities.includes('Tanks Alot')) {
                const nowT = Date.now();
                if (!game._lastTruckSpawn) game._lastTruckSpawn = nowT;
                const interval = 3000; // every 3 seconds as requested
                if (nowT - game._lastTruckSpawn >= interval) {
                    spawnTruck();
                    game._lastTruckSpawn = nowT;
                }
            }

            // Silent But Deadly poison trail spawning
            if (game.player && game.player.abilities && game.player.abilities.includes('Silent But Deadly')) {
                const nowP = Date.now();
                if (!game._lastPoisonCloud) game._lastPoisonCloud = nowP;
                const interval = 120; // ms between trail puffs
                if (nowP - game._lastPoisonCloud >= interval) {
                    if (!Array.isArray(game.poisonClouds)) game.poisonClouds = [];
                    game.poisonClouds.push({
                        x: game.player.x + (Math.random()*14-7),
                        y: game.player.y + (Math.random()*14-7),
                        radius: 34 + Math.random()*10,
                        life: 180, // frames (~3s at 60fps)
                        maxLife: 180,
                        tickTimer: 0
                    });
                    // Trim excessive lingering (cap to ~120 clouds = 6s trail worst case)
                    if (game.poisonClouds.length > 120) game.poisonClouds.splice(0, game.poisonClouds.length - 120);
                    game._lastPoisonCloud = nowP;
                }
            }

            // Duck Dynasty: periodic flock swoop (every ~2s) -- redesigned to spawn from top and arc downward in a swoop
            if (game.player && game.player.abilities && game.player.abilities.includes('Duck Dynasty')) {
                if (!Array.isArray(game.duckFlocks)) game.duckFlocks = [];
                const frameNow = game.frame||0;
                const intervalFrames = 120; // 2 seconds at 60fps
                if (frameNow >= (game.nextDuckFlockFrame||0)) {
                    game.nextDuckFlockFrame = frameNow + intervalFrames;
                    // Spawn a flock entering slightly above the top edge, choosing a horizontal band entry span
                    const flockSize = 6 + Math.floor(Math.random()*4); // 6-9 ducks
                    const baseDamage = calculateDamage();
                    const entryY = -40 - Math.random()*60; // start above screen
                    const exitY = canvas.height + 80; // allow overshoot before cleanup
                    const bandLeft = 80 + Math.random()*120;
                    const bandRight = canvas.width - (80 + Math.random()*120);
                    const duration = 120 + Math.floor(Math.random()*40); // frames of flight
                    const midCurveY = canvas.height * (0.30 + Math.random()*0.15); // apex of downward curve
                    const lateralDrift = (Math.random()<0.5?-1:1) * (60 + Math.random()*90);
                    for (let i=0;i<flockSize;i++) {
                        const laneFrac = (i / Math.max(1, flockSize-1));
                        const startX = bandLeft + (bandRight - bandLeft) * laneFrac + (Math.random()-0.5)*30;
                        const sway = (Math.random()*0.4 + 0.6); // amplitude multiplier
                        game.duckFlocks.push({
                            mode:'swoop',
                            t:0, tMax: duration,
                            startX, startY: entryY,
                            midX: startX + lateralDrift*0.4 + (Math.random()-0.5)*40,
                            midY: midCurveY + (Math.random()-0.5)*30,
                            endX: startX + lateralDrift + (Math.random()-0.5)*60,
                            endY: exitY,
                            progress:0, // compatibility
                            speed:1,
                            damage: Math.max(2, Math.floor(baseDamage * 0.60)),
                            size: 18 + Math.random()*6,
                            hitIds: new Set(),
                            color: (Math.random()<0.5?'#FFD74A':'#FFECA0'),
                            wingPhase: Math.random()*Math.PI*2,
                            swayAmp: sway * (20 + Math.random()*14)
                        });
                    }
                    // Telegraph: falling feathers / sparks near top (perf-aware)
                    {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!hideSparks) {
                            const count = lowFx ? 8 : 18;
                            for (let p=0;p<count;p++) addParticle((bandLeft+bandRight)/2 + (Math.random()-0.5)*260, entryY + 20 + Math.random()*40, '#FFF2AA','spark');
                        }
                    }
                }
                // Update active ducks
                for (let i=game.duckFlocks.length-1;i>=0;i--) {
                    const d = game.duckFlocks[i];
                    if (d.mode === 'swoop') {
                        d.t++;
                        const u = d.t / d.tMax; // 0->1
                        if (u >= 1) { game.duckFlocks.splice(i,1); continue; }
                        // Ease curve progress (accelerate in, glide out)
                        const e = u<0.5 ? 2*u*u : -1 + (4 - 2*u)*u; // smooth-ish ease
                        // Quadratic Bezier for arc (start->mid->end)
                        const x1 = d.startX, y1 = d.startY;
                        const x2 = d.midX,   y2 = d.midY;
                        const x3 = d.endX,   y3 = d.endY;
                        d.x = (1-e)*(1-e)*x1 + 2*(1-e)*e*x2 + e*e*x3;
                        d.y = (1-e)*(1-e)*y1 + 2*(1-e)*e*y2 + e*e*y3;
                        // Add lateral sinusoidal sway for individual variation
                        d.wingPhase += 0.28 + Math.random()*0.02;
                        d.x += Math.sin(d.wingPhase*0.5 + d.startX*0.01) * (d.swayAmp*0.15);
                    } else {
                        // legacy arc mode (if any old objects remain)
                        d.progress += d.speed;
                        if (d.progress >= 1) { game.duckFlocks.splice(i,1); continue; }
                    }
                    // Collision with enemies (single hit per enemy per duck)
                    if (game.enemies && game.enemies.length) {
                        for (const en of game.enemies) {
                            if (en._dead) continue;
                            const dx = en.x - d.x; const dy = en.y - d.y;
                            const wingSpan = d.size * 1.6; // larger because wings out
                            const hitR = (wingSpan*0.5 + (en.size||20)*0.5);
                            if (dx*dx + dy*dy <= hitR*hitR && !d.hitIds.has(en._guid || en._hitMarker)) {
                                // assign a temp marker id if none
                                if (!en._guid) en._guid = 'e'+Math.random().toString(36).slice(2,9);
                                d.hitIds.add(en._guid);
                                en.health -= d.damage;
                                addDamageNumber(d.damage, en.x, en.y - en.size/2, { type:'wind'});
                                addParticle(en.x, en.y, '#FFECAA','impact');
                                if (en.health <= 0) en._dead = true;
                            }
                        }
                    }
                    // Occasional feather motes (perf-aware)
                    {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!hideSparks) {
                            const prob = lowFx ? 0.12 : 0.25;
                            if (Math.random()<prob) addParticle(d.x + (Math.random()-0.5)*10, d.y + (Math.random()-0.5)*10, '#FFF5CC','spark');
                        }
                    }
                }
                // Light flock separation to reduce overstacking among visible ducks
                if (game.duckFlocks.length > 1) {
                    const ducks = game.duckFlocks;
                    const minR = 18; // minimum comfortable separation
                    for (let i=0;i<ducks.length;i++) {
                        const a = ducks[i]; if (!a || a._gone) continue;
                        let pushes = 0;
                        for (let j=i+1;j<ducks.length;j++) {
                            const b = ducks[j]; if (!b || b._gone) continue;
                            const dx = a.x - b.x; const dy = a.y - b.y; const d2 = dx*dx + dy*dy;
                            const want = (Math.max(minR, (a.size||16)*0.9) + Math.max(minR, (b.size||16)*0.9)) * 0.5;
                            if (d2 < want*want) {
                                const d = Math.sqrt(d2) || 0.0001;
                                const nx = dx/d, ny = dy/d;
                                const push = (want - d) * 0.35; // gentle
                                a.x += nx * (push*0.5);
                                a.y += ny * (push*0.5);
                                b.x -= nx * (push*0.5);
                                b.y -= ny * (push*0.5);
                                pushes++;
                                if (pushes > 8) break;
                            }
                        }
                    }
                }
                // Cap flocks stored to avoid runaway if lag (should be small anyway)
                if (game.duckFlocks.length > 120) game.duckFlocks.splice(0, game.duckFlocks.length - 120);
            }

            // Process scheduled delayed combustion rings (Spontaneous Combustion synergies)
            if (game._pendingCombustionRings && game._pendingCombustionRings.length) {
                for (let i = game._pendingCombustionRings.length - 1; i >= 0; i--) {
                    const ring = game._pendingCombustionRings[i];
                    if (!ring) { game._pendingCombustionRings.splice(i,1); continue; }
                    if ((game.frame||0) >= ring.spawnFrame) {
                        const baseDmg = calculateDamage();
                        const count = ring.count || 10;
                        const speed = ring.speed || 6;
                        const dmgFrac = ring.dmgFrac != null ? ring.dmgFrac : 0.4;
                        for (let s=0; s<count; s++) {
                            const ang = (s / count) * Math.PI * 2; // even spread
                            game.spawnProjectile({
                                x: ring.x,
                                y: ring.y,
                                vx: Math.cos(ang) * speed,
                                vy: Math.sin(ang) * speed,
                                life: 64,
                                size: 5,
                                enemy: false,
                                baseDamage: Math.max(1, Math.floor(baseDmg * dmgFrac)),
                                damageType: 'fire',
                                burningShard: true,
                                piercing: false
                            });
                        }
                        // Visual feedback: modest particle ring & scaled screen shake
                        for (let p=0; p<Math.min(24, count*1.2); p++) {
                            const pang = Math.random()*Math.PI*2;
                            const pr = Math.random()*26;
                            addParticle(ring.x + Math.cos(pang)*pr, ring.y + Math.sin(pang)*pr, (Math.random()<0.35?'#FFDD66':'#FF7722'), 'explosion');
                        }
                        addScreenShake( (ring.tier || 1) * 2 );
                        game._pendingCombustionRings.splice(i,1);
                    }
                }
                // Prevent unbounded growth if something failed to spawn far in the future (> 10s worth of frames)
                if (game._pendingCombustionRings.length > 100) {
                    const nowF = game.frame||0;
                    game._pendingCombustionRings = game._pendingCombustionRings.filter(r => r && r.spawnFrame > nowF - 600);
                }
            }
        }

    // === Tanks Alot (runaway truck + lingering fire) ===
        // Shared visual size for truck draw/collision so hitbox matches sprite size
        window.TRUCK_TARGET_H = window.TRUCK_TARGET_H || 110; // enlarge further per feedback
    // Fire field hitbox scale vs. base radius to align with rendered sprite footprint
    window.TRUCK_FIRE_HIT_SCALE = window.TRUCK_FIRE_HIT_SCALE || 1.75;

        function getTruckDrawSize(frameIndex) {
            const spr = window._truckSprite || {};
            const driveFrames = spr.frames && spr.frames.drive;
            const img = spr.image;
            const idx = Math.max(0, Math.min(frameIndex|0, driveFrames && driveFrames.length ? driveFrames.length-1 : 0));
            if (img && img.complete && !img._broken && img.naturalWidth && driveFrames && driveFrames.length) {
                const src = driveFrames[idx];
                const scale = (window.TRUCK_TARGET_H || 110) / src.h;
                return { w: src.w * scale, h: src.h * scale };
            }
            // Fallback aspect ratio when frames not ready
            const h = (window.TRUCK_TARGET_H || 110);
            return { w: h * 2.2, h };
        }
        function spawnTruck() {
            if (!Array.isArray(game.trucks)) game.trucks = [];
            const h = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || canvas.height;
            const w = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
            // Spawn from the left edge at a random vertical location (with a small top/bottom margin)
            const marginY = 40;
            const y = marginY + Math.random() * Math.max(1, (h - marginY*2));
            const speed = 7.2 + Math.random()*1.6;
            const dmg = Math.max(16, Math.floor(calculateDamage() * 1.4));
            const size = getTruckDrawSize(0);
            const truck = {
                x: -Math.max(120, size.w), y,
                vx: speed, width: size.w, height: size.h,
                state: 'driving', // 'driving' | 'impactSeq' | 'done'
                life: 0,
                damage: dmg,
                hitboxScale: 1.0,
                frame: 0, // 0-based index into drive frames
                _impactStep: 0, // 0=not started, 1=frame2, 2=frame3
                _impactTimer: 0
            };
            game.trucks.push(truck);
        }

        function getDumpsterAabb(wall) {
            // Use the same visual rect as render for precise collision
            if (typeof window.getDumpsterSpriteRect === 'function') {
                const rect = window.getDumpsterSpriteRect(wall);
                return rect ? { x: rect.x, y: rect.y, w: rect.w, h: rect.h } : { x: wall.x, y: wall.y, w: (wall.width||TILE_SIZE), h: (wall.height||TILE_SIZE) };
            }
            return { x: wall.x, y: wall.y, w: (wall.width||TILE_SIZE), h: (wall.height||TILE_SIZE) };
        }

        function updateTrucks() {
            if (!Array.isArray(game.trucks) || !game.trucks.length) return;
            const w = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
            for (let i = game.trucks.length - 1; i >= 0; i--) {
                const t = game.trucks[i];
                if (!t) { game.trucks.splice(i,1); continue; }
                // Ensure width/height reflect current frame for accurate collisions
                const curSize = getTruckDrawSize(t.frame||0);
                t.width = curSize.w; t.height = curSize.h;
                if (t.state === 'driving') {
                    t.x += t.vx;
                    t.life++;
                    // Enemy contact damage while driving
                    if (Array.isArray(game.enemies) && game.enemies.length) {
                        const ax = t.x - (t.width)/2, ay = t.y - (t.height)/2, aw = t.width, ah = t.height;
                        for (const e of game.enemies) {
                            if (!e || e.health <= 0) continue;
                            const ex = e.x - (e.size||10)/2, ey = e.y - (e.size||10)/2, es = (e.size||10);
                            if (ax < ex + es && ax + aw > ex && ay < ey + es && ay + ah > ey) {
                                const now = performance.now ? performance.now() : Date.now();
                                if (!e._lastTruckHitAt || now - e._lastTruckHitAt > 200) {
                                    e._lastTruckHitAt = now;
                                    const hitDmg = Math.max(6, Math.floor(t.damage * 0.6));
                                    e.health -= hitDmg;
                                    addDamageNumber && addDamageNumber(hitDmg, e.x, e.y - (e.size||10)/2, { type: 'impact' });
                                    // Knockback away from truck center
                                    const dx = Math.max(-1e-3, e.x - t.x), dy = Math.max(-1e-3, e.y - t.y);
                                    const len = Math.max(0.001, Math.hypot(dx, dy));
                                    const kx = dx / len, ky = dy / len;
                                    if (typeof applySmoothKnockback === 'function') applySmoothKnockback(e, kx*2.0, ky*2.0, 12);
                                    else if (typeof applyKnockback === 'function') applyKnockback(e, kx, ky, 8);
                                    else { e.vx = (e.vx||0) + kx*2.2; e.vy = (e.vy||0) + ky*2.2; }
                                }
                            }
                        }
                    }
                    // Check dumpster collisions only
                    if (Array.isArray(game.walls) && game.walls.length) {
                        for (const wall of game.walls) {
                            if (wall.type !== 'dumpster') continue;
                            const a = { x: t.x - (t.width)/2, y: t.y - (t.height)/2, w: t.width, h: t.height };
                            const b = getDumpsterAabb(wall);
                            if (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y) {
                                // Start impact sequence: show frame 2 then 3, then explode
                                t.state = 'impactSeq';
                                t._impactStep = 1; // show frame index 1
                                t._impactTimer = 0;
                                t.vx = 0; // stop moving while impacting
                                wall.flashTimer = 10; // brief dumpster flash
                                break;
                            }
                        }
                    }
                    if (t.x - t.width > w + 80) { t.state = 'done'; }
                } else if (t.state === 'impactSeq') {
                    t._impactTimer++;
                    // Also apply contact damage during impact frames
                    if (Array.isArray(game.enemies) && game.enemies.length) {
                        const ax = t.x - (t.width)/2, ay = t.y - (t.height)/2, aw = t.width, ah = t.height;
                        for (const e of game.enemies) {
                            if (!e || e.health <= 0) continue;
                            const ex = e.x - (e.size||10)/2, ey = e.y - (e.size||10)/2, es = (e.size||10);
                            if (ax < ex + es && ax + aw > ex && ay < ey + es && ay + ah > ey) {
                                const now = performance.now ? performance.now() : Date.now();
                                if (!e._lastTruckHitAt || now - e._lastTruckHitAt > 220) {
                                    e._lastTruckHitAt = now;
                                    const hitDmg = Math.max(6, Math.floor(t.damage * 0.5));
                                    e.health -= hitDmg;
                                    addDamageNumber && addDamageNumber(hitDmg, e.x, e.y - (e.size||10)/2, { type: 'impact' });
                                    const dx = Math.max(-1e-3, e.x - t.x), dy = Math.max(-1e-3, e.y - t.y);
                                    const len = Math.max(0.001, Math.hypot(dx, dy));
                                    const kx = dx / len, ky = dy / len;
                                    if (typeof applySmoothKnockback === 'function') applySmoothKnockback(e, kx*2.2, ky*2.2, 12);
                                    else if (typeof applyKnockback === 'function') applyKnockback(e, kx, ky, 9);
                                    else { e.vx = (e.vx||0) + kx*2.4; e.vy = (e.vy||0) + ky*2.4; }
                                }
                            }
                        }
                    }
                    // Sequence: ~8 frames on frame 2, then ~8 frames on frame 3, then explode
                    if (t._impactStep === 1) {
                        t.frame = 1; // second frame
                        if (t._impactTimer >= 8) { t._impactStep = 2; t._impactTimer = 0; }
                    } else if (t._impactStep === 2) {
                        t.frame = 2; // third frame
                        if (t._impactTimer >= 8) {
                            // Detonate now
                            const cx = t.x; const cy = t.y;
                            // Larger explosion that pushes enemies farther and affects a wider area
                            const boom = { x: cx, y: cy, size: 42, knockback: true, damageType: 'fire', explosionRadius: 180, knockbackRadius: 260, knockbackScale: 0.42 };
                            explodeProjectile(boom, Math.floor(t.damage * 1.4));
                            addScreenShake(8);
                            spawnTruckFire(cx, cy);
                            t.state = 'done';
                        }
                    }
                }
                if (t.state === 'done') { game.trucks.splice(i,1); }
            }
        }

        function spawnTruckFire(x, y) {
            if (!Array.isArray(game.truckFires)) game.truckFires = [];
            // Lingering fire lasts 5s, ticks AoE damage periodically
            const field = { x, y, radius: 120, created: Date.now(), duration: 5000, tickEvery: 600, lastTick: 0, frame: 0 };
            game.truckFires.push(field);
        }

        function updateTruckFires() {
            if (!Array.isArray(game.truckFires) || !game.truckFires.length) return;
            const now = Date.now();
            for (let i = game.truckFires.length - 1; i >= 0; i--) {
                const f = game.truckFires[i];
                const age = now - f.created;
                if (age >= f.duration) { game.truckFires.splice(i,1); continue; }
                // Tick damage
                if (now - (f.lastTick||0) >= f.tickEvery) {
                    f.lastTick = now;
                    const base = calculateDamage();
                    const tick = Math.max(4, Math.floor(base * 0.35));
                    const effR = f.radius * (window.TRUCK_FIRE_HIT_SCALE || 1.35);
                    const r2 = effR * effR;
                    for (const e of game.enemies) {
                        if (!e || e.health <= 0) continue;
                        const dx = e.x - f.x, dy = e.y - f.y;
                        if (dx*dx + dy*dy <= r2) {
                            e.health -= tick;
                            e.burning = true;
                            e.burnTime = Math.max(e.burnTime||0, 120);
                            addDamageNumber(tick, e.x, e.y - e.size/2, { type: 'fire' });
                            if (!(game.perf && game.perf.lowFx) && Math.random() < 0.35) addParticle(e.x, e.y, '#FFAA66','impact');
                        }
                    }
                }
            }
        }

        function clampEnemiesToBounds() {
            if (!game.enemies) return;
            const w = canvas.width;
            const h = canvas.height;
            game.enemies.forEach(enemy => {
                // Determine basic facing for sprite use (horizontal priority when significant, else vertical)
                if (!enemy.facing) enemy.facing = 'down';
                const vx = enemy.vx || (game.player.x - enemy.x); // fallback to vector toward player if vx undefined
                const vy = enemy.vy || (game.player.y - enemy.y);
                if (Math.abs(vx) > Math.abs(vy)) {
                    enemy.facing = vx < 0 ? 'left' : 'right';
                } else {
                    enemy.facing = vy < 0 ? 'up' : 'down';
                }
                if (!enemy) return;
                const r = enemy.size || 16;
                // Hard OOB kill: if an enemy somehow gets fully beyond a tolerance outside the canvas, kill it.
                // Tolerance allows minor float drift without triggering death.
                const tol = r * 1.2; // 120% of radius outside view before death
                if (enemy.x < -tol || enemy.x > w + tol || enemy.y < -tol || enemy.y > h + tol) {
                    enemy.health = 0; // will be removed during enemy cleanup
                    return;
                }
                const minX = r;
                const maxX = w - r;
                const minY = r;
                const maxY = h - r;
                let clamped = false;
                if (enemy.x < minX) { enemy.x = minX; if (enemy.kbVX < 0) enemy.kbVX = 0; clamped = true; }
                if (enemy.x > maxX) { enemy.x = maxX; if (enemy.kbVX > 0) enemy.kbVX = 0; clamped = true; }
                if (enemy.y < minY) { enemy.y = minY; if (enemy.kbVY < 0) enemy.kbVY = 0; clamped = true; }
                if (enemy.y > maxY) { enemy.y = maxY; if (enemy.kbVY > 0) enemy.kbVY = 0; clamped = true; }
                // If knockback velocity would push them further outside next frame, damp further
                if (clamped && (enemy.kbVX || enemy.kbVY)) {
                    enemy.kbVX *= 0.4; enemy.kbVY *= 0.4;
                }
            });
        }

        function updatePoisonClouds() {
            if (!Array.isArray(game.poisonClouds) || game.poisonClouds.length === 0) return;
            for (let i = game.poisonClouds.length - 1; i >= 0; i--) {
                const c = game.poisonClouds[i];
                c.life--;
                c.tickTimer++;
                // Every 30 frames (0.5s) apply damage + poison to enemies inside
                if (c.tickTimer >= 30) {
                    c.tickTimer = 0;
                    const r2 = c.radius * c.radius;
                    game.enemies.forEach(e => {
                        const dx = e.x - c.x; const dy = e.y - c.y;
                        if (dx*dx + dy*dy <= r2) {
                            // Apply light damage & poison status
                            const dmg = Math.max(3, Math.round(c.life / c.maxLife * 6)); // scales down as cloud fades
                            e.health -= dmg;
                            addDamageNumber(dmg, e.x, e.y - e.size/2 - 4, { type:'toxic' });
                            // Poison effect augment
                            e.poisoned = true;
                            e.poisonTime = Math.max(e.poisonTime || 0, 120); // 2s poison refresh
                            addParticle(e.x + (Math.random()*10-5), e.y + (Math.random()*10-5), '#55FF88', 'damage');
                        }
                    });
                }
                if (c.life <= 0) {
                    game.poisonClouds.splice(i,1);
                }
            }
        }

        // Fragment Wake spark updater
        function updateFragmentSparks() {
            if (!Array.isArray(game.fragmentSparks) || game.fragmentSparks.length === 0) return;
            for (let i = game.fragmentSparks.length - 1; i >= 0; i--) {
                const s = game.fragmentSparks[i];
                s.ttl--;
                s.pulse += 0.32 + Math.random()*0.05;
                // Light jitter for lively flicker
                s.x += (Math.random()-0.5)*0.6;
                s.y += (Math.random()-0.5)*0.6;
                // Damage tick (every 12 frames baseline)
                s.dpsTick = (s.dpsTick||0)+1;
                if (s.dpsTick >= 12) {
                    s.dpsTick = 0;
                    if (game.enemies && game.enemies.length) {
                        for (const enemy of game.enemies) {
                            const dx = enemy.x - s.x; const dy = enemy.y - s.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist <= s.r + enemy.size*0.5) {
                                const key = enemy._id || (enemy._id = Symbol());
                                if (!s.hitMap.has(key)) {
                                    s.hitMap.add(key);
                                    const dmg = s.damage;
                                    enemy.health -= dmg;
                                    addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type:'fire' });
                                    if (Math.random()<0.25) addParticle(enemy.x, enemy.y, '#FFC977','spark');
                                }
                            }
                        }
                    }
                }
                if (s.ttl <= 0) {
                    game.fragmentSparks.splice(i,1);
                }
            }
        }

        // EKG Trail segment updater: damages enemies that overlap fading trail line segments
        function updateEkgTrailSegments() {
            const segs = game.ekgTrailSegments;
            if (!Array.isArray(segs) || segs.length === 0) return;
            const lowFx = !!(game.perf && game.perf.lowFx);
            const ctxLocal = ctx; // render with main ctx
            for (let i = segs.length - 1; i >= 0; i--) {
                const s = segs[i];
                s.ttl--;
                // Periodic damage tick every 10 frames
                s._tick = (s._tick||0) + 1;
                if (s._tick >= 10) {
                    s._tick = 0;
                    if (game.enemies && game.enemies.length) {
                        const x1 = s.x1, y1 = s.y1, x2 = s.x2, y2 = s.y2;
                        const vx = x2 - x1, vy = y2 - y1;
                        const len2 = vx*vx + vy*vy || 0.0001;
                        const maxR = Math.max(6, s.w * 0.8);
                        for (const e of game.enemies) {
                            if (!e || e.health <= 0) continue;
                            // project enemy point onto segment and compute distance to line segment
                            const wx = e.x - x1, wy = e.y - y1;
                            let t = (wx*vx + wy*vy) / len2; if (t < 0) t = 0; else if (t > 1) t = 1;
                            const cx = x1 + t*vx, cy = y1 + t*vy;
                            const dist = Math.hypot(e.x - cx, e.y - cy);
                            const reach = maxR + (e.size||20)*0.45;
                            if (dist <= reach) {
                                const key = e._id || (e._id = Symbol());
                                if (!s.hitMap.has(key)) {
                                    s.hitMap.set(key, 1);
                                    const dmg = Math.max(1, s.dps||2);
                                    e.health -= dmg;
                                    addDamageNumber(dmg, e.x, e.y - (e.size||20)/2, { color:'#99ffcc' });
                                    if (!lowFx && Math.random() < 0.20) addParticle(e.x, e.y, '#99FFCC', 'spark');
                                }
                            }
                        }
                    }
                }
                // Render the fading green line segment
                if (ctxLocal && s.maxTtl) {
                    const f = Math.max(0, Math.min(1, s.ttl / s.maxTtl));
                    if (f > 0) {
                        ctxLocal.save();
                        ctxLocal.globalCompositeOperation = 'lighter';
                        ctxLocal.strokeStyle = `rgba(120,255,180,${(0.08 + 0.28*f).toFixed(3)})`;
                        ctxLocal.lineWidth = Math.max(1, s.w * (0.6 + 0.4*f));
                        ctxLocal.lineCap = 'round';
                        ctxLocal.beginPath();
                        ctxLocal.moveTo(s.x1, s.y1);
                        ctxLocal.lineTo(s.x2, s.y2);
                        ctxLocal.stroke();
                        ctxLocal.restore();
                    }
                }
                if (s.ttl <= 0) { segs.splice(i,1); }
            }
        }

        // Periodic nuke strike update handler (Oppemheimer ability)
        function updateNukes() {
            if (!Array.isArray(game.nukes) || game.nukes.length === 0) return;
            const now = Date.now();
            for (let i = game.nukes.length - 1; i >= 0; i--) {
                const n = game.nukes[i];
                if (!n) { game.nukes.splice(i,1); continue; }
                // Trigger explosion when warning time elapses
                if (!n.exploded && now >= n.impactAt) {
                    n.exploded = true;
                    n.flashTime = 34; // frames of flash
                    n._flashMax = n.flashTime;
                    // SFX: big retro explosion when the nuke detonates
                    try { if (typeof playNukeExplosionSfx === 'function') playNukeExplosionSfx(); } catch(_) {}
                    addScreenShake(40);
                    // Damage enemies in radius with falloff (40% edge -> 100% center)
                    const baseDamage = calculateDamage() * 6 + 80;
                    const r = n.radius;
                    game.enemies.forEach(e => {
                        const dx = e.x - n.x; const dy = e.y - n.y; const dist = Math.hypot(dx,dy);
                        if (dist <= r) {
                            const falloff = 1 - 0.6 * (dist / r); // dist=0 =>1, dist=r => 0.4
                            const dmg = Math.round(baseDamage * falloff);
                            e.health -= dmg;
                            addDamageNumber(dmg, e.x, e.y - e.size/2 - 6, { color:'#ffdd55', big:true });
                            // Splash particles per enemy hit
                            for (let p=0;p<8;p++) {
                                const ang = Math.random()*Math.PI*2;
                                const spd = 2 + Math.random()*4;
                                addParticle(e.x, e.y, '#ffbb33', 'explosion');
                            }
                        }
                    });
                    // Central explosion particle bloom
                    for (let p=0;p<150;p++) {
                        const ang = Math.random()*Math.PI*2;
                        const dist = Math.random()*n.radius;
                        const px = n.x + Math.cos(ang)*dist*0.4; // concentrate a bit
                        const py = n.y + Math.sin(ang)*dist*0.4;
                        addParticle(px, py, (Math.random()<0.15?'#ffffff':(Math.random()<0.5?'#ffcc55':'#ff8822')), 'explosion');
                    }
                }
                // Decay flash
                if (n.exploded) {
                    n.flashTime -= 1;
                    if (n.flashTime <= 0) {
                        // Remove once flash over
                        game.nukes.splice(i,1);
                    }
                }
            }
        }

        function updateDamageNumbers() {
            if (!game.damageNumbers) return;
            for (let i = game.damageNumbers.length - 1; i >= 0; i--) {
                const dn = game.damageNumbers[i];
                dn.x += dn.vx;
                dn.y += dn.vy;
                dn.vy += 0.04; // slight gravity to curve path
                dn.life--;
                dn.scale *= 0.991; // gentle shrink
                if (dn.life <= 0) game.damageNumbers.splice(i,1);
            }
        }

        function updatePlayer() {
            let dx = 0, dy = 0;
            let speed = game.player.speed;
            
            // Apply speed multipliers
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.speedMultiplier) {
                    speed *= abilityData.effect.speedMultiplier;
                }
            });
            
            if (game.keys['w']) { dy -= speed; game.player.lastDirection = { x: 0, y: -1 }; game.player.facing = 'up'; }
            if (game.keys['s']) { dy += speed; game.player.lastDirection = { x: 0, y: 1 }; game.player.facing = 'down'; }
            if (game.keys['a']) { dx -= speed; game.player.lastDirection = { x: -1, y: 0 }; game.player.facing = 'left'; }
            if (game.keys['d']) { dx += speed; game.player.lastDirection = { x: 1, y: 0 }; game.player.facing = 'right'; }

            // Gamepad analog move/aim when present; keyboard has priority if any WASD key is down
            const anyKeyboardMove = !!(game.keys['w'] || game.keys['a'] || game.keys['s'] || game.keys['d']);
            if (game.input && game.input.gamepadEnabled && !anyKeyboardMove) {
                const mv = game.input.gpMove || {x:0,y:0};
                const av = game.input.gpAim || {x:0,y:0};
                const mvLen = Math.hypot(mv.x, mv.y);
                const avLen = Math.hypot(av.x, av.y);
                if (mvLen > 0) {
                    dx = mv.x * speed;
                    dy = mv.y * speed;
                }
                // Aim stick sets lastDirection independent of movement
                if (avLen > 0) {
                    game.player.lastDirection = { x: av.x / avLen, y: av.y / avLen };
                    // Facing from aim
                    const ax = game.player.lastDirection.x, ay = game.player.lastDirection.y;
                    if (Math.abs(ax) > Math.abs(ay)) game.player.facing = ax < 0 ? 'left' : 'right'; else game.player.facing = ay < 0 ? 'up' : 'down';
                } else if (mvLen > 0) {
                    // If no aim input, derive facing from movement
                    const nx = mv.x / mvLen, ny = mv.y / mvLen;
                    game.player.lastDirection = { x: nx, y: ny };
                    if (Math.abs(nx) > Math.abs(ny)) game.player.facing = nx < 0 ? 'left' : 'right'; else game.player.facing = ny < 0 ? 'up' : 'down';
                }
            }
            
            const newX = game.player.x + dx;
            const newY = game.player.y + dy;
            
            if (!isWall(newX, newY)) {
                game.player.x = Math.max(25, Math.min(newX, canvas.width - 25));
                game.player.y = Math.max(25, Math.min(newY, canvas.height - 25));
            }

            // Movement & animation state
            game.player.moving = (dx !== 0 || dy !== 0);
            if (game.player.spriteLoaded) {
                if (game.player.moving) {
                    game.player.animTimer++;
                    if (game.player.animTimer >= game.player.animSpeed) {
                        game.player.animTimer = 0;
                        game.player.animFrame = (game.player.animFrame + 1) % game.player.spriteMeta.cols;
                    }
                } else {
                    // Idle: frame 0 (could later add separate idle row or subtle bob)
                    game.player.animFrame = 0;
                    game.player.animTimer = 0;
                }
            }
            
            // Attack handling
            // Base cooldown in ms. Previous model multiplied divisively (compounded) which blew up with many sources.
            // New model: treat (attackSpeedMultiplier - 1) as additive bonuses.
            // Example: +100% (2.0) and +150% (2.5) => total bonus = (1.0 + 1.5)=2.5 => effective multiplier = 1 + 2.5 = 3.5.
            // Effective cooldown = base / (1 + sumBonuses).
            let baseAttackCooldown = 300;
            let attackSpeedBonusSum = 0; // sum of (multiplier - 1)
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.attackSpeedMultiplier) {
                    attackSpeedBonusSum += (abilityData.effect.attackSpeedMultiplier - 1);
                }
            });
            const effectiveAttackSpeedMult = 1 + attackSpeedBonusSum;
            let attackCooldown = baseAttackCooldown / effectiveAttackSpeedMult;
            
            const isFiring = !!(game.keys[' '] || (game.input && game.input.gpFire));
            if (isFiring && Date.now() - game.lastAttack > attackCooldown) {
                attack();
                game.lastAttack = Date.now();
            }

            // Continuous beam weapons: while holding space, spawn short beam segments at a high rate
            if (isFiring && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'laser' && ABILITIES[a].effect.continuous)) {
                // spawn extra mini-attacks without resetting lastAttack to allow continuous fire
                // create a rapid beam segment every 50ms
                if (!game._lastBeamSpawn || Date.now() - game._lastBeamSpawn > 50) {
                    // mimic a single projectile spawn in the direction of lastDirection
                    const dir = game.player.lastDirection;
                    const angle = Math.atan2(dir.y, dir.x);
                    const speed = 12;
                    const projIdx = game.spawnProjectile({
                        x: game.player.x + Math.cos(angle) * 16,
                        y: game.player.y + Math.sin(angle) * 16,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 18,
                        r: 4, // approximate size mapping; beam segments small
                        damage: calculateDamage(),
                        damageType: 'plasma'
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    // Carry base damage and energy type for beam ticks
                    game._projMeta.set(projIdx, { beam:true, beamOwner:'player', baseDamage: calculateDamage(), energyType:'laser' });
                    game._lastBeamSpawn = Date.now();
                    addParticle(game.player.x, game.player.y, '#99EEFF', 'spark');
                }
            }

            // Particle Beam: continuous segments while holding fire (tiled along aim direction)
            if (isFiring && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'particle')) {
                // Slightly lower cadence than laser since cores are thicker; about every 60ms
                if (!game._lastPBeamSpawn || Date.now() - game._lastPBeamSpawn > 60) {
                    const dir = game.player.lastDirection;
                    const angle = Math.atan2(dir.y, dir.x);
                    const speed = 9;
                    const base = calculateDamage();
                    const idx = game.spawnProjectile({
                        x: game.player.x + Math.cos(angle) * 16,
                        y: game.player.y + Math.sin(angle) * 16,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 26, // slightly shorter life; segments will tile densely
                        r: 7,
                        damage: Math.floor(base * 1.5) + 6,
                        damageType: 'plasma'
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    // mark as particle beam so SoA beam tick logic uses thicker core and plasma tint
                    game._projMeta.set(idx, {
                        beam: true,
                        particleBeam: true,
                        beamOwner: 'player',
                        baseDamage: base,
                        energyType: 'particle',
                        _beamPatternPhase: 0,
                        infusionElements: (game.player.infusions && game.player.infusions.length)
                            ? game.player.infusions.map(i => ({ type: i.type, potency: i.potency }))
                            : null
                    });
                    game._lastPBeamSpawn = Date.now();
                    addParticle(game.player.x, game.player.y, '#FFD466', 'spark');
                }
            }

            // Ion Cannon: charge while holding space, release a single heavy blast on release
            if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'ion' && ABILITIES[a].effect.chargeShot)) {
                // increment charge while holding
                if (isFiring) {
                    game._ionChargeTime = (game._ionChargeTime || 0) + 1;
                    if (game._ionChargeTime > 100) game._ionChargeTime = 100; // cap
                    if (Math.random() < 0.08) addParticle(game.player.x + (Math.random()-0.5)*24, game.player.y + (Math.random()-0.5)*24, '#99FFEE', 'spark');
                } else if (game._ionChargeTime && game._ionChargeTime > 0) {
                    // on release, fire charged ion blast (one big projectile)
                    if (!game._lastIonFire || Date.now() - game._lastIonFire > 120) {
                        const angle = Math.atan2(game.player.lastDirection.y, game.player.lastDirection.x);
                        const charge = Math.min(1.0, game._ionChargeTime / 80);
                        const speed = 10 + Math.floor(charge * 18);
                        const dmg = Math.floor(calculateDamage() * (1.4 + charge * 2.2));
                        const ionIdx = game.spawnProjectile({
                            x: game.player.x + Math.cos(angle) * 16,
                            y: game.player.y + Math.sin(angle) * 16,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 160,
                            r: 14 + Math.floor(charge * 12),
                            damage: dmg,
                            damageType: 'plasma'
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        if (ionIdx>=0) game._projMeta.set(ionIdx,{ ionCharge:true, charge, piercing:true, pierceCount:6, baseDamage:dmg, energyType:'ion' });
                        // Flash ring at muzzle to emphasize release
                        const mx = game.player.x + Math.cos(angle)*16;
                        const my = game.player.y + Math.sin(angle)*16;
                        for (let p=0;p<10;p++) addParticle(mx + (Math.random()-0.5)*22, my + (Math.random()-0.5)*22, '#AAEEFF', 'explosion');
                        // brief bright ring using particles
                        for (let r=0;r<12;r++) {
                            const a = (r/12)*Math.PI*2;
                            addParticle(mx + Math.cos(a)*(10+charge*12), my + Math.sin(a)*(10+charge*12), '#CCFFFF', 'spark');
                        }
                        addScreenShake(7 + Math.floor(charge*7));
                        game._lastIonFire = Date.now();
                    }
                    game._ionChargeTime = 0;
                }
            }
            
            if (game.keys['enter'] && game.roomCleared) {
                nextRoom();
            }
            
            // Handle invulnerability frames
            if (game.player.invulnerable) {
                game.player.invulnTime--;
                if (game.player.invulnTime <= 0) {
                    game.player.invulnerable = false;
                }
            }
            
            // Regeneration
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.regen) {
                    game.player.health = Math.min(game.player.maxHealth, 
                        game.player.health + abilityData.effect.regen * 0.016);
                    updateUI();
                }
            });
        }

        function attack() {
            game.shotCounter++;
            // Play a minimal attack SFX (rate-limited) once per attack invocation (not per projectile)
            if (typeof playAttackSfx === 'function') playAttackSfx();
            // Multi-shot stacking logic
            let projectileCount = 1;
            let shotgunBlast = false;
            let multiShotCount = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.projectileCount) {
                    multiShotCount += abilityData.effect.projectileCount;
                }
                if (abilityData && abilityData.effect.shotgunBlast) {
                    shotgunBlast = true;
                }
            });
            if (shotgunBlast) {
                projectileCount = multiShotCount + 5;
            } else if (multiShotCount > 0) {
                projectileCount = multiShotCount;
            }
            // Defensive: if lastDirection is still the old default or zeroed, realign with facing so first
            // shot direction matches the sprite orientation. This can happen if a legacy save/object
            // persisted without movement input before first attack.
            if (game.player) {
                const ld = game.player.lastDirection || {x:0,y:0};
                const nearZero = Math.abs(ld.x) < 0.0001 && Math.abs(ld.y) < 0.0001;
                const legacyRight = ld.x === 1 && ld.y === 0 && game.player.facing && game.player.facing !== 'right';
                if (nearZero || legacyRight) {
                    switch (game.player.facing) {
                        case 'up': game.player.lastDirection = {x:0,y:-1}; break;
                        case 'down': game.player.lastDirection = {x:0,y:1}; break;
                        case 'left': game.player.lastDirection = {x:-1,y:0}; break;
                        case 'right': game.player.lastDirection = {x:1,y:0}; break;
                        default: if (nearZero) game.player.lastDirection = {x:0,y:1};
                    }
                }
            }
            const dir = game.player.lastDirection;
            let targetEnemy = null;
            // Auto-aim
            if (game.player.abilities.includes('Auto-Aim')) {
                let closestDist = Infinity;
                game.enemies.forEach(enemy => {
                    const dist = Math.sqrt((enemy.x - game.player.x) ** 2 + (enemy.y - game.player.y) ** 2);
                    if (dist < closestDist) {
                        closestDist = dist;
                        targetEnemy = enemy;
                    }
                });
            }
            // Determine pattern modifiers from abilities
            const hasOmni = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.omniDirectional);
            const hasRadial = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.radialBurst);
            const hasSpiral = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.spiralPattern);
            const hasUzumaki = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.uzumaki);
            const hasCross = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.crossPattern);
            const hasRandomSpread = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.randomSpread);

            // Pattern count handling: Some pattern abilities define a baseline number of directions.
            // Radial Burst wants 16 evenly spaced shots. Omni Shot wants 8. If the player has additional
            // multi-shot bonuses exceeding the pattern baseline, we keep the higher number so stacking
            // projectile count still scales patterns (i.e., 20-way radial if they somehow stack enough).
            // Ensure Cross Shot provides at least a baseline number BEFORE other pattern scaling so it isn't overwritten.
            const CROSS_MIN_PROJECTILES = 4; // Adjust to raise/lower baseline for Cross Shot
            if (hasCross && projectileCount < CROSS_MIN_PROJECTILES) {
                projectileCount = CROSS_MIN_PROJECTILES;
            }
            const baseMultiBeforePattern = projectileCount; // capture current multi-shot total (after Cross minimum)
            if (hasRadial) {
                // Radial Burst: baseline 16; scale if multi-shot already exceeds
                projectileCount = Math.max(baseMultiBeforePattern, 16);
            } else if (hasOmni) {
                // Omni Shot scaling: previously enforced minimum of 8.
                // New behavior: multiply base multi-shot count into directional set.
                // Example: baseMultiBeforePattern = 5 (e.g., Penta Shot) => 5 * 8 = 40-way omni.
                // If player has only Omni (base=1) => 8 directions (unchanged base case).
                const scaled = baseMultiBeforePattern * 8;
                projectileCount = Math.max(scaled, 8);
            } else if (hasCross) {
                // Cross Shot scaling:
                // Minimum 4 shots (one per orthogonal axis). When multi-shot adds more, we allocate them
                // across the 4 arms (Right, Down, Left, Up) evenly. Each arm beyond its first shot fans
                // slightly using a symmetric angular spread so stacking multi-shot meaningfully increases
                // coverage instead of just repeating the same four directions.
                // Example allocations (baseMultiBeforePattern = n after multi-shot):
                // 1..4 => upgraded to 4 (R,D,L,U)
                // 5 => R,D,L,U + 1 extra (goes to Right arm)
                // 8 => 2 per arm
                // 12 => 3 per arm, etc.
                projectileCount = Math.max(baseMultiBeforePattern, CROSS_MIN_PROJECTILES);
            }
            const patternCount = projectileCount; // final number of shots to emit

            // Defensive: ensure all pattern guard flags are defined before conditional spread tweaks
            const hasQuad = game.player.abilities.includes('Quad Shot');

            for (let i = 0; i < projectileCount; i++) {
                let angle;
                // Base angle towards target or last direction
                if (targetEnemy && game.player.abilities.includes('Auto-Aim') && !hasOmni && !hasRadial && !hasCross) {
                    const dx = targetEnemy.x - game.player.x;
                    const dy = targetEnemy.y - game.player.y;
                    angle = Math.atan2(dy, dx);
                } else {
                    angle = Math.atan2(dir.y, dir.x);
                }

                // Pattern-specific angle calculations
                if (hasOmni) {
                    angle = (i / patternCount) * Math.PI * 2;
                } else if (hasRadial) {
                    angle = (i / patternCount) * Math.PI * 2;
                } else if (hasCross) {
                    // Distribute projectiles into 4 arms with per-arm spread.
                    const baseAngles = [0, Math.PI/2, Math.PI, 3*Math.PI/2]; // R, D, L, U
                    const perArm = Math.ceil(patternCount / 4); // logical capacity per arm (not all arms may reach this if remainder)
                    // Determine which arm this index maps to using a round-robin so early extras distribute evenly.
                    // Alternative approach: fill arms sequentially (could bias Right). Round-robin is fairer.
                    const armIndex = i % 4; // 0..3
                    const occurrence = Math.floor(i / 4); // which pass on that arm
                    const armAngle = baseAngles[armIndex];
                    // Count how many projectiles actually end up on this arm to compute spread width.
                    // Derive total shots assigned to armIndex: either occurrence+1 or occurrence based on remainder.
                    // Simpler: compute allShotsForArm by iterating patternCount mod 4 distribution math.
                    let allShotsForArm = Math.floor(patternCount / 4);
                    if (armIndex < (patternCount % 4)) allShotsForArm += 1; // first remainder arms get one extra
                    // Spread parameters: max +/- spreadAngle radians for edge shots; diminishing with more per arm.
                    const spreadAngleMax = 0.35; // ~20 degrees each side
                    if (allShotsForArm <= 1) {
                        angle = armAngle;
                    } else {
                        // Map occurrence (0..allShotsForArm-1) to symmetric offsets centered at 0.
                        // Use normalized position: k in [0, allShotsForArm-1]. offsetIndex = k - (N-1)/2
                        const offsetIndex = occurrence - (allShotsForArm - 1) / 2;
                        const normalized = (allShotsForArm <= 1) ? 0 : offsetIndex / ((allShotsForArm - 1) / 2);
                        const offset = spreadAngleMax * normalized; // linear; could adopt curve if needed
                        angle = armAngle + offset;
                    }
                } else if (hasSpiral) {
                    // For spiral shots, keep the primary firing direction aligned with player,
                    // but add a very small per-shot offset so multi-shot spirals spread lightly.
                    // The in-flight spiral looping behavior is handled in updateProjectiles().
                    angle += (i - (patternCount - 1) / 2) * 0.02;
                } else if (hasUzumaki) {
                    // Uzumaki: do not change the initial firing angle. The SoA updater will
                    // take over and move the projectile along an expanding spiral around the player center.
                } else {
                    if (shotgunBlast || projectileCount > 1) {
                        const spread = shotgunBlast ? 0.6 : 0.4;
                        angle += (i - (projectileCount - 1) / 2) * spread / projectileCount;
                        // Prevent reverse-heading bug: clamp deviation to +/- 90 from base aim
                        const baseAim = Math.atan2(dir.y, dir.x);
                        let delta = angle - baseAim;
                        while (delta > Math.PI) delta -= Math.PI*2;
                        while (delta < -Math.PI) delta += Math.PI*2;
                        const maxDev = Math.PI/2;
                        if (delta > maxDev) angle = baseAim + maxDev;
                        if (delta < -maxDev) angle = baseAim - maxDev;
                    }
                }


                // Random spread abilities add unpredictable deviation
                if (hasRandomSpread) {
                    angle += (Math.random() - 0.5) * 1.2; // wide random spread
                }

                let speed = 6;
                let size = 4;
                let piercing = game.player.abilities.includes('Pierce Shot') || game.player.abilities.includes('Multi-Pierce');
                let pierceCount = game.player.abilities.includes('Multi-Pierce') ? 999 : 3;
                let homing = game.player.abilities.includes('Homing Shot');
                let weakHoming = game.player.abilities.includes('Seeking Shot');
                let bouncing = game.player.abilities.includes('Bouncing Shot');
                let explosive = game.player.abilities.includes('Explosive Shot');
                // Split Shot removed (previously set splitting flag here)
                let growing = game.player.abilities.includes('Growing Shot');
                // Spiral shot: causes the projectile to curve/rotate in-flight
                let spiral = game.player.abilities.includes('Spiral Shot');
                let bounces = 0;
                // explicit per-attack flags (populated below from ability effects)
                let boomerangFlag = false;
                let orbitalFlag = false;
                let drillingFlag = false;
                let phasingFlag = false;
                let teleportingFlag = false;

                // Map a few ability flags that weren't previously wired up
                game.player.abilities.forEach(ability => {
                    const abilityData = ABILITIES[ability];
                    if (!abilityData || !abilityData.effect) return;
                    if (abilityData.effect.projectileSpeed) speed *= abilityData.effect.projectileSpeed;
                    if (abilityData.effect.projectileSize) size *= abilityData.effect.projectileSize;
                    if (abilityData.effect.novaBlast || abilityData.effect.smartExplosive) explosive = true;
                    // Bouncing behavior: support both 'ricochet' (enemy->enemy) and 'bouncing' (wall bounces)
                    if (abilityData.effect.ricochet) {
                        bouncing = true;
                        bounces = Math.max(bounces, abilityData.effect.bounces || 3);
                    }
                    if (abilityData.effect.bouncing) {
                        bouncing = true;
                        bounces = Math.max(bounces, abilityData.effect.bounces || 3);
                    }
                    if (abilityData.effect.ricochet && abilityData.effect.bounces) bounces = Math.max(bounces, abilityData.effect.bounces);
                    if (abilityData.effect.boomerang) boomerangFlag = true;
                    if (abilityData.effect.orbital) orbitalFlag = true;
                    if (abilityData.effect.drilling) drillingFlag = true;
                    if (abilityData.effect.phasing) phasingFlag = true;
                    if (abilityData.effect.teleporting) teleportingFlag = true;
                    if (abilityData.effect.weaponType === 'dagger' && abilityData.effect.projectileCount) { /* handled by projectileCount */ }
                });
                // Defensive: if bouncing was enabled but no explicit bounces value assigned by any ability effect, fall back to 3
                if (bouncing && bounces === 0) bounces = 3;

                // Dynamic projectile travel: base life scaled for enlarged logical canvas.
                // Previously life was a flat 150 frames (~2.5s at 60fps) which limited range after expanding LOGICAL_W.
                // New approach:
                //  - Base life scaled relative to logical diagonal so projectiles can plausibly cross arena (~diagonal / avgSpeed).
                //  - We assume average base speed ~8 (tuned from typical speed variable earlier in attack()).
                //  - Clamp to avoid runaway extremely long-lived shots when future scaling changes occur.
                const logicalDiag = Math.hypot(LOGICAL_W || 1280, LOGICAL_H || 720);
                const avgSpeed = 8; // heuristic average projectile speed in px/frame
                // Travel frames to cross 1.1 * diagonal (gives a bit of off-screen continuation) divided by avg speed.
                let dynamicLife = Math.floor((logicalDiag * 1.1) / avgSpeed);
                // Double the computed life to allow shots (especially post-bounce) to traverse more of the enlarged arena.
                dynamicLife *= 2;
                // Expanded clamp range to reflect doubled lifetime while preventing runaway accumulation.
                dynamicLife = Math.max(340, Math.min(dynamicLife, 760));
                // Spawn core projectile into SoA
                const baseDamage = calculateDamage();
                const primaryIdx = game.spawnProjectile({
                    x: game.player.x + Math.cos(angle) * 16,
                    y: game.player.y + Math.sin(angle) * 16,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: dynamicLife,
                    r: Math.max(2, Math.min(32, Math.floor(size))),
                    damage: baseDamage,
                    damageType: null, // will set below via meta/infusion
                    homing: homing || weakHoming,
                    bouncing: bouncing,
                    teleporting: teleportingFlag,
                    spiralPattern: spiral,
                    sineWave: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.sineWave),
                    wackyZigzag: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.wackyZigzag),
                    ekgWave: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.ekgWave),
                    homing: homing,
                });
                if (!game._projMeta) game._projMeta = new Map();
                const meta = { baseDamage, piercing, pierceCount, weakHoming, bouncing, bounces: (bouncing?bounces:0), explosive, growing, spiral, hasUzumaki, boomerang:boomerangFlag, orbital:orbitalFlag, drilling:drillingFlag, phasing:phasingFlag, teleporting:teleportingFlag };
                // Propagate pattern flags used by SoA updaters so synergies can be detected
                if (game.player.abilities.includes('Pendulum Shot')) meta.pendulumPattern = true;
                if (game.player.abilities.includes('Veering Fan')) { meta.veeringFan = true; meta._veeringTimer = 22; meta._veerMinDist = 80; meta._spawnX = game.player.x; meta._spawnY = game.player.y; }
                if (hasUzumaki) {
                    meta._uzuCx = game.player.x;
                    meta._uzuCy = game.player.y;
                    meta._uzuAngle = angle;
                    meta._uzuRadius = 16;
                    meta._uzuAngularVel = 0.18 + Math.random()*0.05;
                    meta._uzuRadialVel = 1.35 + Math.random()*0.35;
                    meta._uzuDrag = 0.000;
                }
                // --- Ability effect aggregation (store directly onto metadata so collision/hit logic sees them) ---
                let chosenDamageType = null; let chosenDamageTier = -1; let weaponType = null;
                game.player.abilities.forEach(ability => {
                    const aData = ABILITIES[ability]; if(!aData || !aData.effect) return; const eff = aData.effect;
                    // Damage type precedence by tier so higher-tier elemental/combos override lower
                    if (eff.damageType) {
                        if (aData.tier >= chosenDamageTier) { chosenDamageType = eff.damageType; chosenDamageTier = aData.tier; }
                    }
                    if (eff.piercing) { meta.piercing = true; if (eff.pierceCount) meta.pierceCount = Math.max(meta.pierceCount||0, eff.pierceCount); }
                    if (eff.weakHoming) meta.weakHoming = true;
                    if (eff.explosive || eff.smartExplosive) { meta.explosive = true; if (eff.smartExplosive) meta.smartExplosive = true; }
                    if (eff.novaBlast) meta.novaBlast = true;
                    if (eff.chainExplosion) meta.chainExplosion = true;
                    if (eff.timeBomb) meta.timeBomb = true; // detailed timer set below for first projectile
                    if (eff.ricochet) { meta.ricochet = true; meta.bounces = Math.max(meta.bounces||0, eff.bounces||3); }
                    if (eff.knockback) { meta.knockback = true; if (eff.knockbackDistance) meta.knockbackDistance = Math.max(meta.knockbackDistance||0, eff.knockbackDistance); }
                    if (eff.freezes) meta.freezes = true;
                    if (eff.armorPiercing) meta.armorPiercing = true;
                    if (eff.ignoresArmor) meta.ignoresArmor = true;
                    if (eff.ignoresEverything) meta.ignoresEverything = true;
                    if (eff.lifeSteal) meta.lifeSteal = Math.max(meta.lifeSteal||0, eff.lifeSteal);
                    if (eff.hitMultipleTimes) meta.hitMultipleTimes = true;
                    if (eff.massiveExplosion) meta.massiveExplosion = true;
                    if (eff.antimatter) meta.antimatter = true;
                    if (eff.sawWave) meta.sawWave = true;
                    if (eff.crushDamage) meta.crushDamage = true;
                    if (eff.weaponType) weaponType = eff.weaponType;
                    if (eff.realityBreak) meta.realityBreak = true;
                    if (eff.quantum) meta.quantum = true;
                    if (eff.blackHole) meta.blackHole = true;
                    if (eff.vortex) meta.vortex = true;
                    if (eff.meteor) meta.meteorAbility = true; // actual meteor spawn uses dedicated block
                    if (eff.teleporting) meta.teleporting = true;
                    if (eff.areaEffect) meta.areaEffect = true;
                });
                if (chosenDamageType) meta.damageType = chosenDamageType;
                // Choose weapon visual type for the BASE projectile
                // Rule: randomize among owned NON-sword melee weapons so sword never suppresses them.
                // If Sword Throw is owned, we spawn an extra sword projectile separately (handled below).
                const ownedWeapons = ['sword','axe','spear','hammer','dagger','bread'].filter(w => game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.weaponType === w));
                const hasSword = ownedWeapons.includes('sword');
                const ownedNonSword = ownedWeapons.filter(w => w !== 'sword');
                let appliedType = null;
                if (ownedNonSword.length > 0) {
                    appliedType = ownedNonSword[Math.floor(Math.random()*ownedNonSword.length)];
                } else if (hasSword) {
                    // Only sword owned: base remains generic; we'll add a sword projectile below
                    appliedType = 'sword';
                } else if (weaponType) {
                    // Fallback: single owned melee type (non-standard cases)
                    appliedType = weaponType;
                }
                if (appliedType) {
                    // Do not tag the base as 'sword'  we spawn an additional sword projectile separately
                    weaponType = appliedType;
                    if (appliedType !== 'sword') meta.weaponType = appliedType;
                }
                // Multi-Infusion overlay (store infusionElements for applyProjectileHit)
                if (game.player && game.player.infusions && game.player.infusions.length) {
                    meta.infusionElements = game.player.infusions.map(i=>({ type:i.type, potency:i.potency }));
                    if (!meta.damageType) {
                        // choose strongest infusion potency as primary damageType for display/status
                        let best = -1; let chosen=null; meta.infusionElements.forEach(inf=>{ if(inf.potency>best){best=inf.potency; chosen=inf.type;} });
                        meta.damageType = chosen;
                    }
                }
                // Map damageType/infusions to SoA color index for visual feedback
                if (game.projectilesSoA) {
                    const so = game.projectilesSoA;
                    const colMap = { fire:1, shadow:2, poison:2, lightning:1, frost:4, ice:4, void:5, wind:3, plasma:5 };
                    let cIdx = 0;
                    if (meta.damageType && colMap[meta.damageType]!=null) cIdx = colMap[meta.damageType];
                    else if (meta.infusionElements && meta.infusionElements.length) {
                        // pick strongest infusion's color as fallback
                        let strongest = meta.infusionElements[0];
                        meta.infusionElements.forEach(el=>{ if (el.potency > strongest.potency) strongest = el; });
                        if (strongest && colMap[strongest.type]!=null) cIdx = colMap[strongest.type];
                    }
                    if (cIdx != null) so.colorIdx[primaryIdx] = cIdx;
                }
                // Photon Torpedo (instant-travel strike): perform an immediate hit on nearest enemy when fired
                // Note: keep projectile alive so this is additive to normal shots/patterns.
                if (game.player.abilities && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.instantTravel)) {
                    let target = null; let closest = Infinity;
                    for (const e of game.enemies) {
                        const d = Math.hypot(e.x - game.player.x, e.y - game.player.y);
                        if (d < closest) { closest = d; target = e; }
                    }
                    if (target) {
                        let dmg = Math.floor((meta.baseDamage || calculateDamage()) * 1.8);
                        // Pattern synergy: small bonus per additional core motion pattern owned
                        const coreFlags = ['sineWave','wackyZigzag','ekgWave','spiralPattern'];
                        const patternCount = coreFlags.reduce((n,f)=> n + (game.player.abilities.some(a=> ABILITIES[a] && ABILITIES[a].effect[f]) ? 1 : 0), 0);
                        if (patternCount >= 2) dmg = Math.floor(dmg * (1 + 0.08 * (patternCount - 1)));
                        // Infusion bonus: add partial damage per active infusion potency
                        if (game.player.infusions && game.player.infusions.length) {
                            game.player.infusions.forEach(inf => { dmg += Math.floor(dmg * 0.15 * inf.potency); });
                        }
                        target.health -= dmg;
                        addDamageNumber(dmg, target.x, target.y - target.size/2, { type:'plasma', crit:false });
                        addScreenShake(7);
                        // Apply statuses from current build
                        if (typeof applyStatusEffects === 'function') applyStatusEffects(target);
                        // Visual strike record
                        if (!Array.isArray(game.photonStrikes)) game.photonStrikes = [];
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const life = reduceRings ? 16 : 24;
                        const impactSize = Math.min(42, 22 + dmg*0.05) * (lowFx ? 0.85 : 1);
                        game.photonStrikes.push({ x1: game.player.x, y1: game.player.y, x2: target.x, y2: target.y, time: performance.now(), life, impactSize, color: '#CCFFFF' });
                        // Particles at source and impact (perf-aware)
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!lowFx && !hideSparks) {
                            for (let t = 0; t < 8; t++) addParticle(target.x + (Math.random()-0.5)*30, target.y + (Math.random()-0.5)*30, '#FFFFFF', 'explosion');
                            for (let s = 0; s < 10; s++) addParticle(game.player.x + (Math.random()-0.5)*44, game.player.y + (Math.random()-0.5)*44, '#CCFFFF', 'spark');
                        }
                        // Synergies: lightning mini-chains
                        if (game.player.abilities.some(a => a.includes('Lightning Shot') || a.includes('Storm Shot'))) {
                            let chains = 0; const maxChains = 2;
                            for (const o of game.enemies) {
                                if (o === target || chains >= maxChains) break;
                                const d = Math.hypot(o.x - target.x, o.y - target.y);
                                if (d < 140) { const z = Math.max(4, Math.floor(dmg * 0.35)); o.health -= z; addDamageNumber(z, o.x, o.y - o.size/2, { type:'lightning' }); addParticle(o.x, o.y, '#FFFFAA', 'lightning'); chains++; }
                            }
                        }
                        // Explosive synergy
                        if (game.player.abilities.some(a => a.includes('Explosive Shot') || a.includes('Nova Blast'))) {
                            explodeProjectile({ x: target.x, y: target.y, size: 12 }, Math.floor(dmg * 0.5));
                        }
                        // Void synergy: light armor shred pulse
                        if (game.player.abilities.some(a => a.includes('Void Shot') || a.includes('Black Hole'))) {
                            game.enemies.forEach(o => { const d = Math.hypot(o.x - target.x, o.y - target.y); if (d < 110) { o.armorShredded = (o.armorShredded||0) + 1; if (o.armorShredded > 10) o.armorShredded = 10; } });
                        }
                    }
                }
                // Teleport Shot relocation (visual + positional)  perform once at spawn
                if (meta.teleporting) {
                    const so = game.projectilesSoA; const TELEPORT_SHOT_RADIUS = 88; const attempts=10; const margin=30;
                    const ox = so.x[primaryIdx]; const oy = so.y[primaryIdx];
                    for (let a=0;a<attempts;a++) {
                        const r = Math.pow(Math.random(),1.35)*TELEPORT_SHOT_RADIUS; const th = Math.random()*Math.PI*2;
                        let nx = game.player.x + Math.cos(th)*r; let ny = game.player.y + Math.sin(th)*r;
                        nx = Math.max(margin, Math.min(nx, LOGICAL_W - margin)); ny = Math.max(margin, Math.min(ny, LOGICAL_H - margin));
                        // (Simple wall test omitted here; integrate isWall if available in this scope)
                        so.x[primaryIdx]=nx; so.y[primaryIdx]=ny; break;
                    }
                    if (!(game.perf && game.perf.lowFx)) {
                        for (let p=0;p<8;p++) addParticle(so.x[primaryIdx] + (Math.random()-0.5)*26, so.y[primaryIdx] + (Math.random()-0.5)*26, '#FFDFAA','spark');
                        for (let t=0;t<5;t++){ const tRatio=t/4; addParticle(ox + (so.x[primaryIdx]-ox)*tRatio, oy + (so.y[primaryIdx]-oy)*tRatio, '#FFE4AA','trail'); }
                    }
                }
                // Weapon-type adjustments
                if (weaponType || hasSword) {
                    const so = game.projectilesSoA;
                    // If Sword Throw is owned, always spawn an additional sword projectile
                    if (hasSword) {
                        // Spawn sword without replacing the base shot (even if base is axe/bread/etc.)
                        const sAng = angle;
                        const sSpd = speed * 0.85;
                        const sIdx = game.spawnProjectile({
                            x: game.player.x + Math.cos(sAng) * 16,
                            y: game.player.y + Math.sin(sAng) * 16,
                            vx: Math.cos(sAng) * sSpd,
                            vy: Math.sin(sAng) * sSpd,
                            life: 100,
                            r: Math.max(14, Math.floor(size)),
                            damage: baseDamage,
                            damageType: null,
                            sineWave: false,
                            wackyZigzag: false,
                            ekgWave: false,
                            spiralPattern: false
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        const metaSword = {
                            baseDamage,
                            weaponType:'sword',
                            piercing: !!meta.piercing,
                            pierceCount: meta.pierceCount,
                            weakHoming: !!meta.weakHoming,
                            bouncing: !!meta.bouncing,
                            bounces: meta.bounces||0,
                            explosive: !!meta.explosive,
                            boomerang: !!meta.boomerang,
                            orbital: !!meta.orbital,
                            drilling: !!meta.drilling,
                            phasing: !!meta.phasing,
                            teleporting: !!meta.teleporting
                        };
                        if (chosenDamageType) metaSword.damageType = chosenDamageType;
                        game._projMeta.set(sIdx, metaSword);
                    }
                    if (weaponType === 'axe') {
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 16);
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx]*1.6 + 12));
                        meta.knockback = true; meta.knockbackDistance = Math.max(meta.knockbackDistance||0, 55); meta.weaponType='axe'; meta.slowOnHit = true;
                    } else if (weaponType === 'spear') {
                        meta.piercing = true; meta.pierceCount = Math.max(meta.pierceCount||0, 4); meta.weaponType='spear';
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx]*1.2 + 6));
                    } else if (weaponType === 'hammer') {
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 18);
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx]*1.8 + 10));
                        meta._hammer = true; meta.knockback = true; meta.knockbackDistance = Math.max(meta.knockbackDistance||0, 40); meta.weaponType='hammer';
                    } else if (weaponType === 'dagger') {
                        // Dagger Rain: rely on projectileCount logic; small radius fast projectile adjustments could be added
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 5);
                        so.vx[primaryIdx]*=1.12; so.vy[primaryIdx]*=1.12;
                        meta.weaponType='dagger';
                    } else if (weaponType === 'bread') {
                        // Crusty Bread: chunky, high-damage spinning baguette (nerfed)
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 16);
                        // Reduced bump to bring it in line with other heavy weapons
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx] * 1.35 + 10));
                        meta.weaponType = 'bread';
                        // Optional mild knockback due to mass
                        meta.knockback = true; meta.knockbackDistance = Math.max(meta.knockbackDistance||0, 38);
                    }
                }
                // Toenail Clibbins crescents (spawn separate SoA projectiles)  migrated from legacy block
                if (i === 0 && game.player.abilities.includes('Toenail Clibbins')) {
                    const crescents = 4 + Math.floor(Math.random()*3);
                    for (let c=0;c<crescents;c++) {
                        const ang = Math.random()*Math.PI*2;
                        const spd = 3.4 + Math.random()*2.0;
                        const lifeC = 78 + Math.floor(Math.random()*40);
                        const sizeC = 11 + Math.floor(Math.random()*3);
                        const idxC = game.spawnProjectile({ x: game.player.x, y: game.player.y, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, life: lifeC, r: sizeC, damage: Math.max(1, Math.floor(baseDamage * 0.38)) });
                        if (idxC>=0) {
                            game._projMeta.set(idxC, { toenail:true, baseDamage: Math.max(1, Math.floor(baseDamage * 0.38)), _crescentPhase: Math.random()*Math.PI*2, _crescentDir: (Math.random()<0.5?-1:1), _tnThickness: 0.35 + Math.random()*0.25, _tnArcSweep: (Math.PI*(0.85+Math.random()*0.25)), _tnInnerOffset: 0.30 + Math.random()*0.15, _tnTintShift:(Math.random()*18-9) });
                        }
                    }
                }
                // SIGMA: spawn an additional large, strong-homing core projectile (stage 1)
                if (i === 0 && game.player.abilities.includes('SIGMA')) {
                    if (!game._sigma) game._sigma = {};
                    // Fire-rate limit: 1 per 2 seconds (~120 frames)
                    if (typeof game.frame === 'number') {
                        if (game._sigma._s1NextFrame && game.frame < game._sigma._s1NextFrame) {
                            // on cooldown; skip this cycle
                        } else {
                            game._sigma._s1NextFrame = game.frame + 120;
                            const sAng = angle;
                            const sSpeed = speed * 0.95;
                            const sLife = Math.max(dynamicLife, 420);
                            const sIdx = game.spawnProjectile({
                                x: game.player.x + Math.cos(sAng) * 16,
                                y: game.player.y + Math.sin(sAng) * 16,
                                vx: Math.cos(sAng) * sSpeed,
                                vy: Math.sin(sAng) * sSpeed,
                                life: sLife,
                                r: Math.max(18, Math.floor(size * 2.4)),
                                damage: Math.max(1, Math.floor(baseDamage * 1.15)),
                                damageType: null,
                                homing: true
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            const metaS1 = {
                                baseDamage: Math.max(1, Math.floor(baseDamage * 1.15)),
                                sigma1: true,
                                // stronger homing factor for sigma1 only
                                _sigmaHomingFactor: 1.9,
                                _sigmaBlendBoost: 0.08,
                                // Allow stage 1 to pass through obstacles
                                phasing: true,
                                // ensure no accidental pierce/ricochet from other abilities
                                piercing: false,
                                pierceCount: 0
                            };
                            game._projMeta.set(sIdx, metaS1);
                            // Slight cue
                            if (!(game.perf && game.perf.lowFx)) addParticle(game.player.x, game.player.y, '#CCEEFF','ring');
                        }
                    } else {
                        // Fallback if frame counter not available (spawn, but still set a timestamp gate)
                        const now = performance.now();
                        if (!game._sigma._s1NextMs || now >= game._sigma._s1NextMs) {
                            game._sigma._s1NextMs = now + 2000;
                            const sAng = angle;
                            const sSpeed = speed * 0.95;
                            const sLife = Math.max(dynamicLife, 420);
                            const sIdx = game.spawnProjectile({
                                x: game.player.x + Math.cos(sAng) * 16,
                                y: game.player.y + Math.sin(sAng) * 16,
                                vx: Math.cos(sAng) * sSpeed,
                                vy: Math.sin(sAng) * sSpeed,
                                life: sLife,
                                r: Math.max(18, Math.floor(size * 2.4)),
                                damage: Math.max(1, Math.floor(baseDamage * 1.15)),
                                damageType: null,
                                homing: true
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            const metaS1 = { baseDamage: Math.max(1, Math.floor(baseDamage * 1.15)), sigma1: true, _sigmaHomingFactor: 1.9, _sigmaBlendBoost: 0.08, piercing: false, pierceCount: 0 };
                            game._projMeta.set(sIdx, metaS1);
                            if (!(game.perf && game.perf.lowFx)) addParticle(game.player.x, game.player.y, '#CCEEFF','ring');
                        }
                    }
                }
                // Extended pattern/meta flags
                const abilityFlagNames = ['lissajousPattern','pendulumPattern','sawWave','phaseEcho','resonantPulseCore','pivotPattern','convergePair','fragmentWake','spiralBloom','harmonicSplit','temporalDrift','veeringFan','echoBloom','bloomRing','cascadeBurst','helixPair'];
                abilityFlagNames.forEach(fn=>{ meta[fn] = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect[fn]); });
                meta._initialFx = Math.cos(angle); meta._initialFy = Math.sin(angle);
                // Quantum spawn muzzle cue
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.quantum) && !(game.perf && game.perf.lowFx)) {
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!reduceRings) addParticle(game.player.x + Math.cos(angle)*16, game.player.y + Math.sin(angle)*16, '#66FFFF','ring');
                    if (!(game.fxFlags && game.fxFlags.hideSparks)) addParticle(game.player.x, game.player.y, '#AAFFFF','spark');
                    meta.quantum = true; // ensure quantum flag propagates to rendering tint as telegraph
                }
                if (meta.helixPair) {
                    meta._helixSide = -1; meta._helixRadius=26; meta._helixTargetRadius=42; meta._helixPhase=0;
                    // twin spawn
                    const twinIdx = game.spawnProjectile({
                        x: game.player.x + Math.cos(angle) * 16,
                        y: game.player.y + Math.sin(angle) * 16,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: dynamicLife,
                        r: Math.max(2, Math.min(32, Math.floor(size))),
                        damage: Math.max(1, Math.floor(baseDamage*0.85)),
                        damageType:null,
                        spiralPattern: spiral,
                        sineWave: meta.sineWave,
                        wackyZigzag: meta.wackyZigzag,
                        ekgWave: meta.ekgWave,
                        homing: homing
                    });
                    const tMeta = { ...meta, _helixSide:1, baseDamage: Math.max(1, Math.floor(baseDamage*0.85)) };
                    game._projMeta.set(twinIdx, tMeta);
                }
                if (meta.convergePair) {
                    meta._convergeSpawned = true; meta._convGroup = Symbol('convTwins'); meta._convPhase='diverge'; meta._convTimer=0; meta._convPrimary=true; meta._convSide=-1;
                    const off=0.48; const baseAng=angle; // adjust main projectile velocity
                    // adjust SoA velocity directly
                    const so = game.projectilesSoA; so.vx[primaryIdx]=Math.cos(baseAng - off)*speed; so.vy[primaryIdx]=Math.sin(baseAng - off)*speed;
                    const twinIdx = game.spawnProjectile({
                        x: game.player.x + Math.cos(baseAng) * 16,
                        y: game.player.y + Math.sin(baseAng) * 16,
                        vx: Math.cos(baseAng + off) * speed,
                        vy: Math.sin(baseAng + off) * speed,
                        life: dynamicLife,
                        r: Math.max(2, Math.min(32, Math.floor(size))),
                        damage: Math.max(1, Math.floor(baseDamage*0.9)),
                        damageType:null,
                        spiralPattern: spiral,
                        sineWave: meta.sineWave,
                        wackyZigzag: meta.wackyZigzag,
                        ekgWave: meta.ekgWave,
                        homing: homing
                    });
                    const tMeta = { ...meta, _convPrimary:false, _convSide:1, baseDamage: Math.max(1, Math.floor(baseDamage*0.9)) };
                    // Link twins by index to avoid O(N) partner scans during SoA updates
                    meta._convTwin = twinIdx; tMeta._convTwin = primaryIdx;
                    game._projMeta.set(twinIdx, tMeta);
                }
                game._projMeta.set(primaryIdx, meta);
                // Time Bomb metadata (first projectile only)
                if (i === 0 && game.player.abilities.includes('Time Bomb')) {
                    meta.timeBomb = true;
                    meta._timeBombTimer = 54; meta._timeBombArmed=false; meta.piercing=true; meta.pierceCount=4; meta._timeBombExplosionMult=2.0;
                    // Slight slow: adjust velocity in SoA
                    const so = game.projectilesSoA; so.vx[primaryIdx]*=0.62; so.vy[primaryIdx]*=0.62; so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 12);
                }
                // Meteor spawn
                if (i === 0 && game.player.abilities.includes('Meteor')) {
                    const ringRadius = 180 + Math.random()*60;
                    const spawnAng = Math.random()*Math.PI*2;
                    const spawnX = game.player.x + Math.cos(spawnAng) * ringRadius;
                    const spawnY = game.player.y + Math.sin(spawnAng) * ringRadius - (120 + Math.random()*80);
                    const targetRadius = 140; const targetAng = Math.random()*Math.PI*2;
                    const targetX = game.player.x + Math.cos(targetAng) * (40 + Math.random()*targetRadius);
                    const targetY = game.player.y + Math.sin(targetAng) * (40 + Math.random()*targetRadius);
                    const travelTime = 70 + Math.floor(Math.random()*35);
                    const mIdx = game.spawnProjectile({ x:spawnX,y:spawnY,vx:(targetX-spawnX)/travelTime, vy:(targetY-spawnY)/travelTime, life: travelTime+6, r:20, damage: Math.floor(baseDamage*2.6+45), damageType:'fire' });
                    const mMeta = { meteor:true, _meteorAoeRadius:90, _meteorDetonateAt: game.frame + travelTime, _meteorKnockback:120, _meteorTargetX:targetX, _meteorTargetY:targetY, baseDamage: Math.floor(baseDamage*2.6+45) };
                    game._projMeta.set(mIdx, mMeta);
                    if (!game.meteorMarkers) game.meteorMarkers = [];
                    game.meteorMarkers.push({ x:targetX, y:targetY, created:Date.now(), life:(travelTime/60)*1000, pulse:0, _explodeFrame:mMeta._meteorDetonateAt });
                    mMeta._meteorMarkerId = game.meteorMarkers.length -1;
                    for (let t=0;t<12;t++) addParticle(spawnX + (Math.random()-0.5)*18, spawnY + (Math.random()-0.5)*18, '#FFBB66','spark');
                }
                // Popcorn (SoA): mark the primary as a kernel that will pop later
                if (i === 0 && game.player.abilities.includes('Popcorn')) {
                    meta.isPopcornKernel = true;
                    meta._popFuse = 36; // extended fuse for farther travel before popping
                    meta._popDid = false;
                    // Reduce kernel base damage and reflect into SoA numeric channel
                    meta.baseDamage = Math.max(1, Math.floor(meta.baseDamage * 0.55));
                    const so = game.projectilesSoA; so.damage[primaryIdx] = meta.baseDamage;
                    // Store per-kernel pop scaling derived from current multishot amount
                    const multi = Math.max(1, baseMultiBeforePattern || 1);
                    meta._popPuffs = Math.min(6, 2 + Math.floor((multi - 1) / 4));
                    meta._popBursts = Math.min(6, 2 + Math.floor((multi - 1) / 3));
                }
                // Umbrella Shot (SoA): designate first projectile as umbrella core
                if (i === 0 && game.player.abilities.includes('Umbrella Shot')) {
                    meta.umbrellaCore = true;
                    meta._umbOriginX = game.player.x;
                    meta._umbOriginY = game.player.y;
                    meta._umbTravel = 0;
                    meta._umbSplitDistance = 96;
                    meta._umbDidSplit = false;
                    meta._umbCoreAge = 0;
                    // Ensure enough life to reach split distance
                    const so = game.projectilesSoA; if (so.life[primaryIdx] < 120) { so.life[primaryIdx] = 120; so.lifeMax[primaryIdx] = 120; }
                }
                // Pulse Rifle (SoA): emit a short burst of 3 shots (primary + 2 quick companions)
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'pulse' && ABILITIES[a].effect.burstFire)) {
                    const so = game.projectilesSoA;
                    const dmgBase = calculateDamage();
                    // Two companion shots with slight angular offsets and slightly faster speed
                    for (let b = 0; b < 2; b++) {
                        const off = (b === 0 ? -0.06 : 0.06);
                        const ang = Math.atan2(so.vy[primaryIdx], so.vx[primaryIdx]) + off;
                        const idxB = game.spawnProjectile({
                            x: game.player.x + Math.cos(ang) * 20,
                            y: game.player.y + Math.sin(ang) * 20,
                            vx: Math.cos(ang) * (speed * 1.1),
                            vy: Math.sin(ang) * (speed * 1.1),
                            life: dynamicLife,
                            r: Math.max(2, Math.min(18, Math.floor(size * 0.8))),
                            damage: Math.floor(dmgBase * 0.8),
                            damageType: null,
                            sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                            wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                            ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                            spiralPattern: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idxB, { pulseBurst:true, baseDamage:dmgBase, energyType:'pulse', piercing:false, pierceCount:1, lifeSteal:0 });
                    }
                }

                // Diarrhea: spawn a rear-shot brown oval per projectile (SoA path; scales with multi-shot)
                if (game.player.abilities.includes('Diarrhea')) {
                    const rearAng = angle + Math.PI;
                    const dmgBase = (typeof baseDamage !== 'undefined' ? baseDamage : calculateDamage());
                    // Make it larger and last longer for much more travel time
                    const rearLife = Math.max(90, Math.floor(((typeof dynamicLife !== 'undefined' ? dynamicLife : 60)) * 1.7));
                    const rearRadius = Math.max(10, Math.floor(size * 1.55));
                    const rIdx = game.spawnProjectile({
                        x: game.player.x - Math.cos(angle) * 16,
                        y: game.player.y - Math.sin(angle) * 16,
                        vx: Math.cos(rearAng) * (speed * 0.9),
                        vy: Math.sin(rearAng) * (speed * 0.9),
                        life: rearLife,
                        r: rearRadius,
                        damage: Math.floor(dmgBase * 0.9),
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiralPattern: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    // Allow shape/size changes while enforcing brown-only visuals; copy pattern flags into metadata for SoA updaters
                    // Also propagate Uzumaki (global spiral) so the rear-shot is affected the same as primaries
                    const md = {
                        baseDamage: Math.floor(dmgBase * 0.9),
                        _diarrheaBrown: true,
                        growing: game.player.abilities.includes('Growing Shot'),
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiral: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern),
                        pendulumPattern: game.player.abilities.includes('Pendulum Shot'),
                        pivotPattern: game.player.abilities.includes('Vector Pivot')
                    };
                    if (hasUzumaki) {
                        md.hasUzumaki = true;
                        md._uzuCx = game.player.x;
                        md._uzuCy = game.player.y;
                        md._uzuAngle = rearAng; // seed; updater derives from position too
                        md._uzuRadius = 16;
                        md._uzuAngularVel = 0.18 + Math.random()*0.05;
                        md._uzuRadialVel = 1.35 + Math.random()*0.35;
                        md._uzuDrag = 0.000;
                    }
                    game._projMeta.set(rIdx, md);
                }
                continue; // fully handled via SoA metadata

                // Multi-Infusion overlay: attach active infusion elements
                if (game.player && game.player.infusions && game.player.infusions.length) {
                    projectile.infusionElements = game.player.infusions.map(i => ({ type: i.type, potency: i.potency }));
                    // If projectile has no inherent damageType, pick the strongest infusion as primary displayed damageType (for color numbers)
                    if (!projectile.damageType) {
                        let chosen = null; let best = -1;
                        game.player.infusions.forEach(i => { if (i.potency > best) { best = i.potency; chosen = i.type; } });
                        projectile.damageType = chosen;
                    } else {
                        // Already elemental; small additive damage from each infusion (applied later) - mark flag
                        projectile._elementalCore = true;
                    }
                }

                // Toenail Clibbins: emit a cluster of random yellow crescent clippings once per attack primary projectile
                if (i === 0 && game.player.abilities.includes('Toenail Clibbins')) {
                    // Spawn 46 crescents each attack cycle
                    const crescents = 4 + Math.floor(Math.random()*3);
                    for (let c=0;c<crescents;c++) {
                        const ang = Math.random() * Math.PI * 2;
                        // Range Tuning: slight speed increase + higher base life to extend outward arc.
                        // Previous: spd 3.15.1, life 5482
                        // New:     spd 3.45.4, life 78118 (~+45% median travel distance)
                        const spd = 3.4 + Math.random()*2.0;
                        const life = 78 + Math.floor(Math.random()*40);
                        const size = 11 + Math.floor(Math.random()*3);
                        const thicknessRatio = 0.35 + Math.random()*0.25; // controls crescent thickness
                        const arcSweep = (Math.PI * (0.85 + Math.random()*0.25)); // length of visible arc
                        const innerOffset = 0.30 + Math.random()*0.15; // how far to offset inner cut to shape
                        const tintShift = (Math.random()*18 - 9); // slight hue/value shift later
                        game.spawnProjectile({
                            x: game.player.x, y: game.player.y,
                            vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
                            life, size, enemy:false,
                            baseDamage: Math.max(1, Math.floor((projectile.baseDamage||calculateDamage()) * 0.38)),
                            damage: Math.max(1, Math.floor((projectile.baseDamage||calculateDamage()) * 0.38)),
                            toenail:true,
                            _crescentPhase: Math.random()*Math.PI*2,
                            _crescentDir: (Math.random()<0.5?-1:1),
                            _tnThickness: thicknessRatio,
                            _tnArcSweep: arcSweep,
                            _tnInnerOffset: innerOffset,
                            _tnTintShift: tintShift
                        });
                    }
                }

                // Popcorn: replace primary projectile with a kernel that later pops into:
                //  - Two random-direction "kernel burst" mini bullets (new)
                //  - Two angled puffs (existing)
                //  - Each puff still produces crumbs on impact (existing chain)
                // Extended fuse increases forward travel distance for better spacing before proliferation.
                if (i === 0 && game.player.abilities.includes('Popcorn')) {
                    // Mark in metadata instead of mutating legacy projectile object
                    meta.isPopcornKernel = true;
                    meta._popFuse = 36; // extended fuse for farther travel
                    meta._popDid = false;
                    // Adjust stored baseDamage for kernel (SoA damage already set from baseDamage)
                    meta.baseDamage = Math.max(1, Math.floor(meta.baseDamage * 0.55));
                    // Reflect reduced damage into SoA numeric channel
                    const so = game.projectilesSoA; so.damage[primaryIdx] = meta.baseDamage;
                }

                // Umbrella Shot: designate the FIRST projectile of the attack as the umbrella core.
                // It will travel a short distance then split into two arc projectiles that swing overhead and return.
                if (i === 0 && game.player.abilities.includes('Umbrella Shot')) {
                    meta.umbrellaCore = true;
                    meta._umbOriginX = game.player.x;
                    meta._umbOriginY = game.player.y;
                    meta._umbTravel = 0;
                    meta._umbSplitDistance = 180; // travel further before splitting
                    meta._umbDidSplit = false;
                    meta._umbCoreAge = 0;
                    // Ensure sufficient lifetime in SoA array
                    const so = game.projectilesSoA; if (so.life[primaryIdx] < 160) { so.life[primaryIdx] = 160; so.lifeMax[primaryIdx] = 160; }
                }

                // Laser Beam special-case: continuous beam energy weapon
                // If player has Laser Beam (energyType: 'laser' and continuous=true), spawn a short-lived beam segment
                if (projectile.energyType === 'laser' && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.continuous)) {
                    // beam segments are shorter-lived and tile along forward direction while holding fire
                    projectile.size = 8;
                    projectile.life = 18; // lifespan of each segment (frames)
                    projectile.vx = Math.cos(angle) * 12;
                    projectile.vy = Math.sin(angle) * 12;
                    projectile.beam = true;
                    projectile.beamOwner = 'player';
                    projectile.damage = calculateDamage();
                    // Beam pattern blending: inherit motion flags for visual modulation, not trajectory displacement
                    projectile.sineWave = projectile.sineWave || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave);
                    projectile.wackyZigzag = projectile.wackyZigzag || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag);
                    projectile.ekgWave = projectile.ekgWave || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave);
                    projectile.spiral = projectile.spiral || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern);
                    projectile._beamPatternPhase = 0;
                }
                // Particle Beam (SoA)
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'particle')) {
                    const beamAngle = angle;
                    const dmgBase = calculateDamage();
                    const idx = game.spawnProjectile({
                        x: game.player.x + Math.cos(beamAngle) * 8,
                        y: game.player.y + Math.sin(beamAngle) * 8,
                        vx: Math.cos(beamAngle) * 9,
                        vy: Math.sin(beamAngle) * 9,
                        life: 28,
                        r: 7,
                        damage: Math.floor(dmgBase * 1.6) + 8,
                        damageType: 'plasma',
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiralPattern: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    game._projMeta.set(idx, { beam:true, particleBeam:true, beamOwner:'player', baseDamage:dmgBase, energyType:'particle', _beamPatternPhase:0, infusionElements: (game.player.infusions && game.player.infusions.length) ? game.player.infusions.map(i=>({type:i.type,potency:i.potency})) : null });
                }

                // Pulse Rifle: emit a short burst of 3 shots quickly instead of single projectile
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'pulse' && ABILITIES[a].effect.burstFire)) {
                    for (let b=0;b<2;b++) {
                        const ang = angle + (b===0?-0.06:0.06);
                        const dmgBase = calculateDamage();
                        const idx = game.spawnProjectile({
                            x: game.player.x + Math.cos(ang) * 20,
                            y: game.player.y + Math.sin(ang) * 20,
                            vx: Math.cos(ang) * (speed * 1.1),
                            vy: Math.sin(ang) * (speed * 1.1),
                            life: 36,
                            r: Math.max(2, Math.min(18, Math.floor(size*0.8))),
                            damage: Math.floor(dmgBase * 0.8),
                            damageType: null,
                            sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                            wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                            ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave)
                        });
                        if (!game._projMeta) game._projMeta=new Map();
                        game._projMeta.set(idx,{ pulseBurst:true, baseDamage:dmgBase, energyType:'pulse', piercing:false, pierceCount:1, lifeSteal:0 });
                    }
                }
                // Diarrhea: spawn a rear-shot brown oval once per attack
                if (i === 0 && game.player.abilities.includes('Diarrhea')) {
                    const rearAng = angle + Math.PI;
                    const dmgBase = calculateDamage();
                    const rIdx = game.spawnProjectile({
                        x: game.player.x - Math.cos(angle) * 16,
                        y: game.player.y - Math.sin(angle) * 16,
                        vx: Math.cos(rearAng) * (speed * 0.9),
                        vy: Math.sin(rearAng) * (speed * 0.9),
                        life: 42,
                        r: Math.max(6, Math.floor(size * 1.1)),
                        damage: Math.floor(dmgBase * 0.9),
                        // Carry pattern flags so object-mode update hooks can act (render stays brown-only)
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiral: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    // Allow shape/size changes from other abilities (e.g., Growing Shot) while enforcing brown-only visuals
                    // Propagate pattern flags and Uzumaki metadata so the rear-shot respects pattern alterations
                    const md = {
                        baseDamage: Math.floor(dmgBase * 0.9),
                        _diarrheaBrown: true,
                        growing: game.player.abilities.includes('Growing Shot'),
                        pendulumPattern: game.player.abilities.includes('Pendulum Shot'),
                        pivotPattern: game.player.abilities.includes('Vector Pivot'),
                        // Mirror object-mode flags for consistency (update loop reads either proj flags or metadata)
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiral: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    };
                    if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.uzumaki)) {
                        md.hasUzumaki = true;
                        md._uzuCx = game.player.x;
                        md._uzuCy = game.player.y;
                        md._uzuAngle = rearAng;
                        md._uzuRadius = 16;
                        md._uzuAngularVel = 0.18 + Math.random()*0.05;
                        md._uzuRadialVel = 1.35 + Math.random()*0.35;
                        md._uzuDrag = 0.000;
                    }
                    game._projMeta.set(rIdx, md);
                }

                // Teleport on spawn: instant blink forward a short distance
                if (projectile.teleporting) {
                    // New behavior: Teleport Shot relocates EACH fired projectile (including multi-shot patterns)
                    // to a random position within a radius around the player, then resumes forward travel.
                    // This occurs only once at spawn. We attempt to find a non-wall location.
                    // Tunable teleport field radius (reduced from 140 to tighten spread for better accuracy)
                    const TELEPORT_SHOT_RADIUS = 88; // px (adjust here for balance)
                    const maxRadius = TELEPORT_SHOT_RADIUS;
                    const attempts = 12;
                    const origX = projectile.x;
                    const origY = projectile.y;
                    let placed = false;
                    for (let a = 0; a < attempts; a++) {
                        // Biased random point: favor nearer teleports so shots stay relatively close.
                        // Use pow(rand, 1.35) to skew toward smaller radii (1 => uniform, >1 => bias inward)
                        const r = Math.pow(Math.random(), 1.35) * maxRadius;
                        const theta = Math.random() * Math.PI * 2;
                        let nx = game.player.x + Math.cos(theta) * r;
                        let ny = game.player.y + Math.sin(theta) * r;
                        // Clamp to arena bounds with small margin
                        const margin = 30;
                        nx = Math.max(margin, Math.min(nx, canvas.width - margin));
                        ny = Math.max(margin, Math.min(ny, canvas.height - margin));
                        if (!isWall(nx, ny, Math.max(10, projectile.size))) {
                            projectile.x = nx;
                            projectile.y = ny;
                            placed = true;
                            break;
                        }
                    }
                    // Visual effects: portal burst at destination + faint trail from origin
                    const trailSteps = 6;
                    for (let i=0;i<trailSteps;i++) {
                        const t = i / (trailSteps - 1);
                        const ix = origX + (projectile.x - origX) * t;
                        const iy = origY + (projectile.y - origY) * t;
                        if (Math.random() < 0.6) addParticle(ix + (Math.random()-0.5)*8, iy + (Math.random()-0.5)*8, '#FFE4AA', 'spark');
                    }
                    for (let p=0;p<10;p++) {
                        addParticle(projectile.x + (Math.random()-0.5)*24, projectile.y + (Math.random()-0.5)*24, '#FFDFAA', 'spark');
                    }
                    // Synergy: augment portal visuals depending on other pattern flags
                    if (projectile.spiral) {
                        for (let s=0;s<8;s++) addParticle(projectile.x, projectile.y, '#FFC877', 'explosion');
                    }
                    if (projectile.sineWave) {
                        for (let w=0;w<6;w++) addParticle(projectile.x + Math.sin(w)*18, projectile.y + Math.cos(w)*18, '#FFF2CC', 'spark');
                    }
                    if (projectile.wackyZigzag) {
                        for (let z=0;z<5;z++) addParticle(projectile.x + (Math.random()-0.5)*30, projectile.y + (Math.random()-0.5)*30, '#FFE0AA', 'spark');
                    }
                    if (projectile.ekgWave) {
                        for (let e=0;e<6;e++) addParticle(projectile.x + (Math.random()-0.5)*14, projectile.y + (Math.random()-0.5)*38, '#FFF6DD', 'spark');
                    }
                }
                if (projectile.meteor) {
                    // Gentle steering toward telegraphed target
                    if (projectile._meteorTargetX != null) {
                        const dxT = projectile._meteorTargetX - projectile.x;
                        projectile.vx = dxT / 140; // slower correction for natural descent
                    }
                    // Impact check: when reaching target Y (or bottom safety) trigger explosion once
                    if (!projectile._meteorDetonated && projectile.y >= (projectile._meteorTargetY || (canvas.height*0.6))) {
                        projectile._meteorDetonated = true;
                        const aoe = projectile._meteorAoeRadius || 80;
                        const dmg = projectile.baseDamage || calculateDamage();
                        // Damage enemies in radius
                        game.enemies.forEach(en => {
                            const dx = en.x - projectile.x; const dy = en.y - projectile.y;
                            if (dx*dx + dy*dy <= aoe*aoe) {
                                en.health -= dmg;
                                addDamageNumber(dmg, en.x, en.y - en.size/2, { type:'fire'});
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                            }
                        });
                        // Visual explosion + screen shake
                        addScreenShake(10);
                        explodeProjectile({x:projectile.x,y:projectile.y,size:projectile.size}, Math.floor(dmg*0.6));
                        for (let p=0;p<30;p++) addParticle(projectile.x + (Math.random()-0.5)*aoe*1.4, projectile.y + (Math.random()-0.5)*aoe*1.4, '#FF8844','explosion');
                        // Clear marker if still present
                        if (typeof projectile._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[projectile._meteorMarkerId]) {
                            game.meteorMarkers[projectile._meteorMarkerId].life = 0; // let render prune it
                        }
                        projectile.life = 0; // remove meteor projectile
                    }
                }
                // (Legacy projectile object push removed  all spawning handled via SoA earlier.)
                // Rear clone (Diarrhea) already handled in core SoA firing path earlier.
                // Weapon-type: Sword Throw -> convert base projectile into spinning blade instead of spawning an extra blocky projectile
                if (projectile.weaponType === 'sword') {
                    // Re-shape / flag existing projectile for sword rendering (drawing code branches on weaponType)
                    projectile.size = Math.max(projectile.size || 10, 14);
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.spin = true;
                    projectile.spinAngle = angle;
                    projectile.spinSpeed = 0.45;
                    // Slightly slow it for readability
                    projectile.vx *= 0.85;
                    projectile.vy *= 0.85;
                    // Shorter lifespan so it feels like a thrown arc
                    projectile.life = Math.min(projectile.life, 34);
                    addParticle(projectile.x, projectile.y, '#CCCCCC', 'spark');
                }
                // Weapon-type: Axe Hurl - heavy single projectile with knockback
                if (projectile.weaponType === 'axe') {
                    projectile.size = Math.max(projectile.size, 16);
                    // If projectile was flagged as growing, ensure its baseline reflects post-weapon inflation so growth can continue.
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.6 + 12);
                    projectile.knockback = true;
                    projectile.piercing = false;
                    projectile.slowOnHit = true;
                }
                // Spear Thrust: ensure strong piercing behavior
                if (projectile.weaponType === 'spear') {
                    projectile.piercing = true;
                    projectile.pierceCount = Math.max(projectile.pierceCount || 3, 4);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.2 + 6);
                }
                // Hammer Slam: heavy knockback and stun on impact
                if (projectile.weaponType === 'hammer') {
                    projectile.size = Math.max(projectile.size, 18);
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.8 + 10);
                    projectile._hammer = true; // handle stun in collision
                }
                // Removed dead projectile.instantTravel branch; Photon Torpedo handled during fire by ability check.
            }
            // Screen shake for shooting
            // Shockwave ability: emit one traveling wave per attack (cooldown gated)
            if (game.player.abilities && game.player.abilities.includes('Shockwave')) {
                const nowSW = Date.now();
                const swCooldown = 600; // ms
                if (!game._lastShockwave || nowSW - game._lastShockwave >= swCooldown) {
                    const dir = game.player.lastDirection || {x:1,y:0};
                    const ang = Math.atan2(dir.y, dir.x);
                    spawnShockwave(game.player.x, game.player.y, ang);
                    game._lastShockwave = nowSW;
                }
            }
            addScreenShake(2);
        }

    // Dynamic orbital management moved into ensureOrbitals() (called each frame in update())
    function ensureOrbitals() {
            if (!game.player) return;
            const hasOrbital = game.player.abilities && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.orbital);
            if (!hasOrbital) {
                // Clean up existing orbital metadata by marking any meta entries with _orbital for recycling
                if (game._projMeta) {
                    for (const [idx, meta] of game._projMeta.entries()) {
                        if (meta && meta._orbital) {
                            // Recycle projectile slot directly
                            if (game.recycleProjectile) game.recycleProjectile(idx);
                            game._projMeta.delete(idx);
                        }
                    }
                }
                return;
            }
            // Determine current orbital indices from metadata
            let existing = [];
            if (game._projMeta) {
                for (const [idx, meta] of game._projMeta.entries()) if (meta && meta._orbital) existing.push(idx);
            }
            // Track respawn cooldown
            if (!game._orbitalRegen) game._orbitalRegen = { nextAt: 0 };
            // Derive desired count using multi-shot style bonuses (simplified mirror of attack logic)
            let multiShotCount = 0; let shotgunBlast = false;
            game.player.abilities.forEach(ab => { const data = ABILITIES[ab]; if (!data||!data.effect) return; if (data.effect.projectileCount) multiShotCount += data.effect.projectileCount; if (data.effect.shotgunBlast) shotgunBlast = true; });
            let desired = 2;
            if (shotgunBlast) desired = multiShotCount + 5; else if (multiShotCount > 0) desired = multiShotCount; else desired = 2;
            if (desired < 2) desired = 2; desired = Math.min(desired, 40);
            // Adjust counts: trim or spawn
            if (existing.length > desired) {
                // Recycle extras beyond desired
                const toRemove = existing.slice(desired);
                toRemove.forEach(idx => { if (game.recycleProjectile) game.recycleProjectile(idx); if (game._projMeta) game._projMeta.delete(idx); });
                existing = existing.slice(0, desired);
            }
            if (existing.length < desired) {
                const now = performance.now();
                if (now < game._orbitalRegen.nextAt) {
                    // too soon to respawn; skip this frame
                } else {
                if (!game._projMeta) game._projMeta = new Map();
                const needed = desired - existing.length;
                const sineWave = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.sineWave);
                const wackyZigzag = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.wackyZigzag);
                const ekgWave = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.ekgWave);
                const spiralPattern = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.spiralPattern);
                for (let s=0; s<needed; s++) {
                    const baseRadius = 72 + Math.min(36, desired * 1.2);
                    const idx = game.spawnProjectile({
                        x: game.player.x + baseRadius, // provisional placement at angle 0; re-spaced below
                        y: game.player.y,
                        vx: 0, vy:0,
                        r: 6,
                        life: 99999,
                        damage: 0 // purely positional / cosmetic until collision logic optionally added
                    });
                    if (idx >= 0) {
                        game._projMeta.set(idx, {
                            _orbital:true,
                            _orbitAngle:0,
                            _orbitRadius: baseRadius,
                            _orbitSpeed: 0.055 + Math.random()*0.035,
                            sineWave: sineWave,
                            wackyZigzag: !sineWave && wackyZigzag,
                            ekgWave: !sineWave && !wackyZigzag && ekgWave,
                            spiral: spiralPattern,
                            spinAngle:0,
                            spinSpeed: spiralPattern ? (0.25 + Math.random()*0.2) : 0,
                            _inheritedPattern:true
                        });
                        existing.push(idx);
                    }
                }
                // set a small regen cooldown to avoid instant spam on mass loss
                game._orbitalRegen.nextAt = now + 450; // ms
                }
            }
            // Animate orbit: increment each orbital's angle and place around player
            if (game.projectilesSoA && existing.length) {
                const { x, y } = game.projectilesSoA;
                const baseSpin = 0.045; // rad/frame baseline
                for (let i=0;i<existing.length;i++) {
                    const idx = existing[i];
                    const meta = game._projMeta.get(idx); if (!meta) continue;
                    // Initialize angle based on slot if not set, to distribute around
                    if (meta._orbitAngle == null) meta._orbitAngle = (i / existing.length) * Math.PI * 2;
                    // Per-orbital spin speed with small variance (respect any existing _orbitSpeed)
                    const spd = (typeof meta._orbitSpeed === 'number' ? meta._orbitSpeed : (baseSpin + i*0.002)) * 1.0;
                    meta._orbitAngle += spd;
                    // Keep within 0..2PI to avoid float growth
                    if (meta._orbitAngle > Math.PI*2) meta._orbitAngle -= Math.PI*2;
                    // Optional tiny breathing on radius for life
                    const breathe = 1 + Math.sin((game.frame||0)*0.02 + i*0.7) * 0.03;
                    const rad = meta._orbitRadius * breathe;
                    x[idx] = game.player.x + Math.cos(meta._orbitAngle) * rad;
                    y[idx] = game.player.y + Math.sin(meta._orbitAngle) * rad;
                }
            }
        }

        // --- Beartrap Ability ---
        function dropBeartrap() {
            if (!game.traps) game.traps = [];
            const MAX_TRAPS = 12;
            if (game.traps.length >= MAX_TRAPS) {
                game.traps.sort((a,b)=>a.created-b.created);
                game.traps.splice(0,1);
            }
            game.traps.push({
                x: game.player.x,
                y: game.player.y,
                radius: 20,
                created: Date.now(),
                triggered: false,
                triggerTime: 0,
                damage: Math.floor(calculateDamage() * 2.2),
                immobilizeMs: 5000
            });
        }

        function updateTraps() {
            if (!game.traps) return;
            const now = Date.now();
            for (let i = game.traps.length - 1; i >= 0; i--) {
                const trap = game.traps[i];
                if (!trap.triggered && now - trap.created > 60000) { game.traps.splice(i,1); continue; }
                if (trap.triggered && now - trap.triggerTime > 800) { game.traps.splice(i,1); continue; }
                if (!trap.triggered) {
                    for (const enemy of game.enemies) {
                        const dx = enemy.x - trap.x;
                        const dy = enemy.y - trap.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < trap.radius) {
                            enemy.health -= trap.damage;
                            // Standardize on frame-based stunTime for reliability and keep a timestamp backup
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, Math.floor(trap.immobilizeMs / 16)); // convert ms -> frames
                            enemy._trapImmobilizeUntil = Date.now() + trap.immobilizeMs; // fallback timestamp in case frame timer desyncs
                            delete enemy.stunnedTime; // remove ms-based variant to avoid confusion
                            addParticle(trap.x, trap.y, '#CCCCCC', 'impact');
                            addDamageNumber(trap.damage, enemy.x, enemy.y - enemy.size, { type:'physical' });
                            trap.triggered = true;
                            trap.triggerTime = now;
                            addScreenShake(3);
                            break;
                        }
                    }
                }
            }
        }

        // --- Punji Pit Ability ---
        function dropPunjiPit() {
            if (!game.pits) game.pits = [];
            const MAX_PITS = 10;
            if (game.pits.length >= MAX_PITS) {
                game.pits.sort((a,b)=>a.created-b.created);
                game.pits.splice(0,1);
            }
            game.pits.push({
                x: game.player.x,
                y: game.player.y,
                radius: 28,
                created: Date.now(),
                duration: 15000, // 15s field
                damageTick: Math.floor(calculateDamage() * 0.5),
                tickInterval: 800, // ms between repeat ticks per enemy
                enemiesHit: {}, // track last tick time per enemy id/hash
                poison: true,
                // Precompute spike layout for consistent rendering (array of {x,y,h,lean})
                spikes: (function(){
                    const arr = [];
                    const count = 18; // dense cluster
                    for (let i=0;i<count;i++) {
                        // random point inside inner disc (avoid edge so heads visible)
                        const ang = Math.random()*Math.PI*2;
                        const rad = Math.sqrt(Math.random()) * 0.75; // bias toward center
                        const rx = Math.cos(ang)*rad;
                        const ry = Math.sin(ang)*rad;
                        const h = 10 + Math.random()*14; // spike height
                        const lean = (Math.random()-0.5)*0.4; // slight lean factor for top offset
                        arr.push({ x: rx, y: ry, h, lean });
                    }
                    return arr;
                })()
            });
        }

        function updatePits() {
            if (!game.pits) return;
            const now = Date.now();
            for (let i = game.pits.length - 1; i >= 0; i--) {
                const pit = game.pits[i];
                if (now - pit.created > pit.duration) { game.pits.splice(i,1); continue; }
                // process enemies
                for (const enemy of game.enemies) {
                    const dx = enemy.x - pit.x;
                    const dy = enemy.y - pit.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < pit.radius) {
                        const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                        const last = pit.enemiesHit[key] || 0;
                        if (now - last >= pit.tickInterval) {
                            // apply damage over time tick
                            enemy.health -= pit.damageTick;
                            addDamageNumber(pit.damageTick, enemy.x, enemy.y - enemy.size, { type:'poison' });
                            enemy.poisoned = true;
                            enemy.poisonTime = Math.max(enemy.poisonTime || 0, 180); // 3s poison baseline or refresh
                            pit.enemiesHit[key] = now;
                            if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#55FF55', 'poison');
                        }
                    }
                }
            }
        }

        function updateEnemies() {
            game.enemies.forEach(enemy => {
                // If enemy is currently under Rizz pull animation, we only interpolate position (handled elsewhere) and skip AI.
                if (enemy._rizzPull && enemy._rizzPull.active) {
                    // decay fear timer if already applied (post pull) else defer.
                    return; // skip rest of processing this frame until pull completes
                }

                        // === Enemy Spatial Hash (mirrors projectile hash) ===
                        (function initEnemyHash(){
                            const CELL = 64; // same as projectile hash for simplicity
                            game.enemyHash = { cell:CELL, buckets:new Map(), frame:0 };
                            function key(cx,cy){ return (cx<<16)^cy; }
                            game.rebuildEnemyHash = function(){
                                const buckets = game.enemyHash.buckets; buckets.clear();
                                const cs = CELL;
                                for (let i=0;i<game.enemies.length;i++){
                                    const e = game.enemies[i]; if(!e || e.dead || e.health<=0) continue;
                                    const cx = (e.x/cs)|0; const cy = (e.y/cs)|0;
                                    const k = key(cx,cy); let arr = buckets.get(k); if(!arr){ arr=[]; buckets.set(k,arr);} arr.push(i);
                                }
                                game.enemyHash.frame++;
                            };
                        })();
                // Status effects
                const nowTs = Date.now();
                // Decay crushed timer
                if (enemy.crushedTimer && enemy.crushedTimer > 0) {
                    enemy.crushedTimer -= 16; // approximate per-frame ms
                    if (enemy.crushedTimer < 0) enemy.crushedTimer = 0;
                }
                // Armor shred decay: every ~2200ms remove one stack
                if (enemy.armorShredded && enemy.armorShredded > 0) {
                    if (!enemy._armorShredDecay) enemy._armorShredDecay = nowTs;
                    if (nowTs - enemy._armorShredDecay > 2200) {
                        enemy.armorShredded = Math.max(0, enemy.armorShredded - 1);
                        enemy._armorShredDecay = nowTs;
                    }
                }
                // Freeze stack decay (if not refreshed)
                if (enemy.freezeStacks && enemy.freezeStacks > 0) {
                    if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                        enemy.frozenTimer -= 16;
                        if (enemy.frozenTimer <= 0) enemy.frozenTimer = 0; // will rely on stack decay afterwards
                    }
                    if (enemy.lastFreezeHit && nowTs - enemy.lastFreezeHit > 2000 && !enemy.frozenTimer) {
                        enemy.freezeStacks--;
                        enemy.lastFreezeHit = nowTs; // reset so further decay is spaced
                        if (enemy.freezeStacks <= 0) {
                            enemy.freezeStacks = 0; delete enemy.lastFreezeHit;
                        }
                    }
                }
                if (enemy.poisoned) {
                    enemy.poisonTime--;
                    if (enemy.poisonTime <= 0) {
                        enemy.poisoned = false;
                    } else {
                        let poisonTick = 0.8;
                        const abil = game.player.abilities;
                        const hasVoid = abil.includes('Void Shot') || abil.includes('Black Hole');
                        const hasFire = abil.includes('Fire Shot') || abil.includes('Inferno') || abil.includes('Magma Shot');
                        if (hasVoid) poisonTick *= 1.25; // void amplifies decay
                        if (hasFire) poisonTick *= 1.12; // fire + poison magma synergy
                        enemy.health -= poisonTick;
                        if (Math.random() < 0.1) {
                            addParticle(enemy.x, enemy.y, '#44FF44', 'poison');
                        }
                    }
                }
                
                if (enemy.burning) {
                    enemy.burnTime--;
                    if (enemy.burnTime <= 0) {
                        enemy.burning = false;
                    } else {
                        let burnTick = 1.2;
                        const abil = game.player.abilities;
                        const hasWind = abil.includes('Wind Blade') || abil.includes('Blizzard');
                        const hasPoison = abil.includes('Poison Shot') || abil.includes('Toxic Cloud') || abil.includes('Silent But Deadly');
                        if (hasWind) burnTick *= 1.15; // oxygen fan effect
                        if (hasPoison) burnTick *= 1.10; // toxic combustion
                        enemy.health -= burnTick;
                        if (Math.random() < 0.2) {
                            addParticle(enemy.x, enemy.y, '#FF4444', 'fire');
                        }
                    }
                }
                
                if (enemy.slowed) {
                    enemy.slowTime--;
                    if (enemy.slowTime <= 0) {
                        enemy.slowed = false;
                    }
                }
                // Blind status decay: reduces detection and accuracy
                if (enemy.blinded) {
                    enemy.blindTime = (enemy.blindTime || 0) - 1;
                    if (enemy.blindTime <= 0) {
                        enemy.blinded = false; enemy.blindTime = 0;
                    } else {
                        // Occasional disoriented shuffle (random small drift)
                        if (Math.random() < 0.02) {
                            enemy._blindWanderAngle = Math.random()*Math.PI*2;
                        }
                        if (enemy._blindWanderAngle != null) {
                            enemy.x += Math.cos(enemy._blindWanderAngle) * 0.4;
                            enemy.y += Math.sin(enemy._blindWanderAngle) * 0.4;
                        }
                    }
                }
                
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Process smooth knockback BEFORE stun/freeze early returns so sliding occurs even if stunned.
                if (enemy.kbFrames && enemy.kbFrames > 0 && (enemy.kbVX || enemy.kbVY)) {
                    // Move enemy by current knockback velocity
                    let nx = enemy.x + enemy.kbVX;
                    let ny = enemy.y + enemy.kbVY;
                    // Wall collision: if blocked, zero out remaining knockback to avoid jitter
                    if (!isWall(nx, ny, enemy.size/2)) {
                        enemy.x = nx; enemy.y = ny;
                    } else {
                        enemy.kbFrames = 0; enemy.kbVX = 0; enemy.kbVY = 0; enemy._knockbacking = false;
                    }
                    // Apply decay
                    const decay = enemy._kbDecay || 0.88;
                    enemy.kbVX *= decay; enemy.kbVY *= decay;
                    enemy.kbFrames--;
                    // Edge clamp handled globally after all movement; local failsafe (hard clamp to canvas bounds using size)
                    const r = enemy.size || 16;
                    const minX = r; const maxX = canvas.width - r;
                    const minY = r; const maxY = canvas.height - r;
                    if (enemy.x < minX) { enemy.x = minX; if (enemy.kbVX < 0) enemy.kbVX = 0; }
                    if (enemy.x > maxX) { enemy.x = maxX; if (enemy.kbVX > 0) enemy.kbVX = 0; }
                    if (enemy.y < minY) { enemy.y = minY; if (enemy.kbVY < 0) enemy.kbVY = 0; }
                    if (enemy.y > maxY) { enemy.y = maxY; if (enemy.kbVY > 0) enemy.kbVY = 0; }
                    if (enemy.kbFrames <= 0 || (Math.abs(enemy.kbVX) < 0.1 && Math.abs(enemy.kbVY) < 0.1)) {
                        enemy.kbFrames = 0; enemy.kbVX = 0; enemy.kbVY = 0; enemy._knockbacking = false;
                    }
                    // Generic sliding feedback
                    if (Math.random() < 0.10) addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.4, enemy.y + enemy.size*0.4, '#FFFFFF', 'spark');
                    // Earth-style debris (brown / stone chips) when flagged
                    if (enemy._earthKBFrames && enemy._earthKBFrames > 0) {
                        enemy._earthKBFrames--;
                        if (Math.random() < 0.45) {
                            const debrisColor = Math.random() < 0.5 ? '#6b4a2b' : '#4a3420';
                            addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.6, enemy.y + (Math.random()-0.2)*enemy.size*0.5, debrisColor, 'spark');
                        }
                    }
                    // Skip AI movement & attack this frame while in knockback motion
                    return;
                }

                // Handle stunned / immobilized enemies (beartrap etc.)
                if (enemy.stunned) {
                    // Primary: frame-based stunTime
                    if (enemy.stunTime != null) {
                        enemy.stunTime--;
                        if (enemy.stunTime <= 0) {
                            enemy.stunTime = 0;
                        }
                    }
                    // Fallback: timestamp window (from beartrap)
                    if (enemy._trapImmobilizeUntil && Date.now() >= enemy._trapImmobilizeUntil) {
                        enemy._trapImmobilizeUntil = null;
                        if (!enemy.stunTime || enemy.stunTime <= 0) enemy.stunned = false;
                    }
                    // Legacy ms-based stunnedTime support (convert to frames roughly)
                    if (enemy.stunnedTime != null) {
                        enemy.stunnedTime -= 16;
                        if (enemy.stunnedTime <= 0) { enemy.stunnedTime = 0; if (!enemy.stunTime || enemy.stunTime <= 0) enemy.stunned = false; }
                    }
                    // Failsafe: if flagged stunned but both stunTime and stunnedTime are 0/undefined and no trap immobilize, clear it.
                    if (enemy.stunned && (!enemy.stunTime || enemy.stunTime <= 0) && (enemy.stunnedTime == null || enemy.stunnedTime <= 0) && !enemy._trapImmobilizeUntil) {
                        enemy.stunned = false;
                    }
                    // Watchdog: track total consecutive frames of being stunned to auto-clear pathological cases (e.g., logic bug leaving stun forever)
                    if (enemy.stunned) {
                        enemy._stunWatch = (enemy._stunWatch || 0) + 1;
                        if (enemy._stunWatch > 360) { // 6 seconds at 60fps
                            enemy.stunned = false;
                            enemy.stunTime = 0;
                            enemy.stunnedTime = 0;
                            delete enemy._trapImmobilizeUntil;
                        }
                    } else if (enemy._stunWatch) {
                        // reset counter when not stunned
                        enemy._stunWatch = 0;
                    }
                    // Visual feedback for immobilization root
                    if (Math.random() < 0.15) addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.6, enemy.y + enemy.size/2, '#BBBBBB', 'spark');
                    if (enemy.stunned) return; // still immobilized
                }
                // Full freeze immobilization
                if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                    // visually could add subtle frost particles
                    if (Math.random() < 0.04) addParticle(enemy.x, enemy.y, '#AAEEFF', 'spark');
                    return;
                }

                // Ranged enemy attacks (silenced enemies cannot attack)
                const detectionRange = enemy.blinded ? 120 : 250;
                const enemyCooldown = (ENEMY_TYPES[enemy.type] && ENEMY_TYPES[enemy.type].rangedCooldown) ? ENEMY_TYPES[enemy.type].rangedCooldown : 2500;
                // Global opening delay for ranged attacks: prevent shooting during first 2000ms of a room
                const openingDelayMs = 2000;
                const roomAge = Date.now() - (game.roomStartTime || 0);
                if (roomAge < openingDelayMs) {
                    // ensure lastAttack is at least roomStartTime to avoid burst after delay
                    if (!enemy._openingDelayApplied) {
                        enemy.lastAttack = Date.now();
                        enemy._openingDelayApplied = true;
                    }
                }
                if (roomAge >= openingDelayMs && !enemy.silenced && enemy.ranged && dist < detectionRange && Date.now() - enemy.lastAttack > enemyCooldown) {
                    const baseSpeed = 4;
                    const shots = [];
                    if (enemy.type === 'The Big Quack') {
                        // Triple fan shot: center + slight left/right spread
                        const baseAng = Math.atan2(dy, dx);
                        const spreads = [0, -0.18, 0.18];
                        spreads.forEach(off => {
                            const a = baseAng + off;
                            shots.push({ vx: Math.cos(a)*baseSpeed, vy: Math.sin(a)*baseSpeed, dmgMul: 0.85 });
                        });
                    } else if (enemy.type === 'Boss Gangster') {
                        // Two-round burst (slight vertical jitter)
                        const baseAng = Math.atan2(dy, dx);
                        const jitter = [ -0.05, 0.05 ];
                        jitter.forEach(off => {
                            const a = baseAng + off;
                            shots.push({ vx: Math.cos(a)*baseSpeed*1.05, vy: Math.sin(a)*baseSpeed*1.05, dmgMul: 0.8 });
                        });
                    } else {
                        shots.push({ vx: (dx / dist) * baseSpeed, vy: (dy / dist) * baseSpeed, dmgMul: 0.8 });
                    }
                    shots.forEach(s => {
                        const pIdx = game.spawnProjectile({
                            x: enemy.x,
                            y: enemy.y,
                            vx: s.vx,
                            vy: s.vy,
                            life: 140,
                            r: enemy.type === 'The Big Quack' ? 5 : 3,
                            damage: Math.floor(enemy.damage * s.dmgMul)
                        });
                        // Mark as enemy-owned so SoA player->enemy collisions skip these, and tint red
                        if (pIdx >= 0) {
                            if (!game._projMeta) game._projMeta = new Map();
                            game._projMeta.set(pIdx, { enemy: true, baseDamage: Math.floor(enemy.damage * s.dmgMul) });
                            if (game.projectilesSoA && game.projectilesSoA.colorIdx) {
                                // Palette index 2 is red in current palette
                                game.projectilesSoA.colorIdx[pIdx] = 2;
                            }
                        }
                        addParticle(enemy.x, enemy.y, '#FFAA00', 'muzzle');
                    });
                    enemy.lastAttack = Date.now();
                }

                // Movement AI
                // Reconstruct baseline each frame from stored baseSpeed to prevent cumulative slow stacking bugs
                if (enemy.baseSpeed == null) enemy.baseSpeed = enemy.speed || 1; // defensive backfill
                enemy.speed = enemy.baseSpeed; // reset any accidental permanent reduction
                let moveSpeed = enemy.speed;
                if (enemy.slowed) moveSpeed *= 0.4;
                // Apply partial freeze slow scaling by stacks (1 or 2 stacks only; 3 is full freeze handled above)
                if (enemy.freezeStacks && enemy.freezeStacks > 0 && (!enemy.frozenTimer || enemy.frozenTimer <= 0)) {
                    if (enemy.freezeStacks === 1) moveSpeed *= 0.6;
                    else if (enemy.freezeStacks === 2) moveSpeed *= 0.35;
                }
                // Blind movement dampening + wandering: do NOT fully immobilize
                if (enemy.blinded) {
                    // Cap blind duration defensively
                    if (enemy.blindTime > 300) enemy.blindTime = 300;
                    moveSpeed *= 0.55; // reduced precision movement
                    // If player out of (very short) pursuit range, wander
                    const shortRange = 70;
                    if (dist > shortRange) {
                        // Create / update wander direction every ~45 frames
                        enemy._blindWanderTicker = (enemy._blindWanderTicker || 0) + 1;
                        if (enemy._blindWanderTicker > 45 || enemy._blindWanderAngle == null) {
                            enemy._blindWanderTicker = 0;
                            enemy._blindWanderAngle = Math.random() * Math.PI * 2;
                        }
                        const wx = Math.cos(enemy._blindWanderAngle) * moveSpeed * 0.7;
                        const wy = Math.sin(enemy._blindWanderAngle) * moveSpeed * 0.7;
                        const nx = enemy.x + wx;
                        const ny = enemy.y + wy;
                        if (!isWall(nx, ny, 15)) { enemy.x = nx; enemy.y = ny; }
                        // Continue to next enemy (skip normal chase) this frame
                        return;
                    }
                }
                // Ensure movement never fully zeroed unless explicitly stunned/frozen
                if (!enemy.stunned && !enemy.frozenTimer) {
                    const minFloor = enemy.baseSpeed * 0.18; // floor at 18% baseline
                    if (moveSpeed < minFloor) moveSpeed = minFloor;
                }

                // Terrifying Aura proximity fear application (room-based only now)
                if (game.player && game.player.auraActive) {
                    const auraRadius = 60; // contact radius
                    const adx = enemy.x - game.player.x;
                    const ady = enemy.y - game.player.y;
                    if (adx*adx + ady*ady <= auraRadius * auraRadius) {
                        // Apply fear for 3s (180 frames) if not already feared or refresh shorter remaining
                        const newFear = 180;
                        if (!enemy.fearTime || enemy.fearTime < newFear * 0.5) {
                            enemy.fearTime = newFear;
                            enemy.feared = true;
                            // one-off particles for feedback
                            addParticle(enemy.x, enemy.y - 12, '#AA44FF', 'spark');
                        }
                    }
                }

                // Fear behavior: run directly away from player
                if (enemy.feared) {
                    enemy.fearTime--;
                    if (enemy.fearTime <= 0) { enemy.feared = false; } else {
                        const fdx = enemy.x - game.player.x;
                        const fdy = enemy.y - game.player.y;
                        const fd = Math.max(1, Math.sqrt(fdx*fdx + fdy*fdy));
                        const fleeSpeed = moveSpeed * 1.15; // slight haste when fleeing
                        const nx = enemy.x + (fdx / fd) * fleeSpeed;
                        const ny = enemy.y + (fdy / fd) * fleeSpeed;
                        if (!isWall(nx, ny, 15)) { enemy.x = nx; enemy.y = ny; }
                        return; // skip rest of AI while feared
                    }
                }

                // Fleeing enemies move away from player
                if (enemy.fleeing) {
                    enemy.fleeTime--;
                    if (enemy.fleeTime <= 0) enemy.fleeing = false;
                    // Move opposite direction
                    const nx = enemy.x - (dx / Math.max(dist, 1)) * moveSpeed;
                    const ny = enemy.y - (dy / Math.max(dist, 1)) * moveSpeed;
                    if (!isWall(nx, ny, 15)) {
                        enemy.x = nx;
                        enemy.y = ny;
                    }
                    return;
                }

                // Charmed enemies: become temporary allies that seek and damage other (non-charmed) enemies.
                if (enemy.charmed) {
                    enemy.charmTime--;
                    if (enemy.charmTime <= 0) { enemy.charmed = false; return; }
                    // Acquire nearest valid hostile target
                    let target = null; let tDist = Infinity;
                    for (const other of game.enemies) {
                        if (other === enemy) continue;
                        if (other.health <= 0) continue;
                        if (other.charmed) continue; // don't attack allies
                        const dx2 = other.x - enemy.x; const dy2 = other.y - enemy.y;
                        const d2 = dx2*dx2 + dy2*dy2;
                        if (d2 < tDist) { tDist = d2; target = other; }
                    }
                    if (target) {
                        const d2 = Math.sqrt(tDist) || 1;
                        const step = moveSpeed * 0.85; // slightly faster than normal to be useful
                        const mx = enemy.x + (target.x - enemy.x)/d2 * step;
                        const my = enemy.y + (target.y - enemy.y)/d2 * step;
                        if (!isWall(mx, my, 15)) { enemy.x = mx; enemy.y = my; }
                        // Contact damage vs target (reduced from original enemy.damage to avoid overpowering)
                        if (Math.sqrt((target.x - enemy.x)**2 + (target.y - enemy.y)**2) < (target.size/2 + enemy.size/2 + 4)) {
                            if (!enemy._charmAttackCooldown || enemy._charmAttackCooldown <= 0) {
                                const base = enemy.damage || 10;
                                const dealt = Math.max(1, Math.floor(base * 0.55));
                                target.health -= dealt;
                                addDamageNumber(dealt, target.x, target.y - target.size/2, { type:'charm' });
                                // Small heart particle burst
                                if (Math.random()<0.6) addParticle(target.x, target.y, '#FF88CC', 'spark');
                                enemy._charmAttackCooldown = 28; // ~0.46s at 60fps
                            }
                        }
                    }
                    if (enemy._charmAttackCooldown) enemy._charmAttackCooldown--;
                    // Occasional ambient charm heart
                    if (Math.random() < 0.04) addParticle(enemy.x + (Math.random()-0.5)*enemy.size, enemy.y - enemy.size/2 - 4, '#FF66BB', 'spark');
                    return; // skip hostile AI
                }

                if (dist > 30) {
                    // Simple pathfinding - try to avoid walls
                    let targetX = enemy.x + (dx / dist) * moveSpeed;
                    let targetY = enemy.y + (dy / dist) * moveSpeed;

                    if (isWall(targetX, targetY, 15)) {
                        // Try alternative paths
                        const perpX = -dy / dist;
                        const perpY = dx / dist;

                        if (!isWall(enemy.x + perpX * moveSpeed * 2, enemy.y + perpY * moveSpeed * 2, 15)) {
                            enemy.x += perpX * moveSpeed;
                            enemy.y += perpY * moveSpeed;
                        } else if (!isWall(enemy.x - perpX * moveSpeed * 2, enemy.y - perpY * moveSpeed * 2, 15)) {
                            enemy.x -= perpX * moveSpeed;
                            enemy.y -= perpY * moveSpeed;
                        }
                    } else {
                        enemy.x = targetX;
                        enemy.y = targetY;
                    }
                }
            });
            
            // Remove dead enemies and award XP
            const deadEnemies = game.enemies.filter(enemy => enemy.health <= 0);
            deadEnemies.forEach(enemy => {
                game.totalKills++;
                // Per-player kill counter (initialize lazily if missing)
                if (game.player) {
                    if (typeof game.player.killCount !== 'number') game.player.killCount = 0;
                    game.player.killCount++;
                    // Terrifying Aura activation: every 25 kills grant aura lasting for 2 rooms (level tracking removed)
                    if (game.player.abilities.includes('Terrifying Aura') && game.player.killCount % 25 === 0) {
                        game.player.auraActive = true;
                        // Level-based fields removed
                        game.player.auraActivatedRoom = game.room || 1;
                        game.player.auraExpireRoom = (game.room || 1) + 2; // expires after 2 rooms
                        // Visual feedback particles
                        for (let k=0;k<18;k++) {
                            const ang = (k/18)*Math.PI*2;
                            const px = game.player.x + Math.cos(ang)*38;
                            const py = game.player.y + Math.sin(ang)*38;
                            addParticle(px, py, '#AA44FF', 'spark');
                        }
                        addScreenShake(4);
                    }
                }
                game.score += enemy.xp;
                
                // Feather poof (white burst then falling) - ensure helper exists
                if (typeof spawnFeatherPoof === 'function') {
                    spawnFeatherPoof(enemy);
                }

                // Death effects: legacy bursts + on-kill pop ring keyed to last damage type
                {
                    for (let i = 0; i < 5; i++) {
                        addParticle(enemy.x, enemy.y, enemy.color, 'explosion');
                    }
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx) {
                        // Damage-type keyed ring and a couple sparks
                        let col = '#FFE6AA';
                        switch (enemy._lastHitType) {
                            case 'fire': col = '#FFAA55'; break;
                            case 'ice': case 'frost': col = '#AAE6FF'; break;
                            case 'poison': case 'toxic': col = '#88FFAA'; break;
                            case 'lightning': case 'storm': col = '#FFF277'; break;
                            case 'void': case 'shadow': col = '#CC88FF'; break;
                            case 'plasma': col = '#FF6688'; break;
                            case 'blizzard': col = '#C0F8FF'; break;
                            case 'inferno': col = '#FF5522'; break;
                        }
                        if (!reduceRings) addParticle(enemy.x, enemy.y, col, 'ring');
                        for (let s=0;s<3;s++) addParticle(enemy.x + (Math.random()-0.5)*12, enemy.y + (Math.random()-0.5)*12, col, 'spark');
                    }
                    addScreenShake(3);
                }

                // Spontaneous Combustion: on kill, emit radial burning shards
                if (game.player && game.player.abilities.includes('Spontaneous Combustion')) {
                    const shardCount = 12; // base number of shards
                    const baseDmg = calculateDamage();
                    for (let s=0; s<shardCount; s++) {
                        const ang = (s / shardCount) * Math.PI * 2;
                        const sp = 5.5; // speed of emitted shard
                        game.spawnProjectile({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(ang) * sp,
                            vy: Math.sin(ang) * sp,
                            life: 70,
                            size: 5,
                            enemy: false,
                            baseDamage: Math.max(1, Math.floor(baseDmg * 0.45)),
                            damageType: 'fire',
                            burningShard: true,
                            piercing: false
                        });
                    }
                    // Visual combustion particles
                    for (let p=0;p<30;p++) {
                        const pang = Math.random()*Math.PI*2;
                        const pr = Math.random()*28;
                        addParticle(enemy.x + Math.cos(pang)*pr, enemy.y + Math.sin(pang)*pr, (Math.random()<0.3?'#FFDD66':'#FF7722'), 'explosion');
                    }
                    addScreenShake(5);

                    // Synergy: if player also has Explosive Shot or Chain Explosion, schedule delayed secondary rings.
                    const hasExplosive = game.player.abilities.includes('Explosive Shot');
                    const hasChainExplosion = game.player.abilities.includes('Chain Explosion');
                    if (hasExplosive || hasChainExplosion) {
                        if (!game._pendingCombustionRings) game._pendingCombustionRings = [];
                        // Secondary ring (slightly larger, fewer but stronger shards)
                        game._pendingCombustionRings.push({
                            x: enemy.x,
                            y: enemy.y,
                            spawnFrame: (game.frame||0) + 10, // ~0.16s delay
                            count: hasChainExplosion ? 14 : 10,
                            speed: 6.0,
                            dmgFrac: hasChainExplosion ? 0.5 : 0.42,
                            fire: true,
                            tier: 2
                        });
                        if (hasChainExplosion) {
                            // Tertiary micro-ring (fast fade, crowd control filler)
                            game._pendingCombustionRings.push({
                                x: enemy.x,
                                y: enemy.y,
                                spawnFrame: (game.frame||0) + 22,
                                count: 18,
                                speed: 6.8,
                                dmgFrac: 0.34,
                                fire: true,
                                tier: 3
                            });
                        }
                    }
                }

                // Final boss defeat check
                if (enemy.type === 'The Big Quack') {
                    game._bigQuackDefeated = true;
                    console.info('[Endgame] The Big Quack defeated. Preparing ending overlay.');
                    // Swap to ending music (play cleansing theme regardless of previous track)
                    try {
                        if (game.bgMusic) { try { game.bgMusic.pause(); } catch(e) {} }
                        game.bgMusic = new Audio('assets/audio/Cleansing.mp3');
                        game.bgMusic.loop = true;
                        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
                    } catch(e) {}
                    // Display ending image overlay
                    if (!document.getElementById('endingOverlay')) {
                        const overlay = document.createElement('div');
                        overlay.id = 'endingOverlay';
                        overlay.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:#000;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:30000;';
                        const img = document.createElement('img');
                        img.src = 'assets/Ending.png';
                        img.alt = 'Ending';
                        img.style.maxWidth = '90%';
                        img.style.maxHeight = '80%';
                        img.style.marginBottom = '24px';
                        overlay.appendChild(img);
                        const prompt = document.createElement('div');
                        prompt.textContent = 'Press FIRE to choose a permanent ability';
                        prompt.style.cssText = 'color:#ffd700;font:20px Arial;text-shadow:0 0 8px #aa8800;';
                        overlay.appendChild(prompt);
                        document.body.appendChild(overlay);
                        console.info('[Endgame] Ending overlay displayed. Awaiting SPACE for permanent ability choice.');
                    }
                }
                
                // Life steal healing
                let totalLifeSteal = 0;
                game.player.abilities.forEach(ability => {
                    const abilityData = ABILITIES[ability];
                    if (abilityData && abilityData.effect.lifeSteal) {
                        totalLifeSteal += abilityData.effect.lifeSteal;
                    }
                });
                
                if (totalLifeSteal > 0) {
                    const healAmount = Math.floor(25 * totalLifeSteal);
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + healAmount);
                    addParticle(game.player.x, game.player.y - 20, '#00FF00', 'heal');
                    updateUI();
                }

                // Chance to drop a health bread slice (pickup heals 25)
                // Base 10% chance; modified by Treasure Hunter (breadDropBonus adds percentage multiplicatively)
                let dropChance = 0.10;
                if (game.player.abilities.includes('Treasure Hunter')) {
                    const th = ABILITIES['Treasure Hunter'];
                    if (th && th.effect && th.effect.breadDropBonus) {
                        dropChance *= (1 + th.effect.breadDropBonus); // e.g., 0.10 * 1.5 = 0.15
                    }
                }
                if (Math.random() < dropChance && game.pickups.length < 40) {
                    game.pickups.push({
                        type: 'bread',
                        x: enemy.x + (Math.random()-0.5)*12,
                        y: enemy.y + (Math.random()-0.5)*12,
                        spawnTime: performance.now(),
                        collected: false
                    });
                }
            });
            
            game.enemies = game.enemies.filter(enemy => enemy.health > 0);
        }

        // Post-update status ticks: doom and weakness durations
        (function postStatusTick() {
            game.enemies.forEach(enemy => {
                if (enemy.doomed) {
                    enemy.doomTime = (enemy.doomTime || 0) - 1;
                    if (enemy.doomTime <= 0) {
                        enemy.doomed = false;
                    } else {
                        enemy.health -= 0.9;
                        if (Math.random() < 0.12) addParticle(enemy.x, enemy.y, '#880088', 'impact');
                    }
                }
                // Corrosion: periodic true damage & temporary armor reduction
                if (enemy.corroded) {
                    enemy.corrodeTime = (enemy.corrodeTime || 0) - 1;
                    if ((enemy.corrodeTime % 30) === 0) {
                        enemy.health -= 2; // small true damage
                        addParticle(enemy.x, enemy.y, '#44FF44', 'impact');
                    }
                    if (enemy.corrodeTime <= 0) {
                        enemy.corroded = false;
                        // remove one stack of armorShredded if present
                        if (enemy.armorShredded) enemy.armorShredded = Math.max(0, enemy.armorShredded - 1);
                    }
                }
                // Void touched: small periodic true damage
                if (enemy.voidTouched) {
                    enemy.voidTime = (enemy.voidTime || 0) - 1;
                    if ((enemy.voidTime % 40) === 0) {
                        enemy.health -= 3;
                        addParticle(enemy.x, enemy.y, '#AA00FF', 'impact');
                    }
                    if (enemy.voidTime <= 0) enemy.voidTouched = false;
                }
                // Bleeding: periodic physical damage (half mitigated by armor)
                if (enemy.bleeding) {
                    enemy.bleedTime = (enemy.bleedTime || 0) - 1;
                    if ((enemy.bleedTime % 25) === 0) {
                        const base = 4;
                        const mitigated = Math.max(1, base - (enemy.armor || 0) * 0.5);
                        enemy.health -= mitigated;
                        addParticle(enemy.x, enemy.y, '#CC2222', 'impact');
                    }
                    if (enemy.bleedTime <= 0) enemy.bleeding = false;
                }
                if (enemy.weakness) {
                    enemy.weaknessTime = (enemy.weaknessTime || 0) - 1;
                    if (enemy.weaknessTime <= 0) enemy.weakness = false;
                }
                if (enemy.cursed) {
                    enemy.curseTime = (enemy.curseTime || 0) - 1;
                    if (enemy.curseTime <= 0) enemy.cursed = false;
                }
            });
        })();

        // Legacy projectile update retained for reference (now superseded by SoA: game.updateProjectilesSoA)
        function updateProjectiles() {
            return; // no-op: all projectile motion handled in SoA system
            // Helper to safely obtain (or recompute) projectile speed.
            const getProjSpeed = (p) => {
                if (!p) return 0.0001;
                if (p._agg && p._agg.baseSpeed) return p._agg.baseSpeed;
                return Math.sqrt(p.vx*p.vx + p.vy*p.vy) || 0.0001;
            };
            game.projectiles = game.projectiles.filter(proj => {
                // Pattern Amplification (SHOOTING INTENSIFIES)
                // We apply a one-time per-frame amplification to pattern-induced lateral/oscillatory components.
                // Implementation approach: after each pattern block mutates velocity (later in the function), we scale
                // key stored intermediate amplitudes. To avoid deep invasive edits across every pattern branch, we
                // apply a consolidated multiplier early that downstream calculations reference. New patterns should
                // consult proj._patternAmpFactor if needing amplitude. Existing code using literal values will receive
                // a post-hoc velocity inflation (controlled) to approximate amplitude boost.
                if (!proj._patternAmpTagged) {
                    // Base factor: +40% amplitude/speed for wave/spiral like motions.
                    let amp = 1.0;
                    if (!proj.enemy && game.player && game.player.abilities && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.patternAmplify)) {
                        amp = 1.4;
                        // Slight scaling if multiple core patterns active (diminishing stacking): add up to +10% more.
                        const patternFlags = ['sineWave','wackyZigzag','ekgWave','spiral','spiralPattern','uzumaki','helixPair','lissajousPattern','slalomPattern','pendulumPattern','sawWave','pivotPattern','convergePair','spiralBloom','temporalDrift','veeringFan','echoBloom'];
                        let count = 0; for (const f of patternFlags) if (proj[f]) count++;
                        if (count > 1) amp *= (1 + Math.min(0.10, (count-1)*0.025));
                        // Store factor for downstream logic that may reference it.
                        proj._patternAmpFactor = amp;
                    } else {
                        proj._patternAmpFactor = 1.0;
                    }
                    proj._patternAmpTagged = true; // mark so we don't recompute excessively
                }
                // Capture pre-pattern position each frame for reliable bounce rewind when complex patterns adjust position before base move.
                proj._prePatternX = proj.x;
                proj._prePatternY = proj.y;
                // Lightning projectile spark trail (visual only)
                if (!proj.enemy && (proj.damageType === 'lightning' || proj.damageType === 'storm')) {
                    if (Math.random() < 0.45) {
                        addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFFFAA', 'lightning');
                    }
                    if (Math.random() < 0.18) {
                        addParticle(proj.x, proj.y, '#FFF6AA', 'spark');
                    }
                }
                // Dimensional Rift projectile interaction: refraction, bending, occasional duplication / teleport
                if (!proj.enemy && !proj.beam && game._dimRifts && game._dimRifts.length) {
                    for (let ri = 0; ri < game._dimRifts.length; ri++) {
                        const rift = game._dimRifts[ri];
                        if (!rift) continue;
                        const dxR = proj.x - rift.x;
                        const dyR = proj.y - rift.y;
                        const distR2 = dxR*dxR + dyR*dyR;
                        const rr = rift.r;
                        if (distR2 <= rr*rr) {
                            const distR = Math.sqrt(distR2) || 1;
                            // Lens bending: mix current velocity with a tangential component to create an arc around center
                            if (!proj._riftBent) {
                                const vx = proj.vx; const vy = proj.vy;
                                // Tangent vector (perpendicular to radius) for swirling deflection
                                const tx = -dyR / distR; const ty = dxR / distR;
                                // Strength scales with closeness to center (stronger near core)
                                const closeness = 1 - (distR / rr);
                                const bend = 0.35 * closeness; // tunable
                                // Blend velocities
                                proj.vx = vx * (1 - bend) + tx * getProjSpeed(proj) * bend;
                                proj.vy = vy * (1 - bend) + ty * getProjSpeed(proj) * bend;
                                proj._riftBent = true;
                                // Slight life extension so refracted shots persist visually
                                proj.life += 4;
                            }
                            // Refraction / duplication (single time per projectile per rift)
                            if (!proj._riftRefracted) {
                                const canDuplicate = game.projectilesSoA ? (game.projectilePool.active() < 1200) : false; // safety cap via SoA count
                                if (canDuplicate && Math.random() < 0.34) {
                                    const copies = (Math.random() < 0.25) ? 2 : 1; // occasionally spawn two extra
                                    for (let c=0; c<copies; c++) {
                                        const ang = Math.atan2(proj.vy, proj.vx) + (Math.random()*0.9 - 0.45); // wide scatter
                                        const spd = getProjSpeed(proj) * (0.75 + Math.random()*0.4);
                                        const lifeChild = Math.max(40, Math.floor(proj.life * (0.55 + Math.random()*0.25)));
                                        const childBase = Math.max(1, Math.floor((proj.baseDamage || proj.damage || calculateDamage()) * 0.8));
                                        const dupIdx = game.spawnProjectile({
                                            x: proj.x + Math.cos(ang)*6,
                                            y: proj.y + Math.sin(ang)*6,
                                            vx: Math.cos(ang)*spd,
                                            vy: Math.sin(ang)*spd,
                                            life: lifeChild,
                                            r: Math.max(2, Math.min(28, Math.floor((proj.size||6)*0.9))),
                                            damage: childBase,
                                            damageType: proj.damageType || null,
                                            sineWave: proj.sineWave, wackyZigzag: proj.wackyZigzag, ekgWave: proj.ekgWave, spiralPattern: proj.spiral
                                        });
                                        if (!game._projMeta) game._projMeta = new Map();
                                        if (dupIdx>=0) game._projMeta.set(dupIdx,{ baseDamage: childBase, _riftChild:true, _riftBent:true, _riftRefracted:true });
                                        addParticle((proj.x + Math.cos(ang)*6), (proj.y + Math.sin(ang)*6), '#AA44FF', 'spark');
                                    }
                                }
                                proj._riftRefracted = true;
                            }
                            // Chance to micro-teleport projectile to rim, preserving direction
                            if (!proj._riftTeleported && Math.random() < 0.12) {
                                const dirAng = Math.atan2(proj.vy, proj.vx);
                                // place on circumference slightly ahead in direction to create skip feel
                                const offsetAng = dirAng + (Math.random()*0.4 - 0.2);
                                const radius = rr * (0.85 + Math.random()*0.15);
                                proj.x = rift.x + Math.cos(offsetAng) * radius;
                                proj.y = rift.y + Math.sin(offsetAng) * radius;
                                // Slight speed boost to emphasize warp
                                proj.vx *= 1.12; proj.vy *= 1.12;
                                proj._riftTeleported = true;
                                addParticle(proj.x, proj.y, '#DD88FF', 'explosion');
                            }
                            // Mark projectile to ignore armor while inside rift (per ability desc) until it leaves radius once
                            proj.ignoresArmor = true;
                            break; // only interact with first rift per frame
                        } else if (proj._riftBent && distR2 > rr*rr*1.21) {
                            // Once clearly outside, allow future bending again if it re-enters another rift
                            proj._riftBent = false;
                        }
                    }
                }
                if (proj.smartExplosive && !proj.enemy && proj.life > 0) {
                    let closest = Infinity;
                    for (let e of game.enemies) {
                        const d = Math.hypot(e.x - proj.x, e.y - proj.y);
                        if (d < closest) closest = d;
                    }
                    if (closest < 60) {
                        // Pre-fuse cue when very close but before detonation
                        if (closest > 26 && !(game.fxFlags && game.fxFlags.reduceRings)) {
                            if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFCC99', radius: 22, life: 120 });
                        }
                        // Draw a brief inner safe-radius halo and a last-moment radial tick as it arms
                        if (closest <= 32) {
                            // cache one-time arming timestamp to time the tick
                            if (!proj._sbArmAt) proj._sbArmAt = performance.now();
                            const since = performance.now() - proj._sbArmAt;
                            // Safe halo (transient effect): small, persistent hint around the smart bomb core
                            if (since < 220 && typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFE4CC', radius: 14, life: 120 });
                            }
                            // Last-moment tick: very short inner pulse right before detonation
                            if (since > 140 && since < 180 && typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFFFFF', radius: 10, life: 60 });
                                if (!(game.perf && game.perf.lowFx)) addScreenShake(0.75);
                            }
                        } else {
                            // reset arming timer if we drift farther away again
                            proj._sbArmAt = null;
                        }
                    }
                    if (closest < 48) {
                        explodeProjectile(proj, calculateDamage());
                        proj.life = 0;
                        return false;
                    }
                }
                // Growing effect (enhanced):
                //  - Higher max size (4.25x base) with soft cap & diminishing returns near end
                //  - Early growth slightly faster; slows as it approaches cap
                //  - Pattern synergy: if projectile also has spiral OR sineWave, grant mild extra growth potential
                //  - Infusion synergy: active infusions raise cap modestly (stacking small boosts)
                if (proj.growing && !proj.enemy) {
                    const start = (typeof proj._initialSize === 'number') ? proj._initialSize : 4;
                    if (!proj._growInit) {
                        proj._growInit = true;
                        proj._growTicks = 0;
                        // Base cap multiplier
                        let baseCapMult = 4.0; // from 2.5 -> 4.0 baseline
                        // Motion pattern synergy adds headroom
                        if (proj.spiral) baseCapMult += 0.35;
                        if (proj.sineWave) baseCapMult += 0.25;
                        // Wacky / EKG minor extra (avoid runaway)
                        if (proj.wackyZigzag) baseCapMult += 0.15;
                        if (proj.ekgWave) baseCapMult += 0.15;
                        // Infusion scaling (each adds 4% cap up to +12%)
                        if (proj.infusionElements && proj.infusionElements.length) {
                            baseCapMult += Math.min(0.12, 0.04 * proj.infusionElements.length);
                        }
                        // Store absolute cap and softCap start (where diminishing returns start)
                        proj._growHardCap = start * baseCapMult; // absolute max
                        proj._growSoftCap = start * (baseCapMult * 0.78); // start easing here
                    }
                    proj._growTicks++;
                    const size = proj.size;
                    const hardCap = proj._growHardCap;
                    const softCap = proj._growSoftCap;
                    if (size < hardCap - 0.05) {
                        // Base growth factor: early faster (first 40 ticks), then normal
                        const earlyPhase = proj._growTicks < 40;
                        let growthRate = earlyPhase ? 1.032 : 1.018; // multiplicative
                        // Diminishing returns after soft cap: interpolate toward 1.0 multiplier
                        if (size > softCap) {
                            const t = (size - softCap) / (hardCap - softCap); // 0..1
                            const damp = 1 - Math.min(1, t); // remaining growth influence
                            growthRate = 1 + (growthRate - 1) * damp * 0.85; // reduce acceleration steeply
                        }
                        // Safety clamp (avoid micro-floating above cap)
                        const newSize = Math.min(size * growthRate, hardCap);
                        proj.size = newSize;
                    }
                }
                // Spiral in-flight motion: looping swirl around the forward path
                if (proj.spiral && !proj.enemy) {
                    // Initialize loop parameters on first pass
                    if (!proj._loopInitialized) {
                        proj._loopInitialized = true;
                        // Prefer the initial firing direction if present so spirals curve around the original path
                        proj._forwardSpeed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) || 0.0001;
                        const initFx = typeof proj._initialFx === 'number' ? proj._initialFx : (proj.vx / proj._forwardSpeed);
                        const initFy = typeof proj._initialFy === 'number' ? proj._initialFy : (proj.vy / proj._forwardSpeed);
                        // normalize captured forward vector
                        const inorm = Math.sqrt(initFx*initFx + initFy*initFy) || 0.0001;
                        proj._fx = initFx / inorm;
                        proj._fy = initFy / inorm;
                        proj._px = -proj._fy; // perpendicular unit
                        proj._py = proj._fx;
                        proj._loopRadius = 6 + Math.random() * 10; // loop radius in px
                        proj._loopAngle = 0;
                        proj._loopSpeed = 0.22 + Math.random() * 0.36; // how fast it spins around
                        proj._lastLoopOffsetX = 0;
                        proj._lastLoopOffsetY = 0;
                    }
                    // advance loop angle (spinDir keeps earlier randomness)
                    proj._loopAngle += proj._loopSpeed * (proj.spinDir || 1);

                    // Optionally modulate radius slightly for breathing effect
                    const radiusMod = proj._loopRadius * (0.85 + 0.3 * Math.sin(proj._loopAngle * 0.7));

                    // compute offset in perpendicular direction to create loops around centerline
                    const offsetX = proj._px * Math.cos(proj._loopAngle) * radiusMod;
                    const offsetY = proj._py * Math.cos(proj._loopAngle) * radiusMod;

                    // forward motion remains the principal velocity
                    const forwardMoveX = proj._fx * proj._forwardSpeed;
                    const forwardMoveY = proj._fy * proj._forwardSpeed;

                    // desired velocity is forward plus the delta of offset to create local loop travel
                    const desiredVx = forwardMoveX + (offsetX - proj._lastLoopOffsetX) * 0.6;
                    const desiredVy = forwardMoveY + (offsetY - proj._lastLoopOffsetY) * 0.6;

                    proj._lastLoopOffsetX = offsetX;
                    proj._lastLoopOffsetY = offsetY;

                    // softly lerp current velocity toward desired velocity so motion is smooth
                    // If Uzumaki is also active, give Spiral a touch more influence so local loops remain apparent
                    const spMix = (proj.uzumaki ? 0.22 : 0.16);
                    proj.vx = proj.vx * (1 - spMix) + desiredVx * spMix;
                    proj.vy = proj.vy * (1 - spMix) + desiredVy * spMix;
                    // keep life stable
                    proj.life -= 0;
                }
                // Uzumaki (object-mode): initialize only; actual motion contribution is applied via the pattern aggregator below
                if (proj.uzumaki && !proj.enemy) {
                    if (!proj._uzuInit) {
                        proj._uzuInit = true;
                        // Anchor center at player's position at spawn (stationary center) for consistent swirl.
                        proj._uzuCx = proj._spawnPlayerX || game.player.x; // fallback if not set
                        proj._uzuCy = proj._spawnPlayerY || game.player.y;
                        proj._uzuAngle = Math.atan2(proj.y - proj._uzuCy, proj.x - proj._uzuCx);
                        proj._uzuRadius = 18; // initial radius from center
                        proj._uzuAngularVel = 0.18 + Math.random()*0.04; // base rotational speed
                        proj._uzuRadialVel = 1.4 + Math.random()*0.4; // outward expansion speed
                        proj._uzuDrag = 0.000; // radial drag currently unused (kept for tuning)
                        // Shorter life so spiral stream refreshes
                        proj.life = Math.min(proj.life, 120 + (Math.random()*30)|0);
                    }
                    // State evolution + velocity contribution occurs inside aggregator to stack with other patterns
                }
                // --- APPLY CONSOLIDATED PATTERN AMPLIFICATION ---
                // After individual pattern logic has potentially modified vx/vy, apply a gentle outward scaling of the
                // lateral (non-forward) component to simulate increased amplitude. We approximate lateral component by
                // subtracting original forward direction (captured at spawn if available) so base travel speed doesn't inflate too much.
                if (proj._patternAmpFactor && proj._patternAmpFactor > 1 && !proj._patternAmpAppliedFrame) {
                    // Derive forward vector baseline
                    const speed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                    let fx = proj._initialFx, fy = proj._initialFy;
                    if (typeof fx !== 'number' || typeof fy !== 'number') {
                        fx = proj.vx / speed; fy = proj.vy / speed;
                    }
                    // Project velocity onto forward
                    const forwardMag = proj.vx*fx + proj.vy*fy; // dot product (signed)
                    const forwardVx = fx * forwardMag;
                    const forwardVy = fy * forwardMag;
                    let lateralVx = proj.vx - forwardVx;
                    let lateralVy = proj.vy - forwardVy;
                    // Scale lateral portion only
                    lateralVx *= proj._patternAmpFactor;
                    lateralVy *= proj._patternAmpFactor;
                    // Recombine
                    proj.vx = forwardVx + lateralVx;
                    proj.vy = forwardVy + lateralVy;
                    // Clamp total speed to avoid runaway (allow up to +25% total speed boost)
                    const newSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                    const maxSpeed = speed * 1.25;
                    if (newSpeed > maxSpeed) {
                        const scale = maxSpeed / newSpeed;
                        proj.vx *= scale; proj.vy *= scale;
                    }
                    proj._patternAmpAppliedFrame = true; // could be reset externally if multi-stage patterns later adjust
                } else if (proj._patternAmpAppliedFrame) {
                    // Reset marker for next frame (since we operate per-frame inside filter loop)
                    proj._patternAmpAppliedFrame = false;
                }
                // === New Pattern Motions ===
                // Helix Pair lateral orbiting around forward trajectory (applied before aggregation so it influences basis subtly)
                if (proj.helixPair && proj._helixSide) {
                    if (!proj._helixInit) {
                        proj._helixInit = true;
                        // capture forward direction
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._helixSpeed = sp;
                        proj._helixFx = proj.vx / sp; proj._helixFy = proj.vy / sp;
                        proj._helixPx = -proj._helixFy; proj._helixPy = proj._helixFx;
                    }
                    proj._helixPhase += 0.25; // spin speed
                    // Ease radius toward target (wider look) then gently breathe
                    if (proj._helixTargetRadius) {
                        const diff = proj._helixTargetRadius - proj._helixRadius;
                        proj._helixRadius += diff * 0.045; // approach target smoothly
                    }
                    // Mild breathing after near target
                    if (Math.abs(proj._helixTargetRadius - proj._helixRadius) < 1.5) {
                        proj._helixRadius += Math.sin(proj._helixPhase*0.18 + (proj._helixSide||1)) * 0.20;
                    }
                    const radius = proj._helixRadius * 0.55; // scaling to keep on-screen clarity
                    const off = Math.sin(proj._helixPhase) * radius * proj._helixSide;
                    proj.x += proj._helixPx * off * 0.11;
                    proj.y += proj._helixPy * off * 0.11;
                }
                // Lissajous pattern: evolving figure-eight / knot path with dynamic frequency ratio, amplitude flips, and motion pulses (intensified)
                if (proj.lissajousPattern && !proj.enemy && !proj.beam) {
                    if (!proj._lissaInit) {
                        proj._lissaInit = true;
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._lissaFx = proj.vx / sp; proj._lissaFy = proj.vy / sp; // forward basis
                        proj._lissaPx = -proj._lissaFy; proj._lissaPy = proj._lissaFx; // lateral basis
                        proj._lissaT = 0;
                        // amplitude envelope (wider for clearer figure)
                        // Tunables: widen factor allows quick global scaling.
                        proj._lissaWidenFactor = 2.05; // intensified
                        proj._lissaBaseA = (24 + Math.random()*10) * proj._lissaWidenFactor;
                        proj._lissaBaseB = (16 + Math.random()*8) * (proj._lissaWidenFactor * 0.85);
                        proj._lissaA = proj._lissaBaseA;
                        proj._lissaB = proj._lissaBaseB;
                        // start with near 1:2 ratio then morph toward 2:3 or 3:4 to create evolving shape
                        proj._lissaFreqA = 0.16; // base horizontal component
                        proj._lissaFreqB = 0.32; // vertical double
                        proj._lissaTargetSets = [ [0.21,0.31], [0.24,0.40], [0.18,0.27] ];
                        proj._lissaCurTarget = 0;
                        proj._lissaPhase = Math.random()*Math.PI*2;
                        proj._lissaRot = 0; // slow rotation of local frame
                        proj._lissaLast = { x:0, y:0 };
                        proj._lissaFlipTimer = 70 + Math.floor(Math.random()*45); // slightly more frequent
                        proj._lissaPulseTimer = 50 + Math.floor(Math.random()*34); // slightly more frequent
                        proj._lissaSpeedPulse = 0; // frames of active speed modulation
                    }
                    proj._lissaT++;
                    // Periodically retarget frequency pair for evolving curve
                    if (proj._lissaT % 160 === 0) {
                        proj._lissaCurTarget = (proj._lissaCurTarget + 1) % proj._lissaTargetSets.length;
                    }
                    const tgt = proj._lissaTargetSets[proj._lissaCurTarget];
                    // Ease current freqs toward target
                    proj._lissaFreqA += (tgt[0] - proj._lissaFreqA) * 0.015;
                    proj._lissaFreqB += (tgt[1] - proj._lissaFreqB) * 0.015;
                    // Light amplitude breathing
                    const ampPulse = 1 + Math.sin(proj._lissaT*0.02)*0.08;
                    proj._lissaA = proj._lissaBaseA * ampPulse;
                    proj._lissaB = proj._lissaBaseB * (1 - Math.sin(proj._lissaT*0.017)*0.06);
                    // Amplitude flip event (swap roles & invert one axis briefly)
                    proj._lissaFlipTimer--;
                    if (proj._lissaFlipTimer === 0) {
                        const tmp = proj._lissaBaseA;
                        proj._lissaBaseA = proj._lissaBaseB;
                        proj._lissaBaseB = tmp * (0.90 + Math.random()*0.25);
                        proj._lissaFlipTimer = 95 + Math.floor(Math.random()*70);
                        // minor inversion of Y component for dramatic knot
                        proj._lissaFreqB *= (Math.random()<0.5? -1:1);
                        addParticle(proj.x, proj.y, '#66E0FF','spark');
                    }
                    // Speed pulse event: temporarily exaggerate lateral displacement
                    proj._lissaPulseTimer--;
                    if (proj._lissaPulseTimer === 0) {
                        proj._lissaPulseTimer = 140 + Math.floor(Math.random()*70);
                        proj._lissaSpeedPulse = 26; // frames, longer
                        addParticle(proj.x, proj.y, '#44F6FF','spark');
                    }
                    // path sample
                    const ax = Math.sin(proj._lissaT * proj._lissaFreqA + proj._lissaPhase) * proj._lissaA;
                    const ay = Math.sin(proj._lissaT * proj._lissaFreqB) * proj._lissaB * Math.sin(proj._lissaT*0.005 + proj._lissaPhase*0.5);
                    // diff to last sample -> local displacement
                    const dx = ax - proj._lissaLast.x;
                    const dy = ay - proj._lissaLast.y;
                    proj._lissaLast.x = ax; proj._lissaLast.y = ay;
                    // Rotate local frame slowly around forward vector to create figure-eight twist
                    proj._lissaRot += 0.0035;
                    const cosr = Math.cos(proj._lissaRot), sinr = Math.sin(proj._lissaRot);
                    // rotated perpendicular basis
                    const rPxX = proj._lissaPx * cosr + proj._lissaFx * sinr * 0.4; // slight coupling of forward to lateral for depth
                    const rPxY = proj._lissaPy * cosr + proj._lissaFy * sinr * 0.4;
                    const rFxX = proj._lissaFx * cosr - proj._lissaPx * sinr * 0.4;
                    const rFxY = proj._lissaFy * cosr - proj._lissaPy * sinr * 0.4;
                    // apply displacement
                    let pulseScale = 1;
                    if (proj._lissaSpeedPulse > 0) { pulseScale = 1.85; proj._lissaSpeedPulse--; }
                    // Increased displacement multipliers to widen path (scaled by widen factor)
                    const lateralScale = 0.34 * (proj._lissaWidenFactor || 1);
                    const forwardScale = 0.18 * (proj._lissaWidenFactor || 1); // slightly stronger forward component
                    proj.x += (rPxX * dx * lateralScale + rFxX * dy * forwardScale) * pulseScale;
                    proj.y += (rPxY * dx * lateralScale + rFxY * dy * forwardScale) * pulseScale;
                    // trailing particles with higher density during pulse
                    if (Math.random() < (proj._lissaSpeedPulse > 0 ? 0.22 : 0.085)) {
                        const col = proj._lissaSpeedPulse>0?'#55FFFF':'#AAEEFF';
                        addParticle(proj.x, proj.y, col,'spark');
                        // Occasional accent ring when pulse active for readability
                        if (proj._lissaSpeedPulse>0 && Math.random()<0.15) addParticle(proj.x, proj.y, '#66FFFF','ring');
                    }
                }
                // Slalom pattern: sharp gated zigzag (hold straight segments, sudden corner turns) (intensified)
                if (proj.slalomPattern && !proj.enemy && !proj.beam) {
                    if (!proj._slalomInit) {
                        proj._slalomInit = true;
                        proj._slalomSegment = 0; // frames into current segment
                        proj._slalomSegmentLen = 12; // shorter straight run
                        proj._slalomTurnAngle = 0.62; // stronger corner
                        proj._slalomDir = 1; // next turn direction sign
                        proj._slalomMaxSegments = 10; // after this revert to straight
                        proj._slalomMade = 0;
                        proj._slalomTrailTick = 0;
                    }
                    proj._slalomSegment++;
                    proj._slalomTrailTick++;
                    // Pre-cue the upcoming lane change shortly before the turn
                    if (proj._slalomMade < proj._slalomMaxSegments && proj._slalomSegment === (proj._slalomSegmentLen - 2)) {
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#AEEBFF', radius: 14, life: 110 });
                        }
                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) {
                            addParticle(proj.x, proj.y, '#AEEBFF', 'ring');
                        }
                        if (!(game.perf && game.perf.lowFx)) {
                            addScreenShake(0.5);
                        }
                    }
                    // light trailing particles while in segment to emphasize straightness
                    if (proj._slalomTrailTick % 7 === 0 && proj._slalomMade < proj._slalomMaxSegments) {
                        addParticle(proj.x, proj.y, '#BBD9FF','trail');
                    }
                    if (proj._slalomSegment >= proj._slalomSegmentLen && proj._slalomMade < proj._slalomMaxSegments) {
                        proj._slalomSegment = 0;
                        proj._slalomMade++;
                        // perform sharp corner turn
                        const ang = Math.atan2(proj.vy, proj.vx);
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        const newAng = ang + proj._slalomDir * proj._slalomTurnAngle;
                        const boost = 1.06;
                        proj.vx = Math.cos(newAng) * sp * boost;
                        proj.vy = Math.sin(newAng) * sp * boost;
                        // flip direction for next corner
                        proj._slalomDir *= -1;
                        // corner visual burst
                        for (let k=0;k<4;k++) addParticle(proj.x, proj.y, '#88C4FF','spark');
                    }
                    // After finishing designated segments, damp pattern to avoid wave illusions
                    if (proj._slalomMade >= proj._slalomMaxSegments) {
                        proj.slalomPattern = false; // stop further zigzagging; projectile resumes straight path
                    }
                }
                // Pendulum pattern: now additive  computes desired instantaneous velocity from swing physics
                // and contributes delta-V to the aggregator instead of directly overriding position/velocity.
                if (proj.pendulumPattern && !proj.enemy && !proj.beam) {
                    if (!proj._pendInit) {
                        proj._pendInit = true;
                        const sp = Math.hypot(proj.vx, proj.vy)||0.0001;
                        proj._pendBaseSpeed = sp; // base linear speed reference
                        proj._pendFx = proj.vx/sp; proj._pendFy = proj.vy/sp;
                        proj._pendPx = -proj._pendFy; proj._pendPy = proj._pendFx;
                        proj._pendAnchorX = proj.x; proj._pendAnchorY = proj.y;
                        proj._pendAngle = (Math.random()<0.5?1:-1) * 0.85; // larger initial deflection (~49) to differentiate visually
                        proj._pendAngVel = 0;
                        proj._pendLength = 42 + Math.random()*14; // longer to exaggerate arc
                        proj._pendGravity = 0.07; // slightly higher for natural period
                        proj._pendDamp = 0.991;   // very gentle damping
                        proj._pendFrame = 0;
                        proj._pendMaxFrames = 240; // slightly longer showcase
                        proj._pendMinSwingVel = 0.0022;
                        proj._pendLastSign = Math.sign(proj._pendAngle);
                        proj._pendPeaks = 0;
                        proj._pendPrevSag = 0;
                    }
                    proj._pendFrame++;
                    // Physics integration
                    const angAcc = -proj._pendGravity * Math.sin(proj._pendAngle);
                    proj._pendAngVel += angAcc;
                    proj._pendAngVel *= proj._pendDamp;
                    proj._pendAngle += proj._pendAngVel;
                    // Detect peak (sign change in angular velocity or near-zero crossing of angle with opposite sign soon)
                    if (proj._pendLastSign !== 0) {
                        const curSign = Math.sign(proj._pendAngVel);
                        if (curSign !== 0 && curSign !== proj._pendLastSign) {
                            proj._pendPeaks++;
                            // Peak particle fan
                            if (!(game.fxFlags && game.fxFlags.hideSparks)) {
                                for (let k=0;k<5;k++) addParticle(proj.x + (Math.random()-0.5)*12, proj.y + (Math.random()-0.5)*12, '#FFD580','spark');
                            }
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) addParticle(proj.x, proj.y, '#88EEFF', 'ring');
                            if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#88EEFF', radius: 22, life: 160 });
                            if (!(game.perf && game.perf.lowFx)) addScreenShake(1);
                        }
                        proj._pendLastSign = curSign;
                    }
                    // Variable forward anchor advance: scaled by |cos(angle)| so it nearly pauses at peaks
                    const forwardScale = Math.max(0.15, Math.abs(Math.cos(proj._pendAngle))); // never fully zero
                    const fStep = proj._pendBaseSpeed * 0.9 * forwardScale; // slightly reduced base
                    // Anchor advances only for physics reference, not applied to absolute pos
                    proj._pendAnchorX += proj._pendFx * fStep;
                    proj._pendAnchorY += proj._pendFy * fStep;
                    // Lateral displacement and vertical sag (for visual depth estimation)
                    const lateral = Math.sin(proj._pendAngle) * proj._pendLength;
                    const sag = (1 - Math.cos(proj._pendAngle)) * (proj._pendLength * 0.20);
                    // Instantaneous velocity approximation as desired target
                    const latVel = Math.cos(proj._pendAngle) * proj._pendLength * proj._pendAngVel;
                    const instVx = proj._pendFx * fStep + proj._pendPx * latVel;
                    const instVy = proj._pendFy * fStep + proj._pendPy * latVel + (sag * 0.25 - (proj._pendPrevSag||0))*0.9;
                    proj._pendPrevSag = sag * 0.25;
                    // Contribute delta-V relative to current forward baseline
                    const curSp = Math.hypot(proj.vx, proj.vy) || 0.0001;
                    const curFx = proj.vx / curSp, curFy = proj.vy / curSp;
                    const baseVx = curFx * curSp;
                    const baseVy = curFy * curSp;
                    const dVX = instVx - baseVx;
                    const dVY = instVy - baseVy;
                    proj._aggDX = (proj._aggDX||0) + dVX;
                    proj._aggDY = (proj._aggDY||0) + dVY;
                    // Mark that a pattern contributed this frame
                    patternApplied = true;
                    // Trail particles more intense near center (fast) using cos-based intensity
                    const trailIntensity = 0.06 + Math.abs(Math.cos(proj._pendAngle))*0.12;
                    if (Math.random() < trailIntensity) addParticle(proj.x, proj.y, '#FFC899','spark');
                    // Termination: when angular velocity minimal OR time cap
                    if ((Math.abs(proj._pendAngVel) < proj._pendMinSwingVel && Math.abs(proj._pendAngle) < 0.12) || proj._pendFrame >= proj._pendMaxFrames) {
                        // Forward speed boost proportional to how many peaks (diminishing)  contribute as delta
                        const boost = 1 + Math.min(0.35, proj._pendPeaks * 0.05);
                        const finalSp = proj._pendBaseSpeed * boost;
                        const curSp2 = Math.hypot(proj.vx, proj.vy) || 0.0001;
                        const curFx2 = proj.vx / curSp2, curFy2 = proj.vy / curSp2;
                        const dVfx = curFx2 * (finalSp - curSp2);
                        const dVfy = curFy2 * (finalSp - curSp2);
                        proj._aggDX = (proj._aggDX||0) + dVfx;
                        proj._aggDY = (proj._aggDY||0) + dVfy;
                        for (let b=0;b<8;b++) addParticle(proj.x + (Math.random()-0.5)*14, proj.y + (Math.random()-0.5)*14, '#FFD9AA','spark');
                        proj.pendulumPattern = false;
                    }
                }
                // Sawtooth wave: slow drift then snap
                if (proj.sawWave && !proj.enemy && !proj.beam) {
                    if (!proj._sawInit) {
                        proj._sawInit = true;
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        proj._sawFx = proj.vx/sp; proj._sawFy = proj.vy/sp;
                        proj._sawPx = -proj._sawFy; proj._sawPy = proj._sawFx;
                        proj._sawT = 0;
                        proj._sawPeriod = 38 + Math.floor(Math.random()*14);
                        proj._sawAmp = 24 + Math.random()*10;
                    }
                    proj._sawT = (proj._sawT + 1) % proj._sawPeriod;
                    const t = proj._sawT / proj._sawPeriod; // 0..1
                    let wave = t; // ramp
                    // At snap point, invert quickly
                    if (t > 0.92) {
                        // One-frame flash ring to indicate the snap
                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) addParticle(proj.x, proj.y, '#FFE0B0', 'ring');
                        if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFD9AA', radius: 18, life: 120 });
                        if (!(game.perf && game.perf.lowFx)) addScreenShake(0.5);
                        wave = -1 + (t - 0.92)/0.08; // rapid return
                    }
                    const lateral = (wave - 0.46) * 2 * proj._sawAmp; // center
                    const dl = (lateral - (proj._sawLast||0));
                    proj._sawLast = lateral;
                    proj.x += proj._sawPx * dl * 0.12;
                    proj.y += proj._sawPy * dl * 0.12;
                }
                // Vector Pivot (pivotPattern): straight flight segments punctuated by crisp quarter-turn pivots.
                // Vector Pivot: now additive  computes a target turn and contributes delta-V rather than directly setting velocity.
                if (proj.pivotPattern && !proj.enemy && !proj.beam && !proj._orbital) {
                    if (!proj._pivotInit) {
                        proj._pivotInit = true;
                        proj._pivotInterval = 26 + Math.floor(Math.random()*10); // frames between pivots
                        proj._pivotTimer = 0;
                        proj._pivotDir = (Math.random()<0.5?1:-1); // rotation direction sign
                        proj._pivotEasing = 0; // 0..1 during active pivot
                        proj._pivotActive = false;
                        proj._pivotTurns = 0;
                        proj._pivotMaxTurns = 6;
                        proj._pivotBaseSpeed = Math.hypot(proj.vx, proj.vy)||1;
                    }
                    proj._pivotTimer++;
                    if (!proj._pivotActive && proj._pivotTimer >= proj._pivotInterval && proj._pivotTurns < proj._pivotMaxTurns) {
                        proj._pivotActive = true;
                        proj._pivotTimer = 0;
                        proj._pivotEasing = 0;
                        const sp = Math.hypot(proj.vx, proj.vy)||1;
                        proj._pivotStartVX = proj.vx/sp; proj._pivotStartVY = proj.vy/sp;
                        const tx = proj._pivotDir * -proj._pivotStartVY;
                        const ty = proj._pivotDir * proj._pivotStartVX;
                        proj._pivotTargetVX = tx; proj._pivotTargetVY = ty;
                        proj._pivotTurns++;
                        // choose next turn randomly instead of alternation
                        proj._pivotDir = (Math.random()<0.5?1:-1);
                        for (let k=0;k<4;k++) addParticle(proj.x, proj.y, '#FFD980','spark');
                        // Pivot start cue
                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) {
                            addParticle(proj.x, proj.y, '#66D6FF','ring');
                        }
                        // Reticule ringflash indicating new direction
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#9FE6FF', radius: 16, life: 120 });
                        }
                    }
                    if (proj._pivotActive) {
                        proj._pivotEasing += 0.12;
                        const p = proj._pivotEasing;
                        const ease = p < 1 ? (1 - Math.pow(1-p, 3)) : 1; // cubic ease-out
                        const nx = proj._pivotStartVX * (1 - ease) + proj._pivotTargetVX * ease;
                        const ny = proj._pivotStartVY * (1 - ease) + proj._pivotTargetVY * ease;
                        const spd = proj._pivotBaseSpeed;
                        const desiredVx = nx * spd;
                        const desiredVy = ny * spd;
                        // contribute delta relative to current velocity
                        proj._aggDX = (proj._aggDX||0) + (desiredVx - proj.vx);
                        proj._aggDY = (proj._aggDY||0) + (desiredVy - proj.vy);
                        patternApplied = true;
                        if (p >= 1) {
                            proj._pivotActive = false;
                            addParticle(proj.x, proj.y, '#FFC040','spark');
                            if (!(game.perf && game.perf.lowFx)) addParticle(proj.x, proj.y, '#AEEBFF','spark');
                        }
                    }
                    if (proj._pivotTurns >= proj._pivotMaxTurns) {
                        proj.pivotPattern = false;
                    }
                }
                // Temporal Drift: stronger cadence (object-mode): adjust both velocity and perceived displacement
                if (proj.temporalDrift && !proj.enemy && !proj.beam) {
                    if (!proj._tdInit) {
                        proj._tdInit = true;
                        proj._tdPhase = 0; // 0 slow-stretch, 1 hold, 2 surge
                        proj._tdTimer = 0;
                        // Capture base speed for clamping
                        const sp0 = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        proj._tdBaseSpeed = sp0;
                        // On-spawn ripple cue
                        const col = '#9FE6FF';
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color: col, radius: Math.max(10, (proj.size||6) * 1.2), life: 120 });
                        } else {
                            addParticle(proj.x, proj.y, col, 'ring');
                        }
                    }
                    proj._tdTimer++;
                    if (proj._tdPhase === 0) { // slow stretch (heavier)
                        const f = 0.94;
                        proj.vx *= f; proj.vy *= f;
                        const base = proj._tdBaseSpeed || (Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001);
                        const spNow = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        const minSp = base * 0.55;
                        if (spNow < minSp) { const s = (minSp / spNow); proj.vx*=s; proj.vy*=s; }
                        if (proj._tdTimer > 30) { proj._tdPhase = 1; proj._tdTimer = 0; if (Math.random()<0.55) addParticle(proj.x, proj.y, '#C0F0FF','spark'); }
                    } else if (proj._tdPhase === 1) { // hold (shorter)
                        if (proj._tdTimer > 10) { proj._tdPhase = 2; proj._tdTimer = 0; if (Math.random()<0.55) addParticle(proj.x, proj.y, '#80E0FF','spark'); }
                    } else if (proj._tdPhase === 2) { // surge (stronger)
                        const f = 1.08;
                        proj.vx *= f; proj.vy *= f;
                        const base = proj._tdBaseSpeed || (Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001);
                        const spNow = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        const maxSp = base * 2.0;
                        if (spNow > maxSp) { const s = (maxSp / spNow); proj.vx*=s; proj.vy*=s; }
                        if (proj._tdTimer > 18) { proj._tdPhase = 0; proj._tdTimer = 0; for (let k=0;k<2;k++) if (Math.random()<0.75) addParticle(proj.x, proj.y, '#44D0FF','spark'); }
                    }
                }
                // Pattern motion aggregation: multiple pattern flags stack by contributing delta-Vs.
                // Ensure aggregator initialized once per projectile.
                if (!proj._patternInit) {
                    proj._patternInit = true;
                    proj._agg = { baseSpeed: null, fwX: null, fwY: null, px: null, py: null };
                }
                // Reset per-frame external deltas from patterns that contributed directly (e.g., pivot/pendulum)
                proj._aggDX = 0; proj._aggDY = 0;
                let patternApplied = false;
                let aggDX = 0, aggDY = 0; // additive velocity deltas from patterns
                // Establish forward & perpendicular bases lazily
                const ensureBasis = () => {
                    if (proj._agg.baseSpeed) return;
                    const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                    proj._agg.baseSpeed = sp;
                    proj._agg.fwX = proj.vx / sp;
                    proj._agg.fwY = proj.vy / sp;
                    // choose a stable perpendicular (seeded by projectile id via random) for repeatability
                    if (Math.random() < 0.5) { proj._agg.px = -proj._agg.fwY; proj._agg.py = proj._agg.fwX; }
                    else { proj._agg.px = proj._agg.fwY; proj._agg.py = -proj._agg.fwX; }
                };
                // Sine wave lateral oscillation (now stackable)
                if (proj.sineWave && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    // Initialize sine metadata once
                    if (!proj._sineInit) {
                        proj._sineInit = true;
                        // capture forward direction unit vector
                        proj._fwx = proj._agg.fwX; proj._fwy = proj._agg.fwY;
                        proj._px = proj._agg.px;  proj._py = proj._agg.py;
                        // amplitude scales lightly with speed but clamped
                        const ampBase = 14 + Math.random()*8; // 14-22
                        // Use stored baseSpeed (captured in ensureBasis) instead of undefined 'sp'
                        const baseSp = proj._agg && proj._agg.baseSpeed ? proj._agg.baseSpeed : Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._sineAmp = Math.min(26, ampBase + baseSp*1.2);
                        // frequency determines how tight the wave is (cycles per 60 frames)
                        proj._sineFreq = 0.18 + Math.random()*0.10; // radians increment per frame
                        proj._sinePhase = Math.random() * Math.PI * 2; // starting phase
                        proj._lastOffset = 0;
                        // store a stable forward speed so homing/other minor steering keeps wave consistent
                        proj._baseSpeed = proj._agg.baseSpeed;
                    }
                    // advance phase
                    proj._sinePhase += proj._sineFreq;
                    // desired lateral offset relative to centerline
                    const offset = Math.sin(proj._sinePhase) * proj._sineAmp;
                    // delta lateral movement this frame
                    const delta = offset - proj._lastOffset;
                    proj._lastOffset = offset;
                    aggDX += proj._px * delta;
                    aggDY += proj._py * delta;
                    patternApplied = true;
                }
                // Uzumaki contribution (object-mode): evolve state and add delta toward swirl target
                if (proj.uzumaki && !proj.enemy && !proj.beam) {
                    // Evolve Uzumaki state
                    proj._uzuRadius += proj._uzuRadialVel;
                    proj._uzuRadialVel *= (1 - proj._uzuDrag);
                    proj._uzuAngle += proj._uzuAngularVel;
                    proj._uzuAngularVel *= 1.003;
                    // Target point on the spiral
                    const targetX = proj._uzuCx + Math.cos(proj._uzuAngle) * proj._uzuRadius;
                    const targetY = proj._uzuCy + Math.sin(proj._uzuAngle) * proj._uzuRadius;
                    const dVx = (targetX - proj.x);
                    const dVy = (targetY - proj.y);
                    // If local Spiral is active, give Uzumaki a bit less authority to keep loops visible
                    const uzBlend = (proj.spiral ? 0.40 : 0.65);
                    aggDX += dVx * uzBlend;
                    aggDY += dVy * uzBlend;
                    patternApplied = true;
                    if (Math.random() < 0.08) addParticle(proj.x, proj.y, '#FFAaff', 'swirl');
                }
                // Wacky zigzag: adds perpendicular velocity component flips (stackable; reduced amplitude if combined)
                if (proj.wackyZigzag && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    if (!proj._wackyInit) {
                        proj._wackyInit = true;
                        const sp = proj._agg.baseSpeed;
                        // Store base forward speed for reference
                        proj._baseSpeed = sp;
                        // New omni-directional jitter system:
                        // Instead of just flipping perpendicular, we pick a random direction vector (including diagonals)
                        // every few frames and blend it in as a steering impulse.
                        proj._wackyTimer = 0;
                        proj._wackyInterval = 5 + Math.floor(Math.random()*8); // 5-12 frames per direction
                        proj._wackyAmpBase = Math.min(32, 14 + sp * 1.8 + Math.random()*10); // base magnitude potential
                        proj._wackyVec = { x: 0, y: 0 };
                        proj._wackyTarget = { x: 0, y: 0 };
                        proj._wackyJitterPhase = Math.random()*Math.PI*2;
                        // Helper to choose next direction from 8-way set (including diagonals) with slight random magnitude skew
                        proj._pickWackyDir = function() {
                            const dirs = [
                                {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},
                                {x:0.707,y:0.707},{x:-0.707,y:0.707},{x:0.707,y:-0.707},{x:-0.707,y:-0.707}
                            ];
                            const d = dirs[Math.floor(Math.random()*dirs.length)];
                            // random magnitude modulation (0.6 - 1.1)
                            const mag = 0.6 + Math.random()*0.5;
                            proj._wackyTarget.x = d.x * mag;
                            proj._wackyTarget.y = d.y * mag;
                        };
                        proj._pickWackyDir();
                        // Chaos variant minor initialization adjustments (if flagged at spawn)
                        if (proj._wackyChaos) {
                            // Slightly higher starting amplitude ceiling
                            proj._wackyAmpBase = Math.min(40, proj._wackyAmpBase + 6 + Math.random()*4);
                            // Shorter first interval for instant flair
                            proj._wackyInterval = 4 + Math.floor(Math.random()*5);
                        }
                    }
                    proj._wackyTimer++;
                    if (proj._wackyTimer >= proj._wackyInterval) {
                        proj._wackyTimer = 0;
                        proj._wackyInterval = 5 + Math.floor(Math.random()*8);
                        proj._pickWackyDir();
                        // occasional spark to indicate sudden re-vectoring
                        if (Math.random() < 0.5) addParticle(proj.x, proj.y, '#FFDD55', 'spark');
                        // mild amplitude modulation on each pick
                        const ampJitter = (Math.random()*6 - 3);
                        proj._wackyAmpBase = Math.max(10, Math.min(36, proj._wackyAmpBase + ampJitter));
                    }
                    // Chaos variant overlay behavior
                    let chaosFactor = 1;
                    if (proj._wackyChaos) {
                        // Frame-based timers (fallback if no global frame counter by using projectile life inverse)
                        const frameNow = (typeof game.frame === 'number') ? game.frame : (game.tick || (6000 - proj.life));
                        proj._wackyChaosTimer = (proj._wackyChaosTimer||0) + 1;
                        if (proj._wackyChaosTimer >= (proj._wackyChaosInterval||12)) {
                            proj._wackyChaosTimer = 0;
                            // Re-roll next chaos interval (tighter range than normal steering interval)
                            proj._wackyChaosInterval = 4 + Math.floor(Math.random()*6); // 4-9
                            // 20% chance: amplitude surge burst
                            if (Math.random() < 0.20) {
                                proj._wackyAmpBase = Math.min(48, proj._wackyAmpBase + 8 + Math.random()*6);
                                proj._wackyChaosBurst = 6 + Math.floor(Math.random()*6); // sustain heightened amplitude
                                addParticle(proj.x, proj.y, '#FFBB44', 'spark');
                            }
                            // 10% chance: dramatic 180 flip (cooldown 24 frames to avoid spam)
                            if (Math.random() < 0.10 && (proj._wackyChaosLastFlip||0) + 24 < frameNow) {
                                proj._wackyTarget.x *= -1; proj._wackyTarget.y *= -1;
                                proj._wackyChaosLastFlip = frameNow;
                                addParticle(proj.x, proj.y, '#FFA722', 'spark');
                            } else {
                                // Otherwise occasionally force an immediate new dir (55%)
                                if (Math.random() < 0.55) proj._pickWackyDir();
                            }
                            // Rare lateral micro explosion impulse (5%)
                            if (Math.random() < 0.05) {
                                const burstAng = Math.random()*Math.PI*2;
                                const impulse = 6 + Math.random()*10;
                                aggDX += Math.cos(burstAng) * impulse;
                                aggDY += Math.sin(burstAng) * impulse;
                                addParticle(proj.x + Math.cos(burstAng)*4, proj.y + Math.sin(burstAng)*4, '#FFD155', 'spark');
                            }
                        }
                        if (proj._wackyChaosBurst && proj._wackyChaosBurst > 0) {
                            proj._wackyChaosBurst--;
                            const t = proj._wackyChaosBurst/10; // 0..~1
                            chaosFactor = 1 + 0.35 * Math.sin(t*Math.PI); // smooth ease in/out
                            if (Math.random() < 0.18) addParticle(proj.x, proj.y, '#FFC966', 'spark');
                        }
                        // Additional subtle random lateral twitches (very small, frequent)
                        if (Math.random() < 0.12) {
                            aggDX += (Math.random()-0.5) * 4;
                            aggDY += (Math.random()-0.5) * 4;
                        }
                    }
                    // Smoothly steer current vector toward target (gives curve instead of instant snap)
                    proj._wackyVec.x = proj._wackyVec.x * 0.72 + proj._wackyTarget.x * 0.28;
                    proj._wackyVec.y = proj._wackyVec.y * 0.72 + proj._wackyTarget.y * 0.28;
                    // Add a subtle sinusoidal micro jitter layered on top (breathing motion)
                    proj._wackyJitterPhase += 0.35 + Math.random()*0.15;
                    const micro = Math.sin(proj._wackyJitterPhase) * 0.35;
                    let vx = proj._wackyVec.x + micro*(Math.random()<0.5?1:-1);
                    let vy = proj._wackyVec.y + micro*(Math.random()<0.5?1:-1);
                    // Normalize vector then scale by dynamic amplitude with pattern dampening
                    const len = Math.sqrt(vx*vx + vy*vy) || 1;
                    vx /= len; vy /= len;
                    const patternDampen = (proj.sineWave ? 0.55 : 1) * (proj.ekgWave ? 0.75 : 1) * (proj.spiral ? 0.85 : 1);
                    const amp = proj._wackyAmpBase * patternDampen * (chaosFactor || 1);
                    aggDX += vx * amp;
                    aggDY += vy * amp;
                    patternApplied = true;
                }
                // EKG wave: path-relative cardiogram-like offset spikes (stackable)
                if (proj.ekgWave && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    if (!proj._ekgInit) {
                        proj._ekgInit = true;
                        proj._fwx = proj._agg.fwX; proj._fwy = proj._agg.fwY;
                        // Lock perpendicular direction and force it to point toward screen-up (negative Y)
                        let px = proj._agg.px, py = proj._agg.py;
                        if (py > 0) { px = -px; py = -py; }
                        proj._px = px;  proj._py = py;
                        proj._baseSpeed = proj._agg.baseSpeed;
                        // Phase timing (frames) sequence: flat -> pre-pulse -> spike ascend -> spike descend -> recovery
                        // We'll encode as state machine
                        proj._ekgState = 'flat';
                        proj._ekgTimer = 0;
                        proj._ekgCycle = 0; // count completed cycles to schedule mega-spike
                        // randomize cycle length slightly so multiple shots desync
                        proj._ekgFlatDur = 10 + Math.floor(Math.random()*8); // shorter baseline
                        proj._ekgPreDur = 1;   // very brief telegraph
                        proj._ekgAscDur = 4;   // longer up for visibility
                        proj._ekgDescDur = 4;  // longer down
                        proj._ekgRecoverDur = 1; // snap settle
                        // Max spike lateral amplitude (increased for more dramatic spikes)
                        // Tunable constants: adjust EKG_AMP_BASE / EKG_AMP_VAR / EKG_AMP_MULT to quickly rebalance.
                        // Baseline jitter amount
                        proj._ekgJitter = 0.8;
                        proj._ekgSeed = Math.random() * Math.PI * 2;
                        // Small vs big spike amplitudes (px)
                        proj._ekgSmallAmp = 3.0 + Math.random()*1.5; // ~3.04.5
                        proj._ekgBigAmp   = 12 + Math.random()*6;    // ~1218
                        // Uniform scale-up so jitter and spikes increase equally
                        const EKG_SCALE = 3.8; // ~+27% stronger scale for jitter + spikes
                        proj._ekgJitter *= EKG_SCALE;
                        proj._ekgSmallAmp *= EKG_SCALE;
                        proj._ekgBigAmp *= EKG_SCALE;
                        proj._ekgUseAmp   = proj._ekgSmallAmp;
                        proj._lastOffset = 0;
                        // Ensure at least one spike early in life
                        proj._ekgGuaranteeAt = 10 + ((Math.random()*8)|0);
                        proj._ekgGuaranteeBigAt = 6 + ((Math.random()*8)|0);
                        proj._ekgBigDone = false;
                        proj._ekgSpikedOnce = false;
                    }
                    proj._ekgTimer++;
                    let offset = 0;
                    const st = proj._ekgState;
                    if (st === 'flat') {
                        // tiny baseline flicker (two-phase)
                        const a = Math.sin((proj._ekgTimer*3.1) + (proj._ekgSeed||0)) * (proj._ekgJitter*0.7);
                        const b = Math.sin((proj._ekgTimer*1.7) + (proj._ekgSeed||0)*0.53) * (proj._ekgJitter*0.3);
                        offset = a + b;
                        if (proj._ekgTimer >= proj._ekgFlatDur || (!proj._ekgSpikedOnce && proj._ekgTimer >= proj._ekgGuaranteeAt)) {
                            if (!proj._ekgBigDone && proj._ekgTimer >= proj._ekgGuaranteeBigAt) {
                                proj._ekgUseAmp = proj._ekgBigAmp; proj._ekgBigDone = true;
                            } else {
                                proj._ekgUseAmp = (Math.random() < 0.18 ? proj._ekgBigAmp : proj._ekgSmallAmp);
                                if (proj._ekgUseAmp === proj._ekgBigAmp) proj._ekgBigDone = true;
                            }
                            proj._ekgState = 'pre'; proj._ekgTimer = 0;
                        }
                    } else if (st === 'pre') {
                        // brief telegraph
                        const t = proj._ekgTimer / Math.max(1, proj._ekgPreDur);
                        offset = Math.sin(proj._ekgTimer*3) * (0.6 + t*0.2);
                        if (proj._ekgTimer >= proj._ekgPreDur) { proj._ekgState = 'asc'; proj._ekgTimer = 0; }
                    } else if (st === 'asc') {
                        // Linear up
                        const t = Math.min(1, proj._ekgTimer / proj._ekgAscDur);
                        offset = Math.abs(proj._ekgUseAmp) * t; // always upward along locked perp
                        if (proj._ekgTimer >= proj._ekgAscDur) { proj._ekgState = 'desc'; proj._ekgTimer = 0; proj._ekgSpikedOnce = true; }
                    } else if (st === 'desc') {
                        const t = Math.min(1, proj._ekgTimer / proj._ekgDescDur);
                        offset = Math.abs(proj._ekgUseAmp) * (1 - t); // linear back to 0
                        if (proj._ekgTimer >= proj._ekgDescDur) { proj._ekgState = 'recover'; proj._ekgTimer = 0; }
                    } else if (st === 'recover') {
                        const t = proj._ekgTimer / Math.max(1, proj._ekgRecoverDur);
                        offset = (proj._lastOffset) * (1 - t); // snap settle
                        if (proj._ekgTimer >= proj._ekgRecoverDur) {
                            proj._ekgState = 'flat';
                            proj._ekgTimer = 0;
                            proj._ekgFlatDur = 10 + Math.floor(Math.random()*8);
                            proj._ekgCycle = (proj._ekgCycle||0)+1;
                            proj._lastOffset = 0; // hard reset baseline
                        }
                    }
                    // Convert offset to perpendicular delta and apply directly to position (avoid velocity drift)
                    let delta = offset - (proj._lastOffset || 0);
                    proj._lastOffset = offset;
                    // Clamp per-frame step; allow larger steps during spikes for visibility
                    const isSpike = (st==='asc' || st==='desc');
                    let maxStep;
                    if (isSpike) {
                        const amp = Math.abs(proj._ekgUseAmp || 0);
                        const dur = Math.max(1, (st==='asc' ? proj._ekgAscDur : proj._ekgDescDur));
                        maxStep = Math.min(31, Math.max(7.7, (amp / dur) * 1.4));
                    } else {
                        maxStep = 2.05; // baseline clamp scaled up ~28% to match amplitude increase
                    }
                    if (delta > maxStep) delta = maxStep; else if (delta < -maxStep) delta = -maxStep;
                    const spikeScale = isSpike ? 1.0 : 0.85;
                    proj.x += proj._px * delta * spikeScale;
                    proj.y += proj._py * delta * spikeScale;
                    patternApplied = true;
                    // subtle trail particle at spike apex / transition
                    if (st === 'desc' && proj._ekgTimer === 0) { addParticle(proj.x, proj.y, '#66FFCC', 'spark'); }
                }
                // Apply aggregated pattern adjustments (only for non-orbital, non-beam, non-enemy projectiles)
                if (patternApplied && !proj._orbital && !proj.beam && !proj.enemy) {
                    // Rebuild forward component from stored basis, add aggregated lateral
                    const fwSpeed = proj._agg.baseSpeed;
                    // Keep forward velocity magnitude stable while adding lateral influence
                    let desiredVx = proj._agg.fwX * fwSpeed + aggDX + (proj._aggDX||0);
                    let desiredVy = proj._agg.fwY * fwSpeed + aggDY + (proj._aggDY||0);
                    // Gyro Stabilizer: reduce lateral displacement influence (acts like damping)
                    if (proj.gyroStabilizer) {
                        const lateralVx = desiredVx - proj._agg.fwX * fwSpeed;
                        const lateralVy = desiredVy - proj._agg.fwY * fwSpeed;
                        desiredVx = proj._agg.fwX * fwSpeed + lateralVx * 0.48; // stronger damping
                        desiredVy = proj._agg.fwY * fwSpeed + lateralVy * 0.48;
                    }
                    // Soft normalization to avoid runaway speed inflation
                    const maxSpeed = fwSpeed * 1.85;
                    const sp2 = Math.sqrt(desiredVx*desiredVx + desiredVy*desiredVy) || 0.0001;
                    if (sp2 > maxSpeed) {
                        desiredVx = desiredVx / sp2 * maxSpeed;
                        desiredVy = desiredVy / sp2 * maxSpeed;
                    }
                    // Blend for smoothness
                    proj.vx = proj.vx * 0.58 + desiredVx * 0.42;
                    proj.vy = proj.vy * 0.58 + desiredVy * 0.42;
                }
                // === Emission / Lifecycle Behaviors (new abilities) ===
                if (!proj.enemy && !proj.beam) {
                    // Bloom Ring: emit expanding pellet ring periodically
                    if (proj.bloomRing) {
                        // Hybrid mode C: Occasional small sub-ring emissions from projectiles (low density)
                        // while main large rings are handled at player level (updateBloomRings())
                        // Use per-projectile stagger so not all cores emit on same frame
                        const subInterval = 160 + ((proj._bloomSubRand)||(proj._bloomSubRand = Math.floor(Math.random()*90))); // ~2.5s avg
                        proj._bloomSubTimer = (proj._bloomSubTimer||0)+1;
                        if (proj._bloomSubTimer >= subInterval) {
                            proj._bloomSubTimer = 0;
                            // Emit a tiny petal burst (6) for visual continuity
                            const count = 6;
                            const baseDmg = proj.baseDamage || calculateDamage();
                            for (let r=0;r<count;r++) {
                                const ang = (r/count)*Math.PI*2;
                                const spd = 3.6 + Math.random()*0.5;
                                game.spawnProjectile({
                                    x: proj.x, y: proj.y,
                                    vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
                                    life: 34,
                                    size: Math.max(2, Math.floor(proj.size*0.45)),
                                    enemy:false,
                                    damage: Math.max(1, Math.floor(baseDmg * 0.22)),
                                    baseDamage: Math.max(1, Math.floor(baseDmg * 0.22)),
                                    bloomChild:true,
                                    _petal:true
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFEEDD','spark');
                        }
                    }
                    // Cascade Burst: pulsing forward micro-bursts
                    if (proj.cascadeBurst) {
                        if (!proj._cascInit) { proj._cascInit=true; proj._cascTimer=12; }
                        proj._cascTimer--;
                        if (proj._cascTimer<=0) {
                            proj._cascTimer = 14; // reset
                            const ang = Math.atan2(proj.vy, proj.vx);
                            const parts = 3;
                            for (let k=0;k<parts;k++) {
                                const off = (k - (parts-1)/2)*0.08;
                                game.spawnProjectile({
                                    x: proj.x + Math.cos(ang)*8,
                                    y: proj.y + Math.sin(ang)*8,
                                    vx: Math.cos(ang+off)* (getProjSpeed(proj)*1.05),
                                    vy: Math.sin(ang+off)* (getProjSpeed(proj)*1.05),
                                    life: 40,
                                    size: Math.max(2, proj.size*0.45),
                                    enemy:false,
                                    damage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.32)),
                                    baseDamage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.32)),
                                    cascadeChild:true,
                                    _initialFx: Math.cos(ang+off), _initialFy: Math.sin(ang+off)
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFD4AA','spark');
                            for (let q=0;q<3;q++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFB866','spark');
                        }
                    }
                    // Fragment Wake: trailing small lingering damaging sparks (new system)
                    if (proj.fragmentWake) {
                        // Initialize per-projectile emission tracking
                        if (!proj._fwPrevX) { proj._fwPrevX = proj.x; proj._fwPrevY = proj.y; proj._fwDistAcc = 0; }
                        const dx = proj.x - proj._fwPrevX, dy = proj.y - proj._fwPrevY;
                        const dist = Math.hypot(dx, dy);
                        proj._fwDistAcc += dist;
                        proj._fwPrevX = proj.x; proj._fwPrevY = proj.y;
                        // Emit a spark every ~18px traveled (slightly randomized spacing)
                        const spacing = 14 + (proj._fwRandOff || (proj._fwRandOff = Math.random()*6));
                        while (proj._fwDistAcc >= spacing) {
                            proj._fwDistAcc -= spacing;
                            const baseDmg = (proj.baseDamage||calculateDamage());
                            if (!Array.isArray(game.fragmentSparks)) game.fragmentSparks = [];
                            if (game.fragmentSparks.length > 220) game.fragmentSparks.splice(0, game.fragmentSparks.length - 220);
                            // Perf-aware pre-shed spark for readability
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                addParticle(proj.x, proj.y, '#FFE6AA','spark');
                            }
                            game.fragmentSparks.push({
                                x: proj.x + (Math.random()-0.5)*6,
                                y: proj.y + (Math.random()-0.5)*6,
                                r: 6 + Math.random()*3,
                                ttl: 38,
                                maxTtl: 38,
                                damage: Math.max(1, Math.floor(baseDmg * 0.10)),
                                dpsTick: 0,
                                hitMap: new Set(),
                                pulse: Math.random()*Math.PI*2
                            });
                        }
                    }
                    // Phase Echo: spawn afterimages that later pop for mini-hit
                    if (proj.phaseEcho) {
                        if (!proj._echoInit) { proj._echoInit=true; proj._echoTimer=10; }
                        proj._echoTimer--;
                        if (proj._echoTimer<=0) {
                            proj._echoTimer = 26; // cadence
                            if ((proj._echoesSpawned||0) < 3) {
                                const gDmg = Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.25));
                                const gIdx = game.spawnProjectile({ x: proj.x, y: proj.y, vx:0, vy:0, life:22, r: Math.max(2, Math.floor((proj.size||6)*0.6)), damage: gDmg });
                                if (!game._projMeta) game._projMeta = new Map();
                                if (gIdx>=0) game._projMeta.set(gIdx,{ phaseGhost:true, parentRef: proj, baseDamage:gDmg });
                                proj._echoesSpawned=(proj._echoesSpawned||0)+1;
                            }
                        }
                    }
                    // Resonant Pulse Core: emits periodic expanding ring that grants temporary speed/damage/homing buff
                    if (proj.resonantPulseCore) {
                        proj._resCoreTimer = (proj._resCoreTimer||0)+1;
                        proj._resActiveRings = proj._resActiveRings || [];
                        const interval = 60; // frames between pulses (was 90)
                        if (proj._resCoreTimer >= interval) {
                            proj._resCoreTimer = 0;
                            const ring = { r: 0, max: 150, life: 38 };
                            proj._resActiveRings.push(ring);
                            // Telegraph pulse (perf-aware)
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!lowFx && !hideSparks) {
                                for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*16, proj.y + (Math.random()-0.5)*16, '#C7A4FF','spark');
                            }
                        }
                        // Update rings
                        for (let i=proj._resActiveRings.length-1;i>=0;i--) {
                            const ring = proj._resActiveRings[i];
                            ring.r += (ring.max - ring.r) * 0.18; // ease out expansion
                            ring.life--;
                            // Apply buff to touched projectiles this frame
                            const rad2 = ring.r*ring.r;
                            game.projectiles.forEach(p2=>{
                                if (p2===proj || p2.enemy || p2.beam) return;
                                const dx = p2.x - proj.x; const dy = p2.y - proj.y;
                                const d2 = dx*dx+dy*dy;
                                if (d2 <= rad2 && !p2._resBuffedFrame) {
                                    // Mark buff application frame and set buff timers
                                    p2._resBuffedFrame = game._frameCount || performance.now();
                                    p2._resBuffSpeed = Math.max(p2._resBuffSpeed||0, 26); // speed buff frames
                                    p2._resBuffDamage = Math.max(p2._resBuffDamage||0, 30); // damage buff frames
                                    p2._resBuffHoming = Math.max(p2._resBuffHoming||0, 24); // slight homing assistance
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                    if (!lowFx && !hideSparks) addParticle(p2.x, p2.y, '#C7A4FF','spark');
                                }
                            });
                            if (ring.life <= 0 || ring.r > ring.max*0.98) proj._resActiveRings.splice(i,1);
                        }
                        // Local optional glow particle
                        if (!(game.perf && game.perf.lowFx) && Math.random()<0.08) addParticle(proj.x, proj.y, '#B88CFF','ambient');
                    }
                    // Spiral Bloom: projectile corkscrews inward tightening radius then detonates into rotating petal spiral
                    if (proj.spiralBloom) {
                        if (!proj._sbInit) {
                            proj._sbInit=true;
                            proj._sbPhase='tighten';
                            proj._sbTimer=0;
                            proj._sbRadius=34;
                            proj._sbAngle = 0; // rotation phase for visible spiral motion
                            // capture forward & perpendicular for local spiral positioning
                            const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                            proj._sbFx = proj.vx/sp; proj._sbFy = proj.vy/sp;
                            proj._sbPx = -proj._sbFy; proj._sbPy = proj._sbFx;
                        }
                        proj._sbTimer++;
                        if (proj._sbTelegraph && proj._sbTelegraph>0) proj._sbTelegraph--;
                        if (proj._sbPhase==='tighten') {
                            proj._sbAngle += 0.38; // spin
                            proj._sbRadius *= 0.965; // contract
                            // apply a local spiral offset around the forward axis (minor visual swirl)
                            const swirl = proj._sbRadius*0.12;
                            const sx = Math.cos(proj._sbAngle)*swirl;
                            const sy = Math.sin(proj._sbAngle)*swirl;
                            proj.x += proj._sbPx * sx * 0.08 + proj._sbFx * sy * 0.02;
                            proj.y += proj._sbPy * sx * 0.08 + proj._sbFy * sy * 0.02;
                            // Pre-bloom telegraph shortly before detonating
                            if (!proj._sbTelegraph && (proj._sbTimer>46 || proj._sbRadius<8.5)) {
                                proj._sbTelegraph = 12;
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                    for (let k=0;k<4;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE6AA','spark');
                                }
                            }
                            if (proj._sbTimer>52 || proj._sbRadius<5.5) { proj._sbPhase='bloom'; proj._sbTimer=0; }
                            if (Math.random()<0.18) addParticle(proj.x, proj.y, '#FFE6AA','spark');
                        } else if (proj._sbPhase==='bloom') {
                            if (!proj._sbBloomed) {
                                proj._sbBloomed = true;
                                const petals = 8;
                                const base = proj.baseDamage||calculateDamage();
                                // Emit petals with initial angular offset to create rotating ring that expands
                                for (let p=0;p<petals;p++) {
                                    const ang = (p/petals)*Math.PI*2;
                                    const speed = 2.4 + (p%2)*0.8; // slight alternation
                                    const vx = Math.cos(ang)*speed;
                                    const vy = Math.sin(ang)*speed;
                                    game.spawnProjectile({
                                        x: proj.x, y: proj.y,
                                        vx, vy,
                                        life: 75,
                                        size: Math.max(10, proj.size * 1.10 * 2.0), enemy:false,
                                        damage: Math.max(1, Math.floor(base*0.42)), baseDamage: Math.max(1, Math.floor(base*0.42)),
                                        petal:true,
                                        // Attach sprite + spin meta so renderer can pick image and rotate
                                        petalImg: ('bloom' + (1 + Math.floor(Math.random()*6))),
                                        _petalAngle: Math.random()*Math.PI*2,
                                        petalSpin: (Math.random()<0.5?1:-1) * (0.06 + Math.random()*0.04)
                                    });
                                }
                                // central burst particles
                                addParticle(proj.x, proj.y, '#FFEEAA','explosion');
                                for (let k=0;k<10;k++) addParticle(proj.x, proj.y, '#FFC870','spark');
                            }
                            // After bloom, remove core projectile
                            proj.life = 0;
                        }
                    }
                    // Harmonic Split: spawn angled child pair at life thresholds; parent continues until all splits done
                    if (proj.harmonicSplit && proj._harmonicThresholds && !proj._harmonicDoneAll) {
                        if (!proj._harmonicDone) proj._harmonicDone = {};
                        if (proj._harmonicTele && proj._harmonicTele>0) proj._harmonicTele--;
                        const ang = Math.atan2(proj.vy, proj.vx);
                        for (let idx=0; idx<proj._harmonicThresholds.length; idx++) {
                            const th = proj._harmonicThresholds[idx];
                            // Pre-split telegraph within a small window above the threshold
                            if (!proj._harmonicDone[th] && proj.life <= th + 8 && proj.life > th) {
                                if (!proj._harmonicTele || proj._harmonicTele<4) proj._harmonicTele = 6;
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks) && Math.random()<0.25) {
                                    addParticle(proj.x, proj.y, '#FFE2BB','spark');
                                }
                            }
                            if (proj.life <= th && !proj._harmonicDone[th]) {
                                proj._harmonicDone[th] = true;
                                const base = proj.baseDamage||calculateDamage();
                                const childSpeed = getProjSpeed(proj) * 0.92;
                                const spread = 0.34; // radians offset (~19.5 deg)
                                for (let dir=-1; dir<=1; dir+=2) {
                                    const cAng = ang + dir*spread;
                                    game.spawnProjectile({
                                        x: proj.x, y: proj.y,
                                        vx: Math.cos(cAng) * childSpeed,
                                        vy: Math.sin(cAng) * childSpeed,
                                        life: Math.max(12, Math.floor(proj.life * 0.78)),
                                        size: Math.max(2, proj.size*0.65), enemy:false,
                                        damage: Math.max(1, Math.floor(base * 0.58)), baseDamage: Math.max(1, Math.floor(base * 0.58)),
                                        harmonicChild:true,
                                        // inherit some pattern flags for visual continuity
                                        sineWave: proj.sineWave, wackyZigzag: proj.wackyZigzag, ekgWave: proj.ekgWave,
                                        spiral: proj.spiral, lissajousPattern: proj.lissajousPattern
                                    });
                                }
                                // Visual burst
                                for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE2BB','spark');
                                addParticle(proj.x, proj.y, '#FFC070','trail');
                                // Optionally trim parent damage slightly each split so total DPS doesn't overscale
                                if (proj.baseDamage) proj.baseDamage = Math.max(1, Math.floor(proj.baseDamage * 0.9));
                            }
                        }
                        if (Object.keys(proj._harmonicDone).length === proj._harmonicThresholds.length) {
                            proj._harmonicDoneAll = true;
                            // Small final marker particle
                            addParticle(proj.x, proj.y, '#FFCC88','ambient');
                        }
                    }
                    // (Legacy umbrella & popcorn blocks removed  logic now handled in SoA metadata update loop)
                    // Echo Bloom: staged echo spawning culminating in amplified bloom burst
                    if (proj.echoBloom) {
                        if (!proj._echoInit) {
                            proj._echoInit = true;
                            proj._echoStage = 0; // stages 0..N then final bloom
                            proj._echoNextLifePoint = Math.floor(proj.life * 0.70); // initial trigger threshold
                            proj._echoMaxStages = 2; // number of intermediate echoes before final
                            proj._echoPetalColor = '#FFE0FF';
                            proj._echoTelegraph = 0; // grows near bloom
                            proj._echoTelegraphMax = 42; // frames of max telegraph before bloom
                        }
                        // Spawn echoes at descending life thresholds
                        if (proj.life <= proj._echoNextLifePoint && proj._echoStage < proj._echoMaxStages) {
                            const scale = 0.55 + proj._echoStage*0.15; const dmgScale = 0.30 + proj._echoStage*0.1;
                            const baseDmgLocal = (proj.baseDamage||calculateDamage());
                            const eIdx = game.spawnProjectile({
                                x: proj.x, y: proj.y,
                                vx: proj.vx*(0.35 + proj._echoStage*0.1), vy: proj.vy*(0.35 + proj._echoStage*0.1),
                                life: proj.life + 18 + proj._echoStage*6,
                                r: Math.max(2, Math.floor((proj.size||6)*scale)),
                                damage: Math.max(1, Math.floor(baseDmgLocal*dmgScale))
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            if (eIdx>=0) game._projMeta.set(eIdx,{ echoChild:true, parentRef: proj, baseDamage: Math.max(1, Math.floor(baseDmgLocal*dmgScale)) });
                            for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFC8FF','spark');
                            proj._echoStage++;
                            // schedule next threshold deeper into life (fractional)
                            proj._echoNextLifePoint = Math.floor(proj.life * (0.55 - proj._echoStage*0.10));
                        }
                        // Check for echoes converging; when all spawned echoes have converged, trigger bloom
                        if (proj._echoStage === proj._echoMaxStages && !proj._echoBloomed) {
                            let converged = true; let echoCount = 0;
                            if (game._projMeta && game.projectilesSoA) {
                                const so = game.projectilesSoA; const { x, y, alive, MAX } = so;
                                for (let si=0; si<MAX; si++) if (alive[si]) {
                                    const m2 = game._projMeta.get(si); if (!m2 || !m2.echoChild || m2.parentRef !== proj) continue;
                                    echoCount++;
                                    const dxc = x[si]-proj.x; const dyc = y[si]-proj.y; if (dxc*dxc+dyc*dyc > 36) { converged=false; break; }
                                }
                            }
                            // Telegraph growth once all echoes spawned
                            if (echoCount && !proj._echoBloomed) {
                                proj._echoTelegraph = Math.min(proj._echoTelegraph + 1, proj._echoTelegraphMax);
                                if (proj._echoTelegraph > proj._echoTelegraphMax * 0.65 && Math.random()<0.25) {
                                    addParticle(proj.x + (Math.random()-0.5)*20, proj.y + (Math.random()-0.5)*20, '#FFD6FF','spark');
                                }
                            }
                            if (echoCount && converged) {
                                // Perform bloom: radial petal ring + explosion damage
                                proj._echoBloomed = true;
                                const base = proj.baseDamage||calculateDamage();
                                const burstDmg = Math.max(1, Math.floor(base * 1.10)); // stronger central pop
                                explodeProjectile({x:proj.x,y:proj.y,size:proj.size,enemy:false}, burstDmg);
                                addScreenShake(6);
                                // Larger petal count scaling with multi-shot patterns (optional simple scale)
                                const petals = 10 + Math.floor(Math.random()*4);
                                for (let p=0;p<petals;p++) {
                                    const ang = (p/petals)*Math.PI*2;
                                    game.spawnProjectile({
                                        x: proj.x, y: proj.y,
                                        vx: Math.cos(ang)*(2.8 + Math.random()*0.6), vy: Math.sin(ang)*(2.8 + Math.random()*0.6),
                                        life: 65,
                                        size: Math.max(2, proj.size*0.55), enemy:false,
                                        damage: Math.max(1, Math.floor(base*0.42)), baseDamage: Math.max(1, Math.floor(base*0.42)),
                                        echoPetal:true
                                    });
                                }
                                // Resonance field: lingering aura dealing periodic pulse damage near center
                                const field = {
                                    x: proj.x, y: proj.y,
                                    radius: 140,
                                    createdAt: Date.now(),
                                    duration: 2000,
                                    tickEvery: 260,
                                    lastTick: 0,
                                    baseDamage: Math.max(1, Math.floor(base * 0.30)),
                                    type: 'echoBloom'
                                };
                                if (!game.echoBloomFields) game.echoBloomFields = [];
                                game.echoBloomFields.push(field);
                                addParticle(proj.x, proj.y, '#FFE6FF','explosion');
                                for (let r=0;r<20;r++) addParticle(proj.x + (Math.random()-0.5)*140, proj.y + (Math.random()-0.5)*140, '#FFC8FF','spark');
                                // consume echoes
                                if (game._projMeta && game.projectilesSoA) {
                                    const so = game.projectilesSoA; const { alive, life, MAX } = so;
                                    for (let si=0; si<MAX; si++) if (alive[si]) {
                                        const m2 = game._projMeta.get(si); if (m2 && m2.echoChild && m2.parentRef === proj) { life[si]=0; }
                                    }
                                }
                            }
                        }
                    }
                    // Veering Fan: mid-flight conversion to multi-shot
                    if (proj.veeringFan && proj._veeringTimer !== undefined) {
                        // Distance gating: ensure projectile traveled enough before considering split.
                        const dxSpawn = proj.x - (proj._spawnX||proj.x);
                        const dySpawn = proj.y - (proj._spawnY||proj.y);
                        const distSq = dxSpawn*dxSpawn + dySpawn*dySpawn;
                        if (distSq < (proj._veerMinDist||0)*(proj._veerMinDist||0)) {
                            // Defer countdown until distance met.
                        } else {
                            proj._veeringTimer--;
                        }
                        if (proj._veeringTimer === 0 && !proj._veered) {
                            proj._veered = true;
                            const ang = Math.atan2(proj.vy, proj.vx);
                            const speed = getProjSpeed(proj);
                            const base = proj.baseDamage||calculateDamage();
                            const sideCount = 4; // number of side projectiles (excludes original center)
                            const maxSpread = 0.55; // total radians from far left to far right (~31 deg)
                            // Keep original projectile as CENTER; adjust its stats slightly
                            proj.baseDamage = Math.max(1, Math.floor(base * 0.65));
                            proj.damage = proj.baseDamage;
                            proj.size = Math.max(2, proj.size * 0.75);
                            proj._centerVeer = true;
                            // Generate side projectiles in symmetrical pairs with easing spread
                            for (let i=0;i<sideCount;i++) {
                                const t = (i/(sideCount-1)) * 2 - 1; // -1 .. 1
                                // Ease towards extremes (quadratic) so inner shots cluster near center
                                const eased = t * Math.abs(t); // stronger near edges
                                const offset = eased * (maxSpread/2);
                                if (Math.abs(offset) < 0.0001) continue; // skip near-zero offset (center occupied)
                                const vx = Math.cos(ang + offset) * speed * 0.97;
                                const vy = Math.sin(ang + offset) * speed * 0.97;
                                game.spawnProjectile({
                                    x: proj.x, y: proj.y,
                                    vx, vy,
                                    life: Math.floor(proj.life * 0.85),
                                    size: Math.max(2, proj.size * 0.60), enemy:false,
                                    damage: Math.max(1, Math.floor(base * 0.45)), baseDamage: Math.max(1, Math.floor(base * 0.45)),
                                    veerChild:true,
                                    _initialFx: Math.cos(ang + offset), _initialFy: Math.sin(ang + offset)
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFF2CC','spark');
                        }
                    }
                    // Converging Twins (new phased behavior): diverge -> curve inward -> fuse -> fused projectile persists (fix left-aim wrap)
                    if (proj.convergePair && proj._convGroup) {
                        proj._convTimer = (proj._convTimer||0)+1;
                        const phase = proj._convPhase || 'diverge';
                        const sp = Math.hypot(proj.vx, proj.vy) || 0.0001;
                        const ang = Math.atan2(proj.vy, proj.vx);
                        if (phase === 'diverge') {
                            // Maintain slight outward lateral drift for a set duration
                            if (proj._convTimer > 14) {
                                // Telegraph the curve-in (perf-aware)
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) addParticle(proj.x, proj.y, '#AEEBFF','ring');
                                proj._convPhase = 'curveIn';
                                proj._convTimer = 0;
                            }
                        } else if (phase === 'curveIn') {
                            // Apply curvature toward central forward direction gradually
                            // Determine average heading of group by sampling partner
                            let partner = null;
                            for (const p2 of game.projectiles) {
                                if (p2!==proj && p2._convGroup === proj._convGroup && !p2._fused && !proj._fused) { partner = p2; break; }
                            }
                            const forwardAng = partner ? Math.atan2((proj.vy+partner.vy)/2, (proj.vx+partner.vx)/2) : ang;
                            const blend = 0.05 + Math.min(0.18, proj._convTimer*0.004);
                            // Normalize smallest angle delta to avoid wrap causing vertical motion when aiming left
                            let delta = forwardAng - ang; delta = (delta + Math.PI) % (Math.PI*2); if (delta < 0) delta += Math.PI*2; delta -= Math.PI;
                            const newAng = ang + delta*blend;
                            proj.vx = Math.cos(newAng)*sp;
                            proj.vy = Math.sin(newAng)*sp;
                            if (proj._convTimer > 26) {
                                proj._convPhase = 'fuseCheck';
                                proj._convTimer = 0;
                            }
                        } else if (phase === 'fuseCheck') {
                            // Only one (primary) attempts fusion logic
                            if (proj._convPrimary) {
                                let partner = null;
                                for (const p2 of game.projectiles) {
                                    if (p2!==proj && p2._convGroup === proj._convGroup && !p2._fused && !proj._fused) { partner = p2; break; }
                                }
                                if (partner) {
                                    const dx = partner.x - proj.x; const dy = partner.y - proj.y; const d2 = dx*dx+dy*dy;
                                    // Allow fairly wide detection so they fuse mid-screen; shrink over time
                                    const fuseRadius = 110 - Math.min(70, proj._convTimer*2); // starts large, narrows
                                    if (d2 <= fuseRadius*fuseRadius) {
                                        // If very close perform actual fusion
                                        if (d2 < 38*38) {
                                            const baseCombined = (proj.baseDamage||calculateDamage()) + (partner.baseDamage||calculateDamage());
                                            const fuseX = (proj.x+partner.x)/2; const fuseY = (proj.y+partner.y)/2;
                                            const fuseVx = (proj.vx+partner.vx)/2; const fuseVy = (proj.vy+partner.vy)/2;
                                            // Spawn fused projectile with boosted size and damage (not full sum to avoid runaway)
                                            const fusedDmg = Math.max(1, Math.floor(baseCombined * 0.95));
                                            game.spawnProjectile({
                                                x: fuseX, y: fuseY,
                                                vx: fuseVx, vy: fuseVy,
                                                life: Math.max(proj.life, partner.life) + 40,
                                                size: Math.max(proj.size, partner.size) + 4,
                                                enemy:false,
                                                damage: fusedDmg,
                                                baseDamage: fusedDmg,
                                                fusedTwin:true,
                                                _fuseAuraTimer: 0,
                                                _convFused:true
                                            });
                                            proj._fused = true; partner._fused = true; proj.life = 0; partner.life = 0;
                                            // AoE burst on fuse (reward mid-range)
                                            const burstR = 90;
                                            const burstDamage = Math.max(2, Math.floor(fusedDmg * 0.45));
                                            if (game.enemies && game.enemies.length) {
                                                for (const en of game.enemies) {
                                                    const ex = en.x - fuseX; const ey = en.y - fuseY;
                                                    if (ex*ex+ey*ey <= burstR*burstR) {
                                                        en.health -= burstDamage;
                                                        addDamageNumber(burstDamage, en.x, en.y - en.size/2, { type:'arcane' });
                                                    }
                                                }
                                            }
                                            addParticle(fuseX, fuseY, '#BBAAFF','explosion');
                                        }
                                    }
                                    // After some time, if not fused yet, gently pull them together
                                    if (!proj._fused && proj._convTimer > 40 && partner) {
                                        const dx2 = partner.x - proj.x; const dy2 = partner.y - proj.y; const d = Math.hypot(dx2, dy2) || 1;
                                        const pull = Math.min(0.35, 12/d);
                                        proj.vx += dx2/d * pull * 0.5; proj.vy += dy2/d * pull * 0.5;
                                        partner.vx -= dx2/d * pull * 0.5; partner.vy -= dy2/d * pull * 0.5;
                                    }
                                }
                            }
                            proj._convTimer++;
                            // Fail-safe: stop checking after long time to avoid infinite state retention
                            if (proj._convTimer > 160) proj._convPhase = 'expired';
                        }
                    }
                }
                // Resonance framework: count active core motion patterns (excluding orbital/beam/enemy)
                if (!proj.enemy && !proj.beam) {
                    const motionPatterns = [proj.sineWave, proj.wackyZigzag, proj.ekgWave, proj.spiral];
                    let patternCount = 0;
                    for (let mp of motionPatterns) if (mp) patternCount++;
                    if (patternCount >= 2) {
                        // light intrinsic damage amplification stored on projectile
                        if (!proj._resonanceApplied) {
                            proj._resonanceApplied = true;
                            // store a multiplier rather than immediately mutating baseDamage so later scaling uses it
                            proj._resonanceMult = 1 + (patternCount === 2 ? 0.08 : patternCount === 3 ? 0.15 : 0.22);
                        }
                        // escalate multiplier if projectile later gains more patterns (e.g., via inheritance)
                        if (proj._resonanceMult) {
                            const desiredMult = 1 + (patternCount === 2 ? 0.08 : patternCount === 3 ? 0.15 : 0.22);
                            if (desiredMult > proj._resonanceMult) proj._resonanceMult = desiredMult;
                        }
                        // resonance pulse setup for >=3 patterns
                        if (patternCount >= 3) {
                            proj._resPulseTimer = (proj._resPulseTimer || 0) + 1;
                            // base interval shrinks slightly with patternCount (e.g., 90 -> 70 frames)
                            const interval = patternCount === 3 ? 90 : 70;
                            if (proj._resPulseTimer >= interval) {
                                proj._resPulseTimer = 0;
                                // spawn a lightweight pulse marker (handled immediately here for simplicity)
                                const pulseRadius = 52 + patternCount * 10;
                                const baseDmg = (proj.baseDamage || calculateDamage());
                                const pulseDamage = Math.floor(baseDmg * (0.18 + 0.04 * (patternCount - 3))); // 18% or 22%
                                game.enemies.forEach(en => {
                                    const dx = en.x - proj.x; const dy = en.y - proj.y;
                                    if (dx*dx + dy*dy <= pulseRadius * pulseRadius) {
                                        en.health -= pulseDamage;
                                        addParticle(en.x, en.y, '#AA66FF', 'impact');
                                    }
                                });
                                // visual ring particles
                                for (let k=0;k<24;k++) {
                                    const ang = (k/24)*Math.PI*2;
                                    addParticle(proj.x + Math.cos(ang)*pulseRadius, proj.y + Math.sin(ang)*pulseRadius, patternCount===3?'#66DDFF':'#FF55FF', 'spark');
                                }
                            }
                        }
                        // Quad resonance (all four patterns) occasional hypersurge: brief speed spike & particle
                        if (patternCount === 4) {
                            proj._quadTick = (proj._quadTick || 0) + 1;
                            if (proj._quadTick % 120 === 0) {
                                // small forward burst
                                const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                                proj.vx *= 1.25; proj.vy *= 1.25;
                                // clamp after burst
                                const nsp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                                const max = sp * 1.8;
                                if (nsp > max) { proj.vx = proj.vx / nsp * max; proj.vy = proj.vy / nsp * max; }
                                addParticle(proj.x, proj.y, '#FF99FF', 'spark');
                            }
                        }
                    }
                }
                // Homing behavior (full homing and weak homing)
                if (!proj.enemy && game.enemies.length > 0 && (proj.homing || proj.weakHoming)) {
                    // find nearest enemy
                    let target = null;
                    let closestDist = Infinity;
                    game.enemies.forEach(enemy => {
                        const dist = Math.sqrt((enemy.x - proj.x) ** 2 + (enemy.y - proj.y) ** 2);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = enemy;
                        }
                    });
                    if (target) {
                        const dx = target.x - proj.x;
                        const dy = target.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                        if (proj.homing) {
                            // stronger homing: steer more aggressively and normalize
                            const steer = 0.35;
                            proj.vx += (dx / dist) * steer;
                            proj.vy += (dy / dist) * steer;
                            const sp = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) || 0.0001;
                            const desired = Math.max(0.6, sp);
                            proj.vx = (proj.vx / sp) * desired;
                            proj.vy = (proj.vy / sp) * desired;
                        } else if (proj.weakHoming) {
                            // weak homing: slightly stronger to remain noticeable next to patterns
                            const steer = 0.16;
                            proj.vx += (dx / dist) * steer;
                            proj.vy += (dy / dist) * steer;
                        }
                    }
                }
                // Pattern Trail Visuals: emit lightweight particles indicating motion synergy
                if (!proj.enemy && !proj.beam) {
                    // Determine if projectile should spawn a trail this frame
                    // Base chance for any projectile with motion pattern; higher for chaos wacky
                    let spawnTrail = false;
                    let baseChance = 0;
                    const motionCount = (proj.sineWave?1:0)+(proj.wackyZigzag?1:0)+(proj.ekgWave?1:0)+(proj.spiral?1:0);
                    if (motionCount > 0) baseChance = 0.10 + motionCount * 0.03; // 10% +3% per pattern
                    if (proj.wackyZigzag) baseChance += 0.05;
                    if (proj._wackyChaos) baseChance += 0.12; // more intense trail for chaos variant
                    if (Math.random() < baseChance) spawnTrail = true;
                    if (spawnTrail) {
                        const hex = getProjectileSynergyColor(proj);
                        // Particle size scales with motion complexity
                        const pSize =  proj._wackyChaos ? 6 : (3 + Math.min(3, motionCount));
                        // Emit 1-2 particles, slight backward offset along velocity
                        const backX = proj.x - proj.vx*0.08;
                        const backY = proj.y - proj.vy*0.08;
                        addParticle(backX, backY, hex, 'spark');
                        if (proj._wackyChaos && Math.random()<0.5) addParticle(backX + (Math.random()-0.5)*6, backY + (Math.random()-0.5)*6, hex, 'spark');
                    }
                }
                // Beam pattern blending (visual modulation) - apply after homing but before movement finalize
                if (proj.beam && !proj.enemy) {
                    // increment phase
                    proj._beamPatternPhase = (proj._beamPatternPhase || 0) + 1;
                    // slight oscillation perpendicular to direction for sine
                    if (!proj._beamBasis) {
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||1;
                        proj._beamBasis = { fx: proj.vx/sp, fy: proj.vy/sp };
                        proj._beamBasis.px = -proj._beamBasis.fy; proj._beamBasis.py = proj._beamBasis.fx;
                    }
                    let offX = 0, offY = 0;
                    const phase = proj._beamPatternPhase;
                    if (proj.sineWave) {
                        const amp = 4 + (proj.spiral?2:0);
                        const s = Math.sin(phase * 0.3) * amp;
                        offX += proj._beamBasis.px * s; offY += proj._beamBasis.py * s;
                    }
                    if (proj.wackyZigzag) {
                        const dirFlip = ((phase/6)|0)%2===0?1:-1;
                        offX += proj._beamBasis.px * dirFlip * 3;
                        offY += proj._beamBasis.py * dirFlip * 3;
                    }
                    if (proj.ekgWave) {
                        const cyc = phase % 50;
                        if (cyc < 8) {
                            const t = cyc/8; const spike = -Math.sin(t*Math.PI)*10;
                            offX += proj._beamBasis.px * spike; offY += proj._beamBasis.py * spike;
                        }
                    }
                    if (proj.spiral) {
                        const rotAng = phase * 0.15;
                        // rotate offset around small circle
                        offX += Math.cos(rotAng)*2; offY += Math.sin(rotAng)*2;
                    }
                    proj.x += offX * 0.25; // damp to avoid large displacement changing collision fairness
                    proj.y += offY * 0.25;
                    // occasional pattern particle
                    if (Math.random() < 0.12) {
                        const color = proj.spiral?'#FF66FF': (proj.ekgWave?'#66FFCC': (proj.wackyZigzag?'#FFDD55':'#66AAFF'));
                        addParticle(proj.x, proj.y, color, 'spark');
                    }
                }
                // Boomerang behavior (ensured return + chaining + movement bias + wind synergy)
                if (proj.boomerang && !proj.enemy) {
                    // Initialization of boomerang arc parameters
                    if (!proj._boomInit) {
                        proj._boomInit = true;
                        // Store origin and initial forward unit vector
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 1;
                        proj._boomFx = proj.vx / sp; proj._boomFy = proj.vy / sp;
                        // Random lateral sign for variety
                        proj._boomSide = (Math.random() < 0.5 ? -1 : 1);
                        // Max lateral offset radius (arc width)
                        proj._boomMaxLat = 90 + Math.random()*30; // px
                        // Distance before turning back
                        proj._boomOutboundDist = 180 + Math.random()*40; // slightly shorter to ensure visible return
                        proj._boomTravel = 0; // accumulated forward distance
                        proj._boomReturn = false;
                        proj._boomChained = false; // echo spawn flag
                        proj._boomOriginX = proj.x; proj._boomOriginY = proj.y;
                        proj._boomAge = 0; // frames alive for safety timeout
                        proj._boomForced = false; // whether forced return occurred
                        proj._boomBaseLife = proj.life || 140;
                    }
                    proj._boomAge++;
                    // Compute forward speed magnitude
                    let speed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.01;
                    // Update forward travel distance using projection onto initial forward vector
                    const stepForward = (proj.vx*proj._boomFx + proj.vy*proj._boomFy);
                    // Accumulate more aggressively so high lateral components still progress outbound timer
                    proj._boomTravel += Math.max(0, stepForward * 0.9);
                    // Fallback: also measure radial distance from origin; if that exceeds outboundDist * 0.9, trigger return
                    if (!proj._boomReturn) {
                        const ox = proj.x - proj._boomOriginX; const oy = proj.y - proj._boomOriginY;
                        const radial = Math.hypot(ox,oy);
                        if (radial > proj._boomOutboundDist * 0.95) proj._boomReturn = true;
                    }

                    // Trigger return when outbound distance met OR if exceeded arena bounds
                    if (!proj._boomReturn && proj._boomTravel >= proj._boomOutboundDist) {
                        proj._boomReturn = true;
                    }
                    // Safety timeout: if not yet returning by frame 90, force it
                    if (!proj._boomReturn && proj._boomAge > 90) {
                        proj._boomReturn = true; proj._boomForced = true;
                    }

                    // Movement bias: if player currently moving, gently bias lateral side toward movement perpendicular (outbound only)
                    if (!proj._boomReturn) {
                        const mvx = (game.keys['d']?1:0) - (game.keys['a']?1:0);
                        const mvy = (game.keys['s']?1:0) - (game.keys['w']?1:0);
                        if (mvx || mvy) {
                            const ml = Math.hypot(mvx,mvy)||1; const nmx = mvx/ml, nmy = mvy/ml;
                            const cross = (proj._boomFx * nmy - proj._boomFy * nmx); // signed relation
                            if (Math.abs(cross) > 0.2) {
                                proj._boomSide = cross > 0 ? 1 : -1;
                            }
                        }
                    }

                    // Base forward direction: outbound uses initial forward; return aims toward player gradually
                    let fx = proj._boomFx, fy = proj._boomFy;
                    if (proj._boomReturn) {
                        const dxp = game.player.x - proj.x;
                        const dyp = game.player.y - proj.y;
                        const dpl = Math.hypot(dxp,dyp)||1;
                        const tFx = dxp / dpl, tFy = dyp / dpl;
                        // Smoothly rotate toward player direction (lerp of unit vectors) stronger when forced
                        const blend = proj._boomForced ? 0.25 : 0.12;
                        fx = fx * (1-blend) + tFx * blend; fy = fy * (1-blend) + tFy * blend;
                        const norm = Math.hypot(fx,fy)||1; fx/=norm; fy/=norm;
                        proj._boomFx = fx; proj._boomFy = fy;
                        // Mirror arc side for return for a classic boomerang path
                        proj._boomSide = proj._boomSide || 1; // safety
                        proj._boomReturnSide = (typeof proj._boomReturnSide==='number')?proj._boomReturnSide: -proj._boomSide;
                        // Extend life on entering return so it doesn't vanish prematurely
                        if (!proj._boomLifeExtended) { proj.life = Math.max(proj.life, 60); proj._boomLifeExtended = true; }
                    }

                    // Lateral progress (0..1) along outbound or return; use sine for graceful arc
                    const phaseFrac = Math.min(1, proj._boomTravel / proj._boomOutboundDist);
                    // Ease the lateral amplitude: outbound grows then stabilizes, return decreases
                    let lateralFrac;
                    if (!proj._boomReturn) {
                        lateralFrac = Math.sin(phaseFrac * Math.PI * 0.9); // peaks before full outbound
                    } else {
                        lateralFrac = Math.sin((1 - phaseFrac) * Math.PI * 0.9); // fade down
                    }
                    lateralFrac = Math.max(0, lateralFrac);
                    const latMag = proj._boomMaxLat * lateralFrac;
                    // Perpendicular vector to forward (fx,fy)
                    const px = -fy, py = fx;
                    // Determine side: outbound uses _boomSide, return uses mirrored side for a figure
                    const side = proj._boomReturn ? (proj._boomReturnSide) : proj._boomSide;
                    // Target lateral position relative to straight-line forward ray
                    proj._boomLat = latMag * side;
                    // We convert lateral displacement into a small velocity tweak pulling the projectile outward along perpendicular
                    // Then speed toward forward direction is slightly reduced near peak arc to curve naturally.
                    const lateralStrength = 0.12;
                    proj.vx = fx * speed * 0.97 + px * (proj._boomLat/ proj._boomMaxLat) * lateralStrength * speed;
                    proj.vy = fy * speed * 0.97 + py * (proj._boomLat/ proj._boomMaxLat) * lateralStrength * speed;
                    // Minimum forward speed clamp so it doesn't stall mid-air
                    const curSpeed = Math.hypot(proj.vx, proj.vy) || 0.01;
                    if (curSpeed < 2) {
                        const boost = (proj._boomReturn ? 1.25 : 1.12);
                        proj.vx = (proj.vx / curSpeed) * (curSpeed * boost + 0.05);
                        proj.vy = (proj.vy / curSpeed) * (curSpeed * boost + 0.05);
                    }
                    // Slight acceleration on return to ensure timely comeback
                    if (proj._boomReturn) {
                        proj.vx *= 1.012; proj.vy *= 1.012;
                    }
                    // Wind synergy: dynamic widening & swirl particles
                    if (game.player && game.player.abilities && game.player.abilities.includes('Wind Blade')) {
                        proj._boomMaxLat = Math.min(170, proj._boomMaxLat * 1.004 + 0.05);
                        if (Math.random() < 0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#AEEFFF','spark');
                    }
                    // Multi-boomerang chaining (echo spawns) during outbound
                    if (!proj._boomReturn && !proj._boomChained && !proj._boomEcho && proj._boomTravel > proj._boomOutboundDist * 0.50) {
                        proj._boomChained = true;
                        const echoCount = 1 + (Math.random()<0.45 ? 1 : 0);
                        for (let e=0;e<echoCount;e++) {
                            const angJ = (Math.random()-0.5)*0.3;
                            const baseSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) * (0.85 - e*0.1);
                            const ang = Math.atan2(proj.vy, proj.vx) + angJ;
                            const eIdx = game.spawnProjectile({
                                x: proj.x + Math.cos(ang)*6,
                                y: proj.y + Math.sin(ang)*6,
                                vx: Math.cos(ang)*baseSpeed,
                                vy: Math.sin(ang)*baseSpeed,
                                life: Math.min(160, (proj.life||140)),
                                r: Math.max(4, Math.floor(((proj.size)||6)*0.85)),
                                damage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage()) * 0.55)),
                                damageType: proj.damageType || null
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            if (eIdx>=0) game._projMeta.set(eIdx,{ boomerang:true, boomerangReturned:false, _boomInit:false, _boomEcho:true, piercing:proj.piercing, pierceCount:proj.pierceCount||0, pierceHits:0, baseDamage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage()) * 0.55)) });
                            for (let p=0;p<6;p++) addParticle((proj.x + Math.cos(ang)*6) + (Math.random()-0.5)*10, (proj.y + Math.sin(ang)*6) + (Math.random()-0.5)*10, '#FFFFFF','spark');
                        }
                    }
                    // Arrival check (close to player once returning)
                    const dxp2 = proj.x - game.player.x;
                    const dyp2 = proj.y - game.player.y;
                    if (proj._boomReturn && Math.hypot(dxp2,dyp2) < 22) {
                        for (let k=0;k<5;k++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFFFFF', 'spark');
                        return false;
                    }
                    // Decorative trailing sparkle (subtle) while returning
                    if (proj._boomReturn && Math.random()<0.18) addParticle(proj.x, proj.y, '#E0F8FF','spark');
                }
                // Time Bomb: delayed explosion after a timer
                if (proj.timeBomb && !proj.enemy) {
                    proj._timeBombTimer = (typeof proj._timeBombTimer === 'number') ? proj._timeBombTimer : 54; // default short fuse
                    // Cache the initial fuse length for normalized glow intensity
                    if (typeof proj._tbFuseMax !== 'number') proj._tbFuseMax = proj._timeBombTimer;
                    proj._timeBombTimer--;
                    const t = proj._timeBombTimer;
                    // Pulse visuals escalate quickly
                    if (t % 10 === 0) addParticle(proj.x, proj.y, '#FFECAA', 'spark');
                    if (t < 36 && t % 5 === 0) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFC744', 'spark');
                    if (t < 18 && t % 2 === 0) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FF9922', 'spark');
                    if (t === 20) proj._timeBombArmed = true;
                    // Fuse glow intensifies as timer approaches 0 (0..1 non-linear easing)
                    {
                        const maxFuse = Math.max(1, proj._tbFuseMax || 54);
                        const frac = 1 - Math.max(0, Math.min(1, t / maxFuse));
                        // Ease-in squared for stronger late-stage emphasis
                        proj._tbGlowI = Math.min(1, frac*frac * (proj._timeBombArmed ? 1.2 : 1));
                    }
                    // Arming ring cue (once at arm) and pre-detonation ring cue (very short)
                    if (typeof addTransientEffect === 'function') {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!lowFx && !reduceRings) {
                            if (t === 20) addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFD38A', radius: 16, life: 140 });
                            if (t === 4) addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFAA55', radius: 18, life: 110 });
                        }
                    }
                    // Mild flashing scale indicator when armed
                    if (proj._timeBombArmed && t % 4 === 0) {
                        addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFD777', 'spark');
                    }
                    if (t <= 0) {
                        const damage = Math.floor((proj.baseDamage || calculateDamage()) * (proj._timeBombExplosionMult || 2.0));
                        explodeProjectile(proj, damage);
                        proj.life = 0;
                    }
                }
                // Meteor: guided descent toward target; guaranteed timed explosion with knockback
                if (proj.meteor && !proj.enemy) {
                    // Flame / trail particles
                    proj._flameTick = (proj._flameTick || 0) + 1;
                    if (proj._flameTick % 2 === 0) {
                        addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFB347', 'spark');
                        if (Math.random() < 0.30) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFD27F', 'spark');
                    }
                    if (proj._flameTick % 5 === 0) addParticle(proj.x + (Math.random()-0.5)*16, proj.y + (Math.random()-0.5)*16, '#663300', 'explosion');
                    // Deterministic interpolation based on spawn/detonate frames
                    if (proj._meteorDetonateAt && proj._meteorSpawnFrame != null && proj._meteorStartY != null) {
                        const total = Math.max(1, proj._meteorDetonateAt - proj._meteorSpawnFrame);
                        const elapsed = Math.min(total, game.frame - proj._meteorSpawnFrame);
                        const t = Math.min(1, elapsed / total);
                        if (proj._meteorTargetX != null && proj._meteorStartX != null) {
                            const easeT = t < 0.5 ? (2*t*t) : (-1 + (4 - 2*t)*t); // easeInOut
                            proj.x = proj._meteorStartX + (proj._meteorTargetX - proj._meteorStartX) * easeT;
                        }
                        if (proj._meteorTargetY != null) {
                            proj.y = proj._meteorStartY + (proj._meteorTargetY - proj._meteorStartY) * t;
                        }
                    }
                    if (game.frame >= proj._meteorDetonateAt && !proj._meteorExploded) {
                        proj._meteorExploded = true;                        
                        const dmg = proj.baseDamage || calculateDamage();
                        const radius = proj._meteorAoeRadius || 90;
                        // Damage + knockback
                        game.enemies.forEach(en => {
                            const dx = en.x - proj.x; const dy = en.y - proj.y; const dist = Math.hypot(dx,dy);
                            if (dist <= radius) {
                                const mult = (1 - dist / radius) * 0.75 + 0.25; // soften edge
                                const dealt = Math.floor(dmg * mult);
                                en.health -= dealt;
                                addDamageNumber(dealt, en.x, en.y - en.size/2, { type: 'fire' });
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                                // Knockback outward
                                const k = (proj._meteorKnockback || 120) * (1 - dist / radius);
                                if (k > 8) applyKnockback(en, k, dx, dy);
                            }
                        });
                        addScreenShake(11);
                        // Visual blast
                        explodeProjectile({ x: proj.x, y: proj.y, size: proj.size, damageType: 'fire', knockback: true, knockbackDistance: proj._meteorKnockback || 120 }, dmg);
                        for (let p=0;p<38;p++) addParticle(proj.x + (Math.random()-0.5)*radius*1.4, proj.y + (Math.random()-0.5)*radius*1.4, '#FF8844','explosion');
                        // Retire telegraph marker
                        if (typeof proj._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[proj._meteorMarkerId]) {
                            game.meteorMarkers[proj._meteorMarkerId].dead = true;
                        }
                        proj.life = 0;
                    } else if (proj.life <= 0 && !proj._meteorExploded) {
                        // Fallback: if life ended prematurely (e.g., offscreen cull modification) still trigger explosion
                        proj._meteorExploded = true;
                        const dmg = proj.baseDamage || calculateDamage();
                        const radius = proj._meteorAoeRadius || 90;
                        game.enemies.forEach(en => {
                            const dx = en.x - proj.x; const dy = en.y - proj.y; const dist = Math.hypot(dx,dy);
                            if (dist <= radius) {
                                const mult = (1 - dist / radius) * 0.75 + 0.25;
                                const dealt = Math.floor(dmg * mult);
                                en.health -= dealt;
                                addDamageNumber(dealt, en.x, en.y - en.size/2, { type: 'fire' });
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                                const k = (proj._meteorKnockback || 120) * (1 - dist / radius);
                                if (k > 8) applyKnockback(en, k, dx, dy);
                            }
                        });
                        addScreenShake(9);
                        explodeProjectile({ x: proj.x, y: proj.y, size: proj.size, damageType: 'fire', knockback: true, knockbackDistance: proj._meteorKnockback || 120 }, dmg);
                        for (let p=0;p<26;p++) addParticle(proj.x + (Math.random()-0.5)*radius*1.2, proj.y + (Math.random()-0.5)*radius*1.2, '#FF7744','explosion');
                        if (typeof proj._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[proj._meteorMarkerId]) {
                            game.meteorMarkers[proj._meteorMarkerId].dead = true;
                        }
                    }
                }
                // Quantum shot: slight life regen so it can hit multiple times
                if (proj.quantum && !proj.enemy) {
                    proj.life += 0.15;
                }
                // Reality field refraction: if projectile passes through an active reality field, bend its velocity
                if (!proj.enemy && game.activeRealityFields && game.activeRealityFields.length > 0) {
                    game.activeRealityFields.forEach(field => {
                        const dx = proj.x - field.x;
                        const dy = proj.y - field.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < field.radius) {
                            // compute vector from field center to projectile and apply small lateral impulse
                            const angleToCenter = Math.atan2(proj.y - field.y, proj.x - field.x);
                            const lateral = (Math.cos(angleToCenter + Math.PI/2) * 0.6);
                            // nudge velocity perpendicular to radial vector to create refraction-like bend
                            const spd = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                            proj.vx += lateral * (1 - dist / field.radius) * 0.6;
                            proj.vy += Math.sin(angleToCenter + Math.PI/2) * (1 - dist / field.radius) * 0.6;
                            // normalize to keep speed stable
                            const nsp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                            proj.vx = (proj.vx / nsp) * spd;
                            proj.vy = (proj.vy / nsp) * spd;
                            // small visual cue
                            if (Math.random() < 0.08) addParticle(proj.x, proj.y, '#66FFFF', 'spark');
                        }
                    });
                }
                // Orbital projectiles: now inherit motion pattern modifiers for dynamic paths & resonance
                if (proj._orbital && !proj.enemy) {
                    // Initialize pattern fusion state once
                    if (!proj._orbitalInit) {
                        proj._orbitalInit = true;
                        proj._baseRadius = proj._orbitRadius;
                        proj._sinePhase = Math.random() * Math.PI * 2;
                        proj._wackyTimer = 0;
                        proj._ekgState = 'flat'; proj._ekgTimer = 0;
                        proj._spiralPhase = 0;
                        // Derive pattern presence flags from existing projectile flags (inherited at spawn)
                        proj._patSine = !!proj.sineWave;
                        proj._patWacky = !!proj.wackyZigzag;
                        proj._patEKG = !!proj.ekgWave;
                        proj._patSpiral = !!proj.spiral;
                        // Base resonance multiplier grows with number of patterns (match non-orbital logic but reduced)
                        const pc = (proj._patSine?1:0)+(proj._patWacky?1:0)+(proj._patEKG?1:0)+(proj._patSpiral?1:0);
                        proj._resonanceOrbMult = pc>=4?1.18: pc===3?1.13: pc===2?1.08:1.0; // gentler than projectile version
                    }
                    proj._orbitAngle += proj._orbitSpeed;
                    let dynamicRadius = proj._baseRadius;
                    // Sine: smooth pulsation of radius
                    if (proj._patSine) {
                        proj._sinePhase += 0.07; // slow pulse
                        dynamicRadius += Math.sin(proj._sinePhase) * (8 + Math.min(18, proj._baseRadius * 0.12));
                    }
                    // Wacky: small angular jitter & radius micro noise
                    if (proj._patWacky) {
                        proj._wackyTimer++;
                        if (proj._wackyTimer % 14 === 0) {
                            proj._orbitAngle += (Math.random() - 0.5) * 0.9; // burst re-vector
                        }
                        dynamicRadius += (Math.random() - 0.5) * 10;
                    }
                    // EKG: periodic sharp contraction / expansion pulses
                    if (proj._patEKG) {
                        proj._ekgTimer++;
                        const cyc = proj._ekgTimer % 120; // 120f cycle (~2s)
                        if (cyc < 12) {
                            // Ascending spike  rapid contraction
                            const t = cyc / 12;
                            dynamicRadius -= (18 + proj._baseRadius * 0.15) * Math.sin(t * Math.PI/2);
                        } else if (cyc >= 12 && cyc < 24) {
                            // Descend & rebound
                            const t = (cyc-12)/12;
                            dynamicRadius -= (18 + proj._baseRadius * 0.15) * (1 - t) * 0.6;
                        }
                    }
                    // Spiral: slow precession of orbital angle and mild radius growth/decay wave
                    if (proj._patSpiral) {
                        proj._spiralPhase += 0.03;
                        proj._orbitAngle += Math.sin(proj._spiralPhase * 0.8) * 0.015;
                        dynamicRadius += Math.sin(proj._spiralPhase * 1.3) * 12;
                    }
                    // Clamp radius to safe bounds
                    const minR = Math.max(40, proj._baseRadius * 0.55);
                    const maxR = Math.min(260, proj._baseRadius * 1.45);
                    if (dynamicRadius < minR) dynamicRadius = minR;
                    if (dynamicRadius > maxR) dynamicRadius = maxR;
                    proj._orbitRadius = dynamicRadius;
                    // Position orbital
                    proj.x = game.player.x + Math.cos(proj._orbitAngle) * dynamicRadius;
                    proj.y = game.player.y + Math.sin(proj._orbitAngle) * dynamicRadius;
                    // Pattern particle trail (color shift with resonance strength)
                    if (Math.random() < 0.22) {
                        const pc = (proj._patSine?1:0)+(proj._patWacky?1:0)+(proj._patEKG?1:0)+(proj._patSpiral?1:0);
                        const color = pc>=4?'#FF99FF': pc===3?'#AA88FF': pc===2?'#88EEFF':'#88EEFF';
                        addParticle(proj.x, proj.y, color, 'spark');
                    }
                    // Damage nearby enemies (resonance multiplier applied)
                    const baseTick = Math.floor(calculateDamage() * 0.6 * (proj._resonanceOrbMult || 1));
                    game.enemies.forEach(enemy => {
                        if (enemy.health<=0) return;
                        const dx = proj.x - enemy.x; const dy = proj.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < (enemy.size/2 + proj.size)) {
                            enemy.health -= Math.max(1, baseTick);
                            addParticle(enemy.x, enemy.y, '#88EEFF', 'impact');
                        }
                    });
                    proj.life = 99999; // persistent
                }
                // Spinning blade (weapon) visual/logic (unchanged behavior for weapon spin)
                if (proj.spin && !proj.enemy && !proj.spiral) {
                    proj.spinAngle += proj.spinSpeed || 0.5;
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    game.enemies.forEach((enemy) => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        if (d < (enemy.size/2 + (proj.size||10))) {
                            enemy.health -= Math.floor(calculateDamage() * 0.9);
                            addParticle(enemy.x, enemy.y, '#CCCCCC', 'impact');
                        }
                    });
                }
                // True Spiral Shot motion: projectiles with proj.spiral orbit along a local circular path while advancing forward.
                if (proj.spiral && !proj.enemy) {
                    // Initialize spiral state once
                    if (!proj._spiralInit) {
                        proj._spiralInit = true;
                        // Base forward direction from initial velocity
                        const baseDirAngle = Math.atan2(proj.vy, proj.vx);
                        proj._spiralBaseAngle = baseDirAngle; // stored for forward drift
                        proj._spiralPhase = 0; // current angle around local loop
                        // Enlarged spiral parameters for more dramatic looping
                        proj._spiralRadius = Math.max(10, Math.min(42, (proj.size||6) * 2.2)); // bigger starting loop
                        proj._spiralRadiusGrowth = 0.085; // faster outward expansion
                        proj._spiralAngularSpeed = 0.30 + Math.random()*0.10; // slightly slower to keep large loops readable
                        proj._spiralForwardSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy);
                        // Stronger damping so forward drift doesn't stretch the spiral too quickly
                        proj._spiralForwardSpeed *= 0.70;
                        // Preserve damage tracking
                    }
                    // Advance spiral phase & radius (cap radius growth to avoid huge loops)
                    proj._spiralPhase += proj._spiralAngularSpeed;
                    // Increase cap for new bigger loops
                    proj._spiralRadius = Math.min(110, proj._spiralRadius + proj._spiralRadiusGrowth);
                    // Compute local circular offset
                    const ox = Math.cos(proj._spiralPhase) * proj._spiralRadius;
                    const oy = Math.sin(proj._spiralPhase) * proj._spiralRadius;
                    // Forward drift anchor moves along base direction each frame
                    proj._spiralAnchorX = (proj._spiralAnchorX == null ? proj.x : proj._spiralAnchorX) + Math.cos(proj._spiralBaseAngle) * proj._spiralForwardSpeed;
                    proj._spiralAnchorY = (proj._spiralAnchorY == null ? proj.y : proj._spiralAnchorY) + Math.sin(proj._spiralBaseAngle) * proj._spiralForwardSpeed;
                    proj.x = proj._spiralAnchorX + ox;
                    proj.y = proj._spiralAnchorY + oy;
                    // Slight spin for visual flair if rendering uses spinAngle
                    proj.spinAngle = (proj.spinAngle || 0) + (proj.spinSpeed || 0.3);
                    // Life decay (already applied below normally)  we override base movement so skip the generic proj.x+=vx/vy step later by flagging
                    proj._skipBaseMove = true;
                    // Optional: emit small spiral particles occasionally
                    if (Math.random() < 0.18) addParticle(proj.x + (Math.random()-0.5)*4, proj.y + (Math.random()-0.5)*4, '#FF66FF', 'spark');
                }
                // Drilling shot: increases pierce and leaves a dust trail
                if (proj.drilling && !proj.enemy) {
                    proj.piercing = true;
                    proj.pierceCount = Math.max(proj.pierceCount, 6);
                    if (Math.random() < 0.2) addParticle(proj.x, proj.y, '#CCCCCC', 'spark');
                    proj._drillTicks = (proj._drillTicks || 0) + 1;
                    if (proj._drillTicks % 30 === 0) {
                        proj.baseDamage = Math.floor((proj.baseDamage || calculateDamage()) * 1.05);
                        addParticle(proj.x, proj.y, '#EEEEEE', 'spark');
                    }
                }
                if (!proj._skipBaseMove) {
                    // Store last safe position before movement for bounce recovery
                    proj._lastX = proj.x;
                    proj._lastY = proj.y;
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                }
                // Apply Resonant buff effects (speed/damage/homing) after base movement so velocity mod applies next frame
                if (!proj.enemy) {
                    if (proj._resBuffSpeed && proj._resBuffSpeed>0) {
                        proj._resBuffSpeed--;
                        proj.vx *= 1.045; proj.vy *= 1.045;
                    }
                    if (proj._resBuffDamage && proj._resBuffDamage>0) {
                        proj._resBuffDamage--;
                        if (proj.baseDamage) proj.damage = Math.max(proj.damage||1, Math.floor(proj.baseDamage * 1.15));
                    }
                    if (proj._resBuffHoming && proj._resBuffHoming>0) {
                        proj._resBuffHoming--;
                        // mild steering toward nearest enemy
                        let nearest=null; let nd2=Infinity;
                        for (const enemy of game.enemies) {
                            if (enemy.dead) continue;
                            const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const d2 = dx*dx+dy*dy; if (d2<nd2) { nd2=d2; nearest=enemy; }
                        }
                        if (nearest) {
                            const sp = Math.hypot(proj.vx, proj.vy)||1;
                            const tx = (nearest.x - proj.x)/Math.sqrt(nd2||1);
                            const ty = (nearest.y - proj.y)/Math.sqrt(nd2||1);
                            // blend velocity slightly
                            proj.vx = proj.vx*0.92 + tx*sp*0.08;
                            proj.vy = proj.vy*0.92 + ty*sp*0.08;
                        }
                    }
                }
                // Reset skip flag for next frame
                proj._skipBaseMove = false;
                // Prevent life decay for orbitals (already set high) to avoid unnecessary churn
                if (!proj._orbital) proj.life--;
                // Bouncing: handle wall and edge collisions robustly
                // Phasing synergy: if phasing is active, we still decrement bounces on edge contact, and we allow
                // ricochet chaining (enemy-to-enemy) without requiring an actual wall collision.
                if (proj.bouncing && proj.bounces > 0) {
                    let bounced = false;
                    // Predict next position to determine collision normal
                    const nextX = proj.x + proj.vx;
                    const nextY = proj.y + proj.vy;

                    // If we are already overlapping a wall (pattern lateral shift pushed us inside), rewind to last safe and force bounce
                    if (!proj.phasing && isWall(proj.x, proj.y, Math.max(8, proj.size))) {
                        // Use last base move position or pre-pattern snapshot if available
                        if (proj._lastX != null && proj._lastY != null) {
                            proj.x = proj._lastX; proj.y = proj._lastY;
                        } else if (proj._prePatternX != null) {
                            proj.x = proj._prePatternX; proj.y = proj._prePatternY;
                        }
                        // Determine which axis caused penetration by testing offset separately
                        const testXBlocked = isWall(proj.x + proj.vx, proj.y, Math.max(8, proj.size));
                        const testYBlocked = isWall(proj.x, proj.y + proj.vy, Math.max(8, proj.size));
                        if (testXBlocked && !testYBlocked) {
                            proj.vx = -proj.vx * 0.85;
                        } else if (testYBlocked && !testXBlocked) {
                            proj.vy = -proj.vy * 0.85;
                        } else {
                            proj.vx = -proj.vx * 0.78;
                            proj.vy = -proj.vy * 0.78;
                        }
                        bounced = true;
                    }

                    // Bounce off canvas edges (phasing still bounces on arena bounds)
                    if (nextX - proj.size <= 0 || nextX + proj.size >= canvas.width) {
                        proj.vx = -proj.vx * 0.86;
                        bounced = true;
                    }
                    if (nextY - proj.size <= 0 || nextY + proj.size >= canvas.height) {
                        proj.vy = -proj.vy * 0.86;
                        bounced = true;
                    }

                    // Bounce off walls (skip internal walls if phasing, but edge bounce already handled above)
                    if (!proj.phasing) {
                        // Check collision at next position with a modest size to detect wall contact
                        if (isWall(nextX, nextY, Math.max(8, proj.size))) {
                            // Determine which axis to reflect based on wall overlap by sampling small offsets
                            // If horizontal offset is more obstructed, flip vx, else flip vy.
                            const horBlocked = isWall(proj.x + proj.vx, proj.y, Math.max(8, proj.size));
                            const verBlocked = isWall(proj.x, proj.y + proj.vy, Math.max(8, proj.size));
                            if (horBlocked && !verBlocked) {
                                proj.vx = -proj.vx * 0.82;
                            } else if (verBlocked && !horBlocked) {
                                proj.vy = -proj.vy * 0.82;
                            } else {
                                // both blocked or unclear - reflect both with damping
                                proj.vx = -proj.vx * 0.76;
                                proj.vy = -proj.vy * 0.76;
                            }
                            bounced = true;
                            // Split Shot: split on wall bounce
                            // (Split Shot removed  no wall-bounce splitting)
                        }
                    }

                    if (bounced) {
                        proj.bounces = Math.max(0, proj.bounces - 1);
                        proj.life += 40;
                        addParticle(proj.x, proj.y, '#FFFFFF', 'spark');
                        // Impact ring and spark shower for visual clarity
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFFFFF', radius: 20, life: 140 });
                        }
                        for (let s=0;s<4;s++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#DDDDFF', 'spark');
                        // Maintain a reasonable minimum travel speed after damping so projectiles don't stall
                        const sp = Math.hypot(proj.vx, proj.vy) || 0;
                        const minSpeed = 3.8;
                        if (sp < minSpeed) {
                            // Re-normalize velocity to minSpeed preserving direction
                            const nx = (proj.vx || 0) / (sp || 1);
                            const ny = (proj.vy || 0) / (sp || 1);
                            proj.vx = nx * minSpeed;
                            proj.vy = ny * minSpeed;
                        }
                        // Phasing bounce visual accent (a faint cyan flash) so player sees the virtual ricochet
                        if (proj.phasing) {
                            addParticle(proj.x, proj.y, '#66EEFF', 'spark');
                            // Added brief cyan ring flash for clearer phasing ricochet feedback
                            if (typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#66EEFF', radius:24, life:18 });
                            } else {
                                // Fallback: spawn extra outward spark petals
                                for (let rf=0; rf<5; rf++) {
                                    addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#AAFFFF', 'spark');
                                }
                            }
                        }
                    }
                } else {
                    // Non-bouncing projectiles collide with walls and are removed (unless phasing)
                    if (!proj.phasing && isWall(proj.x, proj.y, Math.max(5, proj.size))) {
                        // Split Shot: split on wall impact
                        // (Split Shot removed  no wall-impact splitting)
                        return false;
                    }
                }
                // Beam segments: continuous tick damage (not orbital)
                if (proj.beam && !proj.enemy) {
                    if (!proj._beamHitTimes) proj._beamHitTimes = {};
                    proj._beamTickFrame = (proj._beamTickFrame || 0) + 1;
                    if (Math.random() < 0.15) addParticle(proj.x + (Math.random()-0.5)*proj.size, proj.y + (Math.random()-0.5)*proj.size, '#99EEFF', 'spark');
                    const tickIntervalFrames = 5;
                    const base = (proj.damage || calculateDamage());
                    const tickDamage = Math.max(1, Math.floor(base * 0.18));
                    game.enemies.forEach(enemy => {
                        const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const r = enemy.size/2 + proj.size;
                        if (dx*dx + dy*dy <= r*r) {
                            const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                            const last = proj._beamHitTimes[key] || 0;
                            if (proj._beamTickFrame - last >= tickIntervalFrames) {
                                proj._beamHitTimes[key] = proj._beamTickFrame;
                                enemy.health -= tickDamage;
                                addDamageNumber(tickDamage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType || 'laser' });
                                if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#55CCFF', 'impact');
                            }
                        }
                    });
                    // Close-range fallback: if an enemy is extremely close to the player along the beam's forward arc but
                    // not caught due to the beam segment offset, apply a reduced tick so hugging enemies still get hurt.
                    if (game.player) {
                        const originX = game.player.x;
                        const originY = game.player.y;
                        const dirX = proj.vx || Math.cos(proj.spinAngle || 0) || 1;
                        const dirY = proj.vy || Math.sin(proj.spinAngle || 0) || 0;
                        const dirLen = Math.hypot(dirX, dirY) || 1;
                        const ux = dirX / dirLen; const uy = dirY / dirLen;
                        const fallbackRadius = 42; // small circle around player
                        const arcCos = Math.cos(Math.PI/2); // 90 deg half-angle (only slight forward bias)
                        const miniTick = Math.max(1, Math.floor(base * 0.12));
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - originX; const dy = enemy.y - originY;
                            const dist2 = dx*dx + dy*dy;
                            if (dist2 <= fallbackRadius * fallbackRadius) {
                                const dist = Math.sqrt(dist2) || 1;
                                const dot = (dx/dist)*ux + (dy/dist)*uy;
                                if (dot >= arcCos) { // roughly within forward 180 (wide) to avoid punishing behind player
                                    const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                                    const last = proj._beamHitTimes[key] || 0;
                                    if (proj._beamTickFrame - last >= tickIntervalFrames) {
                                        proj._beamHitTimes[key] = proj._beamTickFrame;
                                        enemy.health -= miniTick;
                                        addDamageNumber(miniTick, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType || 'laser' });
                                        if (Math.random() < 0.18) addParticle(enemy.x, enemy.y, '#66BBFF', 'impact');
                                    }
                                }
                            }
                        });
                    }
                }
                // Final positional cull / life check
                // Extended off-screen tolerance: allow projectiles to travel further outside view before culling so
                // longer-lived shots (larger logical canvas) aren't prematurely despawned right at edge.
                const OFFSCREEN_PAD = 140; // previously 20; generous margin for effects that arc back or explode
                const alive = proj.life > 0 &&
                              proj.x > -OFFSCREEN_PAD && proj.x < canvas.width + OFFSCREEN_PAD &&
                              proj.y > -OFFSCREEN_PAD && proj.y < canvas.height + OFFSCREEN_PAD;
                if (!alive && proj.damageType === 'crystal' && !proj._crystalShattered) {
                    createCrystalShatter(proj.x, proj.y, proj.baseDamage || proj.damage || calculateDamage(), proj);
                }
                return alive;
            });
            // Orphan meteor marker cleanup: remove markers whose scheduled explode frame passed without a meteor claiming them
            if (Array.isArray(game.meteorMarkers)) {
                for (let i = game.meteorMarkers.length - 1; i >= 0; i--) {
                    const m = game.meteorMarkers[i];
                    if (!m) { game.meteorMarkers.splice(i,1); continue; }
                    if (m.dead) { game.meteorMarkers.splice(i,1); continue; }
                    if (m._explodeFrame && game.frame > m._explodeFrame + 5) { // small grace period
                        // If no meteor set dead flag, prune to prevent misleading lingering marker
                        game.meteorMarkers.splice(i,1);
                    }
                }
            }
        }

        function updateParticles() {
            const fast = game.perf && game.perf.lowFx;
            game.particles = game.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= fast ? 2 : 1;
                particle.alpha = particle.life / particle.maxLife;
                return particle.life > 0;
            });
        }

        function checkCollisions() {
            // --- Helper utilities (declared inside so they capture freshest sprites) ---
            function getEnemyAABB(enemy) {
                if (!enemy) return null;
                if (!game.enemySprites) return null;
                const map = {
                    'Thug':'thug',
                    'Street Dog':'streetDog',
                    'Punk':'punk',
                    'Gangster':'gangster',
                    'Dealer':'dealer',
                    'Enforcer':'enforcer',
                    'Boss Thug':'bossThug',
                    'Boss Gangster':'bossGangster',
                    'The Big Quack':'bigQuack'
                };
                const key = map[enemy.type];
                if (!key) return null;
                const entry = game.enemySprites[key];
                if (!entry || !entry.loaded) return null;
                // computeHitbox original APIs differ: thug returned {w,h,ox,oy}; new ones return either offset style or absolute; normalize.
                if (entry.computeHitbox) {
                    try {
                        const hb = entry.computeHitbox(enemy);
                        if (!hb) return null;
                        if ('ox' in hb || 'oy' in hb) {
                            // Center-relative definition
                            return { x: enemy.x + (hb.ox||0), y: enemy.y + (hb.oy||0), w: hb.w, h: hb.h };
                        } else if ('x' in hb && 'y' in hb) {
                            return { x: hb.x, y: hb.y, w: hb.w, h: hb.h };
                        }
                    } catch(e) { /* fallback later */ }
                }
                return null;
            }
            function circleIntersectsAABB(cx, cy, r, box) {
                const clampedX = Math.max(box.x, Math.min(cx, box.x + box.w));
                const clampedY = Math.max(box.y, Math.min(cy, box.y + box.h));
                const dx = cx - clampedX; const dy = cy - clampedY;
                return (dx*dx + dy*dy) <= r*r;
            }
            // Expose helpers to renderer/SoA update paths that run outside this scope
            window.getEnemyAABB = getEnemyAABB; window.circleIntersectsAABB = circleIntersectsAABB;
            function playerCircleRadius() { return 24; } // enlarged to match bigger player sprite

            // --- Player contact damage (enemy -> player) using AABB when available ---
            if (!game.player.invulnerable) {
                const pr = playerCircleRadius();
                game.enemies.forEach(enemy => {
                    if (enemy.dead || enemy.health <= 0) return;
                    // During active Rizz pull, temporarily disable player contact for this enemy
                    if (enemy._rizzPull && enemy._rizzPull.active) return;
                    const box = getEnemyAABB(enemy);
                    let collide = false;
                    if (box) {
                        collide = circleIntersectsAABB(game.player.x, game.player.y, pr, box);
                    } else {
                        // fallback circle vs circle
                        const dx = game.player.x - enemy.x; const dy = game.player.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < pr + enemy.size/2) collide = true;
                    }
                    if (collide) {
                        const incoming = Math.floor(enemy.damage * (enemy.cursed ? 0.7 : 1));
                        takeDamage(incoming);
                    }
                });

                // Enemy projectiles hitting player (remain circle-based for now)
                game.projectiles = game.projectiles.filter(proj => {
                    if (proj.enemy) {
                        const dx = proj.x - game.player.x;
                        const dy = proj.y - game.player.y;
                        if (Math.sqrt(dx * dx + dy * dy) < pr) {
                            takeDamage(proj.damage || 15);
                            addParticle(proj.x, proj.y, '#FF4444', 'impact');
                            return false;
                        }
                    }
                    return true;
                });
            }

            // SoA enemy projectiles vs player collision
            (function soaEnemyProjectilePlayerCollisions(){
                const ps = game.projectilesSoA; if (!ps || !game._projMeta || !game.player) return;
                const { x:PX, y:PY, radius:PR, alive:PA, MAX:PM } = ps;
                const pr2 = playerCircleRadius();
                for (let i=0;i<PM;i++){
                    if (!PA[i]) continue;
                    const meta = game._projMeta.get(i); if (!meta || !meta.enemy) continue;
                    const dx = PX[i] - game.player.x; const dy = PY[i] - game.player.y;
                    const r = PR[i] || 4;
                    if (dx*dx + dy*dy <= (r + pr2)*(r + pr2)) {
                        takeDamage((meta.baseDamage || 10));
                        addParticle(PX[i], PY[i], '#FF4444', 'impact');
                        // recycle this projectile
                        game.recycleProjectile(i);
                    }
                }
            })();

            // --- Player projectiles vs enemies (SoA + enemy hash accelerated) ---
            (function soaPlayerProjectileEnemyCollisions(){
                const ps = game.projectilesSoA;
                if (!ps) return; // safety
                const { x:PX, y:PY, radius:PR, damage:PD, alive:PA, life:PL, MAX:PM, flags:PF } = ps;
                const collisionStats = game.collisionStats || (game.collisionStats = { frame:0, checks:0, hits:0, buckets:0 });
                collisionStats.frame++;
                let bucketLookups = 0; let checks = 0; let hits = 0;
                const useHash = !!(game.enemyHash && game.enemyHash.buckets && game.enemyHash.buckets.size);
                const cs = useHash ? game.enemyHash.cell : 0;
                // Iterate SoA pool
                for (let i=0;i<PM;i++) {
                    if (!PA[i]) continue;
                    // Future: differentiate enemy projectiles via a flag bit; for now rely on metadata or placeholder flags
                    // If metadata marks enemy projectile, skip player->enemy collision.
                    const meta = game._projMeta && game._projMeta.get(i);
                    if (meta && meta.enemy) continue;
                    // Skip beam / special continuous effects (handled elsewhere) if flagged in metadata.
                    if (meta && meta.beam) continue;
                    const r = PR[i] || 6;
                    // Tumbleweed impulse: if this player projectile overlaps the tumbleweed, kick it
                    if (game._tumbleweedIndex != null && game._tumbleweedIndex >= 0 && game._projMeta) {
                        const ti = game._tumbleweedIndex;
                        // Ensure index is valid and alive
                        if (ti < PM && PA[ti] && ti !== i) {
                            const twMeta = game._projMeta.get(ti);
                            if (twMeta && twMeta.tumbleweed) {
                                const dxTW = (PX[ti] - PX[i]);
                                const dyTW = (PY[ti] - PY[i]);
                                const rr = (PR[ti]||14) + r + 2; // small pad
                                if (dxTW*dxTW + dyTW*dyTW <= rr*rr) {
                                    // Impulse along shot velocity (fallback to direction from projectile to tumbleweed)
                                    let ivx = ps.vx ? ps.vx[i] : 0;
                                    let ivy = ps.vy ? ps.vy[i] : 0;
                                    if (!ivx && !ivy) {
                                        const dist = Math.hypot(dxTW, dyTW) || 1;
                                        ivx = dxTW / dist; ivy = dyTW / dist;
                                    }
                                    const shotSpeed = Math.hypot(ivx, ivy) || 1;
                                    const k = Math.min(5.0, 1.2 + shotSpeed * 0.55);
                                    if (ps.vx && ps.vy) {
                                        ps.vx[ti] += ivx * k;
                                        ps.vy[ti] += ivy * k;
                                    }
                                    // Small on-kick ring cue
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!lowFx && !reduceRings) addParticle(PX[ti], PY[ti], '#EED7AA','ring');
                                }
                            }
                        }
                    }
                    // Kick the Can impulse: same as Tumbleweed but uses separate index and tint
                    if (game._kickCanIndex != null && game._kickCanIndex >= 0 && game._projMeta) {
                        const ki = game._kickCanIndex;
                        if (ki < PM && PA[ki] && ki !== i) {
                            const kcMeta = game._projMeta.get(ki);
                            if (kcMeta && kcMeta.kickTheCan) {
                                const dxK = (PX[ki] - PX[i]);
                                const dyK = (PY[ki] - PY[i]);
                                const rr = (PR[ki]||13) + r + 2;
                                if (dxK*dxK + dyK*dyK <= rr*rr) {
                                    let ivx = ps.vx ? ps.vx[i] : 0;
                                    let ivy = ps.vy ? ps.vy[i] : 0;
                                    if (!ivx && !ivy) {
                                        const dist = Math.hypot(dxK, dyK) || 1;
                                        ivx = dxK / dist; ivy = dyK / dist;
                                    }
                                    const shotSpeed = Math.hypot(ivx, ivy) || 1;
                                    const k = Math.min(5.0, 1.2 + shotSpeed * 0.55);
                                    if (ps.vx && ps.vy) {
                                        ps.vx[ki] += ivx * k;
                                        ps.vy[ki] += ivy * k;
                                    }
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!lowFx && !reduceRings) addParticle(PX[ki], PY[ki], '#D8F0FF','ring');
                                }
                            }
                        }
                    }
                    let consumed = false;
                    if (useHash) {
                        const cx = (PX[i] / cs)|0; const cy = (PY[i] / cs)|0;
                        for (let cyOff=-1; cyOff<=1 && !consumed; cyOff++) {
                            for (let cxOff=-1; cxOff<=1 && !consumed; cxOff++) {
                                const key = ((cx+cxOff)<<16) ^ (cy+cyOff);
                                const bucket = game.enemyHash.buckets.get(key); if(!bucket) continue; bucketLookups++;
                                for (let bi=0; bi<bucket.length && !consumed; bi++) {
                                    const enemy = game.enemies[bucket[bi]]; if(!enemy || enemy.dead || enemy.health<=0) continue; checks++;
                                    let hit=false; const box = getEnemyAABB(enemy);
                                    if (box) hit = circleIntersectsAABB(PX[i], PY[i], r, box); else {
                                        const dx = PX[i] - enemy.x; const dy = PY[i] - enemy.y; if (dx*dx + dy*dy < (enemy.size/2 + r)**2) hit=true;
                                    }
                                    if (hit) {
                                        hits++;
                                        // Build a temporary lightweight projectile descriptor for hit logic expecting object props.
                                        const projObj = meta || { };
                                        projObj.x = PX[i]; projObj.y = PY[i]; projObj.size = r; projObj.damage = PD[i];
                                        // Ensure commonly used ability fields exist on the temporary object
                                        if (meta) {
                                            if (meta.damageType) projObj.damageType = meta.damageType;
                                            if (meta.infusionElements) projObj.infusionElements = meta.infusionElements;
                                            if (meta.lifeSteal) projObj.lifeSteal = meta.lifeSteal;
                                            if (meta.knockback) { projObj.knockback = true; projObj.knockbackDistance = meta.knockbackDistance; }
                                            if (meta.piercing) { projObj.piercing = true; projObj.pierceCount = meta.pierceCount; projObj.pierceHits = meta.pierceHits||0; }
                                            if (meta.ricochet) { projObj.ricochet = true; projObj.bounces = meta.bounces||3; }
                                            if (meta.freezes) projObj.freezes = true;
                                            if (meta._hammer) projObj._hammer = true;
                                            if (meta.weaponType) projObj.weaponType = meta.weaponType;
                                            if (meta.drilling) projObj.drilling = true;
                                            if (meta.armorPiercing) projObj.armorPiercing = true;
                                            if (meta.ignoresArmor) projObj.ignoresArmor = true;
                                            if (meta.ignoresEverything) projObj.ignoresEverything = true;
                                            if (meta.crushDamage) projObj.crushDamage = true;
                                            if (meta.realityBreak) projObj.realityBreak = true;
                                            if (meta.hitMultipleTimes) projObj.hitMultipleTimes = true;
                                            if (meta.areaEffect) projObj.areaEffect = true;
                                            if (meta.smartExplosive) projObj.smartExplosive = true;
                                            if (meta.vortex) projObj.vortex = true;
                                        }
                                        // Preserve/forward some pattern flags if caller logic inspects them.
                                        projObj.sineWave = !!(PF[i] & ps.FLAG.SINE);
                                        projObj.wackyZigzag = !!(PF[i] & ps.FLAG.WACKY);
                                        projObj.ekgWave = !!(PF[i] & ps.FLAG.EKG);
                                        projObj.spiral = !!(PF[i] & ps.FLAG.SPIRAL);
                                        let consumedNow = applyProjectileHit(enemy, projObj);
                                        // Never consume the Tumbleweed / Kick the Can projectile
                                        if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                                            consumedNow = false;
                                            // Ensure pierce remains effectively unlimited and persistent
                                            meta.piercing = true; meta.pierceCount = Math.max(meta.pierceCount||0, 999999);
                                            meta.indestructible = true;
                                        }
                                        if (consumedNow) { PL[i]=0; PA[i]=0; /* recycle stack push */ }
                                        consumed = consumedNow;
                                    }
                                }
                            }
                        }
                    } else {
                        for (let ei=0; ei<game.enemies.length && !consumed; ei++) {
                            const enemy = game.enemies[ei]; if(!enemy || enemy.dead || enemy.health<=0) continue; checks++;
                            let hit=false; const box = getEnemyAABB(enemy);
                            if (box) hit = circleIntersectsAABB(PX[i], PY[i], r, box); else {
                                const dx = PX[i] - enemy.x; const dy = PY[i] - enemy.y; if (dx*dx + dy*dy < (enemy.size/2 + r)**2) hit = true;
                            }
                            if (hit) {
                                hits++;
                                const projObj = meta || { };
                                projObj.x = PX[i]; projObj.y = PY[i]; projObj.size = r; projObj.damage = PD[i];
                                if (meta) {
                                    if (meta.damageType) projObj.damageType = meta.damageType;
                                    if (meta.infusionElements) projObj.infusionElements = meta.infusionElements;
                                    if (meta.lifeSteal) projObj.lifeSteal = meta.lifeSteal;
                                    if (meta.knockback) { projObj.knockback = true; projObj.knockbackDistance = meta.knockbackDistance; }
                                    if (meta.piercing) { projObj.piercing = true; projObj.pierceCount = meta.pierceCount; projObj.pierceHits = meta.pierceHits||0; }
                                    if (meta.ricochet) { projObj.ricochet = true; projObj.bounces = meta.bounces||3; }
                                    if (meta.freezes) projObj.freezes = true;
                                    if (meta._hammer) projObj._hammer = true;
                                    if (meta.weaponType) projObj.weaponType = meta.weaponType;
                                    if (meta.drilling) projObj.drilling = true;
                                    if (meta.armorPiercing) projObj.armorPiercing = true;
                                    if (meta.ignoresArmor) projObj.ignoresArmor = true;
                                    if (meta.ignoresEverything) projObj.ignoresEverything = true;
                                    if (meta.crushDamage) projObj.crushDamage = true;
                                    if (meta.realityBreak) projObj.realityBreak = true;
                                    if (meta.hitMultipleTimes) projObj.hitMultipleTimes = true;
                                    if (meta.areaEffect) projObj.areaEffect = true;
                                    if (meta.smartExplosive) projObj.smartExplosive = true;
                                    if (meta.vortex) projObj.vortex = true;
                                }
                                projObj.sineWave = !!(PF[i] & ps.FLAG.SINE);
                                projObj.wackyZigzag = !!(PF[i] & ps.FLAG.WACKY);
                                projObj.ekgWave = !!(PF[i] & ps.FLAG.EKG);
                                projObj.spiral = !!(PF[i] & ps.FLAG.SPIRAL);
                                let consumedNow = applyProjectileHit(enemy, projObj);
                                if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                                    consumedNow = false;
                                    meta.piercing = true; meta.pierceCount = Math.max(meta.pierceCount||0, 999999);
                                    meta.indestructible = true;
                                }
                                if (consumedNow) { PL[i]=0; PA[i]=0; }
                                consumed = consumedNow;
                            }
                        }
                    }
                }
                collisionStats.checks += checks; collisionStats.hits += hits; collisionStats.buckets += bucketLookups;
            })();
            
            // Chest interactions
            game.chests.forEach(chest => {
                if (!chest.opened) {
                    const dx = game.player.x - chest.x;
                    const dy = game.player.y - chest.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 35) {
                        openChest(chest);
                    }
                }
            });
        }
        // Periodic collision stats logger (every ~5s)
        (function initCollisionStatsLogger(){
            if (game._collisionLoggerStarted) return; game._collisionLoggerStarted = true;
            setInterval(()=>{
                const c = game.collisionStats; if(!c) return;
                const avgChecks = c.frame ? Math.round(c.checks / c.frame) : 0;
                const hitRate = c.checks ? (c.hits / c.checks * 100).toFixed(1) : '0.0';
                const avgBuckets = c.frame ? (c.buckets / c.frame).toFixed(1) : '0.0';
                console.info(`[CollisionStats] frame:${c.frame} checks:${c.checks} hits:${c.hits} hitRate:${hitRate}% avgChecks/frame:${avgChecks} avgBuckets/frame:${avgBuckets}`);
            }, 5000);
        })();
        // Lightweight on-canvas debug overlay for collision hits (optional)
        ;(function injectCollisionDebugHUD(){
            if (game._collisionHUDInjected) return; game._collisionHUDInjected = true;
            const el = document.createElement('div');
            el.style.position='absolute'; el.style.right='6px'; el.style.bottom='6px'; el.style.padding='4px 6px';
            el.style.font='10px monospace'; el.style.background='rgba(0,0,0,0.35)'; el.style.color='#9f9'; el.style.pointerEvents='none';
            el.style.border='1px solid rgba(80,255,80,0.25)'; el.style.borderRadius='4px'; el.style.zIndex=9999;
            el.textContent='collisions: --';
            document.body.appendChild(el);
            let lastFrame = 0; let lastHits = 0; let lastChecks = 0;
            function upd(){
                const c = game.collisionStats; if (c && c.frame !== lastFrame) {
                    lastFrame = c.frame; lastHits = c.hits; lastChecks = c.checks;
                    const rate = c.checks ? ((c.hits / c.checks)*100).toFixed(1) : '0.0';
                    el.textContent = `hits:${c.hits} checks:${c.checks} rate:${rate}%`;
                }
                requestAnimationFrame(upd);
            }
            requestAnimationFrame(upd);
        })();

        // Utility: Blend a projectile's motion pattern & infusion colors into one representative hex.
        function getProjectileSynergyColor(proj) {
            if (proj && proj._diarrheaBrown) return '#8B4513';
            const colors = [];
            if (proj.sineWave) colors.push('#66AAFF');
            if (proj.wackyZigzag && !proj._wackyChaos) colors.push('#FFDD55');
            if (proj._wackyChaos) colors.push('#FFAA33');
            if (proj.ekgWave) colors.push('#66FFCC');
            if (proj.spiral) colors.push('#FF66FF');
            if (proj.infusionElements && proj.infusionElements.length) {
                let strongest = proj.infusionElements[0];
                proj.infusionElements.forEach(el=>{ if (el.potency > strongest.potency) strongest = el; });
                const infusionMap = { fire:'#FF5533', poison:'#55FF55', ice:'#99DDFF', arc:'#DDDDFF', shadow:'#AA66FF', lightning:'#FFFF99', void:'#8844AA', wind:'#BBFFEE' };
                const infCol = infusionMap[strongest.type] || '#FFFFFF';
                colors.push(infCol);
            }
            if (!colors.length) return '#CCCCCC';
            let r=0,g=0,b=0; colors.forEach(c=>{ const v=parseInt(c.slice(1),16); r+=(v>>16)&255; g+=(v>>8)&255; b+=v&255; });
            r=Math.min(255, Math.floor(r/colors.length)); g=Math.min(255, Math.floor(g/colors.length)); b=Math.min(255, Math.floor(b/colors.length));
            if (proj._wackyChaos && Math.random()<0.35) { r=Math.min(255,r+35); g=Math.min(255,g+20);} // subtle flicker
            return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).toUpperCase();
        }

        // Utility: Map damage/element types to canonical colors for consistent FX tints.
        function getDamageTypeColor(type) {
            switch (type) {
                case 'fire':
                case 'inferno':
                    return '#FF5533';
                case 'ice':
                case 'frost':
                case 'blizzard':
                    return '#99DDFF';
                case 'lightning':
                case 'storm':
                    return '#FFFF99';
                case 'poison':
                case 'toxic':
                    return '#55CC55';
                case 'void':
                case 'antimatter':
                    return '#8844AA';
                case 'acid':
                    return '#A8FFAA';
                case 'plasma':
                    return '#FF6677';
                case 'earth':
                    return '#C6A16A';
                case 'crystal':
                    return '#88EEFF';
                case 'shadow':
                    return '#AA66FF';
                case 'wind':
                    return '#BBFFEE';
                case 'solar':
                    return '#FFEFA5';
                default:
                    return null;
            }
        }

        // Utility: Determine the best element color for a projectile (damageType primary, infusion fallback)
        function getProjElementColor(proj) {
            if (!proj) return null;
            const byType = getDamageTypeColor(proj.damageType || proj.energyType);
            if (byType) return byType;
            if (proj.infusionElements && proj.infusionElements.length) {
                let strongest = proj.infusionElements[0];
                proj.infusionElements.forEach(el=>{ if (el.potency > strongest.potency) strongest = el; });
                // Map common infusion names to colors
                const map = { fire:'#FF5533', poison:'#55CC55', ice:'#99DDFF', lightning:'#FFFF99', void:'#8844AA', wind:'#BBFFEE', shadow:'#AA66FF' };
                return map[strongest.type] || null;
            }
            return null;
        }

        function calculateDamage() {
            let damage = 25;
            
            // Base damage bonuses
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageBonus) {
                    damage += abilityData.effect.damageBonus;
                }
            });
            
            // Rage mode
            if (game.player.abilities.includes('Rage Mode')) {
                damage += game.totalKills * 3;
            }
            
            // Berserker
            if (game.player.abilities.includes('Berserker')) {
                const healthPercent = game.player.health / game.player.maxHealth;
                const berserkerMultiplier = 1 + (1 - healthPercent) * 0.5;
                damage = Math.floor(damage * berserkerMultiplier);
            }
            
            // Critical strikes
            let critChance = 0;
            let critMultiplier = 2;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.critChance) {
                    critChance = Math.max(critChance, abilityData.effect.critChance);
                }
                if (abilityData && abilityData.effect.critMultiplier) {
                    critMultiplier = abilityData.effect.critMultiplier;
                }
            });
            
            if (Math.random() < critChance) {
                damage *= critMultiplier;
                addScreenShake(5);
            }
            
            // Death touch
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.deathTouch) {
                    if (Math.random() < abilityData.effect.deathTouch) {
                        damage = 9999; // Instant kill
                        addScreenShake(8);
                    }
                }
            });

            // If player has an ability that ignores armor globally, we may want to
            // reflect that in damage by ensuring armor reductions aren't applied later.
            // For now we keep calculateDamage generic; the per-projectile ignoresArmor flag
            // will be used at damage application time.
            
            return damage;
        }

        // Centralized hit resolution for projectiles. Returns true if projectile is consumed.
        function applyProjectileHit(enemy, proj) {
            if (!enemy || !proj) return true;
            // Track last hit damage type for death telegraph coloring
            if (proj.damageType) enemy._lastHitType = proj.damageType;
            // Speed-scaled damage and impact cue for Tumbleweed / Kick the Can
            if (proj.tumbleweed || proj.kickTheCan) {
                const sp = Math.hypot(proj.vx||0, proj.vy||0);
                const mult = Math.min(2.2, 1.0 + sp * 0.12); // up to ~2.2x at high speeds
                proj.damage = Math.max(1, Math.floor((proj.damage || calculateDamage()) * mult));
                // Impact cue: dust ring, stronger with speed (perf-aware)
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx) {
                    const dustCount = Math.min(8, 2 + Math.floor(sp * 0.8));
                    const col = proj.kickTheCan ? '#D8F0FF' : '#EFDDBF';
                    for (let d=0; d<dustCount; d++) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, col, 'spark');
                }
                if (!reduceRings) addParticle(enemy.x, enemy.y, '#EED7AA', 'ring');
            }
            // Popcorn: if a kernel dies early by impact (should rarely happen) force pop immediately
            if (proj.isPopcornKernel && !proj._popDid) {
                proj._popDid = true;
                const base = proj.baseDamage || calculateDamage();
                // Early impact: also spawn kernel burst shots (scaled)
                const bursts = Math.max(2, Math.min(6, (proj._popBursts||2)));
                for (let b=0;b<bursts;b++) {
                    const angB = Math.random()*Math.PI*2;
                    const speedB = 4.2 + Math.random()*1.6;
                    game.spawnProjectile({
                        x: proj.x, y: proj.y,
                        vx: Math.cos(angB)*speedB,
                        vy: Math.sin(angB)*speedB,
                        life: 48 + Math.floor(Math.random()*18),
                        size: 7, enemy:false,
                        baseDamage: Math.max(1, Math.floor(base * 0.55)),
                        damage: Math.max(1, Math.floor(base * 0.55)),
                        popcornKernelBurst: true,
                        realityBreak: !!proj.realityBreak
                    });
                }
                const puffN = Math.max(2, Math.min(6, (proj._popPuffs||2)));
                for (let k=0;k<puffN;k++) {
                    const ang = Math.atan2(proj.vy||0, proj.vx||1) + (Math.random()*0.9 - 0.45);
                    const speed = (Math.sqrt((proj.vx||0)**2 + (proj.vy||0)**2) * 0.85) + Math.random()*1.2;
                    game.spawnProjectile({
                        x: proj.x, y: proj.y,
                        vx: Math.cos(ang)*speed,
                        vy: Math.sin(ang)*speed,
                        life: 40 + Math.floor(Math.random()*18),
                        size: 12, enemy:false,
                        popcornPuff:true,
                        baseDamage: Math.max(1, Math.floor(base * 0.75)),
                        damage: Math.max(1, Math.floor(base * 0.75)),
                        _puffSpin: Math.random()*Math.PI*2,
                        _puffDir: (Math.random()<0.5? -1:1),
                        realityBreak: !!proj.realityBreak
                    });
                }
                for (let s=0;s<10;s++) addParticle(proj.x + (Math.random()-0.5)*12, proj.y + (Math.random()-0.5)*12, '#FFEFA0','spark');
                proj.life = 0;
                return true; // kernel consumed
            }
            // Time Bomb: armed hits near fuse end can trigger early detonation (feels responsive)
            if (proj.timeBomb && proj._timeBombArmed && proj._timeBombTimer <= 16) {
                const dmg = Math.floor((proj.baseDamage || calculateDamage()) * (proj._timeBombExplosionMult || 2.0));
                explodeProjectile(proj, dmg);
                proj.life = 0;
                return true;
            }
            let damage = proj.damage || proj.baseDamage || calculateDamage();
            // Apply resonance multiplier if present
            if (proj._resonanceMult) {
                damage = Math.floor(damage * proj._resonanceMult);
            }
            // Multi-Infusion bonus pre-modifiers: each infusion adds scaled portion of base (diminishing after first)
            if (proj.infusionElements && proj.infusionElements.length) {
                // Sort by potency to apply strongest first
                const sorted = [...proj.infusionElements].sort((a,b)=>b.potency-a.potency);
                let bonus = 0; let idx=0;
                sorted.forEach(inf => { const weight = (idx===0?1: (idx===1?0.6:0.4)); bonus += (damage * inf.potency * weight); idx++; });
                damage = Math.floor(damage + bonus);
            }
            // Elemental amplifier pre-processing: gather player elemental ability presence
            if (!proj._elemAmpComputed) {
                proj._elemAmpComputed = true;
                const abil = game.player.abilities;
                proj._hasFire = abil.some(a=>a.includes('Fire Shot')||a.includes('Inferno')||a.includes('Magma')||a.includes('Inferno')||a.includes('Steam Shot')||a.includes('Magma Shot'));
                proj._hasWind = abil.some(a=>a.includes('Wind Blade')||a.includes('Blizzard'));
                proj._hasIce = abil.some(a=>a.includes('Ice Shot')||a.includes('Frost')||a.includes('Blizzard'));
                proj._hasLightning = abil.some(a=>a.includes('Lightning Shot')||a.includes('Storm Shot'));
                proj._hasPoison = abil.some(a=>a.includes('Poison Shot')||a.includes('Toxic')||a.includes('Silent But Deadly'));
                proj._hasVoid = abil.some(a=>a.includes('Void Shot')||a.includes('Black Hole'));
                proj._hasEarth = abil.some(a=>a.includes('Earth Spike')||a.includes('Magma Shot'));
            }
            // Fire + Wind: slight damage amp and faster burn tick (handled in status) -> immediate small boost
            if (proj._hasFire && proj._hasWind) {
                damage = Math.floor(damage * 1.06);
            }
            // Ice + Lightning: chance to shatter for bonus burst (simulate crit-like extra)
            if (proj._hasIce && proj._hasLightning) {
                if (Math.random() < 0.12) {
                    const extra = Math.floor(damage * 0.35);
                    enemy.health -= extra; // apply directly
                    addDamageNumber(extra, enemy.x, enemy.y - enemy.size/2 - 14, { type: 'frost', crit: true });
                    addParticle(enemy.x, enemy.y, '#AAEEFF','impact');
                }
            }
            // Poison + Void: amplify damage over time potential (apply immediate small amp)
            if (proj._hasPoison && proj._hasVoid) {
                damage = Math.floor(damage * 1.08);
            }
            // Fire + Poison (Magma/Inferno synergy) further increases immediate hit slightly
            if (proj._hasFire && proj._hasPoison) {
                damage = Math.floor(damage * 1.05);
            }
            // Fire + Earth (true Magma combustion) additional micro-boost beyond Fire+Poison if Earth present
            if (proj._hasFire && proj._hasEarth) {
                damage = Math.floor(damage * 1.04);
            }
            // Earth + Wind: modest knockback amplification (applied post-damage as status effect via enemy displacement)
            if (proj._hasEarth && proj._hasWind && proj.knockbackDistance) {
                proj.knockbackDistance = Math.floor(proj.knockbackDistance * 1.15 + 6);
            }
            // Freeze escalation (before armor so bonus can apply later if desired)
            if (proj.freezes && proj.damageType === 'frost') {
                // initialize freeze tracking fields
                enemy.freezeStacks = Math.min(3, (enemy.freezeStacks || 0) + 1);
                enemy.lastFreezeHit = Date.now();
                if (enemy.freezeStacks === 3) {
                    enemy.frozenTimer = Math.max(enemy.frozenTimer || 0, 900); // full freeze 0.9s
                    // Visual: freeze-locked ring and sparkles (perf-aware)
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx) {
                        if (!reduceRings) addParticle(enemy.x, enemy.y, '#AEEBFF','ring');
                        for (let s=0;s<4;s++) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, '#C0F8FF','spark');
                    }
                }
            }
            // Crush logic: first hammer impact applies crushedTimer + stun; subsequent impacts during window deal amplified damage
            if (proj.crushDamage || proj.weaponType === 'hammer' || proj._hammer) {
                if (!enemy.crushedTimer || enemy.crushedTimer <= 0) {
                    enemy.crushedTimer = 700; // ms window
                    enemy.stunned = true; enemy.stunTime = Math.max(enemy.stunTime || 0, 60);
                    // apply an armor shred stack (temporary) and schedule its decay timer if not existing
                    enemy.armorShredded = (enemy.armorShredded || 0) + 1;
                    if (enemy.armorShredded > 8) enemy.armorShredded = 8; // cap
                    enemy._armorShredDecay = enemy._armorShredDecay || Date.now();
                    addParticle(enemy.x, enemy.y, '#EECCAA','impact');
                } else {
                    // Already crushed: bonus damage multiplier
                    damage = Math.floor(damage * 1.4);
                    addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, crit: true });
                }
            }
            if (enemy.weakness) damage = Math.floor(damage * 1.35);
            if (proj.ignoresEverything) damage = Math.floor(damage * 1.25);
            if (!proj.ignoresEverything && !proj.ignoresArmor && !proj.armorPiercing) {
                const shred = enemy.armorShredded || 0;
                const effectiveArmor = Math.max(0, (enemy.armor || 0) - shred);
                const preArmor = damage;
                damage = Math.max(1, damage - effectiveArmor);
                if (effectiveArmor > 0) {
                    // Armor mitigation sparkle cue: brief metallic flecks when damage is reduced
                    const mitig = Math.max(0, preArmor - damage);
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    if (!lowFx && mitig > 0) {
                        const flecks = Math.min(6, 2 + Math.floor(mitig / Math.max(1, preArmor) * 6));
                        for (let f=0; f<flecks; f++) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, '#D0D0D0', 'spark');
                    }
                    addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, armor: true });
                }
            }
            // Bonus damage while fully frozen
            if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                damage = Math.floor(damage * 1.2);
            }
            enemy.health -= damage;
            if (!proj._suppressDamageNumber) {
                addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, crit: proj.ignoresEverything });
            }
            // Standardized elemental impact tint + optional ring telegraph
            {
                const impactHex = getProjElementColor(proj) || '#FFAA00';
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                if (!hideSparks) addParticle(enemy.x, enemy.y, impactHex, 'impact');
                if (!lowFx && !reduceRings) addParticle(enemy.x, enemy.y, impactHex, 'ring');
            }
            // Drill Shot: eject shrapnel on exit/kill (overpenetrate + shrapnel)
            // Extended: optional overrides to control shard count and base angle
            function spawnDrillShrapnel(originX, originY, vx, vy, baseDmg, opts) {
                // opts: { count?: number, angle?: number, spread?: number }
                const speed = 6.0;
                const lowFx = !!(game.perf && game.perf.lowFx);
                // Default dynamic count (perf-aware)
                let count = 4;
                try {
                    const active = game.projectilePool && game.projectilePool.active && game.projectilePool.active();
                    if (active && active > 1200) count = 3;
                    if (active && active > 2000) count = 2;
                } catch(_) {}
                if (lowFx) count = Math.max(2, Math.floor(count * 0.75));
                // Apply override if provided
                if (opts && typeof opts.count === 'number') count = opts.count;
                const ang0 = (opts && typeof opts.angle === 'number') ? opts.angle : Math.atan2(vy||0, vx||1);
                const spread = (opts && typeof opts.spread === 'number') ? opts.spread : 0.5; // total spread in radians
                const shardDmg = Math.max(1, Math.floor((baseDmg||calculateDamage()) * 0.35));
                for (let i=0;i<count;i++) {
                    const off = (-spread/2) + (i * (spread / ((count-1)||1))); // symmetric spread
                    const a = ang0 + off + (Math.random()-0.5)*0.10; // tiny jitter
                    const idx = game.spawnProjectile({
                        x: originX,
                        y: originY,
                        vx: Math.cos(a) * speed,
                        vy: Math.sin(a) * speed,
                        life: 34,
                        r: 4,
                        damage: shardDmg,
                        damageType: proj.damageType || null,
                        enemy: false
                    });
                    if (idx>=0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idx, { baseDamage: shardDmg, piercing:false, pierceCount:0, drillingShard:true });
                    }
                }
            }
            // Void on-hit flash: a brief luminous ringFlash distinct from generic impact
            if (proj.damageType === 'void' || proj.energyType === 'void') {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') {
                    const rr = Math.max(12, (proj.size || proj.r || 6) * 1.6);
                    addTransientEffect({ type:'ringFlash', x: enemy.x, y: enemy.y, color: getDamageTypeColor('void') || '#8844AA', radius: rr, life: 100 });
                }
            }
            // Shadow on-hit flash: darker purple pulse distinct from Void
            if (proj.damageType === 'shadow' || proj.energyType === 'shadow') {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') {
                    const rr = Math.max(10, (proj.size || proj.r || 6) * 1.5);
                    addTransientEffect({ type:'ringFlash', x: enemy.x, y: enemy.y, color: getDamageTypeColor('shadow') || '#AA66FF', radius: rr, life: 95 });
                }
            }
            // Armor-piercing/Acid melt ring cue (perf-aware)
            {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const isArmorPunch = proj.armorPiercing || proj.damageType === 'acid';
                if (isArmorPunch && !lowFx && !reduceRings) {
                    addParticle(enemy.x, enemy.y, '#A8FFAA', 'ring');
                }
            }
            // On-hit AoE hooks for elemental combos
            if ((proj.damageType === 'blizzard' || proj.areaEffect === true) && !proj.beam) {
                // Light area slow to make Blizzard noticeable even without explicit explode trigger
                const cx = proj.x || enemy.x, cy = proj.y || enemy.y;
                for (let i = 0; i < 6; i++) addParticle(cx + (Math.random()-0.5)*50, cy + (Math.random()-0.5)*50, '#AEEBFF', 'fire');
                game.enemies.forEach(en => {
                    const dx = en.x - cx, dy = en.y - cy; const d = Math.hypot(dx, dy);
                    if (d < 100) { en.slowed = true; en.slowTime = Math.max(en.slowTime||0, 160); }
                });
            }
            // Plasma splash: on hit create small area heat burst (excludes original enemy for secondary damage)
            if (proj.damageType === 'plasma' && !proj._plasmaSplashed) {
                proj._plasmaSplashed = true;
                const splashRadius = 60;
                const splashDmg = Math.max(1, Math.floor(damage * 0.6));
                // visual burst particles (plasma hue)
                for (let p=0;p<14;p++) {
                    const ang = Math.random()*Math.PI*2;
                    const dist = Math.random()*splashRadius*0.9;
                    addParticle(enemy.x + Math.cos(ang)*dist, enemy.y + Math.sin(ang)*dist, '#ff4455', 'spark');
                }
                game.enemies.forEach(other => {
                    if (other === enemy || other.health <= 0) return;
                    const dx = other.x - enemy.x;
                    const dy = other.y - enemy.y;
                    if (dx*dx + dy*dy <= splashRadius * splashRadius) {
                        other.health -= splashDmg;
                        addDamageNumber(splashDmg, other.x, other.y - other.size/2, { type: 'plasma' });
                        // brief burn extension
                        other.burning = true;
                        other.burnTime = Math.max(other.burnTime || 0, 120);
                    }
                });
            }
            // Vortex on-hit trigger: if projectile carries vortex ability, spawn one at impact (rate-limited)
            if (proj.vortex && typeof createVortex === 'function') {
                const nowV = Date.now();
                const cd = 900; // ms cooldown between vortex spawns
                if (!game._lastVortexSpawn || nowV - game._lastVortexSpawn >= cd) {
                    game._lastVortexSpawn = nowV;
                    const cx = proj.x != null ? proj.x : enemy.x;
                    const cy = proj.y != null ? proj.y : enemy.y;
                    createVortex(cx, cy);
                }
            }
            // SIGMA stage handling
            if (proj.sigma1 && !proj._sigmaSplit) {
                proj._sigmaSplit = true;
                // spawn 3 smaller homing sigma2 shots at slight angle offsets
                const base = proj.baseDamage || proj.damage || calculateDamage();
                const count = 3;
                const baseAng = Math.atan2((proj.vy||0), (proj.vx||1));
                if (!game._sigma) game._sigma = {};
                if (!game._sigma.trackers) game._sigma.trackers = new Map();
                const token = Symbol('sigmaChain');
                const children = [];
                for (let k=0; k<count; k++) {
                    const off = (-0.22) + (k * (0.22)); // -0.22, 0, +0.22 rad
                    const ang = isFinite(baseAng) ? baseAng + off : Math.random()*Math.PI*2;
                    const spd = Math.max(4.5, Math.hypot(proj.vx||0, proj.vy||0) * 0.9);
                    const idx = game.spawnProjectile({
                        x: proj.x, y: proj.y,
                        vx: Math.cos(ang) * spd,
                        vy: Math.sin(ang) * spd,
                        life: 240,
                        r: Math.max(8, Math.floor((proj.size||10) * 0.66)),
                        damage: Math.max(1, Math.floor(base * 0.7)),
                        damageType: null,
                        homing: true
                    });
                        if (idx >= 0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idx, { baseDamage: Math.max(1, Math.floor(base * 0.7)), sigma2: true, _sigmaToken: token, phasing: true });
                        children.push(idx);
                    }
                }
                // track this trio to spawn sigma3 when all 3 children are gone (expired or hit and consumed)
                const cFrame = (typeof game.frame==='number') ? game.frame : 0;
                game._sigma.trackers.set(token, { kids: children, originX: proj.x, originY: proj.y, _spawned:false, createdFrame: cFrame });
                // consume sigma1
                proj.life = 0;
                return true;
            }
            // Sigma2 completion rule: when all 3 sigma2 children have disappeared, spawn sigma3 at their last center
            if (proj.sigma2 && proj._sigmaToken && game._sigma && game._sigma.trackers) {
                const tr = game._sigma.trackers.get(proj._sigmaToken);
                if (tr && tr.kids && tr.kids.length && !tr._spawned) {
                    // Update a centroid of existing kids each time one hits to place sigma3 near the last activity
                    tr._centroidX = (tr._centroidX || 0) * 0.5 + (enemy.x) * 0.5;
                    tr._centroidY = (tr._centroidY || 0) * 0.5 + (enemy.y) * 0.5;
                }
            }
            // (Meteor on-hit explosion removed; meteor now detonates strictly at telegraph end for consistency)
            // Infusion status application (projectile-specific overlay)
            if (proj.infusionElements && proj.infusionElements.length) {
                proj.infusionElements.forEach(inf => {
                    switch(inf.type) {
                        case 'fire': enemy.burning = true; enemy.burnTime = Math.max(enemy.burnTime||0, 120 + Math.floor(60*inf.potency)); break;
                        case 'ice': enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime||0, 140 + Math.floor(40*inf.potency)); break;
                        case 'poison': enemy.poisoned = true; enemy.poisonTime = Math.max(enemy.poisonTime||0, 180 + Math.floor(60*inf.potency)); break;
                        case 'lightning': // small chain mini pulse
                            if (Math.random() < 0.15 + inf.potency*0.3) {
                                let chained=0; game.enemies.forEach(o=>{ if(o===enemy||chained>=2) return; const d=Math.hypot(o.x-enemy.x,o.y-enemy.y); if(d<120){ const zap=Math.max(4,Math.floor(damage*0.25)); o.health-=zap; addDamageNumber(zap,o.x,o.y-o.size/2,{type:'lightning'}); addParticle(o.x,o.y,'#FFFF99','spark'); chained++; } }); }
                            break;
                        case 'void': // mild armor shred stacking
                            enemy.armorShredded = (enemy.armorShredded||0) + (inf.potency>0.4?2:1); if (enemy.armorShredded>10) enemy.armorShredded=10; break;
                        case 'wind': // push slight
                            const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const dist=Math.hypot(dx,dy)||1; applyKnockback(enemy, 20 + inf.potency*40, dx, dy);
                            break;
                    }
                });
            }
            // Life steal
            if (proj.lifeSteal && proj.lifeSteal > 0) {
                const heal = Math.max(1, Math.floor(damage * 0.1 * proj.lifeSteal));
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                addParticle(game.player.x, game.player.y - 18, '#00FF55', 'heal');
                updateUI();
            }
            applyStatusEffects(enemy);
            if (proj.knockback) {
                const pdx = enemy.x - proj.x; const pdy = enemy.y - proj.y; const pd = Math.hypot(pdx,pdy) || 1;
                let kbDist = proj.knockbackDistance || 0;
                if (!kbDist && proj.weaponType === 'hammer') kbDist = 40; // hammer baseline
                if (!kbDist) kbDist = 28; // default fallback
                // Earth Spike / Magma derived impacts: always use smooth knockback (less jarring)
                // proj._hasEarth is precomputed earlier (includes Magma combo). We slightly reduce raw distance
                // so the slide duration feels physical instead of a huge displacement burst.
                const isEarthStyle = proj._hasEarth;
                if (isEarthStyle) {
                    const earthDist = Math.max(14, Math.floor(kbDist * 0.75)); // temper distance for smoother slide
                    applySmoothKnockback(enemy, pdx/pd, pdy/pd, earthDist);
                    enemy._earthKBFrames = Math.max(enemy._earthKBFrames || 0, Math.min(38, Math.floor(earthDist * 0.9))); // debris duration
                } else {
                    // Large knockback distances (e.g. Wind Blade 120) look like teleporting when instant.
                    // Use smooth velocity-based knockback if threshold exceeded; otherwise keep instant push.
                    if (kbDist >= 60) {
                        applySmoothKnockback(enemy, pdx/pd, pdy/pd, kbDist);
                    } else {
                        applyKnockback(enemy, kbDist, pdx, pdy);
                    }
                }
            }
            if (proj._hammer) {
                enemy.stunned = true; enemy.stunTime = Math.max(enemy.stunTime || 0, 46); addParticle(enemy.x, enemy.y, '#FFDFFF', 'impact');
            }
            if (proj.weaponType === 'axe') { enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime || 0, 90); }
            if (proj.chaining) {
                let next=null, nd=Infinity; game.enemies.forEach(o=>{ if(o===enemy) return; const d=Math.hypot(o.x-enemy.x,o.y-enemy.y); if(d<140&&d<nd){nd=d;next=o;} });
                if (next) { const cd=Math.max(1, Math.floor(damage*0.5)); next.health -= cd; addParticle(next.x,next.y,'#FFDFAA','impact'); addDamageNumber(cd, next.x, next.y - next.size/2, { type: proj.damageType }); }
            }
            // Reality break projectile single-target hit also boosts distortion a bit
            if (proj.realityBreak) {
                if (!game.realityBreakDistort) game.realityBreakDistort = { time:0, intensity:0 };
                game.realityBreakDistort.time = Math.min(game.realityBreakDistort.time + 24, 160);
                game.realityBreakDistort.intensity = Math.min(0.65, game.realityBreakDistort.intensity + 0.08);
                // Brief auto-enable of overlay so distortion displays even if setting is off
                if (!game.settings) game.settings = {};
                game.settings._rbAutoOverlay = 4; // frames to force on (shorter)
                // Add a tiny burst of screen shake for jitter
                if (typeof addScreenShake === 'function' && !(game.perf && game.perf.lowFx)) addScreenShake(1.5);
                // Also spawn a small Reality Break field at impact (rate-limited) so the ability has visible gameplay effect without requiring an explosion
                const nowRB = Date.now();
                const cd = 900; // ms cooldown between spawns
                if (!game._lastRealityBreakSpawn || nowRB - game._lastRealityBreakSpawn >= cd) {
                    game._lastRealityBreakSpawn = nowRB;
                    const base = proj.baseDamage || proj.damage || calculateDamage();
                    // Place field slightly biased toward enemy position for readability
                    const fx = (proj.x != null ? (proj.x*0.4 + enemy.x*0.6) : enemy.x);
                    const fy = (proj.y != null ? (proj.y*0.4 + enemy.y*0.6) : enemy.y);
                    if (typeof createRealityBreak === 'function') {
                        createRealityBreak(fx, fy, Math.max(80, Math.floor(base * 1.0)));
                    }
                }
            }
            // Split trigger (primary): ensure Split Shot triggers on first enemy impact even if projectile will continue (piercing, ricochet, etc.).
            // Exclude beams and orbitals to avoid excessive child spam.
            // (Split Shot primary enemy-impact trigger removed)
            // Crystal Shot shatter: spawn shards on first enemy impact (before potential pierce continuation) once.
            if (proj.damageType === 'crystal' && !proj._crystalShattered) {
                createCrystalShatter(enemy.x, enemy.y, proj.baseDamage || proj.damage || calculateDamage(), proj);
            }
            if (proj.hitMultipleTimes) {
                proj.remainingHits = (typeof proj.remainingHits === 'number') ? proj.remainingHits : 3; proj.remainingHits--; proj.life += 12;
                // Stronger telegraph when Quantum extra hit triggers
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings) addParticle(proj.x, proj.y, '#66FFFF', 'ring');
                addParticle(proj.x, proj.y, '#66FFFF','spark');
                if (!lowFx) {
                    // a couple of faint shimmer sparks for readability
                    if (!(game.fxFlags && game.fxFlags.hideSparks)) {
                        addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#AAFFFF','spark');
                        if (Math.random()<0.5) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#88EEFF','spark');
                    }
                }
                if (proj.remainingHits > 0) { const sp=Math.hypot(proj.vx,proj.vy)||1; proj.vx = (proj.vx/sp)*(sp*1.04); proj.vy=(proj.vy/sp)*(sp*1.04); return false; }
            }
            if (proj.antimatter || proj.massiveExplosion) {
                const explosDmg = Math.max(200, Math.floor((proj.baseDamage || damage) * 1.5));
                explodeProjectile(proj, explosDmg); proj.life = 0; return true;
            }
            // (Legacy) Popcorn puff impact crumb spawn removed after SoA migration. Will reintroduce via metadata if needed.
            // Ricochet chaining: allow when ricochet flag set AND remaining bounces >0; phasing no longer blocks logic.
            if (proj.ricochet && proj.bounces > 0) {
                // Initialize ricochet state
                if (!proj._ricochetHits) proj._ricochetHits = [];
                // Prevent hitting same enemy consecutively unless only one remains
                proj._ricochetHits.push(enemy._id || (enemy._id = Math.random().toString(36).slice(2)));
                const already = new Set(proj._ricochetHits);
                const maxRange = 240; // search radius for next bounce
                let nextTarget = null, nextDist = Infinity;
                game.enemies.forEach(o => {
                    if (o === enemy || o.health <= 0) return;
                    const oid = o._id || (o._id = Math.random().toString(36).slice(2));
                    // Allow re-targeting if we've hit nearly everyone (fallback) after 3 unique hits
                    const allowRepeat = proj._ricochetHits.length > 3 && proj._ricochetHits.length > game.enemies.length - 2;
                    if (!allowRepeat && already.has(oid)) return;
                    const d = Math.hypot(o.x - proj.x, o.y - proj.y);
                    if (d < nextDist && d <= maxRange) { nextDist = d; nextTarget = o; }
                });
                if (nextTarget) {
                    const ang = Math.atan2(nextTarget.y - proj.y, nextTarget.x - proj.x);
                    // Preserve existing speed but enforce a floor and mild retention (avoid cumulative slowdown)
                    const prevSpeed = Math.hypot(proj.vx, proj.vy) || 0;
                    const sp = Math.max(5, prevSpeed * 0.95); // slight damping only
                    // Blend direction for smoother turn instead of instant snap
                    const desiredVx = Math.cos(ang) * sp;
                    const desiredVy = Math.sin(ang) * sp;
                    proj.vx = desiredVx;
                    proj.vy = desiredVy;
                    proj.bounces--;
                    // Extend life a bit so chained ricochets travel meaningful distance
                    proj.life = Math.max(proj.life + 55, proj.life);
                    // Small flash particle at source to indicate energy jump
                    // Light energy arc particle burst
                    for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*14, proj.y + (Math.random()-0.5)*14, '#FFEFAA','spark');
                    // Telegraph: faint source ring + short forward dash
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx && !reduceRings) addParticle(proj.x, proj.y, '#FFE6AA','ring');
                    if (typeof addTransientEffect === 'function') {
                        addTransientEffect({ type:'dashTick', x: proj.x, y: proj.y, ang, len: 18, color:'#FFE6AA', life: 100 });
                    }
                    // Telegraph: draw a quick lightning arc or tracer towards the next target
                    if (typeof createLightningArc === 'function') {
                        createLightningArc(proj.x, proj.y, nextTarget.x, nextTarget.y, 7);
                    } else if (ctx && ctx.beginPath) {
                        // Fallback tracer stored as transient effect end-ring only
                        addTransientEffect && addTransientEffect({ type:'ringFlash', x: nextTarget.x, y: nextTarget.y, color:'#FFEFAA', radius: 18, life: 140 });
                    }
                    // Destination ring flash to mark impact point
                    if (typeof addTransientEffect === 'function') {
                        addTransientEffect({ type:'ringFlash', x: nextTarget.x, y: nextTarget.y, color:'#FFDDAA', radius: 22, life: 160 });
                    }
                    if (typeof addScreenShake === 'function') addScreenShake(2);
                    return false; // keep projectile alive
                }
            }
            if (proj.piercing) {
                proj.pierceHits=(proj.pierceHits||0)+1;
                // Do NOT split again here; primary split already occurred above if applicable.
                if (proj.pierceHits < proj.pierceCount) {
                    // Drill shrapnel on successful pass-through
                    if (proj.drilling) {
                        const vx = (proj.vx!=null?proj.vx:(proj._lastVX||1));
                        const vy = (proj.vy!=null?proj.vy:(proj._lastVY||0));
                        // Eject shrapnel slightly ahead of exit point in travel direction
                        const ex = enemy.x + Math.sign(vx||1) * Math.min(enemy.size||16, 8);
                        const ey = enemy.y + Math.sign(vy||0) * Math.min(enemy.size||16, 8);
                        spawnDrillShrapnel(ex, ey, vx, vy, proj.baseDamage || proj.damage || damage);
                    }
                    // If only one pierce remains after this hit, enable a brief warning aura on the projectile
                    const remaining = Math.max(0, (proj.pierceCount||0) - proj.pierceHits);
                    if (remaining === 1) {
                        proj._pierceWarn = Math.max(proj._pierceWarn||0, 18);
                    }
                    // Telegraph: quick exit ring where it passed through (perf-aware)
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx && !reduceRings) addParticle(enemy.x, enemy.y, '#AEEFD4','ring');
                    // Mark a brief forward streak flash on the projectile itself (renderer will show and then decay)
                    // Note: proj here is the same metadata object stored in game._projMeta for SoA bullets.
                    if (proj) {
                        proj._pierceFlash = Math.max(proj._pierceFlash||0, 9);
                    }
                    return false; // keep traveling until pierce limit reached
                }
            }
            // (Split Shot final consumption trigger removed)
            // Drill Shot: if this hit killed the enemy, also eject shrapnel once
            if (proj.drilling && enemy.health <= 0 && !proj._drillShrapThisHit) {
                // Determine enemy facing vector (fallback to projectile travel if unavailable)
                let fx = 0, fy = 1;
                const facing = enemy.facing || 'down';
                if (facing === 'left') { fx = -1; fy = 0; }
                else if (facing === 'right') { fx = 1; fy = 0; }
                else if (facing === 'up') { fx = 0; fy = -1; }
                else { fx = 0; fy = 1; }
                // Fire shrapnel opposite the enemy facing
                const angOpp = Math.atan2(-fy, -fx);
                // Use exactly 3 shards, tighter spread
                const baseDmg = proj.baseDamage || proj.damage || damage;
                spawnDrillShrapnel(enemy.x, enemy.y, 1, 0, baseDmg, { count: 3, angle: angOpp, spread: 0.35 });
                proj._drillShrapThisHit = true;
            }
            // Time Bomb safeguard: do not consume the projectile via normal hit logic before its fuse expires.
            // Rationale: Previously the projectile could reach its pierce limit and be removed before the countdown hit 0,
            // preventing the explosion from ever triggering. We allow it to keep traveling (no extra special damage changes)
            // until the timer section in updateProjectiles() detonates it, or the armed early-detonation condition fires above.
            if (proj.timeBomb && proj._timeBombTimer > 0) {
                return false; // keep projectile alive until explosion
            }
            return true;
        }

        // SIGMA stage 3 spinner spawner and update hooks
        function spawnSigma3(x, y, power) {
            if (!game._sigma) game._sigma = {};
            const idx = game.spawnProjectile({ x, y, vx: 0, vy: 0, life: 120, r: 60, damage: power, damageType: null });
            if (idx >= 0) {
                if (!game._projMeta) game._projMeta = new Map();
                game._projMeta.set(idx, {
                    sigma3: true,
                    baseDamage: power,
                    _spin: 0,
                    _spinRate: 0.28,
                    _age: 0,
                    phasing: true,
                    // Unlimited piercing so sigma3 never disappears on enemy contact
                    piercing: true,
                    pierceCount: 999999,
                    // Tag damage type so contact hits show with a consistent tint
                    damageType: 'void'
                });
                // cue
                if (!(game.perf && game.perf.lowFx)) addParticle(x, y, '#BBD7FF','ring');
            }
        }

        function applyStatusEffects(enemy) {
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageType) {
                    switch (abilityData.effect.damageType) {
                        case 'poison':
                            enemy.poisoned = true;
                            let poisonDur = 240;
                            // Poison + Void synergy extends duration
                            if (game.player.abilities.includes('Void Shot') || game.player.abilities.includes('Black Hole')) {
                                poisonDur += 90; // extend 1.5s
                            }
                            enemy.poisonTime = Math.max(enemy.poisonTime || 0, poisonDur);
                            break;
                        case 'ice':
                            enemy.slowed = true;
                            let slowDur = 180;
                            // Ice + Wind (Blizzard synergy) increases slow duration
                            if (game.player.abilities.includes('Wind Blade') || game.player.abilities.includes('Blizzard')) {
                                slowDur += 60;
                            }
                            enemy.slowTime = Math.max(enemy.slowTime || 0, slowDur);
                            break;
                        case 'fire':
                            enemy.burning = true;
                            let burnDur = 200;
                            if (game.player.abilities.includes('Wind Blade')) burnDur += 40; // fire + wind extends burn
                            if (game.player.abilities.includes('Poison Shot') || game.player.abilities.includes('Toxic Cloud') || game.player.abilities.includes('Inferno') || game.player.abilities.includes('Magma Shot')) {
                                burnDur += 30; // fire + poison style synergy (magma) extends further
                            }
                            enemy.burnTime = Math.max(enemy.burnTime || 0, burnDur);
                            break;
                        case 'lightning':
                            // Chain lightning
                            let chained = 0;
                            const maxChains = 3;
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && chained < maxChains) {
                                    const dx = otherEnemy.x - enemy.x;
                                    const dy = otherEnemy.y - enemy.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < 100) {
                                        const zapDmg = Math.floor(calculateDamage() * 0.6);
                                        otherEnemy.health -= zapDmg;
                                        addDamageNumber(zapDmg, otherEnemy.x, otherEnemy.y - otherEnemy.size/2, { type: 'lightning' });
                                        addParticle(otherEnemy.x, otherEnemy.y, '#FFFF44', 'lightning');
                                        // Visual lightning arc from enemy -> otherEnemy
                                        if (typeof createLightningArc === 'function') createLightningArc(enemy.x, enemy.y, otherEnemy.x, otherEnemy.y, 5 + Math.random()*3);
                                        chained++;
                                    }
                                }
                            });
                            break;
                        case 'stun':
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, 60);
                            break;
                        case 'frost':
                            // freezing: short stun + slow
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, 36);
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 160);
                            break;
                        case 'plasma':
                            // plasma applies burning over time
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 200);
                            break;
                        case 'acid':
                            // acid: applies corrosion (armor shred) and DoT bypassing armor
                            enemy.corroded = true;
                            enemy.corrodeTime = Math.max(enemy.corrodeTime || 0, 200);
                            enemy.armorShredded = (enemy.armorShredded || 0) + 1; // track stacks
                            // Unique: spawn a small lingering acid pool on first application per recent window
                            if (game && game._acidPoolsEnabled !== false) {
                                const nowA = Date.now();
                                const key = enemy._lastAcidPoolAt || 0;
                                const cd = 800; // ms cooldown per enemy to avoid spam
                                if (!key || nowA - key >= cd) {
                                    enemy._lastAcidPoolAt = nowA;
                                    spawnAcidPool(enemy.x, enemy.y, Math.max(42, Math.floor(56 + Math.random()*18)), 4000);
                                }
                            }
                            break;
                        case 'void':
                            // void: applies a weakening field (extra damage taken) and a small true damage tick over time
                            enemy.voidTouched = true;
                            enemy.voidTime = Math.max(enemy.voidTime || 0, 180);
                            enemy.weakness = true;
                            enemy.weaknessTime = Math.max(enemy.weaknessTime || 0, 180);
                            break;
                        case 'earth':
                            // earth: minor stun/slow due to impact shock
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 50);
                            if (Math.random() < 0.18) { // slightly lower chance
                                enemy.stunned = true;
                                // Cap cumulative stun chain length
                                const newDur = Math.max(enemy.stunTime || 0, 18);
                                enemy.stunTime = Math.min(newDur, 50); // hard cap
                            }
                            break;
                        case 'solar':
                            // solar blinds (reduces detection range)
                            if (abilityData.effect && abilityData.effect.blinds) {
                                enemy.blinded = true;
                                enemy.blindTime = Math.max(enemy.blindTime || 0, 120);
                                // Flash particles
                                for (let f=0; f<6; f++) addParticle(enemy.x + (Math.random()-0.5)*28, enemy.y + (Math.random()-0.5)*28, '#FFEFA5','explosion');
                                // Small radial spark ring
                                for (let s=0; s<10; s++) addParticle(enemy.x + Math.cos((s/10)*Math.PI*2)*18, enemy.y + Math.sin((s/10)*Math.PI*2)*12, '#FFF7D1','spark');
                                // Optional mini AoE blind pulse (shorter duration) around primary target
                                const aoeR = 80;
                                game.enemies.forEach(o=>{ if(o===enemy) return; const dx=o.x-enemy.x; const dy=o.y-enemy.y; const d=Math.sqrt(dx*dx+dy*dy); if(d<aoeR){ o.blinded=true; o.blindTime=Math.max(o.blindTime||0,60); if(Math.random()<0.25) addParticle(o.x,o.y,'#FFEFA5','spark'); } });
                            }
                            break;
                        case 'shadow':
                            // shadow drains life slightly on hit
                            const heal = Math.max(1, Math.floor(calculateDamage() * 0.06));
                            game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                            addParticle(game.player.x, game.player.y - 18, '#AA00AA', 'heal');
                            break;
                        case 'wind':
                            // gust: small knockback
                            const kdx = enemy.x - game.player.x;
                            const kdy = enemy.y - game.player.y;
                            const kdist = Math.sqrt(kdx*kdx + kdy*kdy) || 0.0001;
                            applyKnockback(enemy, 12, kdx, kdy);
                            break;
                        case 'steam':
                            // steam = hot + cold: burn and slow a little
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 120);
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 120);
                            break;
                        case 'magma':
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 260);
                            // heavy shove
                            const mdx = enemy.x - game.player.x;
                            const mdy = enemy.y - game.player.y;
                            const mdist = Math.sqrt(mdx*mdx + mdy*mdy) || 0.0001;
                            applyKnockback(enemy, Math.max(6, Math.floor((mdist) * 0.06)), mdx, mdy);
                            break;
                        case 'storm':
                            // storm: small chain lightning + slow
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 140);
                            // mini chain
                            let chainedLocal = 0; const maxChainsLocal = 2;
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && chainedLocal < maxChainsLocal) {
                                    const dx = otherEnemy.x - enemy.x; const dy = otherEnemy.y - enemy.y;
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist < 90) {
                                        otherEnemy.health -= Math.floor(calculateDamage() * 0.35);
                                        addParticle(otherEnemy.x, otherEnemy.y, '#FFFF88', 'lightning');
                                        chainedLocal++;
                                    }
                                }
                            });
                            break;
                        case 'crystal':
                            // Crystal Shot: reliable shatter on hit spawning prismatic shards
                            // Nerf: fewer shards on direct hit (2-3 instead of 3-4)
                            const shardBase = 2 + Math.floor(Math.random()*2); // 2-3
                            for (let s = 0; s < shardBase; s++) {
                                const ang = Math.random()*Math.PI*2;
                                const sp = 3.2 + Math.random()*3.2;
                                const dmgFrac = 0.16 + Math.random()*0.08; // 16-24% of base damage (slight total nerf)
                                game.spawnProjectile({
                                    x: enemy.x + Math.cos(ang)*6,
                                    y: enemy.y + Math.sin(ang)*6,
                                    vx: Math.cos(ang)*sp,
                                    vy: Math.sin(ang)*sp,
                                    life: 46 + Math.floor(Math.random()*12),
                                    size: 4,
                                    enemy: false,
                                    damage: Math.max(1, Math.floor(calculateDamage()*dmgFrac)),
                                    damageType: 'crystal',
                                    refract: true // flag for future synergy (e.g., bonus vs armored)
                                });
                            }
                            // Visual sparkle burst
                            for (let p=0;p<6;p++) addParticle(enemy.x + (Math.random()-0.5)*20, enemy.y + (Math.random()-0.5)*20, '#88EEFF', 'spark');
                            break;
                        case 'fear':
                            enemy.fleeing = true;
                            enemy.fleeTime = Math.max(enemy.fleeTime || 0, 120);
                            break;
                        case 'blind':
                            enemy.blinded = true;
                            enemy.blindTime = Math.max(enemy.blindTime || 0, 100);
                            break;
                        case 'charm':
                            enemy.charmed = true;
                            enemy.charmTime = Math.max(enemy.charmTime || 0, 120);
                            break;
                        case 'silence':
                            enemy.silenced = true;
                            enemy.silenceTime = Math.max(enemy.silenceTime || 0, 120);
                            break;
                        case 'curse':
                            // reduce enemy damage output for a period
                            enemy.cursed = true;
                            enemy.curseTime = Math.max(enemy.curseTime || 0, 240);
                            break;
                        case 'weakness':
                            // increase damage taken
                            enemy.weakness = true;
                            enemy.weaknessTime = Math.max(enemy.weaknessTime || 0, 240);
                            break;
                        case 'doom':
                            // mark for death: small periodic damage
                            enemy.doomed = true;
                            enemy.doomTime = Math.max(enemy.doomTime || 0, 300);
                            break;
                        case 'knockback':
                            // shove enemy away from player
                            const kx = enemy.x - game.player.x;
                            const ky = enemy.y - game.player.y;
                            const kdist2 = Math.sqrt(kx*kx + ky*ky) || 0.0001;
                            applyKnockback(enemy, 30, kx, ky);
                            break;
                    }
                }
            });
            // Post-processing: lifeSteal from abilities (apply on next hit resolution)
            // lifeSteal is handled when enemies die in updateEnemies; ensure flag exists
        }

        // --- Acid Pools (lingering) ---
        function spawnAcidPool(x, y, radius, durationMs) {
            if (!Array.isArray(game.acidPools)) game.acidPools = [];
            // Performance cap
            if (game.acidPools.length > 24) game.acidPools.shift();
            const pool = { x, y, r: radius, created: Date.now(), duration: durationMs, tickCd: 0 };
            game.acidPools.push(pool);
        }
        function updateAcidPools() {
            if (!Array.isArray(game.acidPools) || !game.acidPools.length) return;
            const now = Date.now();
            for (let i = game.acidPools.length - 1; i >= 0; i--) {
                const p = game.acidPools[i]; if (!p) { game.acidPools.splice(i,1); continue; }
                const age = now - p.created;
                if (age >= p.duration) { game.acidPools.splice(i,1); continue; }
                // Damage tick cadence ~200ms
                p.tickCd = (p.tickCd||0) - 16;
                if (p.tickCd <= 0) {
                    p.tickCd = 200;
                    const r2 = p.r * p.r;
                    game.enemies.forEach(e => {
                        if (!e || e.health<=0) return;
                        const dx = e.x - p.x; const dy = e.y - p.y;
                        if (dx*dx + dy*dy <= r2) {
                            const dps = Math.max(1, Math.floor(calculateDamage() * 0.10)); // true-like damage
                            e.health -= dps;
                            // apply corrosion stack and timer refresh
                            e.corroded = true; e.corrodeTime = Math.max(e.corrodeTime||0, 120);
                            e.armorShredded = Math.min(10, (e.armorShredded||0) + 1);
                            addDamageNumber(dps, e.x, e.y - e.size/2, { type: 'acid' });
                            if (Math.random()<0.12) addParticle(e.x, e.y, '#66FF44', 'impact');
                        }
                    });
                }
            }
        }

        function explodeProjectile(proj, damage) {
            // Create explosion particles (amplified for Time Bomb)
            const isTB = !!proj.timeBomb;
            const lowFx = !!(game.perf && game.perf.lowFx);
            const pCount = isTB ? (lowFx ? 12 : 28) : 8;
            // Choose explosion tint based on element when available
            const explHex = getProjElementColor(proj) || (isTB ? '#FF8844' : '#FF6600');
            for (let i = 0; i < pCount; i++) {
                const col = isTB
                    ? (Math.random() < 0.2 ? '#FFFFFF' : (Math.random() < 0.5 ? lightenHex(explHex, 0.35) : explHex))
                    : explHex;
                const spread = isTB ? 26 : 0;
                addParticle(
                    proj.x + (Math.random()-0.5)*spread,
                    proj.y + (Math.random()-0.5)*spread,
                    col,
                    'explosion'
                );
            }
            if (isTB && !lowFx) {
                // Central hot ring burst
                addParticle(proj.x, proj.y, lightenHex(explHex, 0.25), 'ring');
                addParticle(proj.x, proj.y, lightenHex(explHex, 0.45), 'ring');
            }
            
            // Damage nearby enemies (use proj.baseDamage when available so effects remain consistent)
            const baseRadius = proj.antimatter ? 120 : (isTB ? 90 : 60);
            // Allow callers (e.g., SIGMA3) to override the explosion radius to match visuals
            let radius = baseRadius * (proj.antimatter ? 1.4 : (isTB ? 1.35 : 1));
            if (typeof proj.explosionRadius === 'number' && isFinite(proj.explosionRadius)) {
                radius = proj.explosionRadius;
            }
            // Optional: separate radius for knockback-only area (can exceed damage radius)
            const kbRadius = (typeof proj.knockbackRadius === 'number' && isFinite(proj.knockbackRadius)) ? proj.knockbackRadius : radius;
            const sourceDmg = proj.baseDamage || damage;
            game.enemies.forEach(enemy => {
                const dx = enemy.x - proj.x;
                const dy = enemy.y - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    // chainExplosion: cause secondary smaller explosions on nearby enemies
                    // If enemy is weakened, take extra damage
                    const mult = enemy.weakness ? 1.45 : 1.0;
                    // Allow explosion to bypass armor if flagged
                    let applied = Math.floor(sourceDmg * (proj.antimatter ? 1.0 : 0.7) * mult);
                    if (proj.ignoresEverything) applied = Math.floor(applied * 1.3);
                    // ignoresArmor would skip any armor calculation; since we don't have an armor
                    // scalar in this build, keeping applied as-is but honoring the flag for future hooks
                    enemy.health -= applied;
                    const dmgTypeOut = proj.damageType || (proj.antimatter ? 'void' : null);
                    addParticle(enemy.x, enemy.y, getDamageTypeColor(dmgTypeOut) || '#FF4444', 'impact');
                    addDamageNumber(applied, enemy.x, enemy.y - enemy.size/2, { type: dmgTypeOut });
                    if (proj.chainExplosion) {
                        // small secondary blast
                        setTimeout(() => {
                            explodeProjectile({ x: enemy.x, y: enemy.y, chainExplosion: false }, Math.floor(sourceDmg * 0.5));
                        }, 80);
                    }
                    // lifeSteal: heal player slightly based on damage dealt
                    if (proj.lifeSteal && proj.lifeSteal > 0) {
                        const heal = Math.min(10, Math.floor(sourceDmg * 0.06));
                        game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                        addParticle(game.player.x, game.player.y - 18, '#00FF00', 'heal');
                    }
                }
                // Apply knockback in a possibly larger area (outside damage radius) when flagged
                if (proj.knockback && dist < kbRadius) {
                    const falloff = Math.max(0, kbRadius - dist);
                    const scale = (typeof proj.knockbackScale === 'number' && isFinite(proj.knockbackScale)) ? proj.knockbackScale : 0.30;
                    const push = Math.max(10, Math.floor(falloff * scale));
                    const ndx = dx / Math.max(dist,1);
                    const ndy = dy / Math.max(dist,1);
                    applyKnockback(enemy, push, ndx, ndy);
                }
            });
            
            addScreenShake(proj.antimatter ? 12 : (isTB ? 10 : 6));

            // Trigger area effects if the projectile carried those abilities
            if (proj.shockwave) {
                createShockwave(proj.x, proj.y);
            }
            if (proj.timeWarp) {
                createTimeWarp(proj.x, proj.y);
            }
            if (proj.blackHole) {
                createBlackHole(proj.x, proj.y);
            }
            if (proj.vortex) {
                createVortex(proj.x, proj.y);
            }

            // Spawn outward shards similar to an omni blast when Time Bomb detonates
            if (isTB) {
                let shardCount = lowFx ? 10 : 16;
                // If many projectiles already active, tone it down a bit
                try { if (game.projectilePool && game.projectilePool.active && game.projectilePool.active() > 1200) shardCount = Math.max(8, Math.floor(shardCount * 0.7)); } catch (e) {}
                const spd = 4.2;
                const life = 55;
                const base = sourceDmg || calculateDamage();
                const shardDmg = Math.max(1, Math.floor(base * 0.5));
                const rSmall = 6;
                for (let s = 0; s < shardCount; s++) {
                    const ang = (s / shardCount) * Math.PI * 2;
                    const jitter = (Math.random() - 0.5) * 0.15; // tiny variance
                    const a = ang + jitter;
                    const idx = game.spawnProjectile({
                        x: proj.x,
                        y: proj.y,
                        vx: Math.cos(a) * spd,
                        vy: Math.sin(a) * spd,
                        life: life,
                        r: rSmall,
                        damage: shardDmg,
                        damageType: 'fire',
                        enemy: false
                    });
                    // Sanitize shard metadata: ensure plain bullet with no bomb/explosive chaining flags
                    if (idx >= 0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idx, {
                            baseDamage: shardDmg,
                            damageType: 'fire',
                            // Explicitly disable all explosive/bomb style flags
                            timeBomb: false,
                            smartExplosive: false,
                            chainExplosion: false,
                            novaBlast: false,
                            explosive: false,
                            meteorAbility: false,
                            meteor: false,
                            // Keep them simple projectiles; allow piercing as false by default
                            piercing: false,
                            pierceCount: 0
                        });
                    }
                }
            }

            // Elemental area effects
            if (proj.areaEffect || proj.damageType === 'toxic') {
                // Toxic cloud: poisons enemies in area
                for (let i = 0; i < 6; i++) addParticle(proj.x + (Math.random()-0.5)*40, proj.y + (Math.random()-0.5)*40, '#44AA44', 'poison');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 90) {
                        enemy.poisoned = true;
                        enemy.poisonTime = Math.max(enemy.poisonTime || 0, 240);
                    }
                });
            }
            if (proj.damageType === 'blizzard' || proj.energyType === 'pulse') {
                // Blizzard: slows in area, small ice particles, and a light frostbite tick for feedback
                for (let i = 0; i < 10; i++) addParticle(proj.x + (Math.random()-0.5)*70, proj.y + (Math.random()-0.5)*70, '#88EEFF', 'fire');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 110) {
                        enemy.slowed = true;
                        enemy.slowTime = Math.max(enemy.slowTime || 0, 200);
                        // light frost tick (safe value) and number
                        const frost = Math.max(1, Math.floor((proj.baseDamage||calculateDamage()) * 0.10));
                        enemy.health -= frost;
                        addDamageNumber(frost, enemy.x, enemy.y - enemy.size/2, { type:'blizzard' });
                        if (Math.random() < 0.35) addParticle(enemy.x, enemy.y, '#C0F8FF', 'impact');
                    }
                });
            }
            if (proj.spreading || proj.damageType === 'inferno' || proj.energyType === 'laser') {
                // Inferno / spreading fire: ignite nearby area and apply burning
                const hex = getDamageTypeColor('fire') || '#FF3333';
                for (let i = 0; i < 10; i++) addParticle(proj.x + (Math.random()-0.5)*80, proj.y + (Math.random()-0.5)*80, hex, 'fire');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 130) {
                        enemy.burning = true;
                        enemy.burnTime = Math.max(enemy.burnTime || 0, 220);
                    }
                });
            }

            // Dimensional Rift: tears space, pulls enemies, damages and occasionally teleports them
            if (proj.dimensional) {
                createDimensionalRift(proj.x, proj.y, Math.max(80, Math.floor(damage * 0.8)));
            }
            // Reality Break: unpredictable physics distortions, small periodic damage and enemy jitter
            if (proj.realityBreak) {
                // slightly stronger base than dimensional by default
                createRealityBreak(proj.x, proj.y, Math.max(120, Math.floor(damage * 1.0)));
            }
        }

        // Small helper: lighten a hex color by fraction [0..1]
        function lightenHex(hex, amt) {
            if (!hex || !/^#([0-9a-fA-F]{6})$/.test(hex)) return hex || '#FFFFFF';
            const v = parseInt(hex.slice(1), 16);
            let r = (v >> 16) & 255, g = (v >> 8) & 255, b = v & 255;
            r = Math.min(255, Math.floor(r + (255 - r) * amt));
            g = Math.min(255, Math.floor(g + (255 - g) * amt));
            b = Math.min(255, Math.floor(b + (255 - b) * amt));
            return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1).toUpperCase();
        }

        // Area effect: shockwave knocks back and damages
        function createShockwave(x, y) {
                    // Expanding shockwave: short-lived ring that applies damage ticks as it expands
                    const maxRadius = 160;
                    const steps = 8;
                    const intervalMs = 28; // ~28ms per step for a quick expansion
                    let step = 0;
                    addParticle(x, y, '#AAAAFF', 'explosion');
                    const swInterval = setInterval(() => {
                        const r = (step / steps) * maxRadius;
                        // visual ring particles
                        for (let i = 0; i < 12; i++) {
                            const ang = Math.random() * Math.PI * 2;
                            const px = x + Math.cos(ang) * (r + (Math.random() - 0.5) * 12);
                            const py = y + Math.sin(ang) * (r + (Math.random() - 0.5) * 12);
                            addParticle(px, py, '#AAAAFF', 'spark');
                        }
                        // damage enemies near the ring edge
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - x;
                            const dy = enemy.y - y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > Math.max(0, r - 18) && dist < r + 18) {
                                enemy.health -= Math.floor(12 * (1 - step / steps));
                                // small shove away from ring center
                                enemy.x += (dx / Math.max(dist, 1)) * 10;
                                enemy.y += (dy / Math.max(dist, 1)) * 10;
                                addParticle(enemy.x, enemy.y, '#AAAAFF', 'impact');
                            }
                        });
                        step++;
                        if (step > steps) {
                            clearInterval(swInterval);
                            addScreenShake(3);
                        }
                    }, intervalMs);
        }

        // --- Dimensional Rift (fallback implementation) ---
        // Creates a transient singularity that gently pulls nearby enemies and deals minor ticking damage.
        // Called by explodeProjectile when proj.dimensional is true. Ensures game won't crash if ability acquired.
        function createDimensionalRift(x, y, power) {
            // power ~ base damage reference; scale effects lightly
            const radius = Math.min(220, 80 + Math.sqrt(power)*4);
            const life = 60; // frames
            const tickDamage = Math.max(6, Math.floor(power * 0.12));
            const rift = { x, y, r: radius, life, maxLife: life, tickDamage, t:0 };
            if (!game._dimRifts) game._dimRifts = [];
            game._dimRifts.push(rift);
            // Spawn cue: faint ring and a couple of sparks (perf-gated)
            const lowFx = !!(game.perf && game.perf.lowFx);
            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
            if (!reduceRings) addParticle(x, y, '#E6CCFF', 'ring');
            if (!lowFx && !hideSparks) {
                for (let p=0;p<3;p++) addParticle(x + (Math.random()-0.5)*radius*0.4, y + (Math.random()-0.5)*radius*0.4, '#CFA6FF', 'spark');
            }
        }

        // Update Dimensional Rifts (pull + damage + visuals)
        function updateDimensionalRifts() {
            if (!game._dimRifts || !game._dimRifts.length) return;
            for (let i = game._dimRifts.length - 1; i >= 0; i--) {
                const r = game._dimRifts[i];
                r.life--;
                const lowFx = !!(game.perf && game.perf.lowFx);
                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                // Visual particles: violet sparks (perf-gated)
                if (!lowFx && !hideSparks && r.life % 5 === 0) {
                    const count = 2; // reduced baseline
                    for (let p=0; p<count; p++) {
                        addParticle(r.x + (Math.random()-0.5)*r.r*1.4, r.y + (Math.random()-0.5)*r.r*1.4, '#AA44FF', 'spark');
                    }
                }
                // Apply pull + tick damage every 10 frames
                if (r.life % 10 === 0) {
                    game.enemies.forEach(enemy => {
                        if (enemy.health <= 0) return;
                        const dx = r.x - enemy.x;
                        const dy = r.y - enemy.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        if (dist < r.r) {
                            // Pull strength decays with distance
                            const pull = Math.max(0.4, 1 - dist / r.r) * 14;
                            enemy.x += (dx / dist) * pull;
                            enemy.y += (dy / dist) * pull;
                            // Damage (ignores armor per ability description context)
                            enemy.health -= r.tickDamage;
                            addDamageNumber(r.tickDamage, enemy.x, enemy.y - enemy.size/2, { type:'void' });
                            addParticle(enemy.x, enemy.y, '#AA44FF', 'impact');
                        }
                    });
                }
                if (r.life <= 0) {
                    // Collapse effect
                    if (!lowFx && !hideSparks) {
                        for (let c=0;c<10;c++) addParticle(r.x, r.y, '#DD99FF', 'spark');
                    }
                    // Collapse ring telegraph (perf-gated)
                    if (!lowFx && !reduceRings) {
                        addParticle(r.x, r.y, '#E6CCFF', 'ring');
                    }
                    game._dimRifts.splice(i,1);
                }
            }
        }

        // --- Traveling Shockwave (linear ground wave) ---
        function spawnShockwave(x, y, angle) {
            if (!game.shockwaves) game.shockwaves = [];
            game.shockwaves.push({
                x, y,
                angle,
                distance: 0,
                speed: 15,
                length: 70,
                width: 80,
                life: 36,
                maxLife: 36,
                hit: []
            });
        }

        function updateShockwaves() {
            if (!game.shockwaves || !game.shockwaves.length) return;
            for (let i = game.shockwaves.length - 1; i >= 0; i--) {
                const w = game.shockwaves[i];
                w.life--;
                w.distance += w.speed;
                const ax = Math.cos(w.angle), ay = Math.sin(w.angle);
                const frontStart = Math.max(0, w.distance - w.length);
                const frontEnd = w.distance;
                game.enemies.forEach(enemy => {
                    if (enemy.health <= 0) return;
                    if (w.hit.includes(enemy)) return;
                    const dx = enemy.x - w.x;
                    const dy = enemy.y - w.y;
                    const along = dx * ax + dy * ay;
                    if (along < frontStart || along > frontEnd) return;
                    const perp = Math.abs(-ay * dx + ax * dy);
                    if (perp > w.width * 0.5) return;
                    // Apply damage & push
                    const pct = 1 - (along / (frontEnd + 0.0001));
                    const base = calculateDamage();
                    const dmg = Math.max(5, Math.floor(base * 0.5 * (0.65 + 0.35 * pct)));
                    enemy.health -= dmg;
                    addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type: 'earth' });
                    applyKnockback(enemy, 34, ax, ay);
                    addParticle(enemy.x, enemy.y, '#AAAACC', 'impact');
                    w.hit.push(enemy);
                });
                // Auto remove when expired or out of bounds
                const endX = w.x + ax * w.distance;
                const endY = w.y + ay * w.distance;
                if (w.life <= 0 || endX < -100 || endX > canvas.width + 100 || endY < -100 || endY > canvas.height + 100) {
                    game.shockwaves.splice(i,1);
                }
            }
        }

        // Transient lightning arc segment (visual only)
        function createLightningArc(x1, y1, x2, y2, life = 8) {
            if (!game.lightningArcs) game.lightningArcs = [];
            const segs = 6 + Math.floor(Math.random()*4); // number of jitter points
            const points = [];
            for (let i=0;i<=segs;i++) {
                const t = i / segs;
                const bx = x1 + (x2 - x1) * t;
                const by = y1 + (y2 - y1) * t;
                const jitterScale = Math.sin(Math.PI * t); // 0 at ends, 1 mid
                const jx = (Math.random()-0.5) * 22 * jitterScale;
                const jy = (Math.random()-0.5) * 22 * jitterScale;
                points.push({ x: bx + jx, y: by + jy });
            }
            game.lightningArcs.push({ points, life, maxLife: life });
        }

        // Time warp: slows enemies in area briefly
        function createTimeWarp(x, y) {
            // Persistent temporal distortion field
            if (!game.timeWarpFields) game.timeWarpFields = [];
            const field = {
                x, y,
                radius: 170,
                createdAt: Date.now(),
                duration: 3000, // ms lifetime
                pulseInterval: 400, // ms between slow pulses
                lastPulse: 0,
                wave: 0 // internal animation phase
            };
            game.timeWarpFields.push(field);
            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                for (let i = 0; i < 10; i++) addParticle(x + (Math.random()-0.5)*field.radius*0.4, y + (Math.random()-0.5)*field.radius*0.4, '#44FFFF', 'victory');
            }
            addScreenShake(2);
        }

        function updateTimeWarpFields() {
            if (!game.timeWarpFields || !game.timeWarpFields.length) return;
            const now = Date.now();
            for (let i = game.timeWarpFields.length - 1; i >= 0; i--) {
                const f = game.timeWarpFields[i];
                const age = now - f.createdAt;
                if (age > f.duration) {
                    // collapse burst
                    if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                        for (let p=0;p<8;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.3, f.y + (Math.random()-0.5)*f.radius*0.3, '#2277FF', 'spark');
                    }
                    game.timeWarpFields.splice(i,1);
                    continue;
                }
                f.wave += 0.06;
                if (now - f.lastPulse >= f.pulseInterval) {
                    f.lastPulse = now;
                    // Apply slow to enemies inside radius
                    game.enemies.forEach(enemy => {
                        if (enemy.health <= 0) return;
                        const dx = enemy.x - f.x;
                        const dy = enemy.y - f.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < f.radius) {
                            enemy.slowed = true;
                            // refresh / extend but cap to avoid infinite stacking
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 150);
                            // Optional: add tiny temporal jitter particle
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                if (Math.random() < 0.25) addParticle(enemy.x, enemy.y - enemy.size/2, '#66AAFF', 'spark');
                                // Subtle flash indicator on pulse
                                addParticle(enemy.x, enemy.y, '#88DDFF', 'impact');
                            }

        // === Bloom Ring System (Hybrid Mode C) ===
        // Player periodically spawns large expanding damage rings. Projectiles emit occasional sub-petal bursts (handled inline earlier).
        // Each enemy is damaged at most once per ring (edge pass). Ring has telegraph (pre-detonation) then expansion phase.
        function spawnBloomRing(x, y, opts) {
            if (!game.bloomRings) game.bloomRings = [];
            const maxActive = 6;
            if (game.bloomRings.length >= maxActive) game.bloomRings.shift();
            // Vortex proximity synergy: if spawning within any vortex innerRadius*1.1, boost damage and growth slightly
            let vortexBoost = 1;
            if (Array.isArray(game.vortexFields) && game.vortexFields.length) {
                for (const vf of game.vortexFields) {
                    const dx = x - vf.x, dy = y - vf.y; const d = Math.hypot(dx, dy);
                    if (d < vf.innerRadius * 1.1) { vortexBoost = 1.18; break; }
                }
            }
            const ring = {
                x, y,
                radius: 0,
                width: opts && opts.width || 28, // slightly thicker for readability
                growth: (opts && opts.growth || 7.2) * (vortexBoost>1?1.06:1),
                maxRadius: (opts && opts.maxRadius || 440) * (vortexBoost>1?1.04:1),
                damage: (opts && opts.damage || Math.max(2, Math.floor(calculateDamage() * 0.55))) * vortexBoost,
                createdAt: Date.now(),
                maxLife: (opts && opts.maxLife) || 6000,
                hits: new Set(),
                detonated: true,
                seed: Math.random()*Math.PI*2,
                telegraphUntil: performance.now() + 180, // first 180ms gets brighter core pulse
                firstDamage: false // flag for one-time stronger feedback on first enemy hit
            };
            game.bloomRings.push(ring);
            // Petal emission (stronger, fewer) at ring birth
            const petals = 8;
            for (let i=0;i<petals;i++) {
                const ang = (i/petals)*Math.PI*2;
                const spd = 4.2 + Math.random()*0.8;
                game.spawnProjectile({
                    x, y,
                    vx: Math.cos(ang)*spd,
                    vy: Math.sin(ang)*spd,
                    life: 46,
                    size: 4,
                    enemy:false,
                    damage: Math.max(1, Math.floor(ring.damage * 0.42 * (vortexBoost>1?1.1:1))),
                    baseDamage: Math.max(1, Math.floor(ring.damage * 0.42 * (vortexBoost>1?1.1:1))),
                    bloomChild:true,
                    _petal:true
                });
            }
            if (typeof addScreenShake === 'function') addScreenShake(4, 180);
            addParticle(x, y, '#FFE4CC','explosion');
        }

        function updateBloomRings() {
            if (!game.player || !game.player.abilities || !game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect && ABILITIES[a].effect.bloomRing)) return;
            if (!game._bloomRingCharge) game._bloomRingCharge = 0;
            const chargeTime = 58; // frames between main rings (approx 1s at 60fps)
            game._bloomRingCharge++;
            // Pre-fire telegraph: a brief ringFlash at the intended spawn spot shortly before spawning (perf-aware)
            if (game._bloomRingCharge === chargeTime - 6) {
                let sx = game.player.x, sy = game.player.y;
                if (game.player && game.player.vx && game.player.vy) { sx += game.player.vx * 4; sy += game.player.vy * 4; }
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings) addTransientEffect({ type:'ringFlash', x:sx, y:sy, color:'#FFE4CC', radius: 26, life: 160 });
            }
            if (game._bloomRingCharge >= chargeTime) {
                game._bloomRingCharge = 0;
                // Spawn ring at player location (slightly ahead if moving for dynamism)
                let sx = game.player.x;
                let sy = game.player.y;
                if (game.player && game.player.vx && game.player.vy) {
                    sx += game.player.vx * 4;
                    sy += game.player.vy * 4;
                }
                // Optional synergy: if Echo Bloom field active, increase radius a bit
                const activeEcho = game.echoBloomFields && game.echoBloomFields.length;
                spawnBloomRing(sx, sy, activeEcho ? { maxRadius: 470, growth: 7.8 } : null);
            }
            // Ring progression & damage application
            if (!game.bloomRings || !game.bloomRings.length) return;
            for (let i = game.bloomRings.length - 1; i >= 0; i--) {
                const rg = game.bloomRings[i];
                rg.radius += rg.growth;
                // Soft acceleration near early phase to feel more explosive
                if (rg.radius < rg.maxRadius*0.25) rg.radius += rg.growth*0.15;
                // Vortex intersection synergy: when ring edge passes through vortex radius for first time, spawn bonus petals & temp damage buff
                if (!rg._vortexProc && Array.isArray(game.vortexFields) && game.vortexFields.length) {
                    for (const vf of game.vortexFields) {
                        const dxv = rg.x - vf.x, dyv = rg.y - vf.y; const dv = Math.hypot(dxv, dyv);
                        // Check if ring edge intersects vortex outer radius band this frame
                        if (Math.abs(dv - rg.radius) < rg.growth + 8 && dv < vf.radius + rg.width) {
                            rg._vortexProc = true;
                            // Damage boost for remaining expansion
                            rg.damage *= 1.15;
                            rg.growth *= 1.08;
                            // Spawn bonus petals focused tangentially (12 smaller petals)
                            const bonus = 12;
                            for (let b=0;b<bonus;b++) {
                                const ang = (b/bonus)*Math.PI*2;
                                const spd = 4.6 + Math.random()*0.9;
                                game.spawnProjectile({
                                    x: rg.x + Math.cos(ang)*rg.radius,
                                    y: rg.y + Math.sin(ang)*rg.radius,
                                    vx: Math.cos(ang + Math.PI/2)*spd*0.55,
                                    vy: Math.sin(ang + Math.PI/2)*spd*0.55,
                                    life: 34,
                                    size: 3,
                                    enemy:false,
                                    damage: Math.max(1, Math.floor(rg.damage * 0.24)),
                                    baseDamage: Math.max(1, Math.floor(rg.damage * 0.24)),
                                    bloomChild:true,
                                    _petal:true,
                                    _vortexPetal:true
                                });
                            }
                            addParticle(rg.x, rg.y, '#FFEEDD','explosion');
                            if (typeof addScreenShake === 'function') addScreenShake(3, 160);
                            break;
                        }
                    }
                }
                // Lifespan fail-safe (ms)
                if (Date.now() - rg.createdAt > rg.maxLife || rg.radius > rg.maxRadius + rg.width*1.2) {
                    game.bloomRings.splice(i,1);
                    continue;
                }
                // Damage band: treat ring edge as annulus
                if (game.enemies && game.enemies.length) {
                    for (const enemy of game.enemies) {
                        if (!enemy || enemy.health <= 0) continue;
                        const id = enemy._id || enemy.__rid || enemy; // fallback: object ref
                        if (rg.hits.has(id)) continue;
                        const dx = enemy.x - rg.x;
                        const dy = enemy.y - rg.y;
                        const dist = Math.hypot(dx, dy);
                        const edgeDelta = Math.abs(dist - rg.radius);
                        if (edgeDelta <= rg.width * 0.55 && dist <= rg.radius + rg.width) {
                            rg.hits.add(id);
                            const dmg = Math.max(1, Math.floor(rg.damage * (0.85 + Math.random()*0.3)));
                            applyPlayerDamage(enemy, dmg);
                            addDamageNumber(dmg, enemy.x, enemy.y - (enemy.size||18)/2, { color:'#FFC8AA' });
                            // Hit shimmer particles (consistent, a couple per hit for clarity)
                            addParticle(enemy.x, enemy.y, '#FFE0CC','spark');
                            if (Math.random()<0.35) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, '#FFD0B0','spark');
                            // Slight outline flash effect via a temporary marker
                            enemy._bloomFlash = 4; // frames of flash handled in enemy render (if implemented)
                            // One-time stronger feedback on first damage event of this ring
                            if (!rg.firstDamage) {
                                rg.firstDamage = true;
                                if (typeof addScreenShake === 'function') addScreenShake(5);
                                // Central flash particle cluster
                                for (let f=0;f<6;f++) addParticle(rg.x + (Math.random()-0.5)*rg.width*2, rg.y + (Math.random()-0.5)*rg.width*2, '#FFE8D8','explosion');
                            }
                        }
                    }
                }
            }
        }
                        }
                    });
                }
            }
        }

        // Black hole: persistent field handled in update loop for deterministic pulling
        function createBlackHole(x, y) {
            if (!game.blackHoles) game.blackHoles = [];
            const hole = {
                x, y,
                radius: 200,
                createdAt: performance.now(),
                lifeMs: 1900, // total duration
                pulseTimer: 0,
                pulseInterval: 140, // add a damage pulse every 140ms
                spin: 0,
                strength: 5.5, // base pull (effective strength now ramps over life)
                damagePerSecond: 32, // slight tweak (pull stronger so balanced DPS)
                id: Math.random().toString(36).slice(2)
            };
            // Initial particles
            for (let i = 0; i < 18; i++) addParticle(x + (Math.random()-0.5)*40, y + (Math.random()-0.5)*40, '#331133', 'explosion');
            game.blackHoles.push(hole);
            addScreenShake(6);
        }

        function updateBlackHoles() {
            if (!game.blackHoles || !game.blackHoles.length) return;
            const now = performance.now();
            for (let i = game.blackHoles.length - 1; i >= 0; i--) {
                const h = game.blackHoles[i];
                const age = now - h.createdAt;
                const lifeT = age / h.lifeMs; // 0..1
                if (lifeT >= 1) {
                    // collapse burst
                    for (let p=0;p<14;p++) addParticle(h.x + (Math.random()-0.5)*h.radius*0.3, h.y + (Math.random()-0.5)*h.radius*0.3, '#662244','spark');
                    for (let r=0;r<10;r++) addParticle(h.x + Math.cos((r/10)*Math.PI*2)*30, h.y + Math.sin((r/10)*Math.PI*2)*30, '#AA77CC','spark');
                    game.blackHoles.splice(i,1);
                    continue;
                }
                // Spin for visual modulation; spawn subtle inward drifting sparks
                h.spin += 0.04 + lifeT*0.06;
                if (Math.random() < 0.45) addParticle(h.x + Math.cos(h.spin)* (40 + Math.random()*50), h.y + Math.sin(h.spin)*(40 + Math.random()*50), '#442244','spark');
                // Pull + damage
                const radius = h.radius * (1 - lifeT*0.05); // shrink a little less over life
                const pullFalloff = 0.75;
                const frameDamage = (h.damagePerSecond / 60);
                h.pulseTimer += (1000/60);
                const doPulse = h.pulseTimer >= h.pulseInterval;
                if (doPulse) h.pulseTimer = 0;
                game.enemies.forEach(enemy => {
                    if (enemy.health <= 0) return;
                    const dx = h.x - enemy.x;
                    const dy = h.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < radius) {
                        const norm = dist || 0.0001;
                        // Raw falloff 0..1 (1 = center)
                        const fallRaw = (radius - dist) / radius;
                        // Lifetime scaling: suction ramps up toward collapse (0.6..1.5x)
                        const lifeBoost = 0.6 + lifeT * 0.9;
                        // Blend so outer ring still moves meaningfully (min motion) while inner accelerates strongly
                        const blended = 0.25 + Math.max(0, fallRaw) * 0.75; // 0.25..1.0
                        const base = h.strength * lifeBoost;
                        const pull = Math.max(0.35, base * blended * pullFalloff); // ensure minimum noticeable pull
                        enemy.x += (dx / norm) * pull;
                        enemy.y += (dy / norm) * pull;
                        // Frame damage scaled a bit less by distance now (outer ring still hurts some)
                        enemy.health -= frameDamage * (0.5 + blended * 0.5);
                        if (doPulse) {
                            const burst = Math.max(2, Math.floor(frameDamage * 12 * blended));
                            enemy.health -= burst;
                            addDamageNumber(burst, enemy.x, enemy.y - enemy.size/2, { type:'void'});
                            addParticle(enemy.x, enemy.y, '#8844AA','impact');
                        }
                    }
                });
            }
        }

        // Vortex: spinning damage field that applies burning
        function createVortex(x, y) {
            // Spawn a persistent field entry. Fields update in updateVortexFields.
            if (!Array.isArray(game.vortexFields)) game.vortexFields = [];
            const field = {
                x, y,
                radius: 260,
                innerRadius: 80,
                createdAt: Date.now(),
                duration: 4200, // ms lifetime (longer)
                tickEvery: 200, // ms between damage ticks (faster)
                lastTick: 0,
                spin: Math.random() * Math.PI * 2,
                spinSpeed: 0.10 + Math.random()*0.05,
                pullStrength: 7.5, // px per frame at center falloff (much stronger)
                damagePerTick: 12, // higher base damage
                burnTime: 200
            };
            game.vortexFields.push(field);
            for (let i = 0; i < 18; i++) addParticle(x + (Math.random()-0.5)*field.radius*0.65, y + (Math.random()-0.5)*field.radius*0.65, '#FF33FF', 'explosion');
            addScreenShake(4);
        }

        // Update active vortex fields (called from update())
        function updateVortexFields() {
            if (!Array.isArray(game.vortexFields) || game.vortexFields.length === 0) return;
            const now = Date.now();
            for (let i = game.vortexFields.length - 1; i >= 0; i--) {
                const f = game.vortexFields[i];
                if (!f) { game.vortexFields.splice(i,1); continue; }
                // Lifetime expiry
                if (now - f.createdAt > f.duration) {
                    // small dissipate effect
                    for (let p=0;p<8;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.5, f.y + (Math.random()-0.5)*f.radius*0.5, '#AA44AA', 'spark');
                    game.vortexFields.splice(i,1);
                    continue;
                }
                f.spin += f.spinSpeed;
                // Pull + damage ticks
                game.enemies.forEach(enemy => {
                    if (!enemy || enemy.health <= 0) return;
                    const dx = f.x - enemy.x;
                    const dy = f.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < f.radius) {
                        // Normalized inward vector
                        const nx = dx / Math.max(dist, 1);
                        const ny = dy / Math.max(dist, 1);
                        // Falloff ramps sharply near center so pull overcomes movement
                        const proximity = (f.radius - dist) / f.radius; // 0..1
                        const falloff = Math.max(0, Math.min(1, proximity * proximity));
                        // Direct positional pull (guaranteed effect independent of enemy movement model)
                        const pull = f.pullStrength * falloff;
                        enemy.x += nx * pull;
                        enemy.y += ny * pull;
                        // If enemy uses velocity fields, damp and add a small inward accel so the pull "wins"
                        if (typeof enemy.vx === 'number' && typeof enemy.vy === 'number') {
                            const damp = 0.88; // light damping while inside the field
                            enemy.vx *= damp;
                            enemy.vy *= damp;
                            let ax = nx * f.pullStrength * 0.35 * falloff;
                            let ay = ny * f.pullStrength * 0.35 * falloff;
                            const maxAccel = 2.8;
                            const aMag = Math.hypot(ax, ay);
                            if (aMag > maxAccel && aMag > 0) { ax *= maxAccel / aMag; ay *= maxAccel / aMag; }
                            enemy.vx += ax;
                            enemy.vy += ay;
                        }
                        // Apply stronger slow while inside vortex
                        enemy.slowed = true;
                        enemy.slowTime = Math.max(enemy.slowTime||0, 60);
                        if (now - f.lastTick >= f.tickEvery) {
                            // Apply damage + burn once per tick interval
                            let dmg = f.damagePerTick;
                            if (enemy.weakness) dmg = Math.floor(dmg * 1.3);
                            enemy.health -= dmg;
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, f.burnTime);
                            addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type: 'void' });
                            if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#FF66FF', 'impact');
                        }
                    }
                });
                if (now - f.lastTick >= f.tickEvery) {
                    f.lastTick = now;
                    // Pulse visual: tighter ring contraction, slightly more frequent flicker
                    for (let p=0;p<10;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.8, f.y + (Math.random()-0.5)*f.radius*0.8, '#AA44AA','spark');
                    // Mark a short flash for renderer
                    f._flash = 6;
                }
            }
        }

        // Echo Bloom lingering resonance fields
        function updateEchoBloomFields() {
            if (!Array.isArray(game.echoBloomFields) || !game.echoBloomFields.length) return;
            const now = Date.now();
            for (let i = game.echoBloomFields.length - 1; i >= 0; i--) {
                const f = game.echoBloomFields[i];
                if (now - f.createdAt > f.duration) { game.echoBloomFields.splice(i,1); continue; }
                if (now - f.lastTick >= f.tickEvery) {
                    f.lastTick = now;
                    // Track stacked hits: if ticks land close together (due to many enemies inside), boost a short-lived visual intensity
                    f._stackCount = (f._stackCount||0) + 1;
                    f._stackVisUntil = performance.now() + Math.min(260, 120 + f._stackCount * 40);
                    game.enemies.forEach(en => {
                        if (en.health<=0) return;
                        const dx = en.x - f.x; const dy = en.y - f.y; const d = Math.hypot(dx,dy);
                        if (d < f.radius) {
                            const fall = 0.45 + 0.55*(1 - d / f.radius);
                            const dmg = Math.max(1, Math.floor(f.baseDamage * fall));
                            en.health -= dmg;
                            addDamageNumber(dmg, en.x, en.y - en.size/2, { type:'void' });
                            if (Math.random()<0.25) addParticle(en.x, en.y, '#FFC8FF','impact');
                        }

                        // Blizzard Frost Aura: persistent slow/tick around player when they have Blizzard
                        function updateFrostAura() {
                            if (!game.player || !Array.isArray(game.player.abilities)) return;
                            const hasBlizzard = game.player.abilities.some(a => /Blizzard/i.test(a));
                            if (!hasBlizzard) { game._frostAura = null; return; }
                            const now = performance.now();
                            if (!game._frostAura) game._frostAura = { r: 140, lastTick: 0, tickMs: 420 };
                            const aura = game._frostAura;
                            // Apply slow and intermittent frost tick to nearby enemies
                            if (game.enemies && game.enemies.length) {
                                game.enemies.forEach(enemy => {
                                    const dx = enemy.x - game.player.x; const dy = enemy.y - game.player.y; const d = Math.hypot(dx, dy);
                                    if (d <= aura.r + (enemy.size||16)) {
                                        enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime||0, 120);
                                        if (now - aura.lastTick >= aura.tickMs) {
                                            const frost = Math.max(1, Math.floor(calculateDamage() * 0.08));
                                            enemy.health -= frost; addDamageNumber(frost, enemy.x, enemy.y - (enemy.size||18)/2, { type:'blizzard' });
                                        }
                                        if (!game.disableCosmeticParticles && Math.random() < 0.25) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y - (enemy.size||12), '#C8F4FF', 'spark');
                                    }
                                });
                            }
                            if (now - (aura.lastTick||0) >= aura.tickMs) aura.lastTick = now;
                            // Ambient snowflakes around player (cosmetic)
                            if (!game.disableCosmeticParticles) {
                                for (let i=0;i<2;i++) {
                                    const ang = Math.random()*Math.PI*2; const rad = 20 + Math.random()*aura.r;
                                    addParticle(game.player.x + Math.cos(ang)*rad, game.player.y + Math.sin(ang)*rad, '#E0FAFF', 'spark');
                                }
                            }
                        }
                    });
                }
            }
        }

        // Reality Break: short, chaotic distortion that jitters enemies, applies small damage ticks,
        // and occasionally warps an enemy's position to a random nearby location. Conservative safe defaults.
        function createRealityBreak(x, y, baseDamage) {
            const lowFx = !!(game.perf && game.perf.lowFx);
            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
            if (!lowFx && !hideSparks) {
                for (let i = 0; i < 10; i++) addParticle(x + (Math.random()-0.5)*100, y + (Math.random()-0.5)*100, '#66FFFF', 'explosion');
            }
            if (!reduceRings) {
                addParticle(x, y, '#CCFFFF', 'ring');
                if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x, y, color:'#AEEFFF', radius: 36, life: 140 });
            }
            const duration = 100; // frames (~1.6s)
            const radius = 220;
            const start = Date.now();
            // register active reality field for projectile refraction
            const field = { x, y, radius, expiresAt: start + duration * 16 };
            game.activeRealityFields.push(field);
            // Boost global distortion effect (cumulative but clamped)
            if (!game.realityBreakDistort) game.realityBreakDistort = { time:0, intensity:0 };
            game.realityBreakDistort.time = Math.min(game.realityBreakDistort.time + 40, 160);
            game.realityBreakDistort.intensity = Math.min(0.75, game.realityBreakDistort.intensity + 0.12);
            const interval = setInterval(() => {
                // chaotic visual sparks
                if (Math.random() < 0.6) addParticle(x + (Math.random()-0.5)*160, y + (Math.random()-0.5)*160, '#99FFFF', 'spark');

                game.enemies.forEach(enemy => {
                    const dx = enemy.x - x;
                    const dy = enemy.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 220) {
                        // small random jitter to simulate physics break
                        enemy.x += (Math.random() - 0.5) * Math.min(18, (220 - dist) / 8);
                        enemy.y += (Math.random() - 0.5) * Math.min(18, (220 - dist) / 8);

                        // periodic small damage ticks scaled down for safety
                        const dmg = Math.max(1, Math.floor(baseDamage * 0.035));
                        enemy.health -= dmg;
                        addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type:'void' });
                        if (Math.random() < 0.12) addParticle(enemy.x, enemy.y, '#66FFFF', 'impact');

                        // small chance to randomly teleport the enemy a short distance (disorienting)
                        if (Math.random() < 0.035) {
                            const tx = enemy.x + (Math.random()-0.5) * 120;
                            const ty = enemy.y + (Math.random()-0.5) * 120;
                            enemy.x = Math.max(40, Math.min(tx, canvas.width - 40));
                            enemy.y = Math.max(40, Math.min(ty, canvas.height - 40));
                            addParticle(enemy.x, enemy.y, '#FFFFFF', 'spark');
                        }
                    }
                });

                // subtle camera feedback
                if (Math.random() < 0.08) addScreenShake(3);

                if (Date.now() - start > duration * 16) {
                    clearInterval(interval);
                    // final destabilizing burst
                    if (!lowFx && !hideSparks) {
                        for (let i = 0; i < 10; i++) addParticle(x + (Math.random()-0.5)*140, y + (Math.random()-0.5)*140, '#66FFFF', 'explosion');
                    }
                    if (!reduceRings) addParticle(x, y, '#B8F8FF', 'ring');
                    addScreenShake(8);
                    // remove field from active list
                    const idx = game.activeRealityFields.indexOf(field);
                    if (idx >= 0) game.activeRealityFields.splice(idx, 1);
                }
            }, 16);
        }

        // splitProjectile removed (Split Shot ability deprecated)

        // Crystal Shot helper: spawn prismatic shards on shatter
        function createCrystalShatter(x, y, baseDamage, sourceProj) {
            const abil = game.player.abilities || [];
            // Nerf: baseline 2-3 shards on death instead of 4-5
            let shardCount = 2 + Math.floor(Math.random()*2); // 2-3 baseline
            // Synergy: ice increases control -> +1 shard
            if (abil.some(a=>/Ice Shot|Frost|Blizzard/i.test(a))) shardCount++;
            // Synergy: lightning energizes fracture -> +1 shard (chance)
            if (abil.some(a=>/Lightning Shot|Storm Shot/i.test(a)) && Math.random()<0.6) shardCount++;
            // Cap to avoid spam
            shardCount = Math.min(6, shardCount);
            for (let i=0;i<shardCount;i++) {
                const ang = Math.random()*Math.PI*2;
                const sp = 3.4 + Math.random()*2.4;
                const dmgFrac = 0.18 + Math.random()*0.06; // 18-24%
                const vx = Math.cos(ang)*sp;
                const vy = Math.sin(ang)*sp;
                game.spawnProjectile({
                    x: x + Math.cos(ang)*4,
                    y: y + Math.sin(ang)*4,
                    vx, vy,
                    life: 55 + Math.floor(Math.random()*18),
                    size: 5,
                    enemy:false,
                    damage: Math.max(1, Math.floor((baseDamage||calculateDamage()) * dmgFrac)),
                    baseDamage: Math.max(1, Math.floor((baseDamage||calculateDamage()) * dmgFrac)),
                    damageType: 'crystal',
                    piercing: false,
                    crystalShard: true,
                    refract: true,
                    homing: false,
                    // (removed splitting flag)
                });
            }
            // Visual sparkle field
            for (let s=0;s<10;s++) addParticle(x + (Math.random()-0.5)*28, y + (Math.random()-0.5)*28, '#AAEEFF', 'spark');
            addScreenShake(4);
            if (sourceProj) sourceProj._crystalShattered = true;
        }

        function takeDamage(amount) {
            let finalDamage = amount;
            
            // Damage reduction
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageReduction) {
                    finalDamage -= abilityData.effect.damageReduction;
                }
            });
            
            // Block chance
            let blockChance = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.blockChance) {
                    blockChance = Math.max(blockChance, abilityData.effect.blockChance);
                }
            });
            
            if (Math.random() < blockChance) {
                finalDamage = 0;
                addParticle(game.player.x, game.player.y - 15, '#0088FF', 'shield');
            }
            
            finalDamage = Math.max(0, finalDamage);
            
            if (finalDamage > 0) {
                game.player.health -= finalDamage;
                game.player.invulnerable = true;
                game.player.invulnTime = 80;
                addScreenShake(4);
                addParticle(game.player.x, game.player.y, '#FF4444', 'damage');
            }
            
            if (game.player.health <= 0 && !game.gameOver && !game._bigQuackDefeated) {
                // Prevent game over overlapping with victory/ending flow
                triggerGameOver();
            }
            
            updateUI();
        }

        function triggerGameOver() {
            game.gameOver = true;
            // Pause gameplay music
            try { if (game.bgMusic) game.bgMusic.pause(); } catch(e) {}
            // One-shot game over audio (respect SFX preference)
            try {
                if (game._gameOverSound) { try { game._gameOverSound.pause(); } catch(e) {} }
                game._gameOverSound = new Audio('assets/audio/gameover.mp3');
                game._gameOverSound.loop = false;
                if (game.sfxEnabled) {
                    game._gameOverSound.play().catch(()=>{});
                }
            } catch(e) {}
            // Enforce a 1 second delay before restart allowed
            game._gameOverAt = performance.now();
            const restart = (e) => {
                if (e.code !== 'Space' && e.key !== ' ' ) return; // only fire button (Space)
                if (performance.now() - game._gameOverAt < 1000) return; // delay
                window.removeEventListener('keydown', restart);
                // Prevent any residual room-cleared flow from advancing
                game.roomCleared = false;
                game.gameOver = false;
                // Defensive: clear any residual duck dynasty flock visuals before reset (prevents one-frame ghost row)
                if (Array.isArray(game.duckFlocks)) game.duckFlocks.length = 0;
                game.nextDuckFlockFrame = 0;
                // Reset progression to the same street (do NOT advance)  keep current dungeon & room unless they were out of range
                if (game.room < 1 || game.room > 5) game.room = 1;
                if (game.dungeon < 1 || game.dungeon > 10) game.dungeon = 1;
                // Clear any transient flags that could trigger nextRoom()
                game._pendingAdvance = false;
                resetGame();
                if (typeof rebuildPlayerSprite === 'function') rebuildPlayerSprite();
            };
            window.addEventListener('keydown', restart);
        }

        function openChest(chest) {
            chest.opened = true;
            game.chestsOpened++;
            // Opening effect (color keyed to variant)
            if (chest.variant === 'rainbow' || chest.rainbow) {
                const hues = [0,60,120,180,240,300];
                for (let i = 0; i < 10; i++) {
                    const h = hues[i % hues.length];
                    addParticle(chest.x, chest.y, `hsl(${h}, 85%, 65%)`, 'treasure');
                }
            } else {
                const baseColor = chest.variant === 'platinum' ? '#FFFFFF' : chest.variant === 'irradiated' ? '#b4ff5c' : '#FFD700';
                for (let i = 0; i < 8; i++) addParticle(chest.x, chest.y, baseColor, 'treasure');
            }

            // Rainbow chest: let the player choose any ability (preferably new)
            if (chest.variant === 'rainbow' || chest.rainbow) {
                showRainbowAbilityPicker((picked) => {
                    if (!picked || !ABILITIES[picked]) return;
                    if (!game.player.abilities.includes(picked)) game.player.abilities.push(picked);
                    // Play pickup power-up sound on ability acquisition
                    try { playPowerupSfx(); } catch(_) {}
                    showAbilityTooltip(picked);
                    const abilityData = ABILITIES[picked];
                    if (abilityData && abilityData.effect && abilityData.effect.maxHealthBonus) {
                        game.player.maxHealth += abilityData.effect.maxHealthBonus;
                        game.player.health += abilityData.effect.maxHealthBonus;
                    }
                    updateUI();
                    addScreenShake(3);
                });
                return;
            }

            // Default chest behavior (preselected/random ability)
            let newAbility = chest.ability || null;
            if (newAbility && game.player.abilities.includes(newAbility)) {
                const tier = ABILITIES[newAbility] ? (ABILITIES[newAbility].tier || 1) : 1;
                const sameTierPool = Object.keys(ABILITIES).filter(a => !game.player.abilities.includes(a) && (ABILITIES[a].tier || 1) === tier);
                if (sameTierPool.length > 0) newAbility = sameTierPool[Math.floor(Math.random()*sameTierPool.length)]; else newAbility = null;
            }
            if (!newAbility) {
                const pool = Object.keys(ABILITIES).filter(a => !game.player.abilities.includes(a));
                if (pool.length > 0) newAbility = pool[Math.floor(Math.random()*pool.length)];
            }
            if (newAbility) {
                game.player.abilities.push(newAbility);
                // Play pickup power-up sound on ability acquisition
                try { playPowerupSfx(); } catch(_) {}
                showAbilityTooltip(newAbility);
                const abilityData = ABILITIES[newAbility];
                if (abilityData && abilityData.effect && abilityData.effect.maxHealthBonus) {
                    game.player.maxHealth += abilityData.effect.maxHealthBonus;
                    game.player.health += abilityData.effect.maxHealthBonus;
                }
                updateUI();
                addScreenShake(3);
            }
        }

        function checkRoomComplete() {
            // Grace guard: ignore empty enemy list for a few frames right after a restart to prevent false 'Street Cleared'.
            if (game._restartGraceFrames && game._restartGraceFrames > 0) {
                game._restartGraceFrames--;
                return;
            }
            if (!game.roomCleared && game.enemies.length === 0 && (game._roomSpawnedEnemies||0) > 0) {
                game.roomCleared = true;
                game.roomsCleared++;
                game.score += 50 * game.dungeon;
                
                // Room clear effect
                for (let i = 0; i < 10; i++) {
                    addParticle(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        '#00FF00',
                        'victory'
                    );
                }
                
                updateUI();
            }
        }

        function nextRoom() {
            game.room++;
            
            if (game.room > 5) {
                game.dungeon++;
                game.room = 1;
                // New district: reset chest counter
                game.chestsThisCycle = 0;
                
                if (game.dungeon > 10) {
                    completeGame();
                    return;
                }
            }
            
            // Defensive: clear any transient Duck Dynasty visuals when moving rooms
            if (Array.isArray(game.duckFlocks)) game.duckFlocks.length = 0;
            game.nextDuckFlockFrame = 0;
            // Clear active SoA projectiles to avoid carry-over between rooms
            if (typeof game.resetProjectilePool === 'function') game.resetProjectilePool();
            generateRoom();
            updateUI();
        }

        function completeGame() {
            // Victory screen
            // Prevent multiple invocations (some pathways may call completeGame or offerPermanentAbilityChoice twice)
            if (game._victorySequenceShown) return; // hard guard
            game._victorySequenceShown = true;
            const overlay = document.createElement('div');
            overlay.id = 'endingOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(circle, rgba(0,255,0,0.2), rgba(0,0,0,0.9));
                display: flex; flex-direction: column; justify-content: center; align-items: center;
                color: white; font-family: 'Courier New', monospace; z-index: 1000;
                animation: fadeIn 1s ease-in;
            `;
            
            overlay.innerHTML = `
                <h1 style="color: #00FF00; font-size: 48px; text-shadow: 0 0 20px #00FF0088; margin-bottom: 20px;">
                    VICTORY!
                </h1>
                <h2 style="color: #FFFF00; margin-bottom: 30px;">
                    All Districts Cleared!
                </h2>
                <div style="background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center;">
                    <p><strong>Final Score:</strong> ${game.score.toLocaleString()}</p>
                    <p><strong>Total Kills:</strong> ${game.totalKills}</p>
                    <p><strong>Streets Cleared:</strong> ${game.roomsCleared}</p>
                    <p><strong>Chests Opened:</strong> ${game.chestsOpened}</p>
                    <button onclick="this.parentElement.parentElement.remove(); (window.game&&Array.isArray(window.game.duckFlocks))&&(window.game.duckFlocks.length=0); if (window.game) window.game.nextDuckFlockFrame=0; resetGame();" 
                            style="margin-top: 20px; padding: 10px 20px; font-size: 16px; 
                                   background: #333; color: white; border: 2px solid #666; 
                                   border-radius: 5px; cursor: pointer;">
                        Play Again
                    </button>
                </div>
offerPermanentAbilityChoice();
`;
            // Only offer permanent ability if not already done (flagged elsewhere via Space key path)
            if (!game._finalAbilityOffered) {
                offerPermanentAbilityChoice();
                game._finalAbilityOffered = true;
            }
            
            
            // Add fadeIn animation
            const style = document.createElement('style');
            style.textContent = '@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }';
            document.head.appendChild(style);
            
            document.body.appendChild(overlay);
        }

        function resetGame() {
                    // Preserve existing sprite sheet/meta before wiping player object so we don't lose load state
                    const prevSheet = game.player && game.player.spriteSheet;
                    const prevMeta = game.player && game.player.spriteMeta;
                    const prevFrames = game.player && game.player.directionalFrames;
                    const prevScale = game.player && game.player.spriteScale;
                    const prevLoaded = game.player && game.player.spriteLoaded;
                    // Restore standard gameplay music if coming from boss/ending sequences
                    try {
                        if (game.bgMusic) { try { game.bgMusic.pause(); } catch(e) {} }
                        game.bgMusic = new Audio('assets/audio/QuackshotChronicles.mp3');
                        game.bgMusic.loop = true; game._bossMusicPlaying = false;
                        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
                    } catch(e) {}
                    game._bigQuackDefeated = false;
                    game._finalAbilityOffered = false;
                    game._victorySequenceShown = false; // reset victory guard
            game.player = {
                x: 320, y: 240, health: 100, maxHealth: 100,
                abilities: [], permanentAbilities: [],
                facing: 'down',
                lastDirection: { x: 0, y: 1 },
                invulnerable: false, invulnTime: 0,
                speed: 2.5,
                // Terrifying Aura tracking
                killCount: 0,
                auraActive: false,
                // Removed level-based fields: auraActivatedLevel, auraExpireLevel
                auraExpireRoom: 0,
                auraKillCounter: 0, // explicit counter separate from totalKills if used for 25 threshold UI
                // Rendering / visibility control fields reset
                blinkTimer: 0,
                wasHitTimer: 0,
                directionalFrames: prevFrames || null,
                spriteScale: prevScale || null,
                spriteSheet: prevSheet || null,
                spriteMeta: prevMeta || (prevSheet ? { rows: 4, cols: 4, frameWidth: 48, frameHeight: 48, order: ['down','left','right','up'] } : null),
                spriteLoaded: prevLoaded || (prevSheet ? prevSheet.complete : false)
            };

            // If sprite sheet was lost (first ever reset before load code ran), reinitialize it similar to startup
            if (!game.player.spriteSheet) {
                game.player.spriteSheet = new Image();
                game.player.spriteSheet.src = 'assets/player.png';
                game.player.spriteMeta = { rows: 4, cols: 4, frameWidth: 48, frameHeight: 48, order: ['down','left','right','up'] };
                game.player.spriteSheet.onload = () => {
                    game.player.spriteLoaded = true;
                    rebuildPlayerSprite();
                };
            }

            // --- Permanent Ability Integration ---
            loadPermanentAbilities();
            grantPermanentAbilities();

            game.dungeon = 1;
            game.room = 1;
            game.score = 0;
            game.shotCounter = 0;
            game.chestsThisCycle = 0;
            game.totalKills = 0;
            game.roomsCleared = 0;
            game.chestsOpened = 0;
            game.paused = false;

            // Clear any lingering Terrifying Aura UI text / prompts (defensive)
            const auraNotice = document.getElementById('auraNotice');
            if (auraNotice) auraNotice.remove();
            if (game.player) {
                game.player.auraActive = false;
                // auraExpireLevel removed
                game.player.auraExpireRoom = 0;
                game.player.auraKillCounter = 0;
            }

            // Hide pause menu if open (fix: check if element exists)
            var pauseOverlay = document.getElementById('pauseOverlay');
            if (pauseOverlay) {
                pauseOverlay.style.display = 'none';
            }

            // Hard purge of any lingering entities from previous run (defensive in case a reference was kept elsewhere)
            game.enemies = [];
            game.projectiles = [];
            game.particles = [];
            game.chests = [];
            game.pickups = [];
            game.traps = [];
            game.pits = [];
            game.nukes = [];
            game.poisonClouds = [];
            game.shockwaves = [];
            game.vortexFields = [];
            game.lightningArcs = [];
            game.acidPools = [];
            game.duckFlocks = []; // clear any lingering Duck Dynasty flock sprites stuck after victory
            game.nextDuckFlockFrame = 0; // reset scheduling so first flock re-times correctly
            // Restart grace: suppress premature room clear until enemies have visibly spawned
            game._restartGraceFrames = 30; // ~0.5s at 60fps
            game._roomSpawnedEnemies = 0;
            // Rebuild & force visibility (will also set spriteLoaded true)
            if (typeof rebuildPlayerSprite === 'function') {
                rebuildPlayerSprite();
            } else if (typeof window !== 'undefined' && typeof window.rebuildPlayerSprite === 'function') {
                window.rebuildPlayerSprite();
            } else {
                console.warn('[Reset] rebuildPlayerSprite unavailable at call time');
            }
            // If for any reason directionalFrames not established, mark for early retry
            if (!game.player.directionalFrames) {
                game.player._pendingSpriteRetry = 6; // attempt for first 6 frames
            }
            game.player.spriteLoaded = true; // hard assert loaded since sheet persisted
            game.player.forceVisibleFrames = 90; // extend a bit longer (1.5s) to visually confirm

            // Ensure no lingering pause or overlays hide player
            game.gameOver = false;
            game.paused = false;
            game._bigQuackDefeated = false; // already set above, reinforce

            // Ensure all projectiles and metadata are cleared before starting a new run
            if (typeof game.resetProjectilePool === 'function') game.resetProjectilePool();
            generateRoom();
            updateUI();
        }

        // (Removed floating Reset Progress button; now in Pause -> Options)

        function addParticle(x, y, color, type) {
            // Cosmetic gating: suppress low-priority particle categories if potato mode is on.
            const cosmeticTypes = { spark:1, ambient:1, lightning:1, heal:1, shield:1, damage:1, treasure:1, swirl:1, dust:1 };
            if ((game.potatoMode || game.disableCosmeticParticles) && cosmeticTypes[type]) return;
            // Probabilistic suppression in low FX mode (only for cosmetic types)
            if (game.perf && game.perf.lowFx && cosmeticTypes[type]) {
                if (Math.random() < 0.55) return;
            }
            if (!game.particles) game.particles = [];
            const cap = (game.potatoMode ? 600 : ((game.perf && game.perf.lowFx) ? 1200 : 2500));
            if (game.particles.length >= cap) return;
            const particle = {
                x: x + (Math.random() - 0.5) * 10,
                y: y + (Math.random() - 0.5) * 10,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: (game.perf && game.perf.lowFx ? 22 : 30) + Math.random() * (game.perf && game.perf.lowFx ? 14 : 20),
                maxLife: (game.perf && game.perf.lowFx) ? 38 : 50,
                color: color,
                type: type,
                alpha: 1
            };
            
            // Type-specific properties
            switch (type) {
                case 'explosion':
                    particle.vx *= 2;
                    particle.vy *= 2;
                    particle.life = 20;
                    break;
                case 'fire':
                    particle.vy -= 1;
                    break;
                case 'heal':
                    particle.vy -= 2;
                    particle.vx = 0;
                    break;
                case 'treasure':
                    particle.vy -= 1.5;
                    particle.life = 60;
                    break;
            }
            
            game.particles.push(particle);
        }

        // Feather poof helper (re-added / ensured). Creates an initial bright burst and spawns drifting feather particles.
        function spawnFeatherPoof(enemy) {
            if (!enemy || !game || !game.particles) return;
            const size = enemy.size || 20;
            const scaleFactor = size / 20;
            const burstCount = Math.min(40, Math.floor(18 * scaleFactor));
            // Bright radial flash (quick fade) using featherSingle for a few for variety
            for (let i=0;i<burstCount;i++) {
                const ang = Math.random()*Math.PI*2;
                const dist = Math.random()* (6 + size*0.15);
                const px = enemy.x + Math.cos(ang)*dist;
                const py = enemy.y + Math.sin(ang)*dist;
                if (i < burstCount * 0.25) {
                    addParticle(px, py, '#ffffff', 'featherSingle');
                } else {
                    addParticle(px, py, '#ffffff', 'spark');
                }
            }
            // Drifting long-lived feathers
            const featherCount = Math.min(80, Math.floor(22 * scaleFactor));
            for (let f=0; f<featherCount; f++) {
                const ang = Math.random()*Math.PI*2;
                const sp = (Math.random()*1.8 + 0.6) * (0.8 + scaleFactor*0.2);
                const vx = Math.cos(ang)*sp;
                const vy = Math.sin(ang)*sp - (Math.random()*1.1 + 0.3);
                const life = 60 + Math.random()*70;
                const feather = {
                    x: enemy.x + (Math.random()-0.5)*size*0.4,
                    y: enemy.y + (Math.random()-0.5)*size*0.4,
                    vx, vy,
                    gravity: 0.055 + Math.random()*0.045,
                    life,
                    maxLife: life,
                    color: '#ffffff',
                    type: 'feather',
                    alpha: 1,
                    spin: Math.random()*Math.PI*2,
                    spinSpeed: (Math.random()*0.22 - 0.11),
                    scale: 0.45 + Math.random()*0.85 * (0.85 + scaleFactor*0.25),
                    drift: (Math.random()*0.5 - 0.25)
                };
                game.particles.push(feather);
            }
        }

        function addAmbientParticles() {
            // Skip ambient emissions entirely if cosmetic FX disabled
            if (game.disableCosmeticParticles) return;
            // Add some ambient city particles
            if (Math.random() < 0.3) {
                addParticle(
                    Math.random() * canvas.width,
                    canvas.height + 10,
                    '#666666',
                    'ambient'
                );
            }
        }

        // --- Minimal Attack SFX (WebAudio) ---
        let _atkAudioCtx = null;
        let _atkCompressor = null;
        let _atkLast = 0;
        function _ensureAtkAudio() {
            if (_atkAudioCtx) return;
            try {
                _atkAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                _atkCompressor = _atkAudioCtx.createDynamicsCompressor();
                _atkCompressor.threshold.setValueAtTime(-28, _atkAudioCtx.currentTime);
                _atkCompressor.knee.setValueAtTime(18, _atkAudioCtx.currentTime);
                _atkCompressor.ratio.setValueAtTime(8, _atkAudioCtx.currentTime);
                _atkCompressor.attack.setValueAtTime(0.003, _atkAudioCtx.currentTime);
                _atkCompressor.release.setValueAtTime(0.08, _atkAudioCtx.currentTime);
                _atkCompressor.connect(_atkAudioCtx.destination);
            } catch(e) { /* audio blocked */ }
        }
        function playAttackSfx() {
            if (!game.sfxEnabled) return;
            const nowMs = performance.now();
            const MIN_INTERVAL = 45; // allow slightly faster cadence for automatic fire, still limited
            if (nowMs - _atkLast < MIN_INTERVAL) return;
            _atkLast = nowMs;
            _ensureAtkAudio(); if (!_atkAudioCtx) return;
            const t = _atkAudioCtx.currentTime;
            // Lower-pitched redesign:
            // Layer 1: Core body (sawtooth with short decay, mid-low frequency sweep)
            const bodyOsc = _atkAudioCtx.createOscillator();
            const bodyGain = _atkAudioCtx.createGain();
            const bodyStart = 620 + Math.random()*80; // previously ~1800, now much lower
            const bodyEnd = bodyStart * 0.55;
            bodyOsc.type = 'sawtooth';
            bodyOsc.frequency.setValueAtTime(bodyStart, t);
            bodyOsc.frequency.exponentialRampToValueAtTime(bodyEnd, t + 0.09);
            bodyGain.gain.setValueAtTime(0.0001, t);
            bodyGain.gain.linearRampToValueAtTime(0.34, t + 0.004);
            bodyGain.gain.exponentialRampToValueAtTime(0.0005, t + 0.16);

            // Layer 2: Wider noise burst (lower bandpass center)
            const noiseBuffer = _atkAudioCtx.createBuffer(1, 4410, 44100);
            const data = noiseBuffer.getChannelData(0);
            for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
            const noiseSrc = _atkAudioCtx.createBufferSource(); noiseSrc.buffer = noiseBuffer;
            const bp = _atkAudioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.setValueAtTime(900, t); bp.Q.value = 2.2;
            const noiseGain = _atkAudioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.42, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.0005, t + 0.18);

            // Layer 3: Deep thump (even lower fundamental)
            const thumpOsc = _atkAudioCtx.createOscillator(); thumpOsc.type='sine';
            const thumpGain = _atkAudioCtx.createGain();
            const thumpFreq = 90 + Math.random()*15; // was ~140
            thumpOsc.frequency.setValueAtTime(thumpFreq, t);
            thumpOsc.frequency.exponentialRampToValueAtTime(thumpFreq * 0.65, t + 0.12);
            thumpGain.gain.setValueAtTime(0.0001, t);
            thumpGain.gain.linearRampToValueAtTime(0.28, t + 0.006);
            thumpGain.gain.exponentialRampToValueAtTime(0.0004, t + 0.20);

            // Sub emphasis (short sine burst one octave below thump)
            const subOsc = _atkAudioCtx.createOscillator(); subOsc.type='sine';
            const subGain = _atkAudioCtx.createGain();
            subOsc.frequency.setValueAtTime(thumpFreq/2, t);
            subGain.gain.setValueAtTime(0.0001, t);
            subGain.gain.linearRampToValueAtTime(0.18, t + 0.008);
            subGain.gain.exponentialRampToValueAtTime(0.0003, t + 0.17);

            // Master filters shifted lower
            const hp = _atkAudioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(140, t);
            const lp = _atkAudioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.setValueAtTime(3800, t);

            bodyOsc.connect(bodyGain);
            noiseSrc.connect(bp); bp.connect(noiseGain);
            thumpOsc.connect(thumpGain);
            subOsc.connect(subGain);
            const merger = _atkAudioCtx.createGain();
            bodyGain.connect(merger); noiseGain.connect(merger); thumpGain.connect(merger); subGain.connect(merger);
            merger.connect(hp); hp.connect(lp); lp.connect(_atkCompressor || _atkAudioCtx.destination);

            bodyOsc.start(t); bodyOsc.stop(t + 0.18);
            thumpOsc.start(t); thumpOsc.stop(t + 0.22);
            subOsc.start(t); subOsc.stop(t + 0.20);
            noiseSrc.start(t); noiseSrc.stop(t + 0.20);
        }

        function addScreenShake(intensity) {
            game.screenShake = Math.max(game.screenShake, intensity);
            game.screenShakeIntensity = intensity;
        }

        // Transient effects: small, short-lived visuals like ring flashes or hit blips
        function addTransientEffect(eff) {
            // Hard skip non-essential transient FX in Potato Mode
            if (game && game.potatoMode) return;
            if (!game.transientEffects) game.transientEffects = [];
            const now = performance.now();
            const life = eff.life || 180; // ms
            game.transientEffects.push({
                type: eff.type || 'ringFlash',
                x: eff.x, y: eff.y,
                color: eff.color || '#FFFFFF',
                radius: eff.radius || 24,
                created: now,
                life,
                seed: Math.random()*Math.PI*2
            });
        }

        function render() {
            // Handle screen shake
            let shakeX = 0, shakeY = 0;
            if (game.screenShake > 0) {
                shakeX = (Math.random() - 0.5) * game.screenShakeIntensity;
                shakeY = (Math.random() - 0.5) * game.screenShakeIntensity;
            }
            // Auto-enable reality break overlay briefly when flagged
            if (game.settings && game.settings._rbAutoOverlay) {
                game.settings.realityBreakOverlay = true;
                game.settings._rbAutoOverlay--;
            } else if (game.settings && !game.realityBreakDistort) {
                // If no effect pending, release forced overlay
                game.settings._rbAutoOverlay = 0;
            }
            
            ctx.save();
            ctx.translate(shakeX, shakeY);
            
            // Background: prefer image from assets/streets; during fade-in, draw fallback underneath
            const W = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
            const H = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || canvas.height;
            let drewImage = false;
            let needFallback = true;
            let b = window._streetBackgrounds;
            if (b && b.ready && b.img) {
                const img = b.img;
                const iw = (img.naturalWidth != null ? img.naturalWidth : img.width) || 0;
                const ih = (img.naturalHeight != null ? img.naturalHeight : img.height) || 0;
                if (iw > 0 && ih > 0) {
                // Determine scale and destination rect based on fit mode
                let fitMode = 'fitWidth';
                if (b.fit === 'contain' || b.fit === 'cover' || b.fit === 'fitWidth') fitMode = b.fit;
                let scale;
                if (fitMode === 'contain') {
                    scale = Math.min(W / iw, H / ih);
                } else if (fitMode === 'cover') {
                    scale = Math.max(W / iw, H / ih);
                } else { // fitWidth
                    scale = W / iw; // always match canvas width
                }
                scale *= (typeof b.zoom === 'number' ? Math.max(0.1, b.zoom) : 1.0);
                const dw = iw * scale, dh = ih * scale;
                // Center horizontally by construction; vertically center-crop if taller than canvas
                const dx = (W - dw) * 0.5;
                let dy = (H - dh) * 0.5;
                if (typeof b.alpha !== 'number') b.alpha = 1.0; // default to immediate if not set
                // If still fading, we keep fallback visible underneath
                needFallback = b.alpha < 1.0;
                ctx.save();
                const prevA = ctx.globalAlpha;
                ctx.globalAlpha = prevA * Math.max(0, Math.min(1, b.alpha));
                ctx.imageSmoothingEnabled = true;
                // When in fitWidth, ensure left/right are flush; if height exceeds, cropping will naturally happen by canvas boundary.
                ctx.drawImage(img, dx, dy, dw, dh);
                ctx.globalAlpha = prevA;
                ctx.restore();
                drewImage = true;
                if (b.alpha < 1.0) b.alpha = Math.min(1.0, b.alpha + 0.06);
                }
            }
            if (!drewImage || needFallback) {
                // Fallback/base: theme gradient fill
                const theme = game.currentTheme;
                const gcols = (theme && theme.gradient) || ['#1a1a2e','#16213e'];
                const gradient = ctx.createLinearGradient(0, 0, 0, H);
                if (gcols.length === 1) { gradient.addColorStop(0, gcols[0]); gradient.addColorStop(1, gcols[0]); }
                else if (gcols.length === 2) { gradient.addColorStop(0, gcols[0]); gradient.addColorStop(1, gcols[1]); }
                else { for (let i=0;i<gcols.length;i++) gradient.addColorStop(i/(gcols.length-1), gcols[i]); }
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, W, H);
                // Center line only when no image or during fade
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 3;
                ctx.setLineDash([15, 15]);
                ctx.beginPath();
                ctx.moveTo(0, H / 2);
                ctx.lineTo(W, H / 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw walls (restored original manual drawing)
            game.walls.forEach(wall => {
                ctx.save();
                switch (wall.type) {
                    case 'building':
                        ctx.fillStyle = '#404040';
                        ctx.fillRect(wall.x, wall.y, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(wall.x + 2, wall.y + 2, TILE_SIZE - 4, 4);
                        ctx.fillStyle = '#ffff88';
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 2; j++) {
                                if (Math.random() < 0.7) {
                                    ctx.fillRect(wall.x + 4 + i * 8, wall.y + 8 + j * 8, 4, 4);
                                }
                            }
                        }
                        break;
                    case 'car': {
                        const imgH = window._carObstacleImages && window._carObstacleImages.h;
                        const imgV = window._carObstacleImages && window._carObstacleImages.v;
                        // Use multi-tile footprint if provided (added during generation)
                        const w = wall.width || TILE_SIZE;
                        const h = wall.height || TILE_SIZE;
                        const x = wall.x, y = wall.y;
                        const vertical = wall.orientation === 'vertical';
                        const img = vertical ? imgV : imgH;
                        // Placeholder if image not yet ready / broken
                        if (!img || img._broken || !img.complete || !img.naturalWidth) {
                            ctx.fillStyle = '#444';
                            ctx.fillRect(x, y, w, h);
                            ctx.fillStyle = '#777';
                            ctx.fillRect(x + w*0.08, y + h*0.08, w*0.84, h*0.84);
                            if (wall.flashTimer > 0) {
                                ctx.fillStyle = 'rgba(255,255,255,' + (0.5 * (wall.flashTimer/10)).toFixed(2) + ')';
                                ctx.fillRect(x, y, w, h);
                            }
                            break;
                        }
                        ctx.imageSmoothingEnabled = true;
                        // Assign persistent random tint factor if not already
                        if (wall.tint == null) {
                            // Light variance around neutral (1.0). Keep subtle to avoid artifacting stretched sprite.
                            wall.tint = 0.85 + Math.random()*0.30; // 0.85 - 1.15
                        }
                        // Draw shadow first (simple soft ellipse under car footprint)
                        const shadowInset = Math.min(w,h) * 0.05;
                        const shadowCX = x + w/2;
                        const shadowCY = y + h*0.92;
                        const shadowRX = w/2 - shadowInset;
                        const shadowRY = Math.min(h*0.18, h/2 - shadowInset);
                        ctx.save();
                        ctx.fillStyle = 'rgba(0,0,0,0.28)';
                        ctx.beginPath();
                        ctx.ellipse(shadowCX, shadowCY, shadowRX, shadowRY, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                        // Draw car image stretched to footprint
                        ctx.drawImage(img, x, y, w, h);
                        // Apply subtle tint overlay (multiply-like using globalCompositeOperation if not lowFX)
                        if (!game.lowFX && wall.tint !== 1) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'multiply';
                            const t = wall.tint;
                            // Convert scalar to neutral gray variant; a slight greenish bias adds urban sodium feel
                            const c = Math.floor(200 * t);
                            ctx.fillStyle = `rgba(${c},${Math.floor(c*0.95)},${Math.floor(c*0.85)},0.28)`;
                            ctx.fillRect(x, y, w, h);
                            ctx.restore();
                        }
                        // Flash overlay (e.g., future explosions, collisions)
                        if (wall.flashTimer > 0) {
                            ctx.fillStyle = 'rgba(255,255,255,' + (0.55 * (wall.flashTimer/10)).toFixed(2) + ')';
                            ctx.fillRect(x, y, w, h);
                        }
                        break;
                    }
                    case 'dumpster': {
                        const tileW = wall.width || TILE_SIZE;
                        const tileH = wall.height || TILE_SIZE;
                        const spr = window._dumpsterSprite;
                        const img = spr && spr.image;
                        const frames = spr && spr.frames;
                        if (!img || img._broken || !img.complete || !img.naturalWidth || !frames || frames.length === 0) {
                            // Fallback: simple colored box if sprite not ready
                            ctx.fillStyle = '#2f522f';
                            ctx.fillRect(wall.x, wall.y, tileW, tileH);
                            break;
                        }
                        // Compute destination rect via shared helper so collisions match visuals
                        const rect = window.getDumpsterSpriteRect(wall);
                        // Determine current frame to sample from
                        const fps = spr.fps || 6;
                        const step = Math.max(1, Math.round(60 / fps));
                        const frameIdx = Math.floor(((game.frame||0) / step)) % frames.length;
                        const f = frames[frameIdx];
                        ctx.drawImage(img, f.x, f.y, f.w, f.h, rect.x, rect.y, rect.w, rect.h);
                        break;
                    }
                    case 'streetlight': {
                        const x = wall.x, y = wall.y, w = TILE_SIZE, h = TILE_SIZE;
                        const poleX = x + w*0.45;
                        // Pole
                        ctx.fillStyle = '#7a7a7a';
                        ctx.fillRect(poleX, y - h*0.30, w*0.10, h*1.30);
                        // Base
                        ctx.fillStyle = '#575757';
                        ctx.fillRect(poleX - w*0.10, y + h*0.95, w*0.30, h*0.08);
                        // Arm
                        ctx.fillStyle = '#6c6c6c';
                        ctx.fillRect(poleX + w*0.05, y - h*0.18, w*0.40, h*0.06);
                        // Lamp head
                        const lampX = poleX + w*0.42;
                        const lampY = y - h*0.18 + h*0.03;
                        ctx.fillStyle = '#444';
                        ctx.fillRect(lampX, lampY, w*0.24, h*0.14);
                        // Bulb + glow cone
                        ctx.fillStyle = '#ffec66';
                        ctx.fillRect(lampX + w*0.04, lampY + h*0.02, w*0.16, h*0.10);
                        // Light cone (semi-transparent)
                        const coneGradient = ctx.createLinearGradient(lampX, lampY + h*0.14, lampX, lampY + h*0.80);
                        coneGradient.addColorStop(0, 'rgba(255,236,102,0.45)');
                        coneGradient.addColorStop(1, 'rgba(255,236,102,0)');
                        ctx.fillStyle = coneGradient;
                        ctx.beginPath();
                        ctx.moveTo(lampX - w*0.05, lampY + h*0.14);
                        ctx.lineTo(lampX + w*0.29, lampY + h*0.14);
                        ctx.lineTo(lampX + w*0.18, lampY + h*0.90);
                        ctx.lineTo(lampX + w*0.06, lampY + h*0.90);
                        ctx.closePath();
                        ctx.fill();
                        // Subtle radial glow around bulb
                        const rg = ctx.createRadialGradient(lampX + w*0.12, lampY + h*0.07, 2, lampX + w*0.12, lampY + h*0.07, 18);
                        rg.addColorStop(0, 'rgba(255,236,102,0.6)');
                        rg.addColorStop(1, 'rgba(255,236,102,0)');
                        ctx.fillStyle = rg;
                        ctx.beginPath();
                        ctx.arc(lampX + w*0.12, lampY + h*0.07, 18, 0, Math.PI*2);
                        ctx.fill();
                        // Outline pole
                        ctx.strokeStyle = '#444';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(poleX, y - h*0.30, w*0.10, h*1.30);
                        break;
                    }
                    case 'barrier': {
                        const x = wall.x, y = wall.y;
                        const w = wall.width || TILE_SIZE;
                        const h = wall.height || TILE_SIZE;
                        const img = window._barrierImage;
                        // When available, draw sprite scaled to the obstacle footprint
                        if (img && !img._broken && img.complete && img.naturalWidth) {
                            // Optional: subtle drop shadow
                            ctx.save();
                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = '#000';
                            ctx.fillRect(x + 2, y + h - Math.max(4, Math.round(h*0.08)), w - 4, Math.max(3, Math.round(h*0.06)));
                            ctx.restore();
                            ctx.drawImage(img, x, y, w, h);
                        } else {
                            // Fallback: original procedural barrier if image missing
                            const W = TILE_SIZE, H = TILE_SIZE;
                            const bx = wall.x, by = wall.y;
                            // Support posts
                            ctx.fillStyle = '#5e5e5e';
                            ctx.fillRect(bx + W*0.08, by + H*0.10, W*0.12, H*0.70);
                            ctx.fillRect(bx + W*0.80, by + H*0.10, W*0.12, H*0.70);
                            // Feet
                            ctx.fillStyle = '#444';
                            ctx.fillRect(bx + W*0.02, by + H*0.78, W*0.24, H*0.10);
                            ctx.fillRect(bx + W*0.74, by + H*0.78, W*0.24, H*0.10);
                            // Panel background
                            const panelY = by + H*0.18;
                            const panelH = H*0.42;
                            ctx.fillStyle = '#d8d8d8';
                            ctx.fillRect(bx + W*0.12, panelY, W*0.76, panelH);
                            // Diagonal stripes
                            const stripeW = W*0.10;
                            for (let sx = bx + W*0.10; sx < bx + W*0.90 + stripeW; sx += stripeW*1.3) {
                                ctx.fillStyle = '#ff3b30';
                                ctx.beginPath();
                                ctx.moveTo(sx, panelY);
                                ctx.lineTo(sx + stripeW, panelY);
                                ctx.lineTo(sx + stripeW - panelH, panelY + panelH);
                                ctx.lineTo(sx - panelH, panelY + panelH);
                                ctx.closePath();
                                ctx.fill();
                            }
                            // Reflectors (top row small circles)
                            ctx.fillStyle = '#fffb9a';
                            for (let i=0;i<3;i++) {
                                ctx.beginPath();
                                ctx.arc(bx + W*0.24 + i*W*0.20, panelY + panelH*0.18, W*0.04, 0, Math.PI*2);
                                ctx.fill();
                            }
                            // Shadow at base
                            ctx.fillStyle = 'rgba(0,0,0,0.25)';
                            ctx.fillRect(bx + W*0.08, by + H*0.88, W*0.84, H*0.06);
                            // Outline panel
                            ctx.strokeStyle = '#6a6a6a';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(bx + W*0.12 + 0.5, panelY + 0.5, W*0.76 - 1, panelH - 1);
                        }
                        break;
                    }
                }
                ctx.restore();
            });

            // Render projectiles via SoA optimized renderer
            if (game.renderProjectilesSoA) game.renderProjectilesSoA(ctx);

            // Tanks Alot: lingering fire fields (beneath enemies/projectiles overlays for readability)
            if (Array.isArray(game.truckFires) && game.truckFires.length) {
                const nowTA = Date.now();
                game.truckFires.forEach(f => {
                    const age = nowTA - f.created;
                    const life = Math.max(0, 1 - age / f.duration);
                    const r = f.radius * (0.95 + Math.sin(nowTA/300 + f.x*0.02)*0.05);
                    // Soft orange-red glow under sprite
                    const g = ctx.createRadialGradient(f.x, f.y, r*0.2, f.x, f.y, r);
                    g.addColorStop(0, `rgba(255,220,120,${(0.30*life).toFixed(3)})`);
                    g.addColorStop(0.6, `rgba(255,120,40,${(0.22*life).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(255,60,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(f.x, f.y, r, 0, Math.PI*2); ctx.fill();
                    // Draw looping truck2.png sprite frames above the glow
                    const spr = window._truckSprite || {};
                    const fireImg = spr.fire;
                    const fireFrames = spr.frames && spr.frames.fire;
                    if (fireImg && fireImg.complete && !fireImg._broken && fireFrames && fireFrames.length) {
                        const fps = 6; // loop speed
                        const step = Math.max(1, Math.round(60 / fps));
                        const frameIdx = Math.floor(((game.frame||0) / step)) % fireFrames.length;
                        const src = fireFrames[frameIdx];
                        const scale = 1.0 * (r * 0.012 + 0.9); // scale loosely tied to radius; tweakable
                        const drawW = src.w * (64 / src.h) * scale * 2.2; // derive width from target height ratio
                        const drawH = 64 * scale * 2.2;
                        const yOffset = -12; // nudge upward for better alignment with truck
                        ctx.drawImage(fireImg, src.x, src.y, src.w, src.h, f.x - drawW/2, f.y - drawH/2 + yOffset, drawW, drawH);
                    }
                });
            }

            // Acid pools rendering (beneath enemies/projectiles)
            if (Array.isArray(game.acidPools) && game.acidPools.length) {
                const nowA = Date.now();
                game.acidPools.forEach(p => {
                    const age = nowA - p.created; const life = 1 - Math.min(1, age / p.duration);
                    const r = p.r * (0.98 + Math.sin(nowA/320 + p.x*0.01 + p.y*0.01)*0.02);
                    // Base toxic green pool
                    const g = ctx.createRadialGradient(p.x, p.y, r*0.15, p.x, p.y, r);
                    g.addColorStop(0, `rgba(140,255,100,${(0.28*life).toFixed(3)})`);
                    g.addColorStop(0.55, `rgba(90,220,80,${(0.20*life).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(40,100,30,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
                    // Bubbles
                    if (!(game.perf && game.perf.lowFx)) {
                        ctx.save();
                        ctx.globalAlpha = 0.5 * life;
                        for (let b=0;b<3;b++) {
                            const ang = (b/3)*Math.PI*2 + (nowA/800);
                            const rr = r*0.5 + Math.sin(nowA/500 + b)*r*0.08;
                            const bx = p.x + Math.cos(ang)*rr*0.4;
                            const by = p.y + Math.sin(ang)*rr*0.4 - Math.sin(nowA/300 + b)*3;
                            ctx.fillStyle = 'rgba(200,255,200,0.35)';
                            ctx.beginPath(); ctx.arc(bx, by, Math.max(2, r*0.05), 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                    }
                });
            }

            // Poison cloud trail rendering (Silent But Deadly) - beneath enemies/projectiles for readability
            if (Array.isArray(game.poisonClouds) && game.poisonClouds.length) {
                game.poisonClouds.forEach(c => {
                    const p = c.life / c.maxLife; // 1 -> 0
                    const r = c.radius * (1 + (1-p)*0.15);
                    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r);
                    g.addColorStop(0, `rgba(120,255,150,${0.18 + 0.12*p})`);
                    g.addColorStop(0.5, `rgba(90,220,120,${0.12 + 0.10*p})`);
                    g.addColorStop(1, 'rgba(40,80,50,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, r, 0, Math.PI*2);
                    ctx.fill();
                    // Subtle swirling outline pulses
                    if (p > 0.25) {
                        ctx.save();
                        ctx.strokeStyle = `rgba(160,255,180,${0.08*p})`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6,12]);
                        ctx.lineDashOffset = (Date.now()/90 + c.x*0.2) % 18;
                        ctx.beginPath();
                        ctx.arc(c.x, c.y, r*0.7 + Math.sin(Date.now()/300 + c.y*0.05)*3, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }

            // Fragment Wake sparks (above ground effects but beneath main projectiles)
            if (Array.isArray(game.fragmentSparks) && game.fragmentSparks.length) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const now = Date.now();
                game.fragmentSparks.forEach(s => {
                    const lifeRatio = s.ttl / s.maxTtl; // 1 -> 0
                    const pulse = 0.55 + Math.sin(s.pulse)*0.45;
                    const radius = s.r * (0.7 + 0.6*pulse) * (0.6 + 0.4*lifeRatio);
                    const grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, radius);
                    grd.addColorStop(0, `rgba(255,210,140,${0.55 * lifeRatio})`);
                    grd.addColorStop(0.4, `rgba(255,140,60,${0.30 * lifeRatio})`);
                    grd.addColorStop(1, 'rgba(255,80,0,0)');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, radius, 0, Math.PI*2);
                    ctx.fill();
                    // Core spark flick (slightly brighter)
                    ctx.fillStyle = `rgba(255,245,210,${0.42 * lifeRatio})`;
                    ctx.beginPath();
                    ctx.arc(s.x + Math.sin(now/50 + s.x*0.1)*1.2, s.y + Math.cos(now/60 + s.y*0.1)*1.2, radius*0.25, 0, Math.PI*2);
                    ctx.fill();
                });
                ctx.restore();
            }

            // Vortex field rendering (beneath enemies for clarity, above ground effects)
            if (Array.isArray(game.vortexFields) && game.vortexFields.length) {
                const t = Date.now();
                game.vortexFields.forEach(f => {
                    const age = t - f.createdAt;
                    const lifeRatio = 1 - Math.min(1, age / f.duration);
                    const baseR = f.radius * (0.95 + Math.sin(t/260 + f.x*0.01 + f.spin)*0.05);
                    // Outer swirling gradient
                    const grad = ctx.createRadialGradient(f.x, f.y, f.innerRadius*0.3, f.x, f.y, baseR);
                    grad.addColorStop(0, `rgba(255,120,255,${0.30 * lifeRatio})`);
                    grad.addColorStop(0.55, `rgba(140,20,150,${0.22 * lifeRatio})`);
                    grad.addColorStop(1, 'rgba(60,0,70,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, baseR, 0, Math.PI*2);
                    ctx.fill();
                    // Rotating arc spokes
                    ctx.save();
                    ctx.translate(f.x, f.y);
                    ctx.rotate(f.spin);
                    const spokes = 6;
                    for (let s=0;s<spokes;s++) {
                        const a = (s/spokes)*Math.PI*2;
                        const len = baseR * 0.82;
                        const w = 5 + Math.sin(t/180 + s)*2;
                        ctx.strokeStyle = `rgba(255,180,255,${0.18 * lifeRatio})`;
                        ctx.lineWidth = w;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(a)*f.innerRadius*0.6, Math.sin(a)*f.innerRadius*0.6);
                        ctx.lineTo(Math.cos(a)*len, Math.sin(a)*len);
                        ctx.stroke();
                    }
                    ctx.restore();
                    // Inward wisps (skip if hideSpokes)
                    if (!(game.fxFlags && game.fxFlags.hideSpokes)) {
                        const wCount = 5;
                        for (let w=0; w<wCount; w++) {
                            const ang = (t/300 + w) % (Math.PI*2);
                            const r1 = baseR * (0.6 + (w/wCount)*0.35);
                            const r2 = r1 - 14 - (w*2);
                            ctx.strokeStyle = `rgba(255,180,255,${0.08 * lifeRatio})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(f.x + Math.cos(ang)*r1, f.y + Math.sin(ang)*r1);
                            ctx.lineTo(f.x + Math.cos(ang)*r2, f.y + Math.sin(ang)*r2);
                            ctx.stroke();
                        }
                    }
                    // Inner core pulse
                    const coreR = f.innerRadius * (1 + Math.sin(t/140 + f.y*0.02)*0.25);
                    const cgrad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, coreR);
                    cgrad.addColorStop(0, `rgba(255,200,255,${0.55 * lifeRatio})`);
                    cgrad.addColorStop(1, 'rgba(255,200,255,0)');
                    ctx.fillStyle = cgrad;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, coreR, 0, Math.PI*2);
                    ctx.fill();
                    // Brief flash ring when field ticks
                    if (f._flash && f._flash > 0) {
                        const alpha = Math.min(1, f._flash/6) * 0.9 * lifeRatio;
                        ctx.save();
                        ctx.strokeStyle = `rgba(255,200,255,${alpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(f.x, f.y, baseR*0.8, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                        f._flash--;
                    }
                });
            }

            // Black Hole rendering (beneath enemies, after vortex/echo for clarity)
            if (Array.isArray(game.blackHoles) && game.blackHoles.length) {
                const nowBH = performance.now();
                game.blackHoles.forEach(h => {
                    const age = nowBH - h.createdAt;
                    const k = Math.max(0, 1 - age / h.lifeMs);
                    const r = h.radius * (0.9 + 0.1*k);
                    // Outer lensing glow
                    const lg = ctx.createRadialGradient(h.x, h.y, r*0.65, h.x, h.y, r*1.05);
                    lg.addColorStop(0, `rgba(80,10,90,${0.22*k})`);
                    lg.addColorStop(0.9, 'rgba(40,0,50,0.05)');
                    lg.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = lg;
                    ctx.beginPath(); ctx.arc(h.x, h.y, r*1.05, 0, Math.PI*2); ctx.fill();
                    // Horizon rim
                    ctx.save();
                    ctx.strokeStyle = `rgba(180,80,220,${0.35*k})`;
                    ctx.lineWidth = 2.5;
                    ctx.beginPath(); ctx.arc(h.x, h.y, r*0.82, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();
                });
            }

            // Echo Bloom resonance field rendering (beneath enemies, above vortex for contrast)
            if (Array.isArray(game.echoBloomFields) && game.echoBloomFields.length) {
                const nowT = Date.now();
                game.echoBloomFields.forEach(f => {
                    const age = nowT - f.createdAt;
                    const life = 1 - Math.min(1, age / f.duration);
                    const pulse = 0.5 + Math.sin(nowT/170 + f.x*0.05 + f.y*0.03)*0.5;
                    const radius = f.radius * (0.92 + pulse*0.08);
                    const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, radius);
                    // Stacked-hit resonance highlight: temporarily brighten core when multiple ticks stack
                    const stacked = f._stackVisUntil && performance.now() < f._stackVisUntil;
                    const coreBoost = stacked ? 1.35 : 1.0;
                    const midBoost = stacked ? 1.18 : 1.0;
                    g.addColorStop(0, `rgba(255,230,255,${(0.40 * life * coreBoost).toFixed(3)})`);
                    g.addColorStop(0.45, `rgba(230,140,255,${(0.18 * life * midBoost).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(160,60,200,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(f.x, f.y, radius, 0, Math.PI*2); ctx.fill();
                    // Subtle rotating petal spokes
                    if (!(game.fxFlags && game.fxFlags.hideSpokes)) {
                        ctx.save();
                        ctx.translate(f.x, f.y);
                        ctx.rotate(age/600);
                        const petals = 8;
                        for (let p=0;p<petals;p++) {
                            const a = (p/petals)*Math.PI*2;
                            const ir = radius*0.15; const or = radius*0.75;
                            // Brighten spokes briefly on stacked-hit window
                            const spokeAlpha = (0.10 * life) * (stacked ? 1.6 : 1.0);
                            ctx.strokeStyle = `rgba(255,200,255,${spokeAlpha.toFixed(3)})`;
                            ctx.lineWidth = stacked ? 3.8 : 3;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(a)*ir, Math.sin(a)*ir);
                            ctx.lineTo(Math.cos(a)*or, Math.sin(a)*or);
                            ctx.stroke();
                        }
                        ctx.restore();
                    }
                    // Optional: faint outer halo when stacked highlight is active
                    if (stacked) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = `rgba(255,230,255,${(0.18 * life).toFixed(3)})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(f.x, f.y, radius*0.92, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }

            // Bloom Rings rendering (after Echo Bloom resonance so rings sit above fields but below lightning)
            if (Array.isArray(game.bloomRings) && game.bloomRings.length) {
                const nowBR = Date.now();
                game.bloomRings.forEach(rg => {
                    const age = nowBR - rg.createdAt;
                    const lifeRatio = 1 - Math.min(1, age / rg.maxLife);
                    const growthPhase = Math.min(1, rg.radius / rg.maxRadius);
                    const alpha = 0.65 * lifeRatio;
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                    // Telegraph intensity (first ~180ms)  boosts inner glow & edge pulse
                    const teleActive = performance.now() < (rg.telegraphUntil || 0);
                    let telePulse = teleActive ? (0.55 + Math.sin(performance.now()/70 + rg.seed)*0.45) : 0;
                    if (lowFx) telePulse *= 0.6;
                    // Outer glow donut (warmer & brighter)
                    const grad = ctx.createRadialGradient(rg.x, rg.y, Math.max(0, rg.radius - rg.width*0.9), rg.x, rg.y, rg.radius + rg.width*0.85);
                    grad.addColorStop(0, `rgba(255,240,230,${teleActive?0.25+telePulse*0.25:0.10})`);
                    grad.addColorStop(0.55, `rgba(255,210,180,${alpha * (0.22 + telePulse*0.2)})`);
                    grad.addColorStop(0.80, `rgba(255,140,90,${alpha * 0.65})`);
                    grad.addColorStop(1, 'rgba(255,100,40,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.radius + rg.width*0.85, 0, Math.PI*2);
                    ctx.fill();
                    // Central flash (short lived after first damage)
                    if (rg.firstDamage && age < 220) {
                        const flashA = Math.max(0, 1 - (age/220)) * (lowFx ? 0.8 : 1);
                        const cg = ctx.createRadialGradient(rg.x, rg.y, 0, rg.x, rg.y, Math.min(rg.radius*0.55, 180));
                        cg.addColorStop(0, `rgba(255,250,240,${0.55*flashA})`);
                        cg.addColorStop(0.6, `rgba(255,200,150,${0.25*flashA})`);
                        cg.addColorStop(1, 'rgba(255,150,90,0)');
                        ctx.fillStyle = cg;
                        ctx.beginPath();
                        ctx.arc(rg.x, rg.y, Math.min(rg.radius*0.55, 180), 0, Math.PI*2);
                        ctx.fill();
                    }
                    // Core thin inner ring (charging telegraph fade out early)
                    if (!rg.detonated && !reduceRings) {
                        const teleA = 0.35 + Math.sin(nowBR/140 + rg.x*0.02)*0.25;
                        ctx.strokeStyle = `rgba(255,240,240,${teleA})`;
                        ctx.lineWidth = (lowFx ? 1.5 : 2) + Math.sin(nowBR/90)*1.2;
                        ctx.beginPath();
                        ctx.arc(rg.x, rg.y, 12 + Math.sin(nowBR/120)*3, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    // Ring edge (main visible band) brighter & pulsing
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const pulse = (0.55 + Math.sin(performance.now()/140 + rg.seed)*0.45) * (lowFx ? 0.75 : 1);
                    ctx.strokeStyle = `rgba(255,210,170,${alpha * (0.90 + pulse*0.10)})`;
                    ctx.lineWidth = rg.width * (0.60 + pulse*0.18 * (reduceRings?0.6:1));
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.radius, 0, Math.PI*2);
                    ctx.stroke();
                    // Rotating spokes for motion cue
                    if (!hideSpokes && !lowFx) {
                        ctx.translate(rg.x, rg.y);
                        ctx.rotate(age/600 + rg.seed);
                        const spokes = 4;
                        for (let s=0;s<spokes;s++) {
                            const ang = (s/spokes)*Math.PI*2;
                            ctx.strokeStyle = `rgba(255,200,180,${alpha*0.30})`;
                            ctx.lineWidth = 3.3;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(ang)*(rg.radius-rg.width*0.5), Math.sin(ang)*(rg.radius-rg.width*0.5));
                            ctx.lineTo(Math.cos(ang)*(rg.radius+rg.width*0.5), Math.sin(ang)*(rg.radius+rg.width*0.5));
                            ctx.stroke();
                        }
                    }
                    ctx.restore();
                });
            }

            // Transient effects (ring flashes, blips)
            if (Array.isArray(game.transientEffects) && game.transientEffects.length) {
                const nowTE = performance.now();
                for (let i = game.transientEffects.length - 1; i >= 0; i--) {
                    const t = game.transientEffects[i];
                    const age = nowTE - t.created;
                    const k = Math.min(1, age / t.life);
                    const a = Math.max(0, 1 - k);
                    if (t.type === 'ringFlash') {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = t.color.replace(')', `,${(0.65*a).toFixed(3)})`).replace('#', 'rgba(') || `rgba(255,255,255,${0.65*a})`;
                        // Fallback for hex colors: draw glow + core ring
                        ctx.beginPath();
                        ctx.lineWidth = 6 * (1 - k);
                        ctx.arc(t.x, t.y, t.radius * (0.8 + 0.6*k), 0, Math.PI*2);
                        ctx.stroke();
                        ctx.strokeStyle = `rgba(255,255,255,${0.35*a})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, t.radius * (0.9 + 0.4*k), 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    } else {
                        // blip: small expanding dot
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.fillStyle = `rgba(255,255,255,${0.6*a})`;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, 2 + 6*k, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }
                    if (age >= t.life) game.transientEffects.splice(i,1);
                }
            }

            // Lightning arcs rendering (after vortex so arcs sit on top of fields but beneath enemies for clarity)
            if (Array.isArray(game.lightningArcs) && game.lightningArcs.length) {
                for (let i = game.lightningArcs.length - 1; i >= 0; i--) {
                    const a = game.lightningArcs[i];
                    a.life--;
                    if (!a.points || a.points.length < 2) { game.lightningArcs.splice(i,1); continue; }
                    const fade = Math.max(0, a.life / a.maxLife);
                    // Glow pass
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = `rgba(255,255,180,${0.12 * fade})`;
                    ctx.lineWidth = 10;
                    ctx.beginPath();
                    ctx.moveTo(a.points[0].x, a.points[0].y);
                    for (let p=1;p<a.points.length;p++) ctx.lineTo(a.points[p].x, a.points[p].y);
                    ctx.stroke();
                    ctx.restore();
                    // Core stroke (slightly jagged each frame)
                    ctx.save();
                    ctx.strokeStyle = `rgba(255,255,120,${0.85 * fade})`;
                    ctx.lineWidth = 2 + 1*Math.random();
                    ctx.beginPath();
                    ctx.moveTo(a.points[0].x, a.points[0].y);
                    for (let p=1;p<a.points.length;p++) {
                        const pt = a.points[p];
                        // slight per-frame jitter for liveliness
                        const jx = (Math.random()-0.5) * 2;
                        const jy = (Math.random()-0.5) * 2;
                        ctx.lineTo(pt.x + jx, pt.y + jy);
                    }
                    ctx.stroke();
                    ctx.restore();
                    if (a.life <= 0) game.lightningArcs.splice(i,1);
                }
            }

            // Potato Mode HUD badge (lightweight)  render at top-right to avoid FPS panel overlap
            if (game.potatoMode) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                const label = 'Potato Mode';
                ctx.font = 'bold 12px Courier New, monospace';
                const textW = Math.ceil(ctx.measureText(label).width);
                const padX = 10; // horizontal padding inside badge
                const padY = 4;  // vertical padding inside badge
                const h = 22;    // fixed height for consistent look
                const w = Math.max(118, textW + padX * 2); // keep minimum width, expand if needed
                const margin = 10;
                // Place at top-right of the logical canvas
                const x = (typeof logicalW === 'number' ? logicalW : ctx.canvas.width) - w - margin;
                const y = margin;
                // Backing rounded rect
                ctx.fillStyle = 'rgba(0,0,0,0.45)';
                ctx.beginPath();
                const r = 6;
                ctx.moveTo(x + r, y);
                ctx.arcTo(x + w, y, x + w, y + h, r);
                ctx.arcTo(x + w, y + h, x, y + h, r);
                ctx.arcTo(x, y + h, x, y, r);
                ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
                ctx.fill();
                // Text
                ctx.fillStyle = '#d2ff7c';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, x + padX, y + h/2);
                ctx.restore();
            }

            // Draw punji pits
            if (game.pits && game.pits.length) {
                game.pits.forEach(pit => {
                    const age = Date.now() - pit.created;
                    const fade = Math.max(0.15, 1 - age / pit.duration);
                    ctx.save();
                    ctx.translate(pit.x, pit.y);
                    const r = pit.radius;
                    // Ground base (dirt ring)
                    const baseGrad = ctx.createRadialGradient(0,0,r*0.2,0,0,r);
                    baseGrad.addColorStop(0,'rgba(90,60,30,'+(0.35*fade)+')');
                    baseGrad.addColorStop(1,'rgba(50,30,15,'+(0.55*fade)+')');
                    ctx.fillStyle = baseGrad;
                    ctx.beginPath();
                    ctx.arc(0,0,r,0,Math.PI*2);
                    ctx.fill();
                    // Inner trench shadow
                    ctx.fillStyle = 'rgba(0,0,0,'+(0.25*fade)+')';
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.55,0,Math.PI*2);
                    ctx.fill();
                    // Poison aura subtle (kept but softer to not clash with spikes)
                    const aura = ctx.createRadialGradient(0,0,r*0.15,0,0,r*0.85);
                    aura.addColorStop(0,'rgba(120,255,140,'+(0.18*fade)+')');
                    aura.addColorStop(1,'rgba(40,120,50,0)');
                    ctx.fillStyle = aura;
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.9,0,Math.PI*2);
                    ctx.fill();
                    // Spikes: vertical wooden stakes with darker tips
                    const spikesArr = pit.spikes || [];
                    spikesArr.forEach(sp => {
                        const sx = sp.x * r; // local space
                        const sy = sp.y * r;
                        const h = sp.h; // height in pixels
                        const baseW = 4 + (h*0.08); // width scales lightly with height
                        // Slight lean offset
                        const topOffsetX = sp.lean * h;
                        // Shaft
                        ctx.strokeStyle = '#6B4A2B';
                        ctx.lineWidth = baseW * 0.55;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(sx + topOffsetX, sy - h);
                        ctx.stroke();
                        // Wood fill (behind stroke for thickness): draw a narrow polygon
                        ctx.fillStyle = '#8B5E34';
                        ctx.beginPath();
                        ctx.moveTo(sx - baseW*0.35, sy);
                        ctx.lineTo(sx + baseW*0.35, sy);
                        ctx.lineTo(sx + topOffsetX + baseW*0.15, sy - h*0.94);
                        ctx.lineTo(sx + topOffsetX - baseW*0.15, sy - h*0.94);
                        ctx.closePath();
                        ctx.fill();
                        // Tip (darker, sharpened)
                        ctx.fillStyle = '#3A2412';
                        ctx.beginPath();
                        ctx.moveTo(sx + topOffsetX, sy - h);
                        ctx.lineTo(sx + topOffsetX + baseW*0.25, sy - h*0.88);
                        ctx.lineTo(sx + topOffsetX - baseW*0.25, sy - h*0.88);
                        ctx.closePath();
                        ctx.fill();
                        // Highlight edge (simple light stroke on one side)
                        ctx.strokeStyle = 'rgba(255,230,180,'+(0.35*fade)+')';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(sx + topOffsetX - baseW*0.1, sy - h*0.94);
                        ctx.lineTo(sx - baseW*0.25, sy);
                        ctx.stroke();
                    });
                    // Ambient poison motes (light, low density)
                    if (Math.random() < 0.15 * fade) {
                        addParticle(pit.x + (Math.random()-0.5)*r*1.2, pit.y + (Math.random()-0.5)*r*1.2, '#66FF66','poison');
                    }
                    ctx.restore();
                });
            }

            // Draw beartraps
            if (game.traps && game.traps.length) {
                game.traps.forEach(trap => {
                    const armed = !trap.triggered;
                    ctx.save();
                    ctx.translate(trap.x, trap.y);
                    // base circle
                    ctx.beginPath();
                    ctx.arc(0,0, armed ? 14 : 16, 0, Math.PI*2);
                    ctx.fillStyle = armed ? '#444' : '#772222';
                    ctx.fill();
                    // teeth
                    const teeth = 10;
                    ctx.strokeStyle = armed ? '#bbbbbb' : '#ffdddd';
                    ctx.lineWidth = 2;
                    for (let t=0;t<teeth;t++) {
                        const ang = (t/teeth)*Math.PI*2;
                        const r1 = armed ? 10 : 8;
                        const r2 = armed ? 14 : 16;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
                        ctx.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
                        ctx.stroke();
                    }
                    if (!armed) {
                        ctx.fillStyle = '#ff4444aa';
                        ctx.beginPath();
                        ctx.arc(0,0,8,0,Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                });
            }
            
            // Draw chests
            const now = performance.now();
            game.chests.forEach(chest => {
                if (!chest.opened) {
                    const cx = chest.x;
                    const cy = chest.y;
                    const r = 18;
                    const variant = chest.variant || 'gold';
                    // Proximity jiggle will modify lid vertical offset later; precompute distance to player
                    const dx = game.player.x - cx;
                    const dy = game.player.y - cy;
                    const dist = Math.hypot(dx, dy);
                    // Update jiggle phase
                    const near = dist < 130;
                    chest.jigglePhase = (chest.jigglePhase || 0) + (near ? 0.12 : 0.02);
                    const lidLift = (near ? Math.sin(chest.jigglePhase)*2.4 : Math.sin(chest.jigglePhase)*0.8);

                    // Variant colors
                    const variantSpecs = {
                        gold: { top:'#ffe680', mid:'#f7c846', bot:'#cfa02d', rib:'rgba(255,255,255,0.35)', glow:'rgba(255,223,90,', handle:'#cfa02d' },
                        platinum: { top:'#f2f2f2', mid:'#d9d9d9', bot:'#b0b0b0', rib:'rgba(255,255,255,0.55)', glow:'rgba(200,200,255,', handle:'#e0e0e0' },
                        rusty: { top:'#e8b270', mid:'#b96a33', bot:'#7a3f1c', rib:'rgba(255,220,180,0.25)', glow:'rgba(255,170,60,', handle:'#a85622' },
                        irradiated: { top:'#d2ff7a', mid:'#9bdf31', bot:'#5e8f18', rib:'rgba(255,255,255,0.30)', glow:'rgba(170,255,90,', handle:'#9bdf31' },
                        rainbow: { top:'#ffd1dc', mid:'#c5e1ff', bot:'#d5ffd5', rib:'rgba(255,255,255,0.45)', glow:'rgba(255,255,255,', handle:'#ffffff' }
                    };
                    const spec = variantSpecs[variant] || variantSpecs.gold;
                    let grad = ctx.createLinearGradient(cx, cy - r, cx, cy + r);
                // Frost Aura (Blizzard) soft field around player
                if (game._frostAura && game.player) {
                    const a = game._frostAura;
                    const r = a.r;
                    const cg = ctx.createRadialGradient(game.player.x, game.player.y, 0, game.player.x, game.player.y, r*1.15);
                    const pulse = 0.5 + Math.sin(performance.now()/300)*0.5;
                    cg.addColorStop(0, `rgba(200,245,255,${0.10 + 0.12*pulse})`);
                    cg.addColorStop(0.55, `rgba(180,235,255,${0.08 + 0.10*pulse})`);
                    cg.addColorStop(1, 'rgba(160,220,255,0)');
                    ctx.fillStyle = cg;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, r*1.15, 0, Math.PI*2);
                    ctx.fill();
                    // Subtle ice ring
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = `rgba(180,230,255,${0.25 + 0.25*pulse})`;
                    ctx.lineWidth = 2 + 1.5*pulse;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, r, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                }

                    if (variant === 'rainbow') {
                        const t = (now * 0.001) % 1;
                        // 6-color rainbow gradient that subtly shifts over time
                        const colors = [0, 60, 120, 180, 240, 300].map(h => `hsl(${(h + t*360)|0}, 85%, 65%)`);
                        grad.addColorStop(0.00, colors[0]);
                        grad.addColorStop(0.20, colors[1]);
                        grad.addColorStop(0.40, colors[2]);
                        grad.addColorStop(0.60, colors[3]);
                        grad.addColorStop(0.80, colors[4]);
                        grad.addColorStop(1.00, colors[5]);
                    } else {
                        grad.addColorStop(0, spec.top);
                        grad.addColorStop(0.4, spec.mid);
                        grad.addColorStop(1, spec.bot);
                    }
                    ctx.fillStyle = grad;
                    // Top ellipse (body top) hidden mostly under lid
                    ctx.beginPath();
                    ctx.ellipse(cx, cy - r*0.25, r*0.90, r*0.35, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Side wall
                    ctx.fillRect(cx - r*0.90, cy - r*0.25, r*1.80, r*1.10);
                    // Bottom ellipse
                    ctx.fillStyle = spec.bot;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + r*0.85, r*0.88, r*0.30, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Vertical ribs
                    ctx.strokeStyle = spec.rib;
                    ctx.lineWidth = 2;
                    for (let i=0;i<6;i++) {
                        const t = -r*0.70 + i*(r*1.40/5);
                        ctx.beginPath();
                        ctx.moveTo(cx + t*0.6, cy - r*0.20);
                        ctx.lineTo(cx + t*0.75, cy + r*0.78);
                        ctx.stroke();
                    }
                    // Lid (raised + jiggle)
                    const lidY = cy - r*0.40 - lidLift*0.4;
                    ctx.fillStyle = spec.top;
                    ctx.beginPath();
                    ctx.ellipse(cx, lidY, r*0.95, r*0.38, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = spec.bot;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(cx, lidY, r*0.95, r*0.38, 0, 0, Math.PI*2);
                    ctx.stroke();
                    // Handle arc
                    ctx.strokeStyle = spec.handle;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(cx, lidY - r*0.08, r*0.25, Math.PI*0.90, Math.PI*0.10, false);
                    ctx.stroke();
                    // Side handles
                    ctx.strokeStyle = spec.handle;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(cx - r*1.00, cy + r*0.10);
                    ctx.lineTo(cx - r*1.15, cy + r*0.00);
                    ctx.moveTo(cx + r*1.00, cy + r*0.10);
                    ctx.lineTo(cx + r*1.15, cy + r*0.00);
                    ctx.stroke();
                    // Orbiting sparkles (not for rusty; more for premium variants)
                    if (variant !== 'rusty') {
                        const sparkleCount = 6;
                        for (let i=0;i<sparkleCount;i++) {
                            const ang = (now*0.002 + i*(Math.PI*2/sparkleCount));
                            const sr = r*1.15;
                            const sx = cx + Math.cos(ang)*sr;
                            const sy = cy + Math.sin(ang)*sr*0.65; // ellipse orbit
                            const pulse = 0.5 + 0.5*Math.sin(now*0.005 + i);
                            ctx.globalAlpha = 0.6 * pulse;
                            if (variant === 'rainbow') {
                                const hue = ((i*60) + (now*0.08)) % 360;
                                ctx.fillStyle = `hsl(${hue}, 90%, 70%)`;
                            } else {
                                ctx.fillStyle = variant === 'platinum' ? '#ffffff' : (variant === 'irradiated' ? '#d6ff88' : '#ffec8a');
                            }
                            ctx.beginPath();
                            ctx.moveTo(sx, sy - 3);
                            ctx.lineTo(sx + 3, sy);
                            ctx.lineTo(sx, sy + 3);
                            ctx.lineTo(sx - 3, sy);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    }
                    // Special glow / flicker
                    let alphaBase = 0.45;
                    if (variant === 'platinum') alphaBase = 0.55;
                    if (variant === 'rusty') alphaBase = 0.25;
                    if (variant === 'irradiated') alphaBase = 0.60 + Math.sin(now*0.008)*0.15;
                    if (variant === 'rainbow') alphaBase = 0.62 + Math.sin(now*0.012)*0.10;
                    const chestGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, r*1.6);
                    chestGlow.addColorStop(0, spec.glow + alphaBase + ')');
                    chestGlow.addColorStop(1, spec.glow + '0)');
                    ctx.fillStyle = chestGlow;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r*1.6, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            // Draw pickups (bread slices)
            if (game.pickups && game.pickups.length) {
                game.pickups.forEach(p => {
                    if (p.type === 'bread') {
                        const t = (performance.now() - p.spawnTime) / 1000;
                        const bob = Math.sin(t * 4) * 4;
                        const x = p.x;
                        const y = p.y + bob;
                        const w = 20, h = 20;
                        // Shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.25)';
                        ctx.beginPath(); ctx.ellipse(x, y + h*0.55, w*0.55, h*0.28, 0, 0, Math.PI*2); ctx.fill();
                        // Crust
                        ctx.fillStyle = '#b57533';
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(x - w/2, y - h/2, w, h, 4) : ctx.rect(x - w/2, y - h/2, w, h);
                        ctx.fill();
                        // Crumb interior slightly inset
                        ctx.fillStyle = '#f4e2b6';
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(x - w/2 + 2, y - h/2 + 2, w - 4, h - 6, 3) : ctx.rect(x - w/2 + 2, y - h/2 + 2, w - 4, h - 6);
                        ctx.fill();
                        // Random seed specks (deterministic-ish per spawn)
                        const seedCount = 4;
                        for (let i=0;i<seedCount;i++) {
                            const sx = x - w/2 + 4 + (i * (w-8)/(seedCount-1));
                            const sy = y - 2 + ((i*31)%5) - 2;
                            ctx.fillStyle = '#d9c190';
                            ctx.fillRect(sx, sy, 2, 2);
                        }
                        // Light highlight
                        ctx.strokeStyle = '#ffffff66';
                        ctx.beginPath();
                        ctx.moveTo(x - w/2 + 4, y - h/2 + 4);
                        ctx.lineTo(x + w/2 - 4, y - h/2 + 4);
                        ctx.stroke();
                    }
                });
            }
            
            // Draw particles
            game.particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                
                switch (particle.type) {
                    case 'explosion':
                    case 'fire':
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'feather': {
                        // Draw a slim rotated feather (white) with subtle tip fade
                        const s = (particle.scale || 1) * 4.0; // base length
                        const w = s * 0.35;
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.spin || 0);
                        const grad = ctx.createLinearGradient(0, -s/2, 0, s/2);
                        grad.addColorStop(0, 'rgba(255,255,255,' + (particle.alpha*0.2).toFixed(3) + ')');
                        grad.addColorStop(0.3, 'rgba(255,255,255,' + (particle.alpha*0.85).toFixed(3) + ')');
                        grad.addColorStop(1, 'rgba(255,255,255,' + (particle.alpha*0.05).toFixed(3) + ')');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.ellipse(0,0, w, s, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Center spine
                        ctx.strokeStyle = 'rgba(255,255,255,' + (particle.alpha*0.55).toFixed(3) + ')';
                        ctx.lineWidth = Math.max(0.6, w*0.22);
                        ctx.beginPath();
                        ctx.moveTo(0, -s*0.48);
                        ctx.lineTo(0, s*0.48);
                        ctx.stroke();
                        // Small barb hints
                        ctx.lineWidth = Math.max(0.4, w*0.12);
                        ctx.beginPath();
                        ctx.moveTo(0, -s*0.20); ctx.lineTo(w*0.8, -s*0.05);
                        ctx.moveTo(0, s*0.05); ctx.lineTo(-w*0.8, s*0.20);
                        ctx.stroke();
                        break;
                    }
                    case 'spark':
                    case 'lightning':
                        ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                        break;
                    case 'heal':
                        ctx.font = '12px Arial';
                        ctx.fillText('+', particle.x, particle.y);
                        break;
                    case 'treasure':
                        ctx.font = '8px Arial';
                        ctx.fillText('', particle.x, particle.y);
                        break;
                    case 'shield':
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'damage':
                        ctx.font = '10px Arial';
                        ctx.fillText('!', particle.x, particle.y);
                        break;
                    case 'victory':
                        ctx.font = '14px Arial';
                        ctx.fillText('', particle.x, particle.y);
                        break;
                    default:
                        ctx.fillRect(particle.x - 1, particle.y - 1, 2, 2);
                }
                ctx.restore();
            });
            
            // Rizz telegraph: cooldown sweep ring + active halo
            if (game.player && game.player.abilities && game.player.abilities.includes('Rizz')) {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const px = game.player.x, py = game.player.y;
                const last = game._lastRizz || 0;
                const nowR = performance.now();
                const cd = Math.min(1, Math.max(0, (nowR - last) / RIZZ_INTERVAL_MS)); // 0->1 toward ready
                const r = RIZZ_RING_RADIUS * (1 + (lowFx?0.02:0.08)*Math.sin(nowR/320));
                // Draw cooldown arc (fills clockwise as cooldown progresses)
                if (!reduceRings) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.lineWidth = lowFx ? 2 : 3.5;
                    ctx.strokeStyle = `rgba(200,150,255,${lowFx?0.35:0.55})`;
                    ctx.beginPath();
                    ctx.arc(px, py, r, -Math.PI/2, -Math.PI/2 + cd * Math.PI*2);
                    ctx.stroke();
                    // Faint outer glow ring to hint radius
                    ctx.strokeStyle = `rgba(160,120,230,${lowFx?0.10:0.20})`;
                    ctx.lineWidth = lowFx ? 1.5 : 2;
                    ctx.beginPath();
                    ctx.arc(px, py, r*1.03, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                }
                // Brief halo when pull just started (first 180ms)
                if (nowR - last < 220) {
                    const k = 1 - ((nowR - last) / 220);
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const g = ctx.createRadialGradient(px, py, 0, px, py, r*1.15);
                    g.addColorStop(0, `rgba(225,200,255,${(0.35*k).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(225,200,255,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(px, py, r*1.15, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Duck Dynasty flock rendering (beneath projectile layer, above ground telegraphs)
            if (Array.isArray(game.duckFlocks) && game.duckFlocks.length) {
                game.duckFlocks.forEach(d => {
                    if (d.x == null || d.y == null) return;
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    // Orientation based on instantaneous motion (approx using last two positions if cached)
                    if (!d._lx) { d._lx = d.x; d._ly = d.y; }
                    const mvx = d.x - d._lx; const mvy = d.y - d._ly;
                    d._lx = d.x; d._ly = d.y;
                    const ang = Math.atan2(mvy, mvx);
                    ctx.rotate(ang);
                    const bodyR = d.size * 0.5;
                    // Body ellipse
                    const g = ctx.createLinearGradient(-bodyR,0,bodyR,0);
                    g.addColorStop(0,(d.color||'#FFE8AA')+'AA');
                    g.addColorStop(1,(d.color||'#FFE8AA'));
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.ellipse(0,0, bodyR, bodyR*0.55, 0,0,Math.PI*2); ctx.fill();
                    // Head
                    ctx.fillStyle = d.color||'#FFE8AA';
                    ctx.beginPath(); ctx.ellipse(bodyR*0.95, -bodyR*0.15, bodyR*0.38, bodyR*0.34, 0,0,Math.PI*2); ctx.fill();
                    // Beak
                    ctx.fillStyle = '#FFB243';
                    ctx.beginPath(); ctx.moveTo(bodyR*1.25,-bodyR*0.12); ctx.lineTo(bodyR*1.55,0); ctx.lineTo(bodyR*1.25, bodyR*0.12); ctx.closePath(); ctx.fill();
                    // Wings out (static spread + slight undulation)
                    const flap = Math.sin((d.wingPhase||0)*0.8) * 0.25;
                    const wingSpan = bodyR * 1.9;
                    ctx.fillStyle = (d.color||'#FFE8AA')+'BB';
                    // Left wing
                    ctx.save(); ctx.rotate(-0.25 + flap);
                    ctx.beginPath(); ctx.ellipse(-bodyR*0.2,0, wingSpan*0.55, wingSpan*0.22, 0,0,Math.PI*2); ctx.fill(); ctx.restore();
                    // Right wing
                    ctx.save(); ctx.rotate(0.25 - flap);
                    ctx.beginPath(); ctx.ellipse(-bodyR*0.2,0, wingSpan*0.55, wingSpan*0.22, 0,0,Math.PI*2); ctx.fill(); ctx.restore();
                    // Tail accent
                    ctx.fillStyle = (d.color||'#FFE8AA')+'AA';
                    ctx.beginPath(); ctx.moveTo(-bodyR*0.9, -bodyR*0.15); ctx.lineTo(-bodyR*0.9, bodyR*0.15); ctx.lineTo(-bodyR*0.55, 0); ctx.closePath(); ctx.fill();
                    ctx.restore();
                });
            }
            
            // Nuke pre-impact telegraphs (draw beneath enemies & player for clarity)
            if (Array.isArray(game.nukes) && game.nukes.length) {
                const now = Date.now();
                game.nukes.forEach(n => {
                    if (!n || n.exploded) return; // only telegraph pending strikes
                    const totalWarn = n.impactAt - n.spawnAt;
                    const remaining = Math.max(0, n.impactAt - now);
                    const t = remaining / totalWarn; // 1 -> 0
                    const pulse = 1 + Math.sin(now/120 + n.x*0.05) * 0.05;
                    const radius = n.radius * pulse;
                    // Soft fill glow
                    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, radius);
                    g.addColorStop(0, 'rgba(255,180,40,0.10)');
                    g.addColorStop(0.65, 'rgba(255,120,0,0.08)');
                    g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, radius, 0, Math.PI*2);
                    ctx.fill();
                    // Outer warning ring (animated dash)
                    ctx.save();
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10,8]);
                    const dashOffset = (now/40) % 18;
                    ctx.lineDashOffset = -dashOffset;
                    ctx.strokeStyle = `rgba(${Math.round(255*(1-t))}, ${Math.round(200*t)}, 40, 0.85)`; // shifts to red
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.radius, 0, Math.PI*2);
                    ctx.stroke();
                    // Countdown shrinking inner ring
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, Math.max(6, n.radius * t), 0, Math.PI*2);
                    ctx.stroke();
                    // Crosshair lines
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = 'rgba(255,220,120,0.5)';
                    ctx.beginPath();
                    ctx.moveTo(n.x - n.radius, n.y);
                    ctx.lineTo(n.x + n.radius, n.y);
                    ctx.moveTo(n.x, n.y - n.radius);
                    ctx.lineTo(n.x, n.y + n.radius);
                    ctx.stroke();
                    ctx.restore();
                    // Time text
                    const secs = (remaining/1000).toFixed(2);
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.fillText(secs, n.x, n.y + 6);
                });
            }

            // Meteor impact telegraph markers (appear where meteor will land)
            if (Array.isArray(game.meteorMarkers) && game.meteorMarkers.length) {
                for (let i = game.meteorMarkers.length - 1; i >= 0; i--) {
                    const m = game.meteorMarkers[i];
                    // Convert legacy ms life to frame-based if needed
                    if (!m._initFrameLife) {
                        // If marker provided 'life' as ms ( > 300 ), translate to frames (~60fps)
                        if (m.life && m.life > 300) {
                            m.maxLife = Math.floor((m.life / 1000) * 60);
                        } else {
                            m.maxLife = m.life || 220;
                        }
                        m.life = m.maxLife;
                        m._initFrameLife = true;
                    }
                    // If created timestamp exists and exceeds original requested lifespan (1600ms default), flag dead
                    if (m.created && Date.now() - m.created > 1800) {
                        m.dead = true;
                    }
                    m.life = (typeof m.life === 'number') ? m.life - 1 : (m.maxLife||220) - 1;
                    m.pulse = (m.pulse || 0) + 1;
                    if (m.dead || m.life <= 0) { game.meteorMarkers.splice(i,1); continue; }
                    const t = 1 - (m.life / m.maxLife); // 0 -> 1
                    const baseAlpha = 0.55 * (1 - t);
                    const pulseA = 0.35 + 0.25*Math.sin(m.pulse/6);
                    const alpha = Math.max(0, Math.min(1, baseAlpha + pulseA*(1-t)));
                    const r = 26 + 24 * t; // ring expands slightly
                    const lineW = 3 + 2*Math.sin(m.pulse/5);
                    ctx.save();
                    ctx.translate(m.x, m.y);
                    // shadow / scorch oval (beneath ring)
                    ctx.globalAlpha = 0.35 * (1 - t);
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(0,0,r*1.15,r*0.55,0,0,Math.PI*2);
                    ctx.fill();
                    // main warning ring
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = (m.enemyTarget) ? '#ff8240' : '#ffcf40';
                    ctx.lineWidth = lineW;
                    ctx.beginPath();
                    ctx.ellipse(0,0,r,r*0.65,0,0,Math.PI*2);
                    ctx.stroke();
                    // inner hot core
                    const innerR = r*0.35 + 4*Math.sin(m.pulse/7);
                    ctx.globalAlpha = 0.35 + 0.25*Math.sin(m.pulse/4);
                    ctx.fillStyle = '#ffef9c';
                    ctx.beginPath();
                    ctx.ellipse(0,0,innerR,innerR*0.65,0,0,Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Photon strike beams (rendered after telegraphs, before enemies/projectiles overlays)
            if (Array.isArray(game.photonStrikes) && game.photonStrikes.length) {
                for (let i = game.photonStrikes.length - 1; i >= 0; i--) {
                    const s = game.photonStrikes[i];
                    s.life--;
                    if (s.life <= 0) { game.photonStrikes.splice(i,1); continue; }
                    const reduceBeams = !!(game.fxFlags && game.fxFlags.reduceBeams);
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const baseLife = s.life;
                    const maxLife = 24;
                    const alpha = baseLife / maxLife;
                    const grad = ctx.createLinearGradient(s.x1, s.y1, s.x2, s.y2);
                    const edgeA = alpha * (reduceBeams ? 0.25 : 0.35);
                    const midA = alpha * (reduceBeams ? 0.7 : 0.9);
                    grad.addColorStop(0, 'rgba(120,200,255,'+edgeA+')');
                    grad.addColorStop(0.5, 'rgba(255,255,255,'+midA+')');
                    grad.addColorStop(1, 'rgba(120,200,255,'+edgeA+')');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const width = (reduceBeams ? 3 : 4) + (reduceBeams ? 2 : 3) * alpha;
                    ctx.lineWidth = width;
                    ctx.strokeStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(s.x1, s.y1);
                    ctx.lineTo(s.x2, s.y2);
                    ctx.stroke();
                    // Impact flash orb (skip heavy second core on lowFx)
                    ctx.globalAlpha = alpha * (lowFx ? 0.6 : 0.85);
                    ctx.fillStyle = 'rgba(255,255,255,'+(alpha*(lowFx?0.45:0.6))+')';
                    ctx.beginPath();
                    ctx.arc(s.x2, s.y2, (s.impactSize||30) * (0.6 + 0.4*alpha) * (lowFx?0.85:1), 0, Math.PI*2);
                    ctx.fill();
                    if (!lowFx) {
                        // Subtle core
                        ctx.fillStyle = 'rgba(200,255,255,'+(alpha*0.8)+')';
                        ctx.beginPath();
                        ctx.arc(s.x2, s.y2, Math.max(6, (s.impactSize||30)*0.3*alpha), 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
                if (game.photonStrikes.length > 40) game.photonStrikes.length = 40; // defensive cap
            }

            // Traveling Shockwaves (Shockwave ability) - draw BEFORE enemies/projectiles so they appear on ground
            if (Array.isArray(game.shockwaves) && game.shockwaves.length) {
                game.shockwaves.forEach(w => {
                    const lifePct = w.life / w.maxLife; // 1 -> 0
                    const ax = Math.cos(w.angle), ay = Math.sin(w.angle);
                    const startDist = Math.max(0, w.distance - w.length);
                    const endDist = w.distance;
                    const startX = w.x + ax * startDist;
                    const startY = w.y + ay * startDist;
                    const endX = w.x + ax * endDist;
                    const endY = w.y + ay * endDist;
                    const width = w.width * (0.85 + 0.25*Math.sin((w.maxLife - w.life)/3));
                    const halfW = width * 0.5;
                    // Perp vector
                    const px = -ay, py = ax;
                    const fade = 0.55 * lifePct + 0.15*Math.sin(Date.now()/160 + w.x*0.03);
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, fade);
                    const grad = ctx.createLinearGradient(startX, startY, endX, endY);
                    grad.addColorStop(0, 'rgba(180,200,255,0)');
                    grad.addColorStop(0.15, 'rgba(160,190,255,0.25)');
                    grad.addColorStop(0.55, 'rgba(140,170,255,0.35)');
                    grad.addColorStop(1, 'rgba(110,140,220,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(startX + px*halfW, startY + py*halfW);
                    ctx.lineTo(endX + px*halfW, endY + py*halfW);
                    ctx.lineTo(endX - px*halfW, endY - py*halfW);
                    ctx.lineTo(startX - px*halfW, startY - py*halfW);
                    ctx.closePath();
                    ctx.fill();
                    // Edge highlights
                    ctx.globalAlpha = fade * 0.9;
                    ctx.strokeStyle = 'rgba(200,220,255,0.55)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(startX + px*halfW, startY + py*halfW);
                    ctx.lineTo(endX + px*halfW, endY + py*halfW);
                    ctx.moveTo(startX - px*halfW, startY - py*halfW);
                    ctx.lineTo(endX - px*halfW, endY - py*halfW);
                    ctx.stroke();
                    // Front impact arc (slightly rounded tip)
                    ctx.globalAlpha = fade * 0.75;
                    const tipR = Math.min(40, halfW * 0.8);
                    const tipGrad = ctx.createRadialGradient(endX, endY, tipR*0.15, endX, endY, tipR);
                    tipGrad.addColorStop(0,'rgba(255,255,255,0.55)');
                    tipGrad.addColorStop(1,'rgba(150,180,255,0)');
                    ctx.fillStyle = tipGrad;
                    ctx.beginPath();
                    ctx.arc(endX, endY, tipR, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                });
            }
            
            // Draw enemies (restored original logic)
            game.enemies.forEach(enemy => {
                // Elite aura pass (before sprite/procedural body). Skip for final boss or lowFX to reduce cost.
                if (enemy.elite && !enemy.finalBoss && !game.lowFX) {
                    const pulse = 0.6 + 0.4 * Math.sin(performance.now()/320 + enemy.x*0.015);
                    const baseR = (enemy.size || 12) * 1.45;
                    const grad = ctx.createRadialGradient(enemy.x, enemy.y, baseR*0.1, enemy.x, enemy.y, baseR);
                    grad.addColorStop(0, 'rgba(255,220,120,' + (0.55 * pulse).toFixed(3) + ')');
                    grad.addColorStop(1, 'rgba(255,150,40,0)');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, baseR, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
                let baseColor = enemy.color;
                if (enemy.poisoned && enemy.burning) {
                    baseColor = '#8B4B00';
                } else if (enemy.poisoned && enemy.slowed) {
                    baseColor = '#4B6040';
                } else if (enemy.burning && enemy.slowed) {
                    baseColor = '#8B0080';
                } else if (enemy.poisoned) {
                    baseColor = '#4B8040';
                } else if (enemy.burning) {
                    baseColor = '#FF4040';
                } else if (enemy.slowed) {
                    baseColor = '#4040BB';
                }
                // Duck-style enemy drawing helper (lightweight, with fallback or sprite override)
                const drawDuckEnemy = (ctx, enemy, tintColor) => {
                    try {
                        // Thug sprite override
                        if (enemy.type === 'Thug' && game.enemySprites && game.enemySprites.thug && game.enemySprites.thug.loaded) {
                            const ts = game.enemySprites.thug;
                            const frameSet = ts.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ts.image;
                            const size = enemy.size; // existing radius-like metric
                            const scale = ts.baseScaleForSize ? ts.baseScaleForSize(size) : ( (size*2) / (box ? box.h : 1) );
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save();
                                ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) {
                                        ctx.scale(-1,1);
                                        ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    } else {
                                        ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) {
                                    ctx.strokeStyle = 'rgba(0,255,0,0.6)';
                                    ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH);
                                }
                                ctx.restore();
                                return; // skip procedural drawing
                            }
                        }
                        // Street Dog sprite override
                        if (enemy.type === 'Street Dog' && game.enemySprites && game.enemySprites.streetDog && game.enemySprites.streetDog.loaded) {
                            const ds = game.enemySprites.streetDog;
                            const frameSet = ds.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ds.image;
                            const size = enemy.size;
                            const scale = ds.baseScaleForSize ? ds.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,200,255,0.6)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Punk sprite override
                        if (enemy.type === 'Punk' && game.enemySprites && game.enemySprites.punk && game.enemySprites.punk.loaded) {
                            const ps = game.enemySprites.punk;
                            const frameSet = ps.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ps.image;
                            const size = enemy.size;
                            const scale = ps.baseScaleForSize ? ps.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,0,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Dealer sprite override
                        if (enemy.type === 'Dealer' && game.enemySprites && game.enemySprites.dealer && game.enemySprites.dealer.loaded) {
                            const ds = game.enemySprites.dealer;
                            const frameSet = ds.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = ds.image;
                            const size = enemy.size;
                            const scale = ds.baseScaleForSize ? ds.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,255,0,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Gangster sprite override
                        if (enemy.type === 'Gangster' && game.enemySprites && game.enemySprites.gangster && game.enemySprites.gangster.loaded) {
                            const gs = game.enemySprites.gangster;
                            const frameSet = gs.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = gs.image;
                            const size = enemy.size;
                            const scale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,255,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Enforcer sprite override
                        if (enemy.type === 'Enforcer' && game.enemySprites && game.enemySprites.enforcer && game.enemySprites.enforcer.loaded) {
                            const es = game.enemySprites.enforcer;
                            const frameSet = es.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = es.image;
                            const size = enemy.size;
                            const scale = es.baseScaleForSize ? es.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,128,0,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Boss Thug sprite override
                        if (enemy.type === 'Boss Thug' && game.enemySprites && game.enemySprites.bossThug && game.enemySprites.bossThug.loaded) {
                            const bs = game.enemySprites.bossThug;
                            const frameSet = bs.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = bs.image;
                            const size = enemy.size;
                            const scale = bs.baseScaleForSize ? bs.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(170,90,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Boss Gangster sprite override
                        if (enemy.type === 'Boss Gangster' && game.enemySprites && game.enemySprites.bossGangster && game.enemySprites.bossGangster.loaded) {
                            const gs = game.enemySprites.bossGangster;
                            const frameSet = gs.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = gs.image;
                            const size = enemy.size;
                            const scale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(90,170,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // The Big Quack final boss sprite override
                        if (enemy.type === 'The Big Quack' && game.enemySprites && game.enemySprites.bigQuack && game.enemySprites.bigQuack.loaded) {
                            const bq = game.enemySprites.bigQuack;
                            const frameSet = bq.frames;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = bq.image;
                            const size = enemy.size;
                            const scale = bq.baseScaleForSize ? bq.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,80,80,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Cache style palette per type on the function to avoid re-allocation
                        if (!drawDuckEnemy._styles) {
                            drawDuckEnemy._styles = {
                                'Thug': { body:'#6b4d2e', head:'#765633', beak:'#d08c00', wing:'#5a3f25' },
                                'Gangster': { body:'#2d2d2d', head:'#383838', beak:'#d08c00', wing:'#1f1f1f', hat:'#000000' },
                                'Street Dog': { body:'#704214', head:'#804c19', beak:'#c07000', wing:'#5a3410', ears:true },
                                'Punk': { body:'#91298f', head:'#a936a7', beak:'#ffb000', wing:'#762177', mohawk:true },
                                'Dealer': { body:'#2a6b2a', head:'#2f7a2f', beak:'#d08c00', wing:'#1e4d1e', stripe:'#ffff66' },
                                'Enforcer': { body:'#7c0a02', head:'#8f1208', beak:'#ff9c00', wing:'#5a0601', pads:true },
                                'Boss Thug': { body:'#4a2c85', head:'#533296', beak:'#ffb000', wing:'#392063', crown:true },
                                'Boss Gangster': { body:'#1c1c1c', head:'#262626', beak:'#d08c00', wing:'#131313', hat:'#000000', pinstripe:true },
                                'The Big Quack': { body:'#050505', head:'#0a0a0a', beak:'#e0a800', wing:'#050505', hat:'#000000', pinstripe:true, overfedora:true }
                            };
                        }
                        const style = drawDuckEnemy._styles[enemy.type] || {};
                        const bodyColor = tintColor || style.body || enemy.color || '#888888';
                        const headColor = style.head || bodyColor;
                        const beakColor = style.beak || '#d08c00';
                        const wingColor = style.wing || bodyColor;

                        // Left/right facing only: determine horizontal facing
                        const faceLeft = game.player.x < enemy.x;
                        const s = enemy.size; // base scale reference

                        ctx.save();
                        ctx.translate(enemy.x, enemy.y);
                        // Visual cue if blinded: golden halo + slight dim of body
                        if (enemy.blinded) {
                            const pulse = 0.6 + 0.4*Math.sin(performance.now()/180 + enemy.x*0.02);
                            ctx.globalAlpha = 0.55 * pulse;
                            ctx.fillStyle = '#FFEFA5';
                            ctx.beginPath();
                            ctx.ellipse(0, enemy.size*0.15, enemy.size*0.9, enemy.size*0.45, 0, 0, Math.PI*2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        if (enemy.blinded) {
                            ctx.filter = 'brightness(0.85)';
                        }
                        if (faceLeft) {
                            ctx.scale(-1, 1); // mirror horizontally
                        }

                        // Body (ellipse)
                        ctx.fillStyle = bodyColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.05, 0, s*0.55, s*0.38, 0, 0, Math.PI*2);
                        ctx.fill();

                        // Trenchcoat (wrapped)  sculpted shape hugging body with flare and collar
                        const coatColor = '#3f2c1b';
                        const coatShadow = '#281a10';
                        const coatHighlight = '#705030';
                        // Adjusted for full body coverage
                        const coatTopY = -s*0.28; // raised under beak
                        const coatBottomY = s*0.62; // lowered to cover lower ellipse
                        const coatHalf = s*0.60; // wider wrap to exceed body ellipse width
                        ctx.fillStyle = coatColor;
                        ctx.beginPath();
                        // Top curve (collar base)
                        ctx.moveTo(-coatHalf*0.90, coatTopY + s*0.05);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatTopY - s*0.10, 0, coatTopY - s*0.08);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatTopY - s*0.10, coatHalf*0.90, coatTopY + s*0.05);
                        // Side down (left)
                        ctx.lineTo(coatHalf*0.68, coatBottomY - s*0.06);
                        // Bottom flare waves (extended)
                        ctx.quadraticCurveTo(coatHalf*0.25, coatBottomY + s*0.14, 0, coatBottomY + s*0.06);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatBottomY + s*0.14, -coatHalf*0.68, coatBottomY - s*0.06);
                        // Close along left side
                        ctx.closePath();
                        ctx.fill();
                        // Collar & lapels overlay
                        ctx.fillStyle = coatHighlight;
                        ctx.beginPath();
                        ctx.moveTo(-coatHalf*0.55, coatTopY + s*0.04);
                        ctx.lineTo(-coatHalf*0.20, coatTopY + s*0.36);
                        ctx.lineTo(-coatHalf*0.06, coatTopY + s*0.04);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(coatHalf*0.55, coatTopY + s*0.04);
                        ctx.lineTo(coatHalf*0.20, coatTopY + s*0.36);
                        ctx.lineTo(coatHalf*0.06, coatTopY + s*0.04);
                        ctx.closePath();
                        ctx.fill();
                        // Inner shadow (gradient simulation via semi-transparent stroke)
                        ctx.strokeStyle = coatShadow + 'aa';
                        ctx.lineWidth = Math.max(1, s*0.06);
                        ctx.beginPath();
                        ctx.moveTo(0, coatTopY - s*0.06);
                        ctx.lineTo(0, coatBottomY);
                        ctx.stroke();
                        // Buttons (shifted slightly right for wrap illusion)
                        ctx.fillStyle = '#cfae72';
                        for (let i=0;i<4;i++) {
                            ctx.beginPath();
                            ctx.arc(s*0.07, coatTopY + s*(0.18 + i*0.20), s*0.038, 0, Math.PI*2);
                            ctx.fill();
                        }
                        // Belt suggestion (two small horizontal strokes)
                        ctx.strokeStyle = coatShadow;
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.beginPath();
                        ctx.moveTo(-s*0.32, coatTopY + s*0.54);
                        ctx.lineTo(s*0.32, coatTopY + s*0.54);
                        ctx.moveTo(-s*0.32, coatTopY + s*0.57);
                        ctx.lineTo(s*0.20, coatTopY + s*0.57);
                        ctx.stroke();
                        // Wing aperture (eroded area) + sleeve cap
                        ctx.save();
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.beginPath();
                        ctx.ellipse(-s*0.20, 0, s*0.24, s*0.20, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                        ctx.fillStyle = coatColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.20, -s*0.02, s*0.22, s*0.18, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Subtle outline
                        ctx.strokeStyle = '#00000044';
                        ctx.lineWidth = Math.max(1, s*0.025);
                        ctx.beginPath();
                        ctx.moveTo(-coatHalf*0.90, coatTopY + s*0.05);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatTopY - s*0.10, 0, coatTopY - s*0.08);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatTopY - s*0.10, coatHalf*0.90, coatTopY + s*0.05);
                        ctx.lineTo(coatHalf*0.68, coatBottomY - s*0.06);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatBottomY + s*0.14, 0, coatBottomY + s*0.06);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatBottomY + s*0.14, -coatHalf*0.68, coatBottomY - s*0.06);
                        ctx.closePath();
                        ctx.stroke();
                        // Wing (simple arc) drawn after coat so it appears on top/side
                        ctx.fillStyle = wingColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.15, 0, s*0.30, s*0.22, Math.PI/6, Math.PI*0.15, Math.PI*1.15);
                        ctx.fill();

                        // Head
                        ctx.fillStyle = headColor;
                        ctx.beginPath();
                        ctx.arc(s*0.42, -s*0.15, s*0.28, 0, Math.PI*2);
                        ctx.fill();

                        // Beak
                        ctx.fillStyle = beakColor;
                        ctx.beginPath();
                        ctx.moveTo(s*0.62, -s*0.10);
                        ctx.lineTo(s*0.90, -s*0.05);
                        ctx.lineTo(s*0.62,  -s*0.00);
                        ctx.closePath();
                        ctx.fill();

                        // Eye
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(s*0.50, -s*0.22, s*0.07, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(s*0.515, -s*0.22, s*0.03, 0, Math.PI*2);
                        ctx.fill();

                        // Weapon (before hat so it sits below hat brim visually)
                        // Decide melee vs ranged using enemy.ranged flag
                        if (enemy.ranged) {
                            // Gun lowered to body line (emerges from wing/coat front)
                            const gunBaseX = s*0.42; // forward in facing direction
                            const gunBaseY = s*0.18; // lowered
                            ctx.save();
                            ctx.translate(gunBaseX, gunBaseY);
                            ctx.rotate(-0.08); // slight downward-forward angle
                            ctx.fillStyle = '#2b2b2b';
                            // Body
                            ctx.fillRect(0, -s*0.07, s*0.40, s*0.12);
                            // Barrel
                            ctx.fillRect(s*0.40, -s*0.045, s*0.30, s*0.055);
                            // Front sight
                            ctx.fillRect(s*0.68, -s*0.055, s*0.04, s*0.02);
                            // Grip
                            ctx.fillStyle = '#3d3d3d';
                            ctx.fillRect(s*0.08, s*0.02, s*0.14, s*0.20);
                            // Highlight line
                            ctx.strokeStyle = '#ffffff22';
                            ctx.lineWidth = Math.max(1, s*0.015);
                            ctx.beginPath();
                            ctx.moveTo(s*0.02, -s*0.035);
                            ctx.lineTo(s*0.36, -s*0.035);
                            ctx.stroke();
                            ctx.restore();
                        } else {
                            // Knife lowered to appear held at body level
                            const knifeBaseX = s*0.36;
                            const knifeBaseY = s*0.20;
                            ctx.save();
                            ctx.translate(knifeBaseX, knifeBaseY);
                            ctx.rotate(-0.12);
                            // Handle
                            ctx.fillStyle = '#3a2412';
                            ctx.fillRect(-s*0.05, -s*0.035, s*0.12, s*0.10);
                            // Guard
                            ctx.fillStyle = '#cfae72';
                            ctx.fillRect(s*0.02, -s*0.045, s*0.07, s*0.032);
                            // Blade
                            ctx.fillStyle = '#c8d0d5';
                            ctx.beginPath();
                            ctx.moveTo(s*0.06, -s*0.04);
                            ctx.lineTo(s*0.40, -s*0.012);
                            ctx.lineTo(s*0.06,  s*0.018);
                            ctx.closePath();
                            ctx.fill();
                            // Edge highlight
                            ctx.strokeStyle = '#ffffff55';
                            ctx.lineWidth = Math.max(1, s*0.015);
                            ctx.beginPath();
                            ctx.moveTo(s*0.08, -s*0.030);
                            ctx.lineTo(s*0.36, -s*0.010);
                            ctx.stroke();
                            ctx.restore();
                        }

                        // Type-specific accents
                        // Universal fedora (gangster look)
                        // Fedora: dynamic palette (black for gangster variants)
                        const isBossGang = enemy.type === 'Boss Gangster' || enemy.type === 'The Big Quack' || enemy.type === 'Gangster';
                        const hatBrimColor = isBossGang ? '#000000' : '#5a3b19';
                        const hatCrownColor = isBossGang ? '#111111' : '#6d4722';
                        const hatBandColor = isBossGang ? '#222222' : '#3a2613';
                        const highlightColor = '#ffffff18';
                        // Slightly larger brim
                        const brimWidth = s*0.50;
                        const brimHeight = s*0.085;
                        const brimX = s*0.18;
                        const brimY = -s*0.44;
                        ctx.fillStyle = hatBrimColor;
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(brimX, brimY, brimWidth, brimHeight, brimHeight*0.4) : ctx.fillRect(brimX, brimY, brimWidth, brimHeight);
                        ctx.fill();
                        // Crown (tapered)
                        const crownBaseWidth = s*0.30;
                        const crownTopWidth = crownBaseWidth * 0.70; // taper
                        const crownHeight = s*0.26;
                        const crownBaseX = brimX + (brimWidth - crownBaseWidth)/2;
                        const crownTopX = crownBaseX + (crownBaseWidth - crownTopWidth)/2;
                        const crownBottomY = brimY - s*0.01;
                        const crownTopY = crownBottomY - crownHeight;
                        ctx.fillStyle = hatCrownColor;
                        ctx.beginPath();
                        ctx.moveTo(crownBaseX, crownBottomY);
                        ctx.lineTo(crownBaseX + crownBaseWidth, crownBottomY);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY);
                        ctx.lineTo(crownTopX, crownTopY);
                        ctx.closePath();
                        ctx.fill();
                        // Band wraps around lower third
                        const bandHeight = crownHeight * 0.22;
                        const bandY = crownBottomY - bandHeight - crownHeight*0.18;
                        ctx.fillStyle = hatBandColor;
                        ctx.fillRect(crownBaseX, bandY, crownBaseWidth, bandHeight);
                        // Highlight along top ridge
                        ctx.strokeStyle = highlightColor;
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.beginPath();
                        ctx.moveTo(crownTopX, crownTopY + s*0.01);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY + s*0.01);
                        ctx.stroke();
                        // Outline
                        ctx.strokeStyle = isBossGang ? '#00000088' : '#2b1b0d88';
                        ctx.lineWidth = Math.max(1, s*0.035);
                        ctx.beginPath();
                        ctx.moveTo(crownBaseX, crownBottomY);
                        ctx.lineTo(crownBaseX + crownBaseWidth, crownBottomY);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY);
                        ctx.lineTo(crownTopX, crownTopY);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.strokeStyle = isBossGang ? '#00000066' : '#2b1b0d66';
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.strokeRect(brimX, brimY, brimWidth, brimHeight);
                        // Pinstripes for suit (body area) on boss gangster & big quack
                        if (style.pinstripe) {
                            ctx.save();
                            ctx.translate(0,0);
                            ctx.strokeStyle = enemy.type === 'The Big Quack' ? '#44444488' : '#555555AA';
                            ctx.lineWidth = Math.max(1, s*0.01);
                            for (let ps=-s*0.55; ps<=s*0.55; ps+= s*0.12) {
                                ctx.beginPath();
                                ctx.moveTo(ps, -s*0.30);
                                ctx.lineTo(ps, s*0.55);
                                ctx.stroke();
                            }
                            ctx.restore();
                        }
                        if (style.overfedora) {
                            // Add a subtle wider shadow under brim to emphasize scale
                            ctx.save();
                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = '#000000';
                            ctx.beginPath();
                            ctx.ellipse(brimX + brimWidth/2, brimY + brimHeight*0.65, brimWidth*0.65, brimHeight*0.9, 0, 0, Math.PI*2);
                            ctx.fill();
                            ctx.restore();
                        }
                        if (style.mohawk) {
                            ctx.fillStyle = '#ff00ff';
                            ctx.beginPath();
                            ctx.moveTo(s*0.38, -s*0.42);
                            ctx.lineTo(s*0.44, -s*0.60);
                            ctx.lineTo(s*0.50, -s*0.42);
                            ctx.closePath();
                            ctx.fill();
                        }
                        if (style.ears) {
                            ctx.fillStyle = headColor;
                            ctx.beginPath();
                            ctx.arc(s*0.30, -s*0.34, s*0.08, 0, Math.PI*2);
                            ctx.arc(s*0.54, -s*0.34, s*0.08, 0, Math.PI*2);
                            ctx.fill();
                        }
                        if (style.stripe) {
                            ctx.strokeStyle = style.stripe;
                            ctx.lineWidth = Math.max(2, s*0.08);
                            ctx.beginPath();
                            ctx.moveTo(-s*0.55, -s*0.10);
                            ctx.lineTo(s*0.10, s*0.12);
                            ctx.stroke();
                        }
                        if (style.pads) {
                            ctx.fillStyle = '#ffaa33';
                            ctx.fillRect(-s*0.30, s*0.14, s*0.18, s*0.10);
                            ctx.fillRect(-s*0.05, s*0.14, s*0.18, s*0.10);
                        }
                        // (Removed crown accent in favor of universal fedora)

                        // Subtle outline
                        ctx.strokeStyle = '#00000055';
                        ctx.lineWidth = Math.max(1, s*0.05);
                        ctx.beginPath();
                        ctx.ellipse(-s*0.05, 0, s*0.55, s*0.38, 0, 0, Math.PI*2);
                        ctx.stroke();

                        ctx.restore();
                    } catch (e) {
                        // Fallback to original rectangle if anything goes wrong
                        ctx.save();
                        ctx.fillStyle = tintColor || enemy.color || '#888';
                        ctx.fillRect(enemy.x - enemy.size/2, enemy.y - enemy.size/2, enemy.size, enemy.size);
                        ctx.restore();
                    }
                };

                // Apply fear/flee tint (purple) while under those effects
                const isPanic = enemy.feared || enemy.fleeing;
                const tintColor = isPanic ? '#AA44FF' : baseColor;
                drawDuckEnemy(ctx, enemy, tintColor);
                // Subtle pulsing glow to highlight panic state
                if (isPanic) {
                    const pulse = 0.45 + 0.25 * Math.sin(performance.now()/160 + enemy.x*0.04);
                    ctx.save();
                    ctx.globalAlpha = 0.35 * pulse;
                    ctx.fillStyle = '#AA44FF';
                    ctx.beginPath();
                    ctx.ellipse(enemy.x, enemy.y + enemy.size*0.10, enemy.size*0.95, enemy.size*0.55, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
                // Health bar
                if (enemy.health < enemy.maxHealth && enemy.maxHealth > 0) {
                    const barWidth = enemy.size + 10;
                    const barHeight = 4;
                    const barY = enemy.y - enemy.size/2 - 8;
                    // Clamp ratio to [0,1] to avoid flash expansion when health dips below 0 or state mutates on death
                    let ratio = enemy.health / enemy.maxHealth;
                    if (!isFinite(ratio)) ratio = 0; // safeguard
                    ratio = Math.min(1, Math.max(0, ratio));
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, barHeight);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, barHeight);
                    if (ratio > 0) {
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(enemy.x - barWidth/2, barY, barWidth * ratio, barHeight);
                    }
                }
                
                // Status effect indicators
                let indicatorY = enemy.y - enemy.size/2 - 15;
                if (enemy.poisoned) {
                    ctx.fillStyle = '#90EE90';
                    ctx.fillRect(enemy.x - 8, indicatorY, 16, 3);
                    indicatorY -= 5;
                }
                if (enemy.burning) {
                    ctx.fillStyle = '#FF6600';
                    ctx.fillRect(enemy.x - 8, indicatorY, 16, 3);
                    indicatorY -= 5;
                }
                if (enemy.slowed) {
                    ctx.fillStyle = '#4040ff';
                    ctx.fillRect(enemy.x - 6, indicatorY, 12, 2);
                }
            });

            // Tanks Alot: draw trucks on top of ground effects but beneath enemies/projectiles overlays
            if (Array.isArray(game.trucks) && game.trucks.length) {
                const spr = window._truckSprite || {};
                const img = spr.image;
                const driveFrames = spr.frames && spr.frames.drive || null;
                const targetH = window.TRUCK_TARGET_H || 110; // use shared target height for consistency
                game.trucks.forEach(t => {
                    if (!t) return;
                    ctx.save();
                    ctx.translate(t.x, t.y);
                    // Shadow
                    const shW = (t.width||targetH*2.2)*0.46;
                    const shH = (t.height||targetH)*0.24;
                    ctx.fillStyle = 'rgba(0,0,0,0.25)';
                    ctx.beginPath(); ctx.ellipse(0, (t.height||targetH)*0.28, shW, shH, 0, 0, Math.PI*2); ctx.fill();
                    // Body (use cropped bounds if available)
                    if (img && img.complete && !img._broken && img.naturalWidth) {
                        const sel = (driveFrames && driveFrames[Math.min(t.frame||0, driveFrames.length-1)]) || (driveFrames && driveFrames[0]);
                        const src = sel || { x:0, y:0, w: img.naturalWidth, h: img.naturalHeight };
                        const scale = targetH / src.h;
                        const drawW = src.w * scale;
                        const drawH = src.h * scale;
                        ctx.drawImage(img, src.x, src.y, src.w, src.h, -drawW/2, -drawH/2, drawW, drawH);
                    } else {
                        // Fallback rectangle
                        const wBox = (t.width||targetH*2.2); const hBox = (t.height||targetH);
                        ctx.fillStyle = '#555'; ctx.fillRect(-wBox/2, -hBox/2, wBox, hBox);
                        ctx.fillStyle = '#999'; ctx.fillRect(-wBox*0.45, -hBox*0.30, wBox*0.9, hBox*0.36);
                    }
                    ctx.restore();
                });
            }
            
            // Draw projectiles with enhanced effects
            game.projectiles.forEach(proj => {
                if (proj.enemy) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(proj.x - 3, proj.y - 3, 6, 6);
                    return;
                }
                // Resonant Pulse overlay rings (object-mode)  expanding/fading ring at pulse; perf-gated
                if (proj._resActiveRings && proj._resActiveRings.length && !(game.perf && game.perf.lowFx)) {
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    for (let i=0;i<proj._resActiveRings.length;i++) {
                        const ring = proj._resActiveRings[i];
                        const rr = Math.max(4, ring.r || 0);
                        const lifeNorm = Math.max(0, Math.min(1, (ring.life != null ? ring.life : 0) / 38));
                        const alpha = 0.60 * lifeNorm;
                        ctx.strokeStyle = `rgba(199,164,255,${alpha.toFixed(3)})`;
                        ctx.lineWidth = 2 + 1.4 * lifeNorm;
                        if (!reduceRings && ctx.setLineDash) ctx.setLineDash([6, 6]);
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, rr, 0, Math.PI*2); ctx.stroke();
                        if (!reduceRings && ctx.setLineDash) ctx.setLineDash([]);
                    }
                    ctx.restore();
                }
                // Time Bomb fuse glow (object renderer path): intensifies as fuse nears zero
                if (proj.timeBomb && typeof proj._timeBombTimer === 'number') {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    if (!lowFx) {
                        const maxFuse = Math.max(1, proj._tbFuseMax || 54);
                        const t = Math.max(0, proj._timeBombTimer);
                        const frac = 1 - Math.min(1, t / maxFuse);
                        const intensity = Math.min(1, frac*frac * (proj._timeBombArmed ? 1.2 : 1));
                        const baseR = (proj.size || 6) + 6;
                        const glowR = baseR * (1.1 + 0.55 * intensity);
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        // Outer soft warm glow
                        const g = ctx.createRadialGradient(proj.x, proj.y, glowR*0.25, proj.x, proj.y, glowR);
                        const a0 = 0.12 + 0.28 * intensity;
                        g.addColorStop(0, `rgba(255, 210, 120, ${a0.toFixed(3)})`);
                        g.addColorStop(1, 'rgba(255, 210, 120, 0)');
                        ctx.fillStyle = g;
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, glowR, 0, Math.PI*2); ctx.fill();
                        // Inner hot ring pulse as armed approaches detonation
                        if (proj._timeBombArmed && intensity > 0.5) {
                            ctx.globalAlpha = 0.35 + 0.45 * (intensity - 0.5);
                            ctx.strokeStyle = '#FFB366';
                            ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 4 + intensity*4, 0, Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                    }
                }
                // Visual Accent: Pattern Amplification halo (SHOOTING INTENSIFIES)
                if (proj._patternAmpFactor && proj._patternAmpFactor > 1.01) {
                    const pulse = 0.55 + Math.sin(performance.now()/140 + (proj.x+proj.y)*0.01)*0.25; // 0.3 amplitude
                    const radius = (proj.size||6) * (1.4 + pulse*0.6);
                    ctx.save();
                    const g = ctx.createRadialGradient(proj.x, proj.y, radius*0.15, proj.x, proj.y, radius);
                    g.addColorStop(0,'rgba(255,255,255,0.55)');
                    g.addColorStop(0.45,'rgba(120,255,200,0.35)');
                    g.addColorStop(1,'rgba(0,255,160,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, radius, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                }
                // Visual Accent: Cascade Burst core flicker prior to pulses
                if (proj.cascadeBurst) {
                    // Mild warm core sheen; intensity spikes right before emission when timer small
                    const tLeft = proj._cascTimer || 0;
                    const intensity = (tLeft <= 3) ? 0.85 : (tLeft <= 6 ? 0.55 : 0.25);
                    if (Math.random() < 0.6) {
                        addParticle(proj.x + (Math.random()-0.5)*4, proj.y + (Math.random()-0.5)*4, intensity>0.6?'#FFE5AA':'#FFC877', 'spark');
                    }
                }
                // Determine base elemental color (fallback cyan)
                let baseColor = '#00BFFF';
                if (proj.damageType === 'fire') baseColor = '#FF5522';
                else if (proj.damageType === 'poison') baseColor = '#33DD55';
                else if (proj.damageType === 'ice' || proj.damageType === 'frost') baseColor = '#44AAFF';
                else if (proj.damageType === 'lightning' || proj.damageType === 'storm') baseColor = '#FFFF55';
                else if (proj.damageType === 'acid') baseColor = '#66FF44';
                else if (proj.damageType === 'void') baseColor = '#AA00FF';
                else if (proj.damageType === 'shadow') baseColor = '#663399';
                else if (proj.damageType === 'crystal') baseColor = '#88EEFF';
                else if (proj.damageType === 'magma') baseColor = '#FF7722';
                else if (proj.damageType === 'plasma') baseColor = '#FF4455';
                else if (proj.damageType === 'inferno') baseColor = '#FF3311';
                else if (proj.damageType === 'blizzard') baseColor = '#C0F8FF';
                else if (proj.damageType === 'toxic') baseColor = '#55FFAA';
                // Energy type overrides
                if (proj.energyType) {
                    const energyColors = {
                        laser: '#99EEFF',
                        particle: '#66FFE4',
                        ion: '#FFE066',
                        pulse: '#FF88DD',
                        photon: '#FFFFFF'
                    };
                    if (energyColors[proj.energyType]) baseColor = energyColors[proj.energyType];
                }
                // Homing tint accent
                if (proj.homing) baseColor = '#FFFFFF';
                else if (proj.weakHoming) baseColor = shadeColor(baseColor, 30);
                // Quantum flicker: random slight hue shift
                if (proj.quantum && Math.random() < 0.25) baseColor = '#66FFFF';
                // Spiral Bloom pre-bloom cue (brief inner ring)
                if (proj.spiralBloom && proj._sbTelegraph>0 && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.85, proj._sbTelegraph/12);
                    ctx.strokeStyle = '#FFE6AA';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) * 1.1, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();
                }
                // Harmonic Split pre-split cue (thin ring)
                if (proj.harmonicSplit && proj._harmonicTele>0 && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.8, proj._harmonicTele/6);
                    ctx.strokeStyle = '#FFE2BB';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 4, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();
                }
                // Temporal Drift cues: stronger pre-beat and brighter surge shimmer; always show a minimal ring
                if (proj.temporalDrift) {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const phase = proj._tdPhase || 0;
                    const timer = proj._tdTimer || 0;
                    // Updated thresholds to match stronger cadence
                    const th = phase === 0 ? 30 : (phase === 1 ? 10 : 18);
                    // Pre-beat telegraph: always show one thin ring; add a richer gated ring near swap
                    if (timer >= th - 4) {
                        // minimal always-on ring
                        ctx.save();
                        ctx.globalAlpha = 0.45; // brighter baseline
                        ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                        ctx.lineWidth = 2.2; // thicker
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 4, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                        // ramped richer ring when perf allows
                        if (!lowFx && !reduceRings) {
                            const tight = Math.max(0, Math.min(1, (timer - (th - 4)) / 4));
                            ctx.save();
                            ctx.globalAlpha = 0.30 + 0.65 * tight;
                            ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                            ctx.lineWidth = 2.6;
                            ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 6, 0, Math.PI*2); ctx.stroke();
                            ctx.restore();
                        }
                    }
                    // Surge shimmer: brighter/denser inner core during phase 2 (skips on lowFx)
                    if (!lowFx && phase === 2) {
                        const t = (performance.now()/220) + (proj.x+proj.y)*0.002;
                        const pulse = 0.5 + 0.5*Math.sin(t*2*Math.PI);
                        const radius = (proj.size||6) * (1.35 + 0.35*pulse);
                        ctx.save();
                        const g = ctx.createRadialGradient(proj.x, proj.y, radius*0.10, proj.x, proj.y, radius);
                        g.addColorStop(0, 'rgba(170,250,255,' + (0.58 + 0.30*pulse).toFixed(3) + ')');
                        g.addColorStop(1, 'rgba(170,250,255,0)');
                        ctx.fillStyle = g;
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, radius, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                    // Brief afterimage during surge: faint streaks trailing behind
                    if (!lowFx && phase === 2) {
                        proj._tdTrail = proj._tdTrail || [];
                        const buf = proj._tdTrail;
                        buf.push({ x: proj.x, y: proj.y, t: performance.now() });
                        while (buf.length > 8) buf.shift();
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        for (let k=1; k<buf.length; k++) {
                            const p0 = buf[k-1]; const p1 = buf[k];
                            const ageMs = performance.now() - p0.t;
                            const a = Math.max(0, 1 - ageMs / 140);
                            if (a <= 0) continue;
                            ctx.strokeStyle = `rgba(164,245,255,${(0.20*a).toFixed(3)})`;
                            ctx.lineWidth = Math.max(1.2, (proj.size||6) * 0.22 * a);
                            ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                        }
                        ctx.restore();
                    }
                }
                // Resonant Pulse Core HUD ring for recently buffed shots (perf-gated)
                if ((proj._resBuffSpeed>0 || proj._resBuffDamage>0 || proj._resBuffHoming>0) && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const t = (performance.now()/500) % (Math.PI*2);
                    ctx.rotate(t);
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#C7A4FF';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3,3]);
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+5,0,Math.PI*2); ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
                // Plasma trailing ion particles (add subtle heat haze dots)
                if (proj.damageType === 'plasma' && Math.random() < 0.5) {
                    addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FF7766', 'spark');
                    if (Math.random() < 0.25) addParticle(proj.x, proj.y, '#FFAA99', 'spark');
                }
                // Resonant Pulse Core HUD ring for recently buffed shots (perf-gated)
                if ((proj._resBuffSpeed>0 || proj._resBuffDamage>0 || proj._resBuffHoming>0) && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const t = (performance.now()/500) % (Math.PI*2);
                    ctx.rotate(t);
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#C7A4FF';
                    ctx.lineWidth = 1.5;
                    if (ctx.setLineDash) ctx.setLineDash([3,3]);
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+5,0,Math.PI*2); ctx.stroke();
                    if (ctx.setLineDash) ctx.setLineDash([]);
                    ctx.restore();
                }
                // Weapon-specific override accents
                const wt = proj.weaponType;
                const angle = Math.atan2(proj.vy, proj.vx);
                // Toenail Clibbins enhanced crescent rendering (half-moon keratin shard)
                if (proj.toenail) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    // Gentle forward pointing orientation plus spin
                    const spin = (proj._crescentPhase||0);
                    ctx.rotate(spin);
                    const baseR = (proj.size||10) * 0.95;
                    const thicknessRatio = proj._tnThickness || 0.5;
                    const innerR = baseR * (1 - thicknessRatio);
                    const arcSweep = proj._tnArcSweep || (Math.PI*1.0);
                    const innerOffset = (proj._tnInnerOffset||0.32) * baseR;
                    // Outer arc path
                    ctx.beginPath();
                    const startA = -arcSweep/2;
                    const endA = arcSweep/2;
                    ctx.arc(0,0,baseR,startA,endA,false);
                    // Inner reverse arc (offset center for crescent thickness)
                    const cutX = innerOffset;
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    // Keratin gradient (subtle off-yellow to pale ivory)
                    const grad = ctx.createLinearGradient(-baseR, -baseR, baseR, baseR);
                    grad.addColorStop(0,'#FFF8D7');
                    grad.addColorStop(0.45,'#FFE684');
                    grad.addColorStop(0.75,'#F3D266');
                    grad.addColorStop(1,'#D8B850');
                    ctx.fillStyle = grad;
                    ctx.fill();
                    // Rough edge speckles along outer rim
                    ctx.save();
                    ctx.clip();
                    for (let s=0;s<6;s++) {
                        const a = startA + Math.random()*arcSweep;
                        const rr = baseR - Math.random()*3;
                        ctx.fillStyle = 'rgba(255,255,255,'+(0.25+Math.random()*0.35)+')';
                        ctx.beginPath(); ctx.arc(Math.cos(a)*rr, Math.sin(a)*rr, 1 + Math.random()*1.4, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.restore();
                    // Outline & inner shine
                    ctx.lineWidth = 1.4; ctx.strokeStyle = '#B3943A';
                    ctx.beginPath();
                    ctx.arc(0,0,baseR,startA,endA,false);
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    ctx.stroke();
                    // Inner warm glow
                    const glowR = innerR * 0.85;
                    const g2 = ctx.createRadialGradient(cutX*0.55,0, glowR*0.1, cutX*0.55,0, glowR);
                    g2.addColorStop(0,'rgba(255,240,200,0.6)');
                    g2.addColorStop(1,'rgba(255,240,200,0)');
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = g2;
                    ctx.beginPath(); ctx.arc(cutX*0.55,0,glowR,0,Math.PI*2); ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                    // Occasional sparkle near tip
                    if (Math.random() < 0.10) addParticle(proj.x + Math.cos(spin+0.2)*baseR*0.6 + (Math.random()-0.5)*4, proj.y + Math.sin(spin+0.2)*baseR*0.6 + (Math.random()-0.5)*4, '#FFF6AA','spark');
                    return;
                }
                // Crystal shard unique rendering
                if (proj.crystalShard) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const ang = Math.atan2(proj.vy||0, proj.vx||1);
                    ctx.rotate(ang + (proj._crSpin||0));
                    // Faceted rhombus/triangle shard
                    const r = Math.max(4, (proj.size||5) * 1.2);
                    const hue = 190 + Math.sin((performance.now()/300) + proj.x*0.02 + proj.y*0.02)*5;
                    const body = `hsl(${hue}, 90%, 72%)`;
                    const edge = `hsl(${hue}, 95%, 55%)`;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.8, 0);
                    ctx.lineTo(-r*0.2, -r*0.55);
                    ctx.lineTo(r*0.9, 0);
                    ctx.lineTo(-r*0.2, r*0.55);
                    ctx.closePath();
                    const grad = ctx.createLinearGradient(-r*0.6, -r*0.6, r*0.9, r*0.6);
                    grad.addColorStop(0, 'rgba(255,255,255,0.85)');
                    grad.addColorStop(0.25, body);
                    grad.addColorStop(0.75, 'rgba(150,240,255,0.75)');
                    grad.addColorStop(1, 'rgba(140,230,255,0.0)');
                    ctx.fillStyle = grad;
                    ctx.fill();
                    ctx.strokeStyle = edge; ctx.lineWidth = 1.2;
                    ctx.stroke();
                    // glint
                    if (Math.random()<0.15 && !(game.perf && game.perf.lowFx)) addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#CFF6FF','spark');
                    // subtle spin
                    proj._crSpin = (proj._crSpin||0) + 0.10;
                    ctx.restore();
                    return;
                }
                // Popcorn kernel rendering
                if (proj.isPopcornKernel) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const wob = Math.sin((proj._kernelWobble||0))*0.25;
                    ctx.rotate(wob);
                    const r = (proj.size||6)*0.9;
                    // Outer golden shell
                    const grad = ctx.createRadialGradient(0,-r*0.3, r*0.2, 0,0,r);
                    grad.addColorStop(0,'#FFF7AA');
                    grad.addColorStop(1,'#E0B540');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
                    // Subtle seam
                    ctx.strokeStyle = '#C09030AA';
                    ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(0,0,r*0.65, Math.PI*0.15, Math.PI*1.15); ctx.stroke();
                    ctx.restore();
                    if (Math.random()<0.08) addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFEFA0','spark');
                    return;
                }
                // Popcorn puff rendering
                if (proj.popcornPuff) {
                    const img = window._bulletImages && window._bulletImages.popcorn;
                    if (img && img._ok && img.complete && img.naturalWidth) {
                        ctx.save();
                        ctx.translate(proj.x, proj.y);
                        ctx.rotate(proj._puffSpin||0);
                        const base = Math.max(14, (proj.size||10) * 2.0);
                        const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                        let w = base; let h = w / aspect;
                        ctx.imageSmoothingEnabled = true;
                        ctx.drawImage(img, -w/2, -h/2, w, h);
                        ctx.restore();
                        if (Math.random()<0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFEFA0','spark');
                        return;
                    } else {
                        ctx.save();
                        ctx.translate(proj.x, proj.y);
                        ctx.rotate(proj._puffSpin||0);
                        const r = (proj.size||10)*0.85;
                        // Draw clustered lobes
                        ctx.fillStyle = '#FFF9D6';
                        for (let l=0;l<5;l++) {
                            const ang = l/5 * Math.PI*2;
                            const lr = r * (0.55 + ((l%2)*0.15));
                            const lx = Math.cos(ang)*r*0.55;
                            const ly = Math.sin(ang)*r*0.55;
                            ctx.beginPath(); ctx.arc(lx, ly, lr, 0, Math.PI*2); ctx.fill();
                        }
                        // Toasted shading overlay
                        ctx.fillStyle = 'rgba(255,180,60,0.35)';
                        ctx.beginPath(); ctx.arc(-r*0.15, -r*0.1, r*0.65, 0, Math.PI*2); ctx.fill();
                        // Outline
                        ctx.strokeStyle = '#E8D490';
                        ctx.lineWidth = 1.2;
                        ctx.beginPath(); ctx.arc(0,0,r*0.95,0,Math.PI*2); ctx.stroke();
                        ctx.restore();
                        if (Math.random()<0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFEFA0','spark');
                        return;
                    }
                }
                // Umbrella arc rendering (semi-transparent canopy segment)
                if (proj.umbrellaArc) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    // Draw a curved segment implying part of an overhead umbrella path.
                    const r = (proj.size||6) * 1.55;
                    const sweep = Math.PI * 0.7; // segment width
                    const start = (Date.now()/520 + (proj._arcSide||1)*0.3) % (Math.PI*2);
                    ctx.lineWidth = 2.3;
                    // canopy gradient (brighter center to pop visually)
                    const grad = ctx.createRadialGradient(0,0,r*0.10,0,0,r);
                    grad.addColorStop(0,'#FFF9E8');
                    grad.addColorStop(0.55,'#FFE5B0AA');
                    grad.addColorStop(1,'#FFAF5030');
                    ctx.strokeStyle = '#FFEDBB';
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0,0,r,start,start+sweep, proj._arcSide===-1);
                    ctx.lineTo(0,0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // shimmering rim
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(255,230,180,0.45)';
                    ctx.lineWidth = 1.1;
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.92,start,start+sweep, proj._arcSide===-1);
                    ctx.stroke();
                    ctx.restore();
                    // Core node (slightly larger)
                    ctx.fillStyle = '#FFEBCF';
                    ctx.beginPath(); ctx.arc(0,0,Math.max(3,(proj.size||6)*0.62),0,Math.PI*2); ctx.fill();
                    // motion shimmer dots
                    if (Math.random()<0.25) {
                        ctx.fillStyle = 'rgba(255,240,210,0.8)';
                        ctx.beginPath(); ctx.arc(Math.cos(start+sweep*0.5)*r*0.55, Math.sin(start+sweep*0.5)*r*0.55, r*0.07, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.restore();
                    if (Math.random()<0.14) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE5B8','spark');
                    return;
                }
                // Diarrhea ability rear clone color override
                if (proj._diarrheaBrown) {
                    // Dedicated brown-only look using sprite if available; bypass other overlays
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const ang = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(ang);
                    const img = window._bulletImages && window._bulletImages.diarrhea;
                    if (img && img._ok && img.complete && img.naturalWidth) {
                        const base = Math.max(14, (proj.size||6) * 2.0);
                        const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                        let w = base * 1.15; let h = w / aspect;
                        ctx.imageSmoothingEnabled = true;
                        ctx.drawImage(img, -w*0.15, -h/2, w, h);
                    } else {
                        const brown = '#8B4513';
                        const w = (proj.size||6) * 1.9; // horizontal stretch for oval look
                        const h = (proj.size||6) * 1.05;
                        ctx.fillStyle = brown;
                        ctx.beginPath(); ctx.ellipse(0,0,w,h,0,0,Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#5A3410AA';
                        ctx.beginPath(); ctx.ellipse(-w*0.15,0,w*0.55,h*0.55,0,0,Math.PI*2); ctx.fill();
                        if (Math.random()<0.15) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#6B3410', 'spark');
                    }
                    ctx.restore();
                    return; // skip rest of projectile rendering pipeline
                }
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(angle);
                // Motion trail: draw stretched translucent quad opposite velocity
                const speedMag = Math.max(1, Math.hypot(proj.vx, proj.vy));
                const trailLen = Math.min(60, speedMag * 4);
                ctx.save();
                ctx.rotate(0); // already aligned
                ctx.fillStyle = baseColor + '33';
                ctx.beginPath();
                ctx.moveTo(-trailLen, - (proj.size||6)*0.6);
                ctx.lineTo(0, - (proj.size||6)*0.25);
                ctx.lineTo(0,  (proj.size||6)*0.25);
                ctx.lineTo(-trailLen, (proj.size||6)*0.6);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                // Radial aura / special overlays
                const auraR = (proj.size||6) + 8;
                const aura = ctx.createRadialGradient(0,0,0,0,0,auraR);
                aura.addColorStop(0, baseColor + '55');
                aura.addColorStop(1, baseColor + '00');
                ctx.fillStyle = aura;
                ctx.beginPath();
                ctx.arc(0,0,auraR,0,Math.PI*2);
                ctx.fill();
                // Exotic overlays (skip antimatter visual override for diarrhea brown clones so they stay brown)
                if (proj.antimatter && !proj._diarrheaBrown) {
                    // dark core with bright rim
                    const ring = ctx.createRadialGradient(0,0,(proj.size||6)*0.2,0,0,(proj.size||6)+14);
                    ring.addColorStop(0,'#000000');
                    ring.addColorStop(0.5,'#5500AA88');
                    ring.addColorStop(1,'#FFEEFF11');
                    ctx.fillStyle = ring;
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+14,0,Math.PI*2); ctx.fill();
                }
                // Split child accent (golden halo & brighten core)
                if (proj._splitChild) {
                    const sr = (proj.size||6) + 6;
                    const sg = ctx.createRadialGradient(0,0,sr*0.25,0,0,sr);
                    sg.addColorStop(0,'#FFFAD2');
                    sg.addColorStop(0.45,'#FFDD66');
                    sg.addColorStop(1,'#FFDD6600');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = sg;
                    ctx.beginPath(); ctx.arc(0,0,sr,0,Math.PI*2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    // Inner bright core pulse
                    ctx.fillStyle = '#FFFFFF88';
                    ctx.beginPath(); ctx.arc(0,0,Math.max(2,(proj.size||6)*0.4),0,Math.PI*2); ctx.fill();
                }
                if (proj.dimensional) {
                    // swirling ring (animate via time)
                    const t = Date.now()/400;
                    ctx.strokeStyle = '#AA00FF';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4,4]);
                    ctx.beginPath();
                    ctx.arc(0,0,(proj.size||6)+6 + Math.sin(t)*2, t, t + Math.PI*1.2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                if (proj.realityBreak) {
                    // glitch squares
                    for (let g=0; g<3; g++) {
                        ctx.save();
                        ctx.rotate(Math.random()*Math.PI*2);
                        ctx.fillStyle = '#66FFFF' + (Math.random()<0.5?'AA':'55');
                        ctx.fillRect((proj.size||6)+4, -2, 4,4);
                        ctx.restore();
                    }
                }
                if (proj.quantum) {
                    // duplicate faint offset image
                    ctx.save();
                    ctx.globalAlpha = 0.35;
                    ctx.translate(3 * Math.sin(Date.now()/90), 3 * Math.cos(Date.now()/110));
                    ctx.scale(1.05,1.05);
                    ctx.fillStyle = '#66FFFF88';
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+2,0,Math.PI*2); ctx.fill();
                    ctx.restore();
                    // pulsing quantum ring (perf-aware: skip on lowFx)
                    if (!(game.perf && game.perf.lowFx)) {
                        const q = 0.5 + 0.5*Math.sin(performance.now()/180 + (proj.x+proj.y)*0.01);
                        ctx.save();
                        ctx.globalAlpha = 0.25 + 0.45*q;
                        ctx.strokeStyle = '#66FFFF';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.arc(0,0,(proj.size||6) + 4 + q*2, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                    }
                    // orbiting dots indicate remaining extra hits (if present)
                    if (typeof proj.remainingHits === 'number' && proj.remainingHits > 0) {
                        const count = Math.min(5, proj.remainingHits);
                        const rr = (proj.size||6) + 7;
                        const t = performance.now()/400;
                        ctx.save();
                        ctx.fillStyle = '#AAFFFF';
                        for (let i=0;i<count;i++) {
                            const a = t + i*(Math.PI*2/count);
                            ctx.beginPath(); ctx.arc(Math.cos(a)*rr, Math.sin(a)*rr, 1.8, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                    }
                }
                // Multi-Infusion visual: inner core gradient blended across active infusion elements
                if (proj.infusionElements && proj.infusionElements.length) {
                    const colorsMap = { fire:'#ff6a00', ice:'#55ccff', lightning:'#ffee55', poison:'#55ff55', void:'#aa55ff', wind:'#aaffdd' };
                    const coreR = (proj.size||6) * 0.9;
                    const g = ctx.createRadialGradient(0,0,0,0,0,coreR);
                    const els = proj.infusionElements.slice(0,4); // limit stops for perf
                    els.forEach((inf, idx) => {
                        const c = colorsMap[inf.type] || '#ffffff';
                        const stop = idx/(els.length);
                        g.addColorStop(Math.min(0.98, stop*0.9), c + 'AA');
                    });
                    g.addColorStop(1, baseColor + '00');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0,0,coreR,0,Math.PI*2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                // Draw by weapon type
                if (wt === 'sword') {
                    // Blade
                    ctx.fillStyle = '#d0e4ff';
                    ctx.beginPath();
                    ctx.moveTo(-6, -2);
                    ctx.lineTo(18, -1.5);
                    ctx.lineTo(20, 0);
                    ctx.lineTo(18, 1.5);
                    ctx.lineTo(-6, 2);
                    ctx.closePath();
                    ctx.fill();
                    // Edge highlight
                    ctx.strokeStyle = '#ffffffaa';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-5, -1.2);
                    ctx.lineTo(18.5, -0.4);
                    ctx.stroke();
                    // Guard & hilt
                    ctx.fillStyle = '#c09030';
                    ctx.fillRect(-7, -3.5, 3, 7);
                    ctx.fillRect(-9, -1, 4, 2);
                } else if (wt === 'axe') {
                    // Handle
                    ctx.strokeStyle = '#8b5a2b';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-10,0);
                    ctx.lineTo(10,0);
                    ctx.stroke();
                    // Head
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.moveTo(4,-8);
                    ctx.lineTo(14,-4);
                    ctx.lineTo(14,4);
                    ctx.lineTo(4,8);
                    ctx.lineTo(6,0);
                    ctx.closePath();
                    ctx.fill();
                    // Edge
                    ctx.strokeStyle = '#ffffffdd';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(13.5,-4);
                    ctx.lineTo(13.5,4);
                    ctx.stroke();
                } else if (wt === 'spear') {
                    // Shaft
                    ctx.strokeStyle = '#b07a30';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-14,0);
                    ctx.lineTo(18,0);
                    ctx.stroke();
                    // Tip
                    ctx.fillStyle = '#e0e0e0';
                    ctx.beginPath();
                    ctx.moveTo(18,0);
                    ctx.lineTo(12,-4);
                    ctx.lineTo(12,4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffffffaa';
                    ctx.beginPath();
                    ctx.moveTo(18,0);
                    ctx.lineTo(12,-3);
                    ctx.stroke();
                } else if (wt === 'hammer') {
                    // Handle
                    ctx.strokeStyle = '#7b4a1a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-14,0);
                    ctx.lineTo(10,0);
                    ctx.stroke();
                    // Head (rectangular)
                    ctx.fillStyle = '#bbbbbb';
                    ctx.fillRect(4,-6,12,12);
                    // Face highlight
                    ctx.fillStyle = '#e6e6e6';
                    ctx.fillRect(4,-6,5,12);
                } else if (wt === 'dagger') {
                    // Represent a cluster of small daggers spinning
                    const t = (Date.now()/80)%Math.PI*2;
                    for (let i=0;i<3;i++) {
                        const a = t + i*(Math.PI*2/3);
                        ctx.save();
                        ctx.rotate(a);
                        ctx.fillStyle = '#d8eaff';
                        ctx.beginPath();
                        ctx.moveTo(0,-1.5);
                        ctx.lineTo(10,-0.8);
                        ctx.lineTo(10,0.8);
                        ctx.lineTo(0,1.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    // Central core
                    ctx.fillStyle = '#c09030';
                    ctx.beginPath();
                    ctx.arc(0,0,2.5,0,Math.PI*2);
                    ctx.fill();
                } else if (wt === 'toenail') {
                    // Main projectile as a yellow crescent shard (distinct from separate Toenail crescent spawns)
                    ctx.save();
                    ctx.translate(0,0);
                    const baseR = (proj.size||8) * 1.0;
                    const thicknessRatio = 0.45;
                    const innerR = baseR * (1 - thicknessRatio);
                    const arcSweep = Math.PI*1.05;
                    const cutX = baseR * 0.35;
                    // Outer arc path
                    ctx.beginPath();
                    const startA = -arcSweep/2;
                    const endA = arcSweep/2;
                    ctx.arc(0,0,baseR,startA,endA,false);
                    // Inner reverse arc
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    // Keratin yellow gradient
                    const grad = ctx.createLinearGradient(-baseR, -baseR, baseR, baseR);
                    grad.addColorStop(0,'#FFF8D7');
                    grad.addColorStop(0.45,'#FFE684');
                    grad.addColorStop(0.75,'#F3D266');
                    grad.addColorStop(1,'#D8B850');
                    ctx.fillStyle = grad; ctx.fill();
                    // Outline
                    ctx.lineWidth = 1.2; ctx.strokeStyle = '#B3943A';
                    ctx.beginPath();
                    ctx.arc(0,0,baseR,startA,endA,false);
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                } else if (!proj.meteor) {
                    // Default (non-weapon) projectile (skip if meteor to keep it purely round)
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    const half = proj.size;
                    // Render as a rounded diamond-ish shape for slight polish vs basic square
                    ctx.moveTo(-half, 0);
                    ctx.lineTo(0, -half);
                    ctx.lineTo(half, 0);
                    ctx.lineTo(0, half);
                    ctx.closePath();
                    ctx.fill();
                    // Slalom visual cue: faint alternating chevrons showing gated turns
                    if (proj.slalomPattern) {
                        ctx.save();
                        ctx.globalAlpha = 0.45;
                        ctx.strokeStyle = baseColor + 'AA';
                        ctx.lineWidth = 1;
                        const step = 6;
                        for (let d=step; d<=24; d+=step) {
                            const s = (Math.floor(d/step)%2===0) ? 1 : -1;
                            ctx.beginPath();
                            ctx.moveTo(-d, s*half*0.4);
                            ctx.lineTo(-(d-3), s*half*0.15);
                            ctx.stroke();
                        }
                        ctx.restore();
                    }
                }
                // Meteor custom rendering (round fiery rock with craters & flame trail)
                if (proj.meteor) {
                    const mR = (proj.size || 16);
                    // Overdraw previous shape with meteor look
                    ctx.save();
                    // Core fiery gradient (center bright, edge dark rock)
                    const g = ctx.createRadialGradient(0,0,mR*0.2,0,0,mR);
                    g.addColorStop(0,'#FFE4BB');
                    g.addColorStop(0.35,'#FFAA44');
                    g.addColorStop(0.65,'#DD5511');
                    g.addColorStop(1,'#331104');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(0,0,mR,0,Math.PI*2);
                    ctx.fill();
                    // Rim glow (slight flicker)
                    ctx.strokeStyle = 'rgba(255,180,80,' + (0.35 + Math.random()*0.35).toFixed(2) + ')';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0,0,mR-1,0,Math.PI*2); ctx.stroke();
                    // Crater / scorch marks
                    for (let c=0;c<6;c++) {
                        const ca = Math.random()*Math.PI*2;
                        const cr = Math.random()*mR*0.55;
                        const r  = mR*0.12*(0.6+Math.random()*0.8);
                        ctx.fillStyle = 'rgba(0,0,0,' + (0.25+Math.random()*0.25).toFixed(2) + ')';
                        ctx.beginPath(); ctx.arc(Math.cos(ca)*cr, Math.sin(ca)*cr, r, 0, Math.PI*2); ctx.fill();
                    }
                    // Flame tongue trail (context rotated along velocity, so draw to -X)
                    for (let f=0; f<3; f++) {
                        const fx = -mR - f*mR*0.45;
                        const ry = mR*0.35*(0.9 - f*0.25);
                        ctx.fillStyle = 'rgba(255,' + (120+Math.floor(Math.random()*100)) + ',0,' + (0.25+Math.random()*0.25).toFixed(2) + ')';
                        ctx.beginPath();
                        ctx.ellipse(fx, (Math.random()-0.5)*mR*0.4, mR*0.55*(1-f*0.15), ry, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                    // Spark / ember particles (spawn behind meteor)
                    if (Math.random() < 0.5) {
                        addParticle(proj.x - proj.vx*0.2 + (Math.random()-0.5)*mR*0.6, proj.y - proj.vy*0.2 + (Math.random()-0.5)*mR*0.6, '#FFAA55', 'spark');
                    }
                }
                // Piercing arrowhead indicator
                if (proj.piercing && !wt) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.moveTo((proj.size||6)+4,0);
                    ctx.lineTo((proj.size||6)+0, -3);
                    ctx.lineTo((proj.size||6)+0, 3);
                    ctx.closePath();
                    ctx.fill();
                }
                // Homing indicator
                if (proj.homing) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-1,-1,2,2);
                }
                if (proj.weakHoming && !proj.homing) {
                    ctx.fillStyle = '#ffffffaa';
                    ctx.fillRect(-1,-1,2,2);
                }
                // Explosive ring indicator
                if (proj.explosive) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2,2]);
                    ctx.beginPath();
                    ctx.arc(0,0,(proj.size||6)+5,0,Math.PI*2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                // Remaining quantum hits (small dots)
                if (proj.hitMultipleTimes && proj.remainingHits > 0) {
                    ctx.fillStyle = '#66FFFF';
                    for (let h=0; h<proj.remainingHits; h++) {
                        ctx.beginPath(); ctx.arc(-6 - h*5, - (proj.size||6) - 4, 2, 0, Math.PI*2); ctx.fill();
                    }
                }
                ctx.restore();
            });

            // Ion Cannon charge telegraph (HUD ring near player while holding fire)
            if (game.player && game._ionChargeTime && game._ionChargeTime > 0) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const charge = Math.min(1.0, game._ionChargeTime / 80);
                const r = 18 + charge * 14;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = `rgba(150,240,255,${0.6 + 0.35*charge})`;
                ctx.lineWidth = 2 + charge * 3;
                ctx.beginPath();
                ctx.arc(px, py, r, 0, Math.PI*2);
                ctx.stroke();
                // inner glow
                const g = ctx.createRadialGradient(px, py, r*0.35, px, py, r);
                g.addColorStop(0, `rgba(120,220,255,${0.15 + 0.25*charge})`);
                g.addColorStop(1, 'rgba(120,220,255,0)');
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }

            // Render Dimensional Rift fields (soft pulsing gradient to show radius)
            if (game._dimRifts && game._dimRifts.length) {
                for (let i=0; i<game._dimRifts.length; i++) {
                    const r = game._dimRifts[i];
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const agePct = 1 - (r.life / (r.maxLife||r.life||1));
                    const pulse = 0.9 + 0.1 * Math.sin(performance.now()/260 + i*0.7);
                    const rad = r.r * pulse;
                    const alpha = 0.20 * (1 - agePct * 0.65);
                    const g = ctx.createRadialGradient(r.x, r.y, rad*0.15, r.x, r.y, rad);
                    g.addColorStop(0, `rgba(170,70,255,${(alpha*0.75).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(170,70,255,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(r.x, r.y, rad, 0, Math.PI*2); ctx.fill();
                    // Faint perimeter ring
                    if (!reduceRings) {
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, alpha * 0.9);
                        ctx.strokeStyle = 'rgba(220,180,255,0.5)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5,5]);
                        ctx.beginPath(); ctx.arc(r.x, r.y, r.r*0.9, 0, Math.PI*2); ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                    // Subtle inner swirl hint (skip on lowFx)
                    if (!lowFx) {
                        ctx.save();
                        ctx.globalAlpha = alpha * 0.4;
                        ctx.translate(r.x, r.y);
                        const t = performance.now()/800 + i;
                        ctx.rotate(t);
                        ctx.strokeStyle = 'rgba(210,190,255,0.35)';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        for (let a=0; a<=Math.PI*2; a+=Math.PI/24) {
                            const rr = (r.r*0.35) + Math.sin(a*3 + t*4) * 6;
                            const px = Math.cos(a) * rr;
                            const py = Math.sin(a) * rr;
                            if (a===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
                        }
                        ctx.closePath(); ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            // Render Time Warp fields (under projectiles but above background)
            if (game.timeWarpFields && game.timeWarpFields.length) {
                game.timeWarpFields.forEach(f => {
                    const age = Date.now() - f.createdAt;
                    const pct = age / f.duration;
                    const baseAlpha = Math.max(0, 0.35 * (1 - pct));
                    const ringR = f.radius * (0.85 + 0.15*Math.sin(f.wave*3));
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    // Outer soft glow
                    const grad = ctx.createRadialGradient(f.x, f.y, ringR*0.15, f.x, f.y, ringR);
                    grad.addColorStop(0, 'rgba(80,200,255,' + (baseAlpha*0.8).toFixed(3) + ')');
                    grad.addColorStop(1, 'rgba(80,200,255,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(f.x, f.y, ringR, 0, Math.PI*2); ctx.fill();
                    // Pulsing ring outline
                    ctx.strokeStyle = 'rgba(120,240,255,' + (baseAlpha*0.9).toFixed(3) + ')';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6,6]);
                    ctx.beginPath(); ctx.arc(f.x, f.y, ringR * (0.55 + 0.25*Math.sin(f.wave*4)), 0, Math.PI*2); ctx.stroke();
                    ctx.setLineDash([]);
                    // Brief flash at pulse beats (approximate using wave phase)
                    const beat = Math.sin(f.wave*Math.PI*2);
                    if (beat > 0.985) {
                        ctx.save();
                        ctx.globalAlpha = baseAlpha * 0.9;
                        ctx.strokeStyle = 'rgba(180,255,255,0.9)';
                        ctx.lineWidth = 3.5;
                        ctx.beginPath(); ctx.arc(f.x, f.y, ringR*0.75, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                    }
                    // Pre-pulse telegraph: a faint inner ring just before beat, skip on lowFx
                    if (!lowFx && beat > 0.9 && beat <= 0.985) {
                        ctx.save();
                        ctx.globalAlpha = baseAlpha * 0.5;
                        ctx.strokeStyle = 'rgba(160,230,255,0.6)';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.arc(f.x, f.y, ringR*0.62, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                    }
                });
            }
            
            // Render Reality Break fields (layered shimmering halo + edge highlight)
            if (game.activeRealityFields && game.activeRealityFields.length) {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const nowRB = Date.now();
                for (let i=0;i<game.activeRealityFields.length;i++) {
                    const f = game.activeRealityFields[i];
                    const tLeft = Math.max(0, f.expiresAt - nowRB);
                    const pct = 1 - (tLeft / (100)); // normalized within local span; safe default
                    const pulse = 0.9 + 0.1*Math.sin(performance.now()/280 + i*1.1);
                    const r = f.radius * pulse;
                    // Outer halo
                    const grad = ctx.createRadialGradient(f.x, f.y, r*0.2, f.x, f.y, r);
                    grad.addColorStop(0, 'rgba(120,255,255,0.24)');
                    grad.addColorStop(1, 'rgba(120,255,255,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(f.x, f.y, r, 0, Math.PI*2); ctx.fill();
                    // Edge highlight ring
                    if (!reduceRings) {
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.strokeStyle = 'rgba(180,255,255,0.6)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([3,3]);
                        ctx.beginPath(); ctx.arc(f.x, f.y, f.radius*0.96, 0, Math.PI*2); ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                    // Inner shimmer wobble (skip on lowFx)
                    if (!lowFx) {
                        ctx.save();
                        ctx.globalAlpha = 0.35;
                        ctx.strokeStyle = 'rgba(160,255,255,0.5)';
                        ctx.lineWidth = 1.25;
                        ctx.translate(f.x, f.y);
                        const t = performance.now()/700 + i*0.5;
                        ctx.rotate(Math.sin(t)*0.1);
                        ctx.beginPath();
                        for (let a=0; a<=Math.PI*2; a+=Math.PI/18) {
                            const rr = (f.radius*0.5) + Math.cos(a*5 + t*3) * 5;
                            const px = Math.cos(a) * rr;
                            const py = Math.sin(a) * rr;
                            if (a===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
                        }
                        ctx.closePath(); ctx.stroke();
                        ctx.restore();
                    }
                }
            }
            
            // Draw player with enhanced graphics (sprite sheet based)
            // Elemental Conduit visual halo (behind sprite): blend of active infusion colors
            if (game.player && game.player.infusions && game.player.infusions.length) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const baseR = 36;
                // Compute blended color once per frame using helper
                const blend = (typeof getInfusionColorBlend === 'function') ? getInfusionColorBlend() : '#ffffff';
                // Outer soft radial glow with slight pulsing
                const t = performance.now();
                const pulse = 1 + Math.sin(t/240 + (px+py)*0.01) * 0.08;
                const r = baseR * pulse;
                const g = ctx.createRadialGradient(px, py, 6, px, py, r);
                // Convert hex to rgba stops
                try {
                    const v = parseInt(blend.slice(1), 16);
                    const cr = (v>>16)&255, cg = (v>>8)&255, cb = v&255;
                    g.addColorStop(0, `rgba(${cr},${cg},${cb},0.35)`);
                    g.addColorStop(1, `rgba(${cr},${cg},${cb},0)`);
                } catch(e) {
                    g.addColorStop(0, 'rgba(255,255,255,0.25)');
                    g.addColorStop(1, 'rgba(255,255,255,0)');
                }
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
            // Terrifying Aura visual (behind player sprite)
            if (game.player && game.player.auraActive) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const t = performance.now() * 0.002;
                const baseR = 60; // matches aura contact radius
                const pulse = Math.sin(t*3) * 5;
                const rOuter = baseR + pulse;
                // Multi-layer glow for fuller circular look (less "D" shape)
                for (let layer=0; layer<3; layer++) {
                    const lr = rOuter - layer*6;
                    if (lr <= 0) continue;
                    const g = ctx.createRadialGradient(px, py, 12, px, py, lr);
                    const alphaBase = 0.22 - layer*0.06;
                    g.addColorStop(0, `rgba(185,90,255,${alphaBase})`);
                    g.addColorStop(0.5, `rgba(150,50,230,${alphaBase*0.55})`);
                    g.addColorStop(1, 'rgba(90,0,170,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(px, py, lr, 0, Math.PI*2);
                    ctx.fill();
                }
                // Soft perimeter ring
                ctx.save();
                ctx.beginPath();
                ctx.arc(px, py, rOuter-3, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(210,140,255,0.35)';
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = 14;
                ctx.shadowColor = 'rgba(200,120,255,0.6)';
                ctx.stroke();
                ctx.restore();
            }
            // Ensure player stays visible after final boss defeat (disable blink suppression)
            // forceVisibleFrames: countdown frames where player must be drawn (post-reset/death)
            if (game.player && game.player.forceVisibleFrames && game.player.forceVisibleFrames > 0) {
                game.player.forceVisibleFrames--;
            }
            const forceShowPlayer = (game._bigQuackDefeated && !game.gameOver) || (game.player && game.player.forceVisibleFrames>0);
            if (forceShowPlayer || (!game.player.invulnerable || Math.floor(Date.now() / 100) % 2)) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const meta = game.player.spriteMeta;
                const sheet = game.player.spriteSheet;
                const scale = game.player.spriteScale || 1;
                const df = game.player.directionalFrames;
                // If we are within initial forced visibility window but frames missing, retry rebuild
                if ((!df || !game.player.spriteLoaded) && game.player._pendingSpriteRetry) {
                    game.player._pendingSpriteRetry--;
                    if (typeof rebuildPlayerSprite === 'function') rebuildPlayerSprite();
                }
                let frameW, frameH, sx, sy, sourceW, sourceH, useStatic = false;
                if (df && game.player.spriteLoaded) {
                    // Choose source box based on facing
                    let facing = game.player.facing || 'down';
                    if (facing === 'left' && !df.left) facing = 'left';
                    let box = df[facing];
                    if (!box) {
                        if (facing === 'left' && df.right) {
                            box = df.right; // will mirror later
                        } else {
                            box = df.down || Object.values(df)[0];
                        }
                    }
                    if (box) {
                        sx = box.x; sy = box.y; sourceW = box.w; sourceH = box.h; frameW = sourceW; frameH = sourceH; useStatic = true;
                    }
                }
                if (!useStatic) {
                    const frameWBase = meta ? meta.frameWidth : 48;
                    const frameHBase = meta ? meta.frameHeight : 48;
                    frameW = frameWBase; frameH = frameHBase;
                }
                const drawW = frameW * scale;
                const drawH = frameH * scale;
                const yOffset = 6; // adjust to taste so feet contact ground line
                if (sheet && game.player.spriteLoaded) {
                    // Defensive: if directionalFrames lost (e.g. due to external mutation) rebuild minimal mapping once
                    if (!df && meta && !game.player._rebuildAttempted) {
                        game.player._rebuildAttempted = true;
                        // Reconstruct a single-frame fallback using first frame of sheet
                        game.player.directionalFrames = { down: { x:0, y:0, w: meta.frameWidth, h: meta.frameHeight } };
                    }
                    if (useStatic) {
                        const isLeft = (game.player.facing === 'left');
                        if (isLeft && df && df.right) {
                            // Mirror draw
                            ctx.save();
                            ctx.translate(px, py + yOffset);
                            ctx.scale(-1, 1);
                            ctx.drawImage(sheet, sx, sy, sourceW, sourceH, -drawW/2, -drawH/2, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH);
                            }
                            ctx.restore();
                        } else {
                            ctx.drawImage(sheet, sx, sy, sourceW, sourceH, px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            }
                        }
                    } else if (meta) {
                        // Fallback to grid method if directionalFrames missing
                        if (!df && forceShowPlayer) {
                            // Draw a simple placeholder circle so player is never invisible
                            ctx.save();
                            ctx.fillStyle = 'rgba(255,255,255,0.85)';
                            ctx.beginPath();
                            ctx.arc(px, py, 12, 0, Math.PI*2);
                            ctx.fill();
                            ctx.restore();
                        }
                        let rowIndex = meta.order.indexOf(game.player.facing || 'down');
                        if (rowIndex < 0) rowIndex = 0;
                        if (rowIndex >= meta.rows) rowIndex = 0;
                        let colIndex = game.player.animFrame % (meta.cols || 1);
                        if (colIndex >= meta.cols) colIndex = 0;
                        const _sx = colIndex * frameW;
                        const _sy = rowIndex * frameH;
                        if (_sx + frameW <= sheet.width && _sy + frameH <= sheet.height) {
                            ctx.drawImage(sheet, _sx, _sy, frameW, frameH, px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            }
                        } else {
                            ctx.fillStyle = '#990000';
                            ctx.fillRect(px - 12, py - 12, 24, 24);
                        }
                    }
                } else {
                    // More assertive placeholder if we're forcing visibility
                    if (forceShowPlayer) {
                        ctx.save();
                        ctx.translate(px, py);
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.55)'; // gold shimmer
                        ctx.beginPath();
                        ctx.arc(0, 0, 20, 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    } else if (!game._playerPlaceholderDrawn) {
                        // Single faint silhouette fallback (non-forced path)
                        ctx.fillStyle = 'rgba(0,0,0,0.08)';
                        ctx.beginPath();
                        ctx.arc(px, py, 18, 0, Math.PI*2);
                        ctx.fill();
                        game._playerPlaceholderDrawn = true;
                    }
                }
            }
            
            // Nuke explosion flash overlay (above scene, below damage numbers/UI)
            if (Array.isArray(game.nukes) && game.nukes.length) {
                game.nukes.forEach(n => {
                    if (!n || !n.exploded || n.flashTime <= 0 || !n._flashMax) return;
                    const p = n.flashTime / n._flashMax; // 0..1
                    const intensity = Math.pow(p, 0.6); // slower fade at start
                    const maxR = n.radius * 1.4; // expand slightly
                    const r = maxR * (1 + (1-p)*0.35);
                    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, r);
                    g.addColorStop(0, `rgba(255,255,255,${0.85*intensity})`);
                    g.addColorStop(0.25, `rgba(255,220,120,${0.55*intensity})`);
                    g.addColorStop(0.55, `rgba(255,140,0,${0.35*intensity})`);
                    g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.9*intensity;
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, r, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
            }

            // Floating damage numbers (above everything except pause/menu overlays)
            if (game.damageNumbers && game.damageNumbers.length) {
                ctx.save();
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                game.damageNumbers.forEach(dn => {
                    const alpha = Math.max(0, Math.min(1, dn.life / 60));
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = dn.color;
                    ctx.save();
                    ctx.translate(dn.x, dn.y);
                    ctx.scale(dn.scale, dn.scale);
                    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                    ctx.lineWidth = 3;
                    ctx.strokeText(dn.value, 0, 0);
                    ctx.fillText(dn.value, 0, 0);
                    ctx.restore();
                });
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            // Enemy bullets: draw last so they are always visible on top
            if (game.renderEnemyProjectilesTop) game.renderEnemyProjectilesTop(ctx);

            // Reality Break screen-space distortion: slice displacement & chromatic fringe (gated by settings)
            if (game.settings && game.settings.realityBreakOverlay && game.realityBreakDistort && game.realityBreakDistort.time > 0) {
                const d = game.realityBreakDistort;
                // Create / reuse offscreen buffer
                if (!game._distortCanvas || game._distortCanvas.width !== canvas.width || game._distortCanvas.height !== canvas.height) {
                    game._distortCanvas = document.createElement('canvas');
                    game._distortCanvas.width = canvas.width; game._distortCanvas.height = canvas.height;
                }
                const off = game._distortCanvas;
                const octx = off.getContext('2d');
                octx.clearRect(0,0,off.width,off.height);
                octx.drawImage(canvas, 0, 0);
                const slices = 12;
                for (let i=0;i<slices;i++) {
                    const sliceH = Math.ceil(canvas.height / slices);
                    const sy = i * sliceH;
                    const sh = Math.min(sliceH, canvas.height - sy);
                    const offset = Math.sin((Date.now()/140)+(i*0.9)) * 7 * d.intensity + (Math.random()-0.5)*4*d.intensity;
                    ctx.globalAlpha = 0.50;
                    ctx.drawImage(off, 0, sy, canvas.width, sh, offset, sy, canvas.width, sh);
                    // subtle inverted secondary pass for extra glitch
                    if (Math.random() < 0.08*d.intensity) {
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.12;
                        ctx.drawImage(off, 0, sy, canvas.width, sh, -offset*0.4, sy, canvas.width, sh);
                        ctx.globalCompositeOperation = 'source-over';
                    }
                }
                // Chromatic radial fringe
                ctx.globalAlpha = 0.10 + 0.18*d.intensity;
                const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width*0.65);
                g.addColorStop(0,'rgba(255,255,255,0)');
                g.addColorStop(0.6,'rgba(102,255,255,0)');
                g.addColorStop(1,'rgba(102,255,255,0.5)');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.globalAlpha = 1;
                // Decay timers
                d.time--;
                d.intensity *= 0.97; if (d.time<=0) d.intensity = 0;
            }

            // Room cleared overlay
            if (game.roomCleared) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                // Center using logical dimensions (avoid DPR inflated canvas.width causing mis-centering)
                const logicalMidX = (window.__LOGICAL_CANVAS__ ? window.__LOGICAL_CANVAS__.w : canvas.width) / 2;
                const logicalMidY = (window.__LOGICAL_CANVAS__ ? window.__LOGICAL_CANVAS__.h : canvas.height) / 2;
                ctx.strokeText('STREET CLEARED!', logicalMidX, logicalMidY - 30);
                ctx.fillText('STREET CLEARED!', logicalMidX, logicalMidY - 30);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '18px Arial';
                ctx.strokeText('Press ENTER for next street', logicalMidX, logicalMidY + 20);
                ctx.fillText('Press ENTER for next street', logicalMidX, logicalMidY + 20);

                ctx.fillStyle = '#ffff00';
                ctx.font = '14px Arial';
                ctx.strokeText(`Score: +${50 * game.dungeon}`, logicalMidX, logicalMidY + 50);
                ctx.fillText(`Score: +${50 * game.dungeon}`, logicalMidX, logicalMidY + 50);
                
                ctx.textAlign = 'left';
            }
            // Game Over overlay (draw after room cleared so it supersedes)
            if (game.gameOver) {
                const logicalW = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
                const logicalH = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || canvas.height;
                const cx = logicalW / 2;
                const cy = logicalH / 2;
                const since = performance.now() - (game._gameOverAt || performance.now());
                const fade = Math.min(1, since / 650); // slower fade to full
                // Ease (quadratic out)
                const eased = fade * (2 - fade);
                ctx.save();
                ctx.globalAlpha = 0.85 + eased * 0.10;
                if (game.gameOverImage && game.gameOverImage.complete) {
                    const iw = game.gameOverImage.width;
                    const ih = game.gameOverImage.height;
                    // Target max fractions of logical dimensions
                    const maxW = logicalW * 0.70;
                    const maxH = logicalH * 0.70;
                    let scale = Math.min(maxW / iw, maxH / ih);
                    // Intro pop scale (slightly overshoot then settle)
                    const pop = 1 + (1 - eased) * 0.25; // starts 1.25 -> 1.0
                    scale *= pop;
                    const dw = iw * scale;
                    const dh = ih * scale;
                    const dx = cx - dw / 2;
                    const dy = cy - dh / 2;
                    ctx.drawImage(game.gameOverImage, dx, dy, dw, dh);
                } else {
                    // Fallback simple text if image not yet loaded
                    ctx.fillStyle = 'rgba(0,0,0,'+(0.7+0.2*eased)+')';
                    ctx.fillRect(0,0,logicalW,logicalH);
                    ctx.fillStyle = '#FF4444';
                    const baseFont = 56;
                    ctx.font = 'bold '+Math.round(baseFont)+'px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', cx, cy);
                }
                ctx.restore();
                // Restart hint bar (slide/fade in)
                ctx.save();
                const hintFade = Math.max(0, fade - 0.35) / 0.65;
                ctx.globalAlpha = hintFade;
                const barH = 54;
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.fillRect(0, logicalH - barH, logicalW, barH);
                ctx.fillStyle = '#FFFFFF';
                const hintFont = 18 + Math.floor(2 * (1-hintFade));
                ctx.font = hintFont+'px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Press SPACE to restart', cx, logicalH - 22);
                ctx.restore();
            }
            
            ctx.restore();

            // FPS / FX overlay (debug) -- drawn after primary scene & overlays
            if (game.showFps && game.perf && typeof game.perf.fps === 'number') {
                ctx.save();
                ctx.font = '14px Courier New';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                // Extended performance HUD (toggle with F2)
                const showHud = game.perfHud; // bool set via key handler
                const lines = [];
                lines.push('FPS '+game.perf.fps.toFixed(0));
                if (showHud) {
                    const act = game.projectilePool ? game.projectilePool.active() : (game.projectiles? game.projectiles.length : 0);
                    lines.push('Proj '+act + (game.projectileDegradeTier!=null? ' T'+game.projectileDegradeTier:''));
                    if (game.collisionStats) {
                        const c = game.collisionStats;
                        const eff = c.checks? ((c.hits/c.checks)*100).toFixed(1):'0.0';
                        lines.push('Coll '+c.hits+'/'+c.checks+' '+eff+'%');
                    }
                    if (game._spatial) {
                        lines.push('Buckets '+game._spatial.buckets.size);
                    }
                    if (game.perf && game.perf.avgFrameMs) {
                        lines.push('Frame '+game.perf.avgFrameMs.toFixed(2)+'ms');
                    }
                } else {
                    lines.push('FX '+(game.perf.lowFx?'LOW':'FULL'));
                }
                const panelW = 150;
                const panelH = 8 + lines.length*16;
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.fillRect(4,4,panelW,panelH);
                for (let i=0;i<lines.length;i++){
                    let col = '#0f0';
                    if (lines[i].startsWith('FX')) col = game.perf.lowFx ? '#ffb347' : '#93d3ff';
                    else if (lines[i].startsWith('Coll')) col = '#ffd27f';
                    else if (lines[i].startsWith('Proj')) col = '#6ad3ff';
                    else if (lines[i].startsWith('Buckets')) col = '#c6a0ff';
                    else if (lines[i].startsWith('Frame')) col = '#ffa0a0';
                    ctx.fillStyle = col;
                    ctx.fillText(lines[i], 10, 8 + i*16);
                }
                ctx.restore();
            }
        }

        function updateStats() {
            let damage = 25;
            let projectileCount = 1;
            // Attack speed display now mirrors additive stacking logic used in gameplay.
            let attackSpeedBaseMult = 1; // will become (1 + sum of bonuses)
            let attackSpeedBonusSum = 0;
            let pierceCount = 0;
            let critChance = 0;
            let blockChance = 0;
            let multiShotCount = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect) {
                    if (abilityData.effect.damageBonus) damage += abilityData.effect.damageBonus;
                    if (abilityData.effect.projectileCount) multiShotCount += abilityData.effect.projectileCount;
                    if (abilityData.effect.attackSpeedMultiplier) attackSpeedBonusSum += (abilityData.effect.attackSpeedMultiplier - 1);
                    if (abilityData.effect.pierceCount) pierceCount = Math.max(pierceCount, abilityData.effect.pierceCount);
                    if (abilityData.effect.critChance) critChance = Math.max(critChance, abilityData.effect.critChance);
                    if (abilityData.effect.blockChance) blockChance = Math.max(blockChance, abilityData.effect.blockChance);
                }
            });
            if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.shotgunBlast)) {
                projectileCount = multiShotCount + 5;
            } else if (multiShotCount > 0) {
                projectileCount = multiShotCount;
            }
            // Cross Shot baseline: if owned and computed total is less than 4, display 4 to match firing behavior
            if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.crossPattern)) {
                if (projectileCount < 4) projectileCount = 4;
            }
            if (game.player.abilities.includes('Rage Mode')) {
                damage += game.totalKills * 3;
            }
            // Berserker preview: show current and potential max (+50%) when active
            if (game.player.abilities.includes('Berserker')) {
                const healthPercent = game.player.health / game.player.maxHealth;
                const currentMult = 1 + (1 - healthPercent) * 0.5;
                const currentDamage = Math.floor(damage * currentMult);
                const maxDamage = Math.floor(damage * 1.5);
                document.getElementById('statDamage').textContent = `${currentDamage} (max ${maxDamage})`;
            } else {
                document.getElementById('statDamage').textContent = damage;
            }
            document.getElementById('statProjectiles').textContent = projectileCount;
            const attackSpeed = attackSpeedBaseMult + attackSpeedBonusSum; // effective multiplier
            document.getElementById('statAttackSpeed').textContent = Math.round(attackSpeed * 100) + '%';
            document.getElementById('statPierce').textContent = pierceCount === 999 ? '' : pierceCount;
            document.getElementById('statCrit').textContent = Math.round(critChance * 100) + '%';
            document.getElementById('statBlock').textContent = Math.round(blockChance * 100) + '%';
            document.getElementById('statKills').textContent = game.totalKills;
            document.getElementById('statRooms').textContent = game.roomsCleared;
            document.getElementById('statChests').textContent = game.chestsOpened;
        }

        // Throttled UI updater: reduce DOM churn by diffing + interval gating.
        (function(){
            let lastUIUpdate = 0;
            const UI_INTERVAL = 250; // ms (4Hz)
            // Cached element references (resolved lazily on first call)
            let elHealth, elMaxHealth, elDungeon, elRoom, elScore, elProj, elHealthBar, elAura;
            // Last displayed primitive values for diffing
            let lastHealth=-1, lastMaxHealth=-1, lastDungeon, lastRoom, lastScore, lastProjText, lastHealthBarWidth=-1, lastHealthBarColor='', lastAuraText='';
            function cache() {
                if (!elHealth) {
                    elHealth = document.getElementById('health');
                    elMaxHealth = document.getElementById('maxHealth');
                    elDungeon = document.getElementById('dungeon');
                    elRoom = document.getElementById('room');
                    elScore = document.getElementById('score');
                    elProj = document.getElementById('statProjectiles');
                    elHealthBar = document.getElementById('healthBar');
                    elAura = document.getElementById('auraStatus');
                }
            }
            window.updateUI = function updateUI(){
                cache();
                // Always update health bar width immediately (player feedback critical)
                const healthPercent = (game.player.health / game.player.maxHealth) * 100;
                const widthVal = Math.max(0, healthPercent).toFixed(2) + '%';
                if (elHealthBar && widthVal !== lastHealthBarWidth) {
                    elHealthBar.style.width = widthVal;
                    lastHealthBarWidth = widthVal;
                }
                // Color only changes on band transitions; compute band key
                let colorKey;
                if (healthPercent > 60) colorKey = 'g'; else if (healthPercent > 30) colorKey = 'y'; else colorKey = 'r';
                if (elHealthBar && colorKey !== lastHealthBarColor) {
                    if (colorKey==='g') elHealthBar.style.background = 'linear-gradient(90deg, #00ff88, #00aa66)';
                    else if (colorKey==='y') elHealthBar.style.background = 'linear-gradient(90deg, #ffaa00, #ff8800)';
                    else elHealthBar.style.background = 'linear-gradient(90deg, #ff4444, #aa0000)';
                    lastHealthBarColor = colorKey;
                }

                const now = performance.now();
                if (now - lastUIUpdate < UI_INTERVAL) {
                    return; // defer non-critical DOM writes
                }
                lastUIUpdate = now;

                // Health / max health numbers (integer health rounding)
                const hVal = Math.ceil(game.player.health);
                if (elHealth && hVal !== lastHealth) { elHealth.textContent = hVal; lastHealth = hVal; }
                if (elMaxHealth && game.player.maxHealth !== lastMaxHealth) { elMaxHealth.textContent = game.player.maxHealth; lastMaxHealth = game.player.maxHealth; }

                // Dungeon / room / score
                if (elDungeon && game.dungeon !== lastDungeon) { elDungeon.textContent = game.dungeon; lastDungeon = game.dungeon; }
                if (elRoom && game.room !== lastRoom) { elRoom.textContent = game.room; lastRoom = game.room; }
                const scoreStr = game.score.toLocaleString();
                if (elScore && scoreStr !== lastScore) { elScore.textContent = scoreStr; lastScore = scoreStr; }

                // Projectile instrumentation (SoA active)
                if (game.projectilePool && elProj) {
                    const active = game.projectilePool.active ? game.projectilePool.active() : (game.projectiles? game.projectiles.length : 0);
                    const tier = game.projectileDegradeTier != null ? ` T${game.projectileDegradeTier}` : '';
                    let extra = '';
                    if (game.collisionStats) {
                        const c = game.collisionStats;
                        const eff = c.checks ? Math.round((c.hits / c.checks) * 100) : 0;
                        extra = ` (${eff}% hit)`;
                    }
                    const projText = `${active}${tier}${extra}`;
                    if (projText !== lastProjText) { elProj.textContent = projText; lastProjText = projText; }
                }

                // Stats (runs several DOM writes) - run only on throttled cycle
                updateStats();

                // Terrifying Aura status indicator
                if (elAura && game.player.abilities.includes('Terrifying Aura')) {
                    const kills = game.player.killCount || 0;
                    const nextThreshold = 25 - (kills % 25);
                    let auraText;
                    if (game.player.auraActive) {
                        let remainingRooms = 0;
                        if (game.player.auraExpireRoom) {
                            remainingRooms = game.player.auraExpireRoom - (game.room || 0);
                            if (remainingRooms < 0) remainingRooms = 0;
                        }
                        if (remainingRooms === 0) {
                            game.player.auraActive = false;
                            auraText = 'Terrifying Aura: Expired';
                        } else {
                            auraText = `Terrifying Aura ACTIVE (${remainingRooms} room${remainingRooms===1?'':'s'} left)`;
                        }
                    } else {
                        auraText = `Terrifying Aura: ${nextThreshold === 25 ? 'Ready on next 25 kills' : (nextThreshold + ' kills to activate')}`;
                    }
                    if (auraText !== lastAuraText) { elAura.textContent = auraText; lastAuraText = auraText; }
                }
            }
        })();

        function updateMinimap() {
            const minimap = document.getElementById('minimap');
            minimap.innerHTML = '<div style="position: absolute; top: 2px; left: 2px; font-size: 8px; color: #888;">District Map</div>';
            // Inject (idempotent) Potato Mode toggle button next to minimap if not present
            if (!document.getElementById('btnToggleCosmetic')) {
                const btn = document.createElement('button');
                btn.id = 'btnToggleCosmetic';
                btn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF');
                // Position the button directly to the right of the minimap (minimap is 100x75)
                // Placing inside the minimap keeps layout stable without affecting surrounding flow.
                btn.style.cssText = 'position:absolute; top:8px; left:108px; font-size:10px; padding:3px 6px; background:#222; color:#0f0; border:1px solid #444; border-radius:4px; cursor:pointer; white-space:nowrap;';
                btn.onclick = () => { game.potatoMode = !game.potatoMode; applyPotatoFxClamps(game.potatoMode); saveAudioPreferences(); btn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF'); };
                minimap.appendChild(btn);
                // After adding cosmetic FX button, append chest legend just below it to the right.
                // We'll create a container anchored relative to minimap for tight grouping.
                const legend = document.createElement('div');
                legend.id = 'chestLegend';
                // Position the legend further right (offset 188px) so it clears audio buttons region.
                legend.style.cssText = 'position:absolute; top:8px; left:220px; display:flex; flex-direction:column; gap:4px; background:rgba(0,0,0,0.55); padding:6px 8px 6px 8px; border:1px solid #333; border-radius:6px; font-size:10px; font-family:Courier New, monospace; letter-spacing:0.5px; max-width:210px;';
                legend.innerHTML = `
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #666; background:linear-gradient(#ffffff,#d9d9d9); box-shadow:0 0 3px rgba(255,255,255,0.5);"></span>
                        <span style="color:#ccc;">Platinum <span style=\"color:#888;\">(Common)</span></span>
                    </div>
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #775f00; background:linear-gradient(#ffec8a,#d6a400); box-shadow:0 0 3px rgba(255,220,120,0.4);"></span>
                        <span style="color:#ffdc72;">Gold <span style=\"color:#bfa04a;\">(Rare)</span></span>
                    </div>
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #4a6f1e; background:linear-gradient(#d2ff7a,#5e8f18); box-shadow:0 0 4px #aaff66, 0 0 6px rgba(170,255,90,0.55);"></span>
                        <span style="color:#c9ff86;">Irradiated <span style=\"color:#86c44a;\">(Epic)</span></span>
                    </div>
                `;
                minimap.appendChild(legend);
            }
            

        // === Ability Activation Notifier ===
        // Displays a transient banner once per run when key abilities first become active.
        (function abilityNotifier(){
            const shown = {};
            function showBanner(text, color) {
                let wrap = document.getElementById('abilityNotifyWrap');
                if (!wrap) {
                    wrap = document.createElement('div');
                    wrap.id = 'abilityNotifyWrap';
                    wrap.style.cssText = 'position:fixed;top:14px;left:50%;transform:translateX(-50%);z-index:12000;display:flex;flex-direction:column;gap:6px;pointer-events:none;font-family:Courier New,monospace;';
                    document.body.appendChild(wrap);
                }
                const el = document.createElement('div');
                el.textContent = text;
                el.style.cssText = 'background:rgba(0,0,0,0.70);padding:6px 14px;border:2px solid '+color+';color:'+color+';font-size:14px;letter-spacing:1px;border-radius:6px;opacity:0;transition:opacity .35s, transform .35s;transform:translateY(-6px);text-shadow:0 0 6px '+color+'33;';
                wrap.appendChild(el);
                requestAnimationFrame(()=>{ el.style.opacity='1'; el.style.transform='translateY(0)'; });
                setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(-6px)'; }, 2600);
                setTimeout(()=>{ if (el.parentElement) el.parentElement.removeChild(el); }, 3200);
            }
            setInterval(()=>{
                if (!window.game || !game.player || !Array.isArray(game.player.abilities)) return;
                if (!shown.patternAmplify && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.patternAmplify)) {
                    shown.patternAmplify = true; showBanner('SHOOTING INTENSIFIES ONLINE','#66FFC8');
                }
                if (!shown.cascadeBurst && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.cascadeBurst)) {
                    shown.cascadeBurst = true; showBanner('CASCADE BURST ARMED','#FFB866');
                }
            }, 1000);
        })();
            // Draw minimap grid
            for (let d = 1; d <= 10; d++) {
                const x = 10 + ((d - 1) % 5) * 16;
                const y = 20 + Math.floor((d - 1) / 5) * 20;
                
                const cell = document.createElement('div');
                cell.style.cssText = `
                    position: absolute; left: ${x}px; top: ${y}px;
                    width: 12px; height: 16px; border: 1px solid #333;
                    font-size: 8px; text-align: center; line-height: 16px;
                `;
                
                if (d < game.dungeon) {
                    cell.style.background = '#004400';
                    cell.style.color = '#00ff00';
                    cell.textContent = '';
                } else if (d === game.dungeon) {
                    cell.style.background = '#444400';
                    cell.style.color = '#ffff00';
                    cell.textContent = game.room + '/5';
                } else {
                    cell.style.background = '#222';
                    cell.style.color = '#666';
                    cell.textContent = d;
                }
                
                minimap.appendChild(cell);
            }
        }

        // Legacy showTitleScreen block fully removed (simplified version defined earlier in file)

        // ============ Orientation Enforcement (Mobile Landscape) ============
        (function(){
            function isTouch() { return ('ontouchstart' in window) || (navigator.maxTouchPoints>0); }
            function portraitActive() { return window.matchMedia('(orientation: portrait)').matches; }
            function ensureOverlayElement() {
                let ov = document.getElementById('orientationOverlay');
                if (!ov) {
                    ov = document.createElement('div');
                    ov.id = 'orientationOverlay';
                    ov.innerHTML = '<h1>Rotate Device</h1><p>This game is optimized for landscape. Please rotate your phone or tablet to continue playing.</p>';
                    document.body.appendChild(ov);
                }
                return ov;
            }
            function applyOrientationState(){
                const ov = ensureOverlayElement();
                if (isTouch() && portraitActive()) {
                    document.body.classList.add('enforce-landscape');
                    ov.style.display = 'flex';
                    // Soft pause while portrait
                    if (!game.paused) game._wasAutoPausedForOrientation = true;
                    game.paused = true;
                } else {
                    document.body.classList.remove('enforce-landscape');
                    ov.style.display = 'none';
                    if (game._wasAutoPausedForOrientation) {
                        game._wasAutoPausedForOrientation = false;
                        game.paused = false;
                    }
                }
            }
            window.addEventListener('orientationchange', ()=> setTimeout(applyOrientationState, 120));
            window.addEventListener('resize', ()=> applyOrientationState());
            document.addEventListener('DOMContentLoaded', ()=> setTimeout(applyOrientationState, 300));
            // Expose for manual forcing after init if needed
            window.forceOrientationCheck = applyOrientationState;
        })();
        // ====================================================================
        // THEME SYSTEM -----------------------------------------------------------
        // Each theme adjusts visuals (background gradient), obstacle weighting, enemy weighting, and elite spawn multiplier.
        const THEMES = [
            {
                key: 'neon',
                label: 'Neon District',
                gradient: ['#1a1a2e', '#301848', '#180a28'],
                obstacleWeights: { car: 1.1, dumpster: 0.8, streetlight: 1.2, barrier: 0.9 },
                enemyWeights: { GunDuck: 1.15, KnifeDuck: 0.95 },
                carTintRange: [0.95, 1.25],
                eliteMult: 1.15
            },
            {
                key: 'industrial',
                label: 'Industrial Docks',
                gradient: ['#18222c', '#2a3a42', '#0e181e'],
                obstacleWeights: { car: 0.9, dumpster: 1.3, streetlight: 0.7, barrier: 1.1 },
                enemyWeights: { KnifeDuck: 1.1 },
                carTintRange: [0.80, 1.05],
                eliteMult: 1.0
            },
            {
                key: 'financial',
                label: 'Financial Core',
                gradient: ['#1a2230', '#22384c', '#162a3e'],
                obstacleWeights: { car: 1.2, dumpster: 0.6, streetlight: 1.3, barrier: 0.8 },
                enemyWeights: { GunDuck: 1.2 },
                carTintRange: [0.9, 1.15],
                eliteMult: 1.25
            },
            {
                key: 'underpass',
                label: 'Shadow Underpass',
                gradient: ['#101014', '#181a20', '#08090c'],
                obstacleWeights: { car: 0.7, dumpster: 1.2, streetlight: 0.4, barrier: 1.3 },
                enemyWeights: { KnifeDuck: 1.15 },
                carTintRange: [0.7, 1.0],
                eliteMult: 1.3
            }
        ];

        function pickTheme(dungeon, room) {
            // Simple rotation: cycle by dungeon index with slight variation based on room
            const idx = (dungeon + Math.floor(room/3)) % THEMES.length;
            return THEMES[idx];
        }
        // NOTE: Themes influence:
        //  - Background gradient (applied each frame)
        //  - Obstacle frequency via duplication weighting (generateRoom)
        //  - Enemy spawn weighting (theme enemyWeights scaled & gated by legacy progression)
        //  - Car tint range (overrides random car tint variance)
        //  - Elite spawn multiplier (eliteMult)
        // Elite System:
        //  - Soft elites add health, speed, damage scaling without new behaviors (yet)
        //  - Visual differentiation: pre-body aura with additive glow & outline stroke
        //  - Low FX mode automatically suppresses aura composite for performance
        // Future hooks: elite ability modifiers, loot bonuses, synergy-based elite variants.
    </script>
<!-- Copilot write-check: 2025-10-09T00:00:00Z | token=write-ok-qa -->
<!-- Copilot write-check: 2025-10-08T00:00:00Z (safe to delete) -->
</body>
</html>