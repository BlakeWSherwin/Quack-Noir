<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quack Noir Test</title>
    <style>
        #bossBadge {
            display:inline-block;
            margin-left:8px;
            padding:1px 6px;
            border:1px solid #ffd700;
            border-radius:10px;
            color:#ffd700;
            font-size:10px;
            letter-spacing:0.5px;
            vertical-align:middle;
            background: rgba(255,215,0,0.04);
            font-weight:700;
        }
        #potatoBadge { display:none; padding:2px 7px; border:1px solid #6688aa; border-radius:9px; font-size:10px; letter-spacing:0.6px; font-weight:700; background:rgba(20,40,60,0.55); color:#d6e8ff; text-shadow:0 0 6px rgba(0,0,0,0.55); box-shadow:0 0 6px rgba(0,20,40,0.65); }
        .minimap {
            width: 100px;
            height: 75px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            border-radius: 4px;
            margin-top: 15px;
            position: relative;
        }
        /* Stats panel rows */
        .stat-row { display:flex; justify-content:flex-start; align-items:center; gap:6px; margin:4px 0 2px; padding:1px 0 3px; border-bottom:1px solid #222; flex-wrap:wrap; }
        .stat-label { color:#ccc; font-size:11px; letter-spacing:0.5px; min-width:72px; }
        .stat-value { color:#00ff88; font-weight:bold; font-size:11px; text-shadow:0 0 3px #004422; }
        #abilities > div:first-child { font-weight:bold; margin-bottom:4px; color:#ffdd55; text-shadow:0 0 6px #664400; }
        #abilities { font-family:'Courier New', monospace; }
        .tooltip {
            position: fixed;
            display: none;
            max-width: 320px;
            padding: 10px 12px;
            border-radius: 8px;
            background: rgba(6,6,6,0.94);
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.45;
            box-shadow: 0 9px 22px rgba(0,0,0,0.55);
            pointer-events: none;
            z-index: 2050;
        }
        .tooltip.show { display:block; }
        .tooltip .ability-name {
            font-size: 13px;
            margin-bottom: 6px;
            color: #ffffff;
        }
        .tooltip .ability-desc {
            color: #ffffff;
            font-weight: 400;
        }
        .badge-new {
            display:inline-block;
            margin-left:4px;
            padding:1px 6px 0px;
            border-radius:6px;
            border:1px solid #ffcc33;
            background:rgba(255,215,0,0.15);
            color:#ffdf70;
            font-size:10px;
            letter-spacing:1px;
        }
    html, body { margin:0; padding:0; background:#000; overflow-x:hidden; overflow-y:hidden; min-height:100%; }
    /* Compact mode adjustments for small scale */
    body.compact-ui #ui { padding:6px 8px !important; }
    body.compact-ui #abilities { padding:6px 8px !important; }
    body.compact-ui .stat-row { margin:4px 0 2px; }
    body.compact-ui .stat-label { font-size:10px; }
    body.compact-ui .stat-value { font-size:10px; }
    /* Allow internal scrolling of right panel when viewport height is limited */
    #statsPanelWrapper {
        max-height: calc(100vh - 8px);
        overflow-y: auto;
        overflow-x: hidden;
        background: linear-gradient(180deg, rgba(12,12,18,0.94), rgba(4,4,8,0.9));
        border-radius: 12px;
        border: 1px solid rgba(0,0,0,0.7);
        box-shadow: 0 0 18px rgba(0,0,0,0.55);
        padding: 10px;
    }
    /* Responsive: when body has class panel-below, stack panel under canvas full width */
    body.panel-below #gameSection { flex-direction: column !important; align-items:center !important; }
    body.panel-below #statsPanelWrapper { width:100% !important; max-width:860px; display:flex; flex-direction:row; flex-wrap:wrap; justify-content:space-between; }
    body.panel-below #ui, body.panel-below #abilities { width: calc(50% - 12px); min-width:300px; }
    @media (max-width: 900px) {
        body.panel-below #ui, body.panel-below #abilities { width:100%; }
    }
    #gameSection { gap: 12px !important; }
    #gameCanvas { border: 3px solid #333; box-shadow:0 0 12px rgba(255,160,80,0.25); background:#000; border-radius:6px; }
    #gameContainer { position:relative; }
    /* Reserve space under canvas for HUD; HUD itself will sit below without causing scroll */
    #ui { margin-top:4px; }
        /* Tighten spacing under minimap/sound buttons */
        #gameSection { margin-bottom:0; }
        /* Reduce top margin on minimap to reclaim vertical space */
        .minimap { margin-top: 4px; }
    </style>
</head>
<body>
    <div id="launchCurtain"></div>
                        <div id="gameSection" style="display:flex; flex-direction:row; align-items:flex-start; justify-content:center; gap:12px; margin:6px auto; padding:0; width:fit-content;">
                            <!-- Left: Scaled game canvas column -->
                            <div id="gameOuter" style="position: relative; display: flex; flex-direction: column; align-items: flex-start;">
                                <div id="gameContainer" style="position: relative;">
                                    <canvas id="gameCanvas" width="640" height="480"></canvas>
                                    <div id="abilityTooltip" class="tooltip">
                                        <div id="tooltipName" class="ability-name"></div>
                                        <div id="tooltipDesc" class="ability-desc"></div>
                                    </div>
                                </div>
                            </div>
                            <!-- Right: Side panel (health HUD on top, stats below) -->
                            <div id="statsPanelWrapper" style="position: relative; display: flex; flex-direction: column; align-items: stretch; gap: 8px; margin-left:0; width: 210px; box-sizing:border-box; overflow-x:hidden;">
                                <div id="ui" style="background: rgba(0,0,0,0.88); padding: 8px 10px; border-radius: 8px; width:100%; box-shadow:0 0 10px rgba(0,0,0,0.65); color:#f5f5f5;">
                                    <div style="display:flex; align-items:center; justify-content:flex-start; gap:8px; margin-bottom:6px;">
                                        <div style="font-weight:bold; color:#ffdd55; letter-spacing:0.5px;">Status</div>
                                        <div id="potatoBadge" title="Reduced FX active">LOW FX</div>
                                    </div>
                                    <div style="margin:2px 0;">Health: <span id="health"></span> / <span id="maxHealth"></span></div>
                                    <div style="margin:2px 0;">District: <span id="dungeon"></span> | Street: <span id="room"></span></div>
                                    <div style="margin:2px 0;">Score: <span id="score"></span></div>
                                    <div class="progress-bar" style="margin-top:8px; margin-bottom:6px; height:10px;"><div id="healthBar" class="progress-fill" style="width:100%; height:100%"></div></div>
                                    <div id="chestLegend" style="margin-top:2px;font-size:11px;color:#ffdd55;letter-spacing:0.5px;">Chests: <span id="statChests" style="color:#ffd700"></span></div>
                                </div>
                                <div id="abilities" style="width:100%; background:rgba(0,0,0,0.78); padding:8px 10px; border-radius:8px; box-shadow:0 0 8px rgba(0,0,0,0.55);">
                                    <div style="font-weight:bold; margin-bottom:6px; color:#00ff88; letter-spacing:0.5px;">Stats:</div>
                                    <div class="stat-row"><span class="stat-label">Damage</span><span id="statDamage" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Projectiles</span><span id="statProjectiles" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Attack Speed</span><span id="statAttackSpeed" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Pierce</span><span id="statPierce" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Crit</span><span id="statCrit" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Block</span><span id="statBlock" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Kills</span><span id="statKills" class="stat-value"></span></div>
                                    <div class="stat-row"><span class="stat-label">Rooms</span><span id="statRooms" class="stat-value"></span></div>
                                </div>
                            </div>
                        </div>
                        <!-- Pause overlay with tabbed submenus -->
                        <div id="pauseOverlay" style="display:none; position:fixed; inset:0; z-index:10050; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); pointer-events:auto;">
                            <div id="pauseMenu" style="background:#111;border:2px solid #444;border-radius:10px;padding:16px;box-shadow:0 12px 34px rgba(0,0,0,0.6);width:min(860px,90vw);max-height:85vh;overflow:auto;">
                                <h2 style="margin-top:0;color:#00ff88;">Paused</h2>
                                <div style="display:flex; gap:12px; margin-bottom:14px;">
                                    <button id="tabAbilities" data-tab="abilities" style="flex:1;padding:8px 10px;background:#111;border:2px solid #00ff88;color:#00ff88;border-radius:6px;cursor:pointer;font-family:'Courier New', monospace;">Abilities</button>
                                    <button id="tabAchievements" data-tab="achievements" style="flex:1;padding:8px 10px;background:#111;border:2px solid #444;color:#aaa;border-radius:6px;cursor:pointer;font-family:'Courier New', monospace;">Achievements</button>
                                    <button id="tabOptions" data-tab="options" style="flex:1;padding:8px 10px;background:#111;border:2px solid #444;color:#aaa;border-radius:6px;cursor:pointer;font-family:'Courier New', monospace;">Options</button>
                                </div>
                                <div id="pauseTabContent" style="width:100%; min-height:260px;">
                                    <div id="pauseAbilities" class="ability-grid" style="text-align:left; width:100%;"></div>
                                    <div id="pauseAchievements" style="display:none; text-align:left; width:100%; max-height:55vh; overflow:auto; padding-right:6px;"></div>
                                    <div id="pauseOptions" style="display:none; text-align:left; width:100%;">
                                        <div style="display:flex; flex-direction:column; gap:10px;">
                                            <button id="optToggleSfx" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle SFX</button>
                                            <button id="optToggleMusic" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle Music</button>
                                            <button id="optToggleCosmetic" style="padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:'Courier New', monospace;cursor:pointer;">Toggle Potato Mode</button>
                                            <button id="optResetProgress" style="padding:8px 12px;background:#330000;border:2px solid #aa4444;color:#ff8080;font-family:'Courier New', monospace;cursor:pointer;">Reset Progress</button>
                                            <button id="optQuitToTitle" style="padding:8px 12px;background:#1c1c1c;border:2px solid #996633;color:#ffddaa;font-family:'Courier New', monospace;cursor:pointer;">Quit to Title</button>
                                        </div>
                                    </div>
                                </div>
                                <div style="margin-top:14px;color:#ccc;font-size:12px;">Press P to resume</div>
                            </div>
                        </div>
        <!-- ...existing HTML for game UI, canvas, etc... -->
    <script>
    // Ensure canvas visible early.
    // Ensure unlockActII is available as an early stub to avoid ReferenceErrors
    // (will be overwritten by the full implementation later in the file)
    try {
        if (typeof window.unlockActII !== 'function') {
            window.unlockActII = function(source) {
                // Early stub: record the attempt and also perform a minimal local update so UI reflects progress
                try { window._unlockActIIQueue = window._unlockActIIQueue || []; } catch(_) {}
                try { window._unlockActIIQueue.push(source || 'early-stub'); } catch(_) {}
                try { if (!window.game) window.game = {}; } catch(_){ }
                try { game._actIIUnlocked = true; } catch(_){ }
                try { if (localStorage && localStorage.setItem) localStorage.setItem('actIIUnlocked', '1'); } catch(_){ }
                try { if (localStorage && localStorage.setItem) localStorage.setItem('lastUnlockEvent', JSON.stringify({ ts: Date.now(), source: source || 'early-stub' })); } catch(_){ }
                try { console.info('[Progress-stub] Act II unlocked (early stub)', source || 'early-stub'); } catch(_){ }
                try { if (typeof showToast === 'function') showToast('Act II unlocked!'); } catch(_){ }
                try { const menu = document.getElementById('titleActMenu'); if (menu && typeof menu._refresh === 'function') menu._refresh(); } catch(_){ }
            };
        }
        } catch(_){ }
        if (typeof window.safeUnlockActII !== 'function') {
            window._unlockActIIQueue = window._unlockActIIQueue || [];
            window._safeUnlockActII_flushing = false;
            window.safeUnlockActII = function(source){
                try {
                    // If authoritative handler is present and not the early stub, call it
                    if (typeof window.unlockActII === 'function' && window._safeUnlockActII_flushing === false) {
                        try { window.unlockActII(source); return; } catch(e) { /* fallthrough to queue */ }
                    }
                } catch(_){}
                try { window._unlockActIIQueue.push(source || 'queued'); } catch(_){}
            };
            window._flushUnlockActIIQueue = function(){
                try {
                    if (!window._unlockActIIQueue || window._unlockActIIQueue.length === 0) return;
                    if (window._safeUnlockActII_flushing) return;
                    window._safeUnlockActII_flushing = true;
                    const q = window._unlockActIIQueue.slice(); window._unlockActIIQueue.length = 0;
                    for (let i=0;i<q.length;i++){
                        try { if (typeof window.unlockActII === 'function') window.unlockActII(q[i]); } catch(e) { try { console.warn('[safeUnlock] queued unlock failed', e); } catch(_){} }
                    }
                } catch(_){}
                try { window._safeUnlockActII_flushing = false; } catch(_){}
            };
        }
        // Also provide a safe queued helper for Act III unlock attempts so early calls
        // (before authoritative unlockActIII is parsed) are buffered.
        if (typeof window.safeUnlockActIII !== 'function') {
            window._unlockActIIIQueue = window._unlockActIIIQueue || [];
            window._safeUnlockActIII_flushing = false;
            window.safeUnlockActIII = function(source){
                try {
                    if (typeof window.unlockActIII === 'function' && window._safeUnlockActIII_flushing === false) {
                        try { window.unlockActIII(source); return; } catch(e) { /* fallthrough to queue */ }
                    }
                } catch(_){ }
                try { window._unlockActIIIQueue.push(source || 'queued'); } catch(_){ }
            };
            window._flushUnlockActIIIQueue = function(){
                try {
                    if (!window._unlockActIIIQueue || window._unlockActIIIQueue.length === 0) return;
                    if (window._safeUnlockActIII_flushing) return;
                    window._safeUnlockActIII_flushing = true;
                    const q = window._unlockActIIIQueue.slice(); window._unlockActIIIQueue.length = 0;
                    for (let i=0;i<q.length;i++){
                        try { if (typeof window.unlockActIII === 'function') window.unlockActIII(q[i]); } catch(e) { try { console.warn('[safeUnlockIII] queued unlock failed', e); } catch(_){} }
                    }
                } catch(_){ }
                try { window._safeUnlockActIII_flushing = false; } catch(_){ }
            };
        }
    // Dev: write-access verified 2025-10-06
    // Dev: write-access check OK (assistant) 2025-10-06
    // Dev: write-access re-verified (assistant) 2025-10-07
    document.addEventListener('DOMContentLoaded', ()=> {
            const cv = document.getElementById('gameCanvas');
            if (cv) { cv.style.display='block'; cv.style.visibility='visible'; }
            // Preload car obstacle images
            const carImgH = new Image();
            carImgH.onload = ()=>{ carImgH._ok = true; };
            carImgH.onerror = ()=>{ console.warn('[CarImage] Failed to load assets/cars/car-horizontal.png'); carImgH._broken = true; };
            carImgH.src = 'assets/cars/car-horizontal.png';
            const carImgV = new Image();
            carImgV.onload = ()=>{ carImgV._ok = true; };
            carImgV.onerror = ()=>{ console.warn('[CarImage] Failed to load assets/cars/car-front.png'); carImgV._broken = true; };
            carImgV.src = 'assets/cars/car-front.png';
            window._carObstacleImages = { h: carImgH, v: carImgV };

            // Preload barrier obstacle image (replaces procedural barrier art)
            const barrierImg = new Image();
            barrierImg.onload = ()=>{ barrierImg._ok = true; };
            barrierImg.onerror = ()=>{ console.warn('[BarrierImage] Failed to load assets/barrier.png'); barrierImg._broken = true; };
            barrierImg.src = 'assets/barrier.png';
            window._barrierImage = barrierImg;

            // Rare melee enemy: The Quacken (8x4 spritesheet)
            try {
                window.game = window.game || {};
                game.enemySprites = game.enemySprites || {};
                if (!game.enemySprites.quacken) {
                    const layout = { columns: 8, rows: 4 };
                    const qqImg = new Image();
                    const container = { image: qqImg, loaded: false, sheetLayout: layout };
                    game.enemySprites.quacken = container;
                    try { game.enemySprites['The Quacken'] = container; } catch(_){ }

                    const assignFrames = (img) => {
                        if (!img) return;
                        const totalW = img.naturalWidth || img.width || 0;
                        const totalH = img.naturalHeight || img.height || 0;
                        if (!(totalW > 0 && totalH > 0)) return;
                        const stepX = totalW / layout.columns;
                        const stepY = totalH / layout.rows;
                        const seq = [];
                        for (let row = 0; row < layout.rows; row++) {
                            for (let col = 0; col < layout.columns; col++) {
                                const x1 = Math.round(col * stepX);
                                const y1 = Math.round(row * stepY);
                                const x2 = Math.round((col + 1) * stepX);
                                const y2 = Math.round((row + 1) * stepY);
                                seq.push({ x: x1, y: y1, w: x2 - x1, h: y2 - y1 });
                            }
                        }
                        const reference = seq[0] || { x: 0, y: 0, w: Math.round(stepX) || totalW, h: Math.round(stepY) || totalH };
                        container.frames = container.frames || {};
                        container.frames.seq = seq;
                        container.frames.columns = layout.columns;
                        container.frames.rows = layout.rows;
                        container.frames.frameWidth = reference.w;
                        container.frames.frameHeight = reference.h;
                        container.frames.right = reference;
                        container.frames.left = reference;
                        container.frames.down = reference;
                        container.frames.up = reference;
                        container.anim = container.anim || {};
                        container.anim.frames = seq;
                        container.anim.frameStep = container.anim.frameStep || 6;
                        container.anim.loop = true;
                        container.anim.columns = layout.columns;
                        container.anim.rows = layout.rows;
                        container.anim.frameCount = seq.length;
                        const refH = reference.h || (totalH / Math.max(1, layout.rows)) || 1;
                        container.baseScaleForSize = (size)=> ((size * 2) / refH);
                        container.computeHitbox = (enemy)=> {
                            const enemySize = enemy && enemy.size ? enemy.size : 52;
                            const scale = container.baseScaleForSize ? container.baseScaleForSize(enemySize) : ((enemySize * 2) / refH);
                            const drawW = reference.w * scale;
                            const drawH = reference.h * scale;
                            const hitW = drawW * 0.68;
                            const hitH = drawH * 0.74;
                            return { w: hitW, h: hitH, ox: -hitW / 2, oy: -hitH / 2 + drawH * 0.04 };
                        };
                        container.drawOffsetY = container.drawOffsetY || 0;
                    };

                    qqImg.onload = function(ev){
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            assignFrames(img);
                            container.loaded = true;
                            container.image = img;
                            if (typeof createImageBitmap === 'function' && img && img.complete && (img.naturalWidth || img.width)) {
                                createImageBitmap(img).then(bitmap => {
                                    try { container._forcedBitmap = bitmap; } catch(_){}
                                }).catch(e => { console.warn('[QuackenSprite] createImageBitmap failed', e); });
                            }
                            console.info('[QuackenSprite] Loaded assets/quacken-sheet.png', { width: img.naturalWidth || img.width, height: img.naturalHeight || img.height });
                        } catch(err) {
                            console.warn('[QuackenSprite] onload processing failed', err);
                        }
                    };
                    qqImg.onerror = function(ev){ console.warn('[QuackenSprite] failed to load assets/quacken-sheet.png', ev); };
                    try {
                        const resolved = new URL('assets/quacken-sheet.png', document.baseURI).href;
                        qqImg.src = resolved;
                    } catch(_){ qqImg.src = 'assets/quacken-sheet.png'; }
                }
            } catch(err) {
                console.warn('[QuackenSprite] initialization error', err);
            }

            // Preload bullet sprites
            window._bulletImages = window._bulletImages || {};
            const WUNDER_SCRIBBLE_GIF_BASE64 = (
'R0lGODlhpgCLAPQAAOUCE+YCE+gCE+kCE+oCE+sCE+wCE+0CFO4CFO8CFPACFPECFPMCFPQCFPUCFPYCFPcCFPgCFPkCFfoCFfsCFfwCFf0CFf8cLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkFABgAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAApgCLAAAF/iAmjmRpnmiqrmzrvnAsz3Rtq9Ot73zvrxPGb0gsGlE54XHJbM6UCKd0SiUpDdWstjgYYbfg7AVABtS6omh4TRuTxyz0CB67kNTsfItsKp8mDyh8L3IYgXqIKXgoDEoiOYoIiyqOj4mXJYcskBgWKZqaOCWemJihmzmkJ6GnJpwjqqWIky0TsSOSiwaVJryGspdmMQ+vGIPCIoOCvTXIwD3OL0KvdsnOANUn0Ri+L9vPN9kwV8LO4hjncye0Lung4U8kdubm7t9fMd/vNu4svBfi6IgQSOKejH77aiAEUkLZPGzCCKJbly/hD32b+sgDWHDiQBTsUmC02GxGMQyF/sxEU5kMRSuRI0nOCLniliEoahblxMDOpqJuMm28ZOFzAiARh0BBInbC56qTPKDmeUB1xFCiJqgmRToiR46hTksc/QFobKkoktLMsJlLrQhHadOaCIuLpw8EX2jqKacMBlSWxkaUM9a36wrAO5QVLpUNYExXJ6rZyRYRHWJLKibzIPgYETKIMfC1ZHnN42DDKebxWHmJgVkTlLEtLCE68ODPoz+i1tbyBraCnbU8GKAP928XpU2XVnkag9RqwVOfm80misTex48f7mh6OkvNmBvq3r5uW/QwA1TDHoibBXR51uSRDsyNd+/U2rtCpZ5owAADhWD3WUxopBRfR4N1/tGKHDFdxpUJ/gX1SyMlRCEEXAgAxdUpO91hV32BFKOJhmpNwsBLVxEBiFYpvnDUKV/9YpVRSDiXCVKvEKMJjbG8IpUlZtH4RxYsElOWUFqRECOMQmbSylYz7mjjbjLWWFV4Yv2YBQO56KWCJAbgwaUQJhJzS5gmdFiiFVLWlcKFONUoSxmLsUCnYA4aYlQo3zAnGH0i7IIloBrRp0+Tz5RxQYB2upEMeErmcFw/iKkkThfFIMTXdW8FBcAArrVYwhgcEZbOAwYwx6kZdPiZDKjioSBZfiUwalGoqfI3EKmWQggapxPdZiis3BVaqjbnmaqrFKmic+xhjl73G0er/r4HmBmuqWMfrfB544csrQLbUHYBwvEGaAWZayh9kGDEanG68prsFoo9KwgfA4TyUHzP8nEtMjTaOhGwwZ0bFHEDxgFrkwNEgYYfx8xnjBx7LvMtcAoDKLBFcvGU4QpMWcDJIWS6xaXHaNnliMhQoYVXmpskKaFLoVSMhAWe0CikzFfq+BUknOBs01dXKqmC0IjO7JKIr8HSyYqBgLLjIS8CKQIpTBf9SDErGmUUXUqn6UuGvJDCZZiivTwCl112qgQpobTtIS5pNUJh2DPU6Z8jh9B5TV9+D3LilHxdlrDfeIejj2uS7upqYHTwGt/CHzkGaKvvTjZv4pHViUGu/rbJ65ExjrlhLqyasDp6OaX/ybkP3OIJnbVzSO5nqOxZCpqi6b5OhOetO/qGaYSVAyogxAFkOUQXj+c7EceLp/sgkX8HEaYPIMD8udeJ+7wPDzhSmePM7W7bW0YhkB6dppfq/fdDqI8SntZ86y9zDRuZvX8ar7S5713qUiMyFCZJkEhmbskF21xGtsF5BRCNoAqZXtYx+M3FayzT0h8wiDSvec0qhvBZWahyFK8IjWVbWwqLLDgXlmnNJCeEmlZkKEISssiDtsDZUn7BFCX1kIUmKGAuhJihIgrQbiioTRoUyDaUjelEXpMgXohIRLIF0IARtMWeKghEGJjnfsXz/tve9Ncsf2GsD81DVuC6uILYBIR38sLG8SagPeW5TjCaih1+0MVGPGbHYKSTnORwRatveO94omqIvSzIPT7CZ3tuQOQX+tIPy6kAdF58n4Rypbw8/QmSZEAkGjQHKVk9ppNe/J8exoBI7fVmIRCBg+ScgyrXzVIFeoRNLguVkDguqhXjQ6Pu3CBHKDxsVIvkZQuSaZ85BS6NtZofGgkTRhGMESnq60Jt7qSCCHnrMRt7ARYJ2JYZCHGAcgNZfe6AFnS27UJmQsqJXoiHIqrghy742CdmcMN7ejCGWSoS0PBJlBwlRUc6ck4JhaTDB4rIhynC2TCkosEh3YCGTyKo/guSYhamRDFqIXoEKUR2UFY85Spg+wOMZjJFAdrTCllk2d3ols4ZNKyearNnPSvBiQGWSE1pamBWWMoNEtkAcSiBIi4L57l7FQ5Q5asfCXrYBYj5qUHXpF8+VCmDps7BXaRKQRBYZcnVWUMzEqFRRMIakc4sKlQMkE1ZR6WoPzKBOpqU3W+iRzpKPoo9qjFjVwKBDF5Vz0WnIGVd23iEBv0vkqHqgnoMRT1nBes+hmiWbqK6yyAmp6tFGElnnfoqIaBqWpulXiybgwzCIgg63IOBHUcXg3AeVSLZa8dqTcet8qH2NmG9jzMwyR5q9pV0W83rCYzqm18CQn3EZF4n/ssX3BQ8bFPq4UNjSCAH6xSWPrOKbXJN4oTn8g9Az/TqUK0pvTXe8UGB8OaBoIonaPpKq35RGiQGVxcxsa2JtIBb1OjGTm5UcIBQ1CGLuqFAF6RUFljrxFSldgqfkQBrQLPKSgccqRqMsCYSytmD9BSllzi0gyMDoVg4KhaJ1sBISZNwUETmhSV6wULd6EYOwHTF5YppgzvIoi1m9gq+fLI4SQRcGJ+JXxJoto84oAZyP6K6Zq5HHKilqy8RqQRmQtm06TLOlNcjK+d58nHSfFQjoTwCOTBou+dbhilpK9hRYTZbgoiubBg5N4+0CrNkvjKW4xwrgqSoeYblXDq2/ped9yqzvbbsU0G6G5NVxVJC+hCecMmzLcngMTIlqARe7YsOvr4DI12Qb3tEYl36JezRCm2zbet7qP0BgyZQWqdb3rTPTlVQn6FWqYrFabduJDILP6KxjKvEbIs6u9k4Wu8fMEyDHLo4xmyQiot7NmGGuORGkAn3t0fs4YpqISTKPtmuP7QCoNCCHTm+ZE68hOlv73hdxeqmnGPF7zbbqTmKflMSKofMPZQZ1HQNNC6LmziEEGuStDUuY61sZ0VCaA8Ar7cg0JA68yBn3xS3TDSRQ1alUWp+1DiHeh2trdTYORrM7Z1yE4EROJzii94I+aOrTKU9lPIdefzcziOe/hmdP3qyU8pHdcFRHDPYKkAr5+4JZo1ZYRTC3Gp8B00utAoO0XuqqxCnFTrVcxhw8RJXOdKzeZhfcdeCExm+GhCHUhWoNI3DLpL2C6jmtEG9LiR1c0klUjYMmMlADStbG/yQrA/XflIGvvif040GaLxRSlzWcd28GLWsaY6d6GEz5C6xQBlCEQLWvqn8zDI9kkOUfnOM4urBOw+MPs3G9ZulwT+I8HMJuYM/uIdcDXghe1YXfw2SZgHugwn5fl8E9AlJvrfVcEwanILqNKh+UN7t4A2RvdrgLkLJgnKSY8vYK35ve9nJAu13tALr5wfFDWJh/he3/xmT+Hrf76b/oKP1+QhnlyjOlxHsVnxF5gRRtxfdkl9x5TwetoB3RXtgsGr5pVnHd4BSMFpsMGgycBQZZ3+qZwSelAhwVhIS2GsnmHopOAWORAMjyE8OiICmFww8kB4+AAkrqDhshn0uAAk8OAQJyGZ5V3/x039CiBXwVwRNc4Q0IGJhsIRMWHgxxwQBGIUbNYNaEIRWaHF5cHxs5oXQsIWJA4ZiuAWzEQIAIfkECQUAGAAsAAAAAKYAiwAABf4gJo5kaZ5oqq5s675wLM90bd94ru987//AoHBILBqPyKRyyWw6n9CodEqtWq/YrHbL7Xq/4LB4TC6bz+i0es1uu9/wuHxOr5MVvcfDDq1Mdn9/fE97LQ+CKIWFg04ILI4YeCeFBoxMAJgYACubIp0li5+YmZkmo5+WMxciq6imI64TiBe0AKust7cYF7Ykrqkvnau6J6ifew8Itr+anp7EI9DALqLNJ9C8AAUKgsy8sLQo0mzLO8Tf17ujrSW/m52lxXKf6Deo7KzL9c2okCTDmnqlGLfGVTh7/2pVa4cKEaxmt5ixmlOgmEQXBQqcsvawHQmHIioGdIbi4ppFJv4QSHqhRwFKDAgM+INZQsFKDBVAibg5k0TPOCBLyHpZooLRnCMc7nHIVIQgpEkxyCJBVERVOFeFopQ1AapOqnqiWo3qVSqGsCOuBp3zE4VKmy16qoS00h9cqjAriUDA98RNPiZHeTLZEVYpeCREpjUQ750pwvMs/nu2Qlo5x4Y/KtP1zuC0whN9qQuZlWM0TQcnripwaE+5Ya4g1xGFTbSICld/hUsNbxM3DBpHCgRtiDFBM5hLQEPFOJ1HgcI2bTtbafeuzC20KYB6HDlBV9OjeTYBMCBsp67ZLUQtbjjxNftsC/U42dcmXuji/cGT31mt6/+4R8Jf5Jj2nlMlZP4EWm+NpWWWP3oJRlJAJq2lhj8qpYRCUHWNAMlcNGV4VldSLfKATTzBdFcKU8XxUlAWwogMguhZFYhUT0HVIlgWzjcHUSD1uBYyiwSCTCAt5sQVWlYxucKOcrTVE4EenhDTCJLw1ReKTnW1nyNagukClXBI1GAKzJDCYEcuCcJYPAaWJBt8Kqzn3GmY6ILfYL3gMYECAso2Z4F1RlSnfagB1Bl+2hwyIXucdBeHbPiUlNl9iS6TJybhcSRpaMAIqo0KhkbHaDbXxaPYp/FZMihrhUKkz6zqrFZlnMoNKsenA/aYiUKtvMPoMWYBKOdnr7zgR1Ub8cNgcjjShCayVv7GkFNYLeEh5ocwhRmJiDgte2K2CoTJF4pzaYmiHiTO0SOOsiBlFFdcFXvWUocMpUe+XB1VVpM1/OtGVY7S66+++06wb8JTtWbWjUbhZEJVSyrMcL9HDRXHWzaZy+Vtf4ogU7d7qThXuX2J2KaDe31oLgxeFdDWGKfASaEryzpCCp+CHcZPSCvzLOEMQelqhaav6JPSTbSktst/+3wjbCRSAeo0DeDS90U2lg3TX4DkNSY1fsvVChw3D+iFa3atnuZF2hedgk9v42i6Z7CmlopqiewZPfRAXGwj8DO0Yda2yE/vpimcwq4D9Fmnfap0C7w6cbh5Je2pQnqO7Sl2L/5cL8OawqKJsqnmwWhhs3iQbcpiJIptakuwxET3iwIFZCM7DpUvsbpVM6P5t42kA5dRcBQ+VrNiOyW4NkvBQ9FWV4OjcFfKWBZs8VkoltuyTy9T/RWW0soQsRZbQQlDvuyOiLGOOClc/Fj5JiWI+vaiV9pH/XYhv6M5sJj8kpSUfY3oRSg5UrR8BIr9MSImYeqeurp3CKO0BAEyMxcEz4Uude2EKG0ZGSPeVLM0NaYUflLYm5zRGcZZYxQFMEDQHoUoO0wgeuAwoS0EBxOBSG120tDTr6j2JyAeiw7volB3YNMJuLXiPCOZTC9A14mgMKodvTODE08nIEs1Y3SuMf4PFQ3EGUyNCnL1UQc9spiKqfmGdEC8YmFqhyngjIB5BpIQGwcROtKcxRH5sUweR2PHksknV6ijVn2EER7ccSaK4qFPJmR4R+UUymh0QExIQJY2kShoMO9BTEUAWEgaSkaRfSEZ1Sr4h4WJr0qO+ItdRgSVl5CpBKmcxo3QUq9wKSlekyiEUsRCPbGMpQXzs8SNitfLg7FMJwU7Jo1ycr4XuQB/dYjl97w3lmstQoS32glcZrISJY1AbeVjwYrsgBg1VXIpJIGWO2wmEjctCAZ4jMzPykGS36gmM99B3S1mASpjuQCdk5oIpr6WTzhdDkBSo5EaTaOrfLoBMV4bTv4rLHqP3/0MlPm7jzHwOYfCyRE1Hk1NRJOFiuksIiKPpMYc9HSdlV7miBhlaWJKpDZhHPJQ+pwbdNDxnY+mSmufgMQfcocZemSnpHwCZQs3eYLYPeeQnVBqYhR0piPGYSXg3Fb5yFQIPMhSfD/BgzBN0DEtgdND56pDK5mEpBkZcz6ISCB61vIHap6glZBj1/8GQaQiwQuNd8WLiRgYI3lNQhBrTQX2WsbBKaXgSj6pCdVmdj8rYSidgElOs+ThRa2BVCKAJS0LLaG5q5VWOQQpmylxhMNIDsJUc0rT887BGWj8QRkueOhFifoCaUQIqHV022IG1cVdKZcF0HhpZfQAFBu86AqTyJnttHbikNbRVD7pgcEeyeDTGOwwWUAtKFVhUpHr0sGTPLAoQ346IshVRL7AUGse1JnOtvgBjQ604W188K68fuSvLUqigBHLg9I0RaJCMTCy9lBbGiA0s7gkn18+O40wAiFuqpWvz4DxB+wWd7vk0W4+nvcjFuNAIktU8YqViYEL+6Bu0y3la/mQzCAIkgXSUaQJFKwDd8j0lkIWgm5eUBEiJ7kHzDMaPJ98hBRZK39UFoKEzVe9LO/XySj4r5eHkMsanGjMXfAomqng2jW7+c1wjrOc50znOtv5znjOs573zOc++/nPgA70nEMAACH5BAkFABgALAAAAACmAIsAAAX+ICaOZGmeaKqubOu60PTOdG3foozvKyIyvKBweGIAiUPASIlsOmsM3fPGvEyvWFQ0S7NimNzwFQgRs7xfs7pJXqPQaLcc154vSXG7HibyhfMieYB7hCkyZVkDA2AkjIyFkCgVIohBMSaIRyR+I5yRnyWTGFI7MqI5UqQYlSOsoK+iqjcTpKSuqyWyr2qakiO9NkYxtBOsnhjHyLt2AI8mOkzOLQCKI9Aizo/Sy2aDJDpeF9tvzRhWWyNWgibj3FzerXfiL0rqGAMn2Sbw7lztlfXMtfACQJy0co3Y9WMGr5I9fuaiRby3T+AdbIEW2uFnYEnAFI7mUcRzMY3Fdhr+s4g8wQnhtpBg8JHE2MwexpRzxlXCh+8gwjRgenla9OUnSpxZkuUgAQFIMgRCEXhihQhCGQZSpfZBqkfXqG+HSpSpZPWrtRGxWlkly7UrCillcVFaGmNsLhGiqMaV23YOsHh9Oirb+mPrMUS0XGnt1FePNJk3JWJTQtkEEFrsjDZeUfDKz5lfrHwUWNMiiQHo8FTOuPlNoM5OBqGBDQaM6BOoS9RcbbJ1vka5iXxmnVFk7dsmIL9ejbyEOIgLS1u7hYOac5LzGNnUrbzg9uYXoacUB1mpDeu601F2RFx9+YK8V2Ij6LsIZtg8BriyXS9OZUdKyDQBAj31hp9pvdX+hwmB1exw2Wki9MSbRLUxcVkxFHVXW0IKsmCVEeaxMMEpczlFmDKa+ABVKyOGxddgMMbYoYdrrTVDBSRiVpdcVtli1ygjTnIKiWWx4lVfR4q1ClXFYKaCkJT8WBUuPuogA2anULXkXQr6YIQwKXCCgGDIHJHVYqHgMiaZfpy5yWBQMRADjh8SeKZUBpyJ1V99OTMMA4tIVlKCkw1ApgwSbghUM4w2GiAGcqbnEXs3+SYfkAx4d8GlRQ1agn7FALHppvBpqllEyCmH4DyzSVoffJCy85wzcKwAgQGlPhfRaNGEg42qcdCHYKUaQRecrLCChp9BqF1TD6zlVHFRtCP+pVMSbxzidGByo9xSoXaUGSQNrhnBJ+5HtLEG7Gt30NrYtiNARq5qqs3aKiYd0acOo/ZKO1G1Jg0njXiQ7NZrEfQ2Muqz0Qp7lqhLiLbweslmB3CB2gFyFCiMFuUoU8mRiUKjAccjhUwSdkotxRHG2glPCWnz20JYqZgVmF4Z0cOdsZZBolw1DzAminB6+aWWfLVZQopSAcHnJ3BdsmOQKez1FiWYmcLlkjUuqcOP1uCII1pLzcWijVuDUleTNRIzjNgYYkKdWlg7qSTXNg7zlStOVuC22YDbfUKSy+wpZ5ATgGhAniUwnsKXRiBOQkc2Y0D5iipiAqRZa5ZQuQr+wBSDZ55nkn5zzWjysgUEgTracacj4xOpCLhG4/rHhFJUhrMee/wSo4ocnjgCuE9jBy2ckGrQxAYpZA4+givf3/L+Ogc9OKbVRGqp5nJ/QbOEg0TwFWUk2/2zyt+bBhkih9ZZaZsOexGGq51v7nOzwmtD/ITcmmsjjUqf90xSDKK8hiAk01VmWrEI6uWPXwok1v445YZmUWQ2eZCOegzWLP+Nql8BTJZuqBEF1mlqVrBzjgjPs7F3yAwmuhFJOOBzLO6Fi1/dy9+sOkg8QICHQ+aix3Bysg3RPIJ/9fLIOUI1kePEr1SoGmC3+FQ90OBBPyNrXsFUABlVpTBgP5n+HTIUYQCikOx2JIsQAv50DEVl6y3Du0eDPhEiwLjMcyBams7w4jdcfKhmjDtdm6Yyp6/JqSlYORGknkYCHCUObZ+Y2zPoJje2oEJITrpSjTaJtrisDQOnSEWUNqkCYvwMFXHrHx9A9g26yUJs3SoSJ+PiokziBWSuGMsw2NajS8BAkmaoo+eGqcg+pM4UoiPQ5aQiNEEO8ge785wXHdeJO8XpcKc0gTD9MQNtDDFghnrQZM44md7dTncjTKfvWlCM2qHRMTXQWEUidixzLIxVuxKXDPllweIojFQzao8LtDMs9ZXQfcvqmHcWqkXysC9X5guoteJZKeOURF5QHKH+9ryzq/cFB1cOzKhEx6fOmFWKCe20p0JwiMJyMOuggWgOxSj4rhbGTBDxucdBuXfTHELUodAIlgSjSFNtdWFQ26kJ9MowAAzGlFUs9R74CHSdjenTi9GhRzr/AzysQSoZ54zW7VAjNQaR6ZseSgxVacZIxhQBTSuaiyOb8seaWa5NOrvTnmwkhUM6ZZstoCuIACuHEalgbofoGjGC5EgfzaVIe+tlYmgBS2skBpg72GT41FBZVuKNbcVoW9YcOcpZtq0ua0msKRpLlq5lYbJWs4PiTDe6yiUSGXHygd5OJpjFmG6wWmmaMCibzDwF8nJqaFoYmhG8P7XumywzUHP+7bYh3NnudbLTG+zQeE4kuM67+gziCAwQhcRhR3vUE1S4OpipD/6vZPNJF/gyZU9BNO91D/xeCdt7T/QarAn6VAEKZ5YehuqQhiUE6W6+gyBY6Wqp+Livf2LKUFAMWHxo9dQ4CQqUFCLCOA/U4L4YttR50cZhoXngHkbFmQieITMTKteuIBU3/sHLp+EloQzydcDIqHAyWkwuSlzsAh+6dKL/6gz0IgNdm6xnX60QzMqMKBv+9JMLXkHvDbyIrpMi0CJMHGc+VlKF9Z7GYuEwIjlyMSCsIkEKZVSETVXQRpdMq0KQUYWhcncqj1WDFYrAmEe+CBxtztEJiWmrDVT+sUfaESZzZfoGkeRyDLiSYK+3jAciK+0l84iRKY1eSI5UAbZUGilHZgmcWUhNDLKVLbS3kNrcxjY4SO6CSLnki6ktm+qviYWWZbOsLzPNoy21UtaSyOYoN7sGEqXO0X7YY1YKU7a4tA+32P6L04BRid5ajpou0xMKIFDHZxNCCgcxEE2ItTtE6ENlBzn0SWnyugR1NR9z1oMmilgroGznB6nMYMx8coFrO8wm4srM99bsDpmQGySSeRahrmzvGHqDhs47SXuQCJzUXGcZSoDpCYzDUYlxixS2UQgFRVPPecP3gM5I8JiXseQUIPA42cDiTA4CZRWGfOQunzChV9H+QAKrbQUEgQO8rLCu3AnkITD0eHisJR8MaiPIg/7EtSWFxHrLY12/q6gSg/3xVv0EEDqflNH1IO8FGgVbJvFioEc2qGjkOcsV7zNYAG1AAO4h1FpAhuO0Aoxo/wWYnkg8iDTRR5bE6K9uPQEkoZIMRZ8b1lECnFyulDbNtVIsglO2H4+NGBEJDhPMdoMu/Vh6wFipkUni2zOGDcojxVaTZC9lbD8PCtIpg5piOhHjX9S4p+jx08AEN7Yh/YIxmZuwZnhdGt0Yk7JtvZyu+hWkut0Ogf2HCt+NxBPn02/qW27fb5BNOmsuP7+v1Om+kY4IBRUsmeGb7hEbycOLGpr+mZO0WAHhMLySfZbjGi9BL90xdMYDf30yQ8QxGjj1KQaIf+xyR/V1Az+0GcSDfeDiKf8mI+tmc/lngb2zPwCzGUeAEAKHVBJERe03UWEEYxhIgn1BbjBTcXUXL0vjPCixHnZ0Gn1HA59WH1exCZzANJfWeeHWA4vUSJYBeC8QTR3SeJkHOLegCj/ja7ayCqSQTZxnA1BChEaia7mXamfBSpiVA7SXTZAFhqKHFEPDGEpDgzRICt7WAnHihI4Hgi6QSpvBHhGXAqrCCoLCGZ+RZfnmeR3iK74CEsSUPUKkhENVA4kIcu3CgALVEgKFdI8wN/pzVJbid0fxCFKGZNP+kAeS9H9AF4rssjH6gGKnuIMMtwOq+Ang0kIaA4sD0YkqUIklxRVXp1UU2E3OECIcB35twWUz4GYFSAPU4llrt2VccQvQ9wuSZwMrEjoqoHw20BQ4kYWpx3uoMAtS6GpVIwSntww/k4alxEeZ1XrENm7sSCOiNjlBYFg8EFe9ED7VGCb96AYoFwmMoAlpmGHEyA29UItikIC96IuysgsMSXNvlEVCwH85EWU0o2GrGAQG6QZgEI76ppHRSAUCaY04cQ1r4JDeFQjMuAw60JJToJBN8ChIwocS5XiW5w5+eJPjlo5cQYU8OW4dApJBWZRGeZRImZRKuZRM2ZRO+ZQDNxACACH5BAkFABgALAAAAACmAIsAAAX+ICaOZGmeaKqubOu+cCzPdG3feK7vfO//wKBwSCwaXZejcrkEADCXpwxwiTKv2BMV80zGnCJpdnz1cq0vsMhMbhfB1HhazHXbiU+1k54q8Pl3gTsJGAokCQqGKg0NJoSCkDoNFBiUI5OTKhYnjZGeNp2VJBSTliaknJ+qM48Yra4JhIolpiWvq7grdLt6o7UkgLnCJbskVlJisyZsw80jf8ZydQAFKcHOwsx0VVDAutjggLtRXtIozODCgGbHSVLoz+nYwWJwaGtaR1XX8vEqBiiQcdlTopqtgDFCaSE4rIGCWLdQIEqh8NCIRIVclVCGoeKIiCoUZDqRKBY4U4z+VlD6JYLlpZYdLVWstSnVi5WnLFDYKW+mxxE4aS1qWerlKBE1TfxEwfPXTkYunUWcaEKRsqgfC5lsdatR0oMuHs2yoBNjP2ILTTwBCFPXHjVhNi7lpzauAZGVOJ6Ne64YBoBYo3Xz+3EukjBqFAQ+S/dekgKKlz57p82b3m4syMGltpcF3YF1IIsACSVPncp8PX5ec+zM6s51MtfJ5Kcu6C1oMWcsAW8EOWB8FHyFnXuFFcUa2Zjpgtsbs1rX4txrHgby4s6fpUykYAjNttNq0ZlCR4VbadfALxgkroJfsgY6OxWYDxy0baEi1vthOM00Ys7stQCSIYmItFIneB3+kgBAU4FUUyOMiMTRQ49UiMhlzuxEFlnXtfVSLRRsuFOISVEClVKinMChhkphAhMmkjXjEikxetjJLzXR6GJHHaUElEwmbKgTCindSAoqxGH4l0koWJXVUaQ89JcBEEFEAkcXilRKVEzKEotZTHam5H9pefNjXHAg89aab53CEUN5sOkfbDWyxgd5Z0JRjhVVeMHOFuLtpidmSUQhzW8BIukZN+6oVQCEjyBTaC+I8nVUAtK8s8dyvRHHlgvl6VbdCAbZE0ec8ATX0S153DOoOm9p1qmZnj0znQiKGNBFaZPClQ+pKVIm3WTzSCfHqa4KpgJ5cwb7n2bZkSBaGIb+OuHda8PIuilkZRVgqDV98UGJtwOhuk97Z7REAabVbkEdLvPJiW1LD9FnwH7yblbdtBnNRx9BcFjzBGQIJkBfvPPaEWOBUrrAiEPKVFnSl60o0tTDKZUEy2iOMDwCWT0W4lA6PLHwcGBO0XiCjkc2tWIlPGVSpIeVnGgJJSCPqNORJ5eCCc8tdzgEjNe1jF8JUCUNFFBbllxzkaikZMpToQRN4oh1tiAk1Vn/QOWXZnESoghLWYmrxlcSSOJHX1tpIcMUZhnTSmgDUeWCpOHR5ikNfEqrmv/5KkoDmJabZr6IYUBfKQoAlHAObF6x7SzlLUcMM8dYa5AlfULbp7X+vMU5miHc+TaGrFiQUvga74J3Hkmqu6st6LoJFEc1isbmRqVNGDqpd7aC6rux/IVabaN6PT5Eskpw6i4YaMwqgq6d87rmb5mftx5vWUCrvA/NbmpO60RFetqpxs6umXX3+eC9tpH42qdrtG/DLXfexgr68Pujf8FdO2GX/ipnLfG9734C5E8zAFIbwRkuTtQgWIryo7gHAqxNeViPiQzmr+0FKCFXIs3d5HYjEkQIVwb42sY29iVBYWBIIazSB10wNZn46Ck8I9uIkOKLwbHsZzEpSlGOQkQdnmiGQbpERZKGw1PojGlkg9DDYLalp/3oK4qSDNa6Bg5D4E1Bd9P+S9hIlBJCgA0WTCoQ3mRBIKR8pUIueEjYxFRBNUUucLojW810hUHRAY4/9LmErhL3uALcZS/r2pVmXhUQVwmHEpVb5PwGcyx2HNIYfvpeIXYypk8gaXi8O4HzREM4ZAGKP+RQDrBydx7yweBUwkAO9ZjTgmA8ihSzxM2xrJXKelhhPYOMBvNosMhPYIIQk5SNozBBvc8Bp4DwG4wHzeMbBeLgW4GgBnJWB6rwOMEQfbPjdIqZufUlrxjm0IGxxgC6R35BLe3cBOWAMT/0uaYcOsSfd/ykrGho7pEJLGBA0qk3xd2Fi/6YjBPmowgLhGJ7EOyj6CqIIFIhLF9rmoL+WxzIgzTO8QW3aOEcYcgjjk1PhnEDG0Y0pCOHOESGo0sp2FzKUo/kjSSIQGgLbjTEGIBIaiNxI5Rq8bOiAm1EY1saJ34CRKYglUZQhQrQfqYhkOEgZkFJiEJQgSSarKilPSMKkGICs6omhak1Y0nQaKGyNmBkQSaNwSsKJKgCSdUUYeJYxcCkkYat7aVUaltcCyHGRExiZ9m0Tx7T8Ew5mdAUgptof2IzsM3h0i8YXZNBEsFJOwi0mhpFTLWMIS1nsaEL1Dxfa6CwOd+YR1/LCAYnXXmETPFqBscjHx1wpxHd4bMY5fAPKf2Gnno0kh6+YwIqBzMDWHKUD9YJhRj+JrXYRg3EDMwMBjazQ491FiFZuoQB6qyZ0NlwLzb49MY2xBC73hBEeorDEPGCMEzTgapVpnEPMPiFGUlZynTKEUMpF3u516guXATFQbRaQK7r8jIFp/0L9zRlX9LmUT1Osi6C4au4Tg0vB4FEl0oU4a9pfGMg1eAIAxP333jslnQWkFI1bqoHjhbEg8TYmwx8tIJOvjCKGOttChQhCz1eqWAWqcpgR0IjJw35FRdaAcRUAJGG0VBoKKtJjm5msq5OUKkvJKpNQPTjsuZoKSZKWVKJdB2psmA4KkCZUGtm5DhXjWYw0yHSmOIhS2zCRCUNNH6WsiGKYHmHN1ASOG/+NjIhPznJEyIycUWIKyIiKa8DehKRKHQCs+HBGiFWFHfzODCkscWB+tVdKILpK3oQa6OR1aR4BzqKUMwqvPalAyTxsQxw5XE8tppur2nVgs+picPEhCcbIsPrc1iYL2awhGSJXZxogxYf0Wvf62Kwj3OB73J5rEZN3EMY3Ylh3ARucW7YazoK36Y4pY3E7xL6BCL3ZdjQvoit3CtiVfN6TwLBHEng3AbmtaqCgr42vC2HcGohxDiWkm6+JfUdIuUCm7zNsa+bLQWI9ga+YliPIoTdjeWUeyM4FoQackq2BYX44eam4CXy9hopzEI+6g2fQFSQcjc0zK5rC0uSM8L+kdJJpAWz4HLCvcggW5hRyjolAo+/DAOUPLYEhbY4C6a2NJZASF0mDGqchUYEVtJgq10nwZ+H0gJT5CjhLwIzj5zG9jH4GKT6/kjRSdrpOH5M3yBpOq64QqAEPXov5eaDzPrNAg2iCSGEgQt8TtwP45ZXz2NCtm46UShwrbfF3OGH5j3B8G3nx94bZzCwFCvKxb5DlM8dfWKbbXrFdYK48G78k2wMYHCL3tXzoLc29JN61ccjtc5eSM9ZJ/BmkNzhCnd07nfqj5r3oZb1awY7eh+8vLc+BsrQsHGucfdgy1q59Da3ByXzPVMsv/h1niFXsqKMj2Llpin4SvmHrnb+JAaa66EgdjykdTJQIjPAEgTXGQGoVEayMhRBA2dFAwg4Q7NQgSaVV3IHFgXIfzCgF2Q3DDtHWSyGIr9ydpcHA+sXIM/3eulWaSU4A7Mge+d1gpVnKdtXX9JXYazwbDMAUewRgn8yK7hHe82lgzAIbJ2RXryWYAXxgjTwfKBghOmghP3VgppGbcmmbjtohdrHcTzYJE6YhVyIglrYDKXyN0KHhTVgEO8XA2zYD07mgjlIgC6EAxW1A18nD4BmQnimEn14A1y3A1mFDY3wC4UoA2aXA50QdVIGd7nwdI4QCGyBf6ywf9l0fkoQgjvAe/7XPGV4A5zYiUbQLDyAg6IvaASmCIqneDqYSHmr+EGt+IqyOIu0WIu2eIu4mIu6uIu82Iu++IvAGIzCOIw1EAIAOw=='
);
            const decodeBase64ToUint8Array = (str) => {
                if (!str) return null;
                const clean = String(str).replace(/[\r\n\s]+/g, '');
                try {
                    let binary;
                    if (typeof atob === 'function') {
                        binary = atob(clean);
                    } else if (typeof Buffer !== 'undefined' && Buffer.from) {
                        binary = Buffer.from(clean, 'base64').toString('binary');
                    } else {
                        return null;
                    }
                    const len = binary.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i) & 0xFF;
                    return bytes;
                } catch(_){ return null; }
            };
            const toenailImg = new Image();
            toenailImg.onload = ()=>{ toenailImg._ok = true; };
            toenailImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/toenail_clibbins.png'); toenailImg._broken = true; };
            toenailImg.src = 'assets/bullets/toenail_clibbins.png';
            window._bulletImages.toenail = toenailImg;
            const bloom1Img = new Image(); bloom1Img.onload = ()=>{ bloom1Img._ok = true; }; bloom1Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom1.png'); bloom1Img._broken = true; };
            bloom1Img.src = 'assets/bullets/bloom1.png'; window._bulletImages.bloom1 = bloom1Img;
            const bloom2Img = new Image(); bloom2Img.onload = ()=>{ bloom2Img._ok = true; }; bloom2Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom2.png'); bloom2Img._broken = true; };
            bloom2Img.src = 'assets/bullets/bloom2.png'; window._bulletImages.bloom2 = bloom2Img;
            const bloom3Img = new Image(); bloom3Img.onload = ()=>{ bloom3Img._ok = true; }; bloom3Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom3.png'); bloom3Img._broken = true; };
            bloom3Img.src = 'assets/bullets/bloom3.png'; window._bulletImages.bloom3 = bloom3Img;
            const bloom4Img = new Image(); bloom4Img.onload = ()=>{ bloom4Img._ok = true; }; bloom4Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom4.png'); bloom4Img._broken = true; };
            bloom4Img.src = 'assets/bullets/bloom4.png'; window._bulletImages.bloom4 = bloom4Img;
            const bloom5Img = new Image(); bloom5Img.onload = ()=>{ bloom5Img._ok = true; }; bloom5Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom5.png'); bloom5Img._broken = true; };
            bloom5Img.src = 'assets/bullets/bloom5.png'; window._bulletImages.bloom5 = bloom5Img;
            const bloom6Img = new Image(); bloom6Img.onload = ()=>{ bloom6Img._ok = true; }; bloom6Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bloom6.png'); bloom6Img._broken = true; };
            bloom6Img.src = 'assets/bullets/bloom6.png'; window._bulletImages.bloom6 = bloom6Img;
            // Swan laser sprite (Act III ranged enemies)
            const swanLaserImg = new Image();
            swanLaserImg.onload = ()=>{ swanLaserImg._ok = true; };
            swanLaserImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/swanlaser.png'); swanLaserImg._broken = true; };
            swanLaserImg.src = 'assets/bullets/swanlaser.png';
            window._bulletImages.swanlaser = swanLaserImg;
            // Golden tooth sprite (unlocked by defeating Golden Goose)
            // Defer actual network load until the ability is granted to avoid startup IO overhead.
            const goldToothImg = new Image();
            goldToothImg.onload = ()=>{ goldToothImg._ok = true; };
            goldToothImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/goldtooth.png'); goldToothImg._broken = true; };
            goldToothImg._deferredSrc = 'assets/bullets/goldtooth.png';
            // helper to lazily start loading the gold tooth image
            window._bulletImages.goldtooth = goldToothImg;
            window._bulletImages.loadGoldTooth = function(){ try { if (goldToothImg && !goldToothImg.src) goldToothImg.src = goldToothImg._deferredSrc; } catch(_){} };
            // Wunder Doodle sprite (unlocked by defeating Wunderswan). Defer load until discovered.
            const wunderImg = new Image();
            wunderImg.onload = ()=>{ wunderImg._ok = true; };
            wunderImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/wunderdoodle.png'); wunderImg._broken = true; };
            wunderImg._deferredSrc = 'assets/bullets/wunderdoodle.png';
            window._bulletImages.wunderdoodle = wunderImg;
            window._bulletImages.loadWunderDoodle = function(){ try { if (wunderImg && !wunderImg.src) wunderImg.src = wunderImg._deferredSrc; } catch(_){} };
            // Floating scribble marker (Wunder Doodle DoT overlay). Load on demand with the ability.
            const wunderScribbleImg = new Image();
            wunderScribbleImg.onload = ()=>{ wunderScribbleImg._ok = true; };
            wunderScribbleImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/scribsheet.png'); wunderScribbleImg._broken = true; };
            wunderScribbleImg._deferredSrc = 'assets/bullets/scribsheet.png';
            wunderScribbleImg._ensurePinnedSize = function(){
                try {
                    if (wunderScribbleImg._domPinned) {
                        const w = wunderScribbleImg.naturalWidth || wunderScribbleImg.width || 64;
                        const h = wunderScribbleImg.naturalHeight || wunderScribbleImg.height || 64;
                        wunderScribbleImg.style.width = w + 'px';
                        wunderScribbleImg.style.height = h + 'px';
                    }
                } catch(_){ }
            };
            const WUNDER_SCRIBBLE_SHEET_RECTS = [
                { x:0, y:0, w:176, h:149 },
                { x:176, y:0, w:176, h:149 },
                { x:352, y:0, w:176, h:149 },
                { x:528, y:0, w:176, h:149 },
                { x:704, y:0, w:176, h:149 },
                { x:0, y:149, w:176, h:149 }
            ];
            const WUNDER_SCRIBBLE_FRAME_DURATION = 80;
            const buildWunderScribbleFramesFromSheet = () => {
                try {
                    if (!window._bulletImages) return false;
                    const existing = window._bulletImages.wunderScribbleAnim;
                    if (existing && existing.frames && existing.frames.length && !existing._fallback) {
                        return true;
                    }
                    if (!wunderScribbleImg || !wunderScribbleImg.complete || wunderScribbleImg._broken) return false;
                    const frames = [];
                    for (let i = 0; i < WUNDER_SCRIBBLE_SHEET_RECTS.length; i++) {
                        const rect = WUNDER_SCRIBBLE_SHEET_RECTS[i];
                        const frame = { width: rect.w, height: rect.h, duration: WUNDER_SCRIBBLE_FRAME_DURATION };
                        const canvas = (typeof OffscreenCanvas !== 'undefined') ? new OffscreenCanvas(rect.w, rect.h) : (typeof document !== 'undefined' ? document.createElement('canvas') : null);
                        if (canvas) {
                            if (!canvas.width || canvas.width !== rect.w) canvas.width = rect.w;
                            if (!canvas.height || canvas.height !== rect.h) canvas.height = rect.h;
                            const ctx = canvas.getContext('2d', { alpha: true });
                            if (ctx) {
                                ctx.clearRect(0, 0, rect.w, rect.h);
                                ctx.drawImage(wunderScribbleImg, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
                                frame.canvas = canvas;
                            }
                        }
                            if (frame && img) {
                                const referenceHeight = gs.referenceHeight || frame.h || 1;
                                const referenceWidth = gs.referenceWidth || frame.w || 1;
                                const baseScale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/Math.max(1, referenceHeight));
                                const drawW = referenceWidth * baseScale;
                                const drawH = referenceHeight * baseScale;
                                const anchorRatioX = (typeof frame.anchorRatioX === 'number') ? frame.anchorRatioX : 0.5;
                                const anchorRatioY = (typeof frame.anchorRatioY === 'number') ? frame.anchorRatioY : 0.5;
                                const anchorRefX = anchorRatioX;
                                const anchorRefY = anchorRatioY;
                                const destX = -drawW * anchorRefX;
                                const destY = -drawH * anchorRefY;
                                const playerX = (game && game.player && typeof game.player.x === 'number') ? game.player.x : enemy.x;
                                const spriteCenterX = enemy.x + drawW * (0.5 - anchorRefX);
                }
            };
            wunderScribbleImg.addEventListener('load', () => {
                try { wunderScribbleImg._ensurePinnedSize(); } catch(_){ }
                buildWunderScribbleFramesFromSheet();
            });
            window._bulletImages.wunderScribble = wunderScribbleImg;
                                const drawX = flipLeft ? (-(destX + drawW)) : destX;
                                const sourceBitmap = frame.bitmap;
                                const sourceCanvas = frame.canvas;
                                if (sourceBitmap) {
                                    ctx.drawImage(sourceBitmap, drawX, destY, drawW, drawH);
                                } else if (sourceCanvas) {
                                    ctx.drawImage(sourceCanvas, drawX, destY, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, drawX, destY, drawW, drawH);
                                }
                    const ensureFallbackAnim = () => {
                        if (!window._bulletImages) return;
                        const existing = window._bulletImages.wunderScribbleAnim;
                        if (existing && !existing._fallback) return;
                        const steps = 16;
                        const frames = [];
                        let total = 0;
                        for (let i = 0; i < steps; i++) {
                            const duration = 55;
                            total += duration;
                            const rot = (i / steps) * Math.PI * 2;
                            const scale = 0.92 + 0.14 * Math.sin(i * 0.85);
                            const jitterMag = 3 + Math.sin(i * 1.6) * 2.8;
                            frames.push({ duration, transform: { rotation: rot, scale, jitterX: Math.cos(rot * 1.2) * jitterMag, jitterY: Math.sin(rot * 0.8) * jitterMag } });
                        }
                        window._bulletImages.wunderScribbleAnim = { frames, totalDuration: total, _fallback: true };
                    };

                    ensureFallbackAnim();

                    if (wunderScribbleImg && !wunderScribbleImg.src) {
                        wunderScribbleImg.src = wunderScribbleImg._deferredSrc;
                    }
                    if (!wunderScribbleImg._domPinned && typeof document !== 'undefined') {
                        const attach = () => {
                            try {
                                if (!wunderScribbleImg._domPinned && document && document.body) {
                                    wunderScribbleImg.style.position = 'absolute';
                                    wunderScribbleImg.style.left = '-9999px';
                                    wunderScribbleImg.style.top = '-9999px';
                                    wunderScribbleImg.style.visibility = 'visible';
                                    wunderScribbleImg.style.opacity = '0';
                                    wunderScribbleImg.style.pointerEvents = 'none';
                                    document.body.appendChild(wunderScribbleImg);
                                    wunderScribbleImg._domPinned = true;
                                    wunderScribbleImg._ensurePinnedSize();
                                    try { wunderScribbleImg.decode && wunderScribbleImg.decode().catch(()=>{}); } catch(_){ }
                                }
                            } catch(_){ }
                        };
                        if (!wunderScribbleImg._domListener) {
                            wunderScribbleImg._domListener = true;
                            if (document.readyState === 'loading') {
                                document.addEventListener('DOMContentLoaded', attach, { once: true });
                            } else {
                                attach();
                            }
                        }
                    }
                    if (!buildWunderScribbleFramesFromSheet()) {
                        ensureFallbackAnim();
                    }
                } catch(_){ }
            };
            // Quacken tentacle projectile sprite (deferred to first use/unlock)
            const quackenTentacleImg = new Image();
            quackenTentacleImg.onload = ()=>{ quackenTentacleImg._ok = true; };
            quackenTentacleImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/tentacle.png'); quackenTentacleImg._broken = true; };
            quackenTentacleImg._deferredSrc = 'assets/bullets/tentacle.png';
            window._bulletImages.quackenTentacle = quackenTentacleImg;
            window._bulletImages.loadQuackenTentacle = function(){
                try {
                    if (quackenTentacleImg && !quackenTentacleImg.src) {
                        quackenTentacleImg.src = quackenTentacleImg._deferredSrc;
                    }
                    if (!quackenTentacleImg._domPinned && typeof document !== 'undefined') {
                        const attach = () => {
                            try {
                                if (!quackenTentacleImg._domPinned && document && document.body) {
                                    quackenTentacleImg.style.position = 'absolute';
                                    quackenTentacleImg.style.left = '-9999px';
                                    quackenTentacleImg.style.top = '-9999px';
                                    quackenTentacleImg.style.visibility = 'hidden';
                                    quackenTentacleImg.style.pointerEvents = 'none';
                                    document.body.appendChild(quackenTentacleImg);
                                    quackenTentacleImg._domPinned = true;
                                }
                            } catch(_){ }
                        };
                        if (!quackenTentacleImg._domListener) {
                            quackenTentacleImg._domListener = true;
                            if (document.readyState === 'loading') {
                                document.addEventListener('DOMContentLoaded', attach, { once: true });
                            } else {
                                attach();
                            }
                        }
                    }
                } catch(_){ }
            };
            // Global hook invoked when abilities are added to the player (central spot for asset preloads)
            window._onAbilityAdded = function(name){
                try {
                    if (!name) return;
                    // If Gooster Teeth is discovered/granted in any pathway, start loading its sprite so it's ready when used.
                    if (String(name) === 'Gooster Teeth') {
                        if (window._bulletImages && typeof window._bulletImages.loadGoldTooth === 'function') {
                            try { window._bulletImages.loadGoldTooth(); } catch(_){ }
                        }
                    }
                    if (String(name) === 'Wunder Doodle') {
                        if (window._bulletImages && typeof window._bulletImages.loadWunderDoodle === 'function') {
                            try { window._bulletImages.loadWunderDoodle(); } catch(_){ }
                        }
                        if (window._bulletImages && typeof window._bulletImages.loadWunderScribble === 'function') {
                            try { window._bulletImages.loadWunderScribble(); } catch(_){ }
                        }
                    }
                    if (String(name) === 'Release the Quacken!') {
                        if (window._bulletImages && typeof window._bulletImages.loadQuackenTentacle === 'function') {
                            try { window._bulletImages.loadQuackenTentacle(); } catch(_){ }
                        }
                    }
                } catch(_){ }
            };
            // Preload laser firing SFX for Act III enemy lasers
            try {
                window._sfx = window._sfx || {};
                const laserSfx = new Audio('assets/audio/laser-45816.mp3');
                laserSfx.preload = 'auto';
                laserSfx.volume = 0.45;
                // some browsers require load() to start fetching
                try { laserSfx.load(); } catch(_) {}
                window._sfx.laser_fire = laserSfx;
            } catch(_) {}
            const sigma1Img = new Image();
            sigma1Img.onload = ()=>{ sigma1Img._ok = true; };
            sigma1Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sigma1.png'); sigma1Img._broken = true; };
            sigma1Img.src = 'assets/bullets/sigma1.png';
            window._bulletImages.sigma1 = sigma1Img;
            const sigma2Img = new Image();
            sigma2Img.onload = ()=>{ sigma2Img._ok = true; };
            sigma2Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sigma2.png'); sigma2Img._broken = true; };
            sigma2Img.src = 'assets/bullets/sigma2.png';
            window._bulletImages.sigma2 = sigma2Img;
            const sigma3Img = new Image();
            sigma3Img.onload = ()=>{ sigma3Img._ok = true; };
            sigma3Img.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sigma3.png'); sigma3Img._broken = true; };
            sigma3Img.src = 'assets/bullets/sigma3.png';
            window._bulletImages.sigma3 = sigma3Img;

            const plainImg = new Image(); plainImg.onload = ()=>{ plainImg._ok = true; }; plainImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/plainbullet.png'); plainImg._broken = true; };
            plainImg.src = 'assets/bullets/plainbullet.png'; window._bulletImages.plain = plainImg;
            const timeBombImg = new Image(); timeBombImg.onload = ()=>{ timeBombImg._ok = true; }; timeBombImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/timebomb.png'); timeBombImg._broken = true; };
            timeBombImg.src = 'assets/bullets/timebomb.png'; window._bulletImages.timebomb = timeBombImg;
            const beansImg = new Image(); beansImg.onload = ()=>{ beansImg._ok = true; }; beansImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/beans.png'); beansImg._broken = true; };
            beansImg.src = 'assets/bullets/beans.png'; window._bulletImages.beans = beansImg;
            const tumbleweedImg = new Image(); tumbleweedImg.onload = ()=>{ tumbleweedImg._ok = true; }; tumbleweedImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/tumbleweed.png'); tumbleweedImg._broken = true; };
            tumbleweedImg.src = 'assets/bullets/tumbleweed.png'; window._bulletImages.tumbleweed = tumbleweedImg;
            const ionImg = new Image(); ionImg.onload = ()=>{ ionImg._ok = true; }; ionImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/ion.png'); ionImg._broken = true; };
            ionImg.src = 'assets/bullets/ion.png'; window._bulletImages.ion = ionImg;
            const diarrheaImg = new Image(); diarrheaImg.onload = ()=>{ diarrheaImg._ok = true; }; diarrheaImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/diarrhea.png'); diarrheaImg._broken = true; };
            diarrheaImg.src = 'assets/bullets/diarrhea.png'; window._bulletImages.diarrhea = diarrheaImg;
            const popcornImg = new Image(); popcornImg.onload = ()=>{ popcornImg._ok = true; }; popcornImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/popcorn.png'); popcornImg._broken = true; };
            popcornImg.src = 'assets/bullets/popcorn.png'; window._bulletImages.popcorn = popcornImg;
            const swordImg = new Image(); swordImg.onload = ()=>{ swordImg._ok = true; }; swordImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/sword.png'); swordImg._broken = true; };
            swordImg.src = 'assets/bullets/sword.png'; window._bulletImages.sword = swordImg;
            const axeImg = new Image(); axeImg.onload = ()=>{ axeImg._ok = true; }; axeImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/axe.png'); axeImg._broken = true; };
            axeImg.src = 'assets/bullets/axe.png'; window._bulletImages.axe = axeImg;
            const hammerImg = new Image(); hammerImg.onload = ()=>{ hammerImg._ok = true; }; hammerImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/hammer.png'); hammerImg._broken = true; };
            hammerImg.src = 'assets/bullets/hammer.png'; window._bulletImages.hammer = hammerImg;
            const breadImg = new Image(); breadImg.onload = ()=>{ breadImg._ok = true; }; breadImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/bread.png'); breadImg._broken = true; };
            breadImg.src = 'assets/bullets/bread.png'; window._bulletImages.bread = breadImg;
            const meteorImg = new Image(); meteorImg.onload = ()=>{ meteorImg._ok = true; }; meteorImg.onerror = ()=>{ console.warn('[BulletImage] Failed to load assets/bullets/meteor.png'); meteorImg._broken = true; };
            meteorImg.src = 'assets/bullets/meteor.png'; window._bulletImages.meteor = meteorImg;

            // Tanks Alot ability sprites
            // Primary truck sprite (driving)
            const truckImg = new Image();
            truckImg.onload = ()=>{ truckImg._ok = true; };
            truckImg.onerror = ()=>{ console.warn('[AbilityImage] Failed to load assets/bullets/truck.png'); truckImg._broken = true; };
            truckImg.src = 'assets/bullets/truck.png';
            // Secondary sprite (lingering fire loop or alt frame)
            const truckFireImg = new Image();
            truckFireImg.onload = ()=>{ truckFireImg._ok = true; };
            truckFireImg.onerror = ()=>{ console.warn('[AbilityImage] Failed to load assets/bullets/truck2.png'); truckFireImg._broken = true; };
            truckFireImg.src = 'assets/bullets/truck2.png';
            window._truckSprite = { image: truckImg, fire: truckFireImg };
            // Helper to compute tight opaque bounds from an Image
            function computeOpaqueBounds(img, alphaThreshold = 10) {
                try {
                    const iw = (img.naturalWidth != null ? img.naturalWidth : img.width) || 0;
                    const ih = (img.naturalHeight != null ? img.naturalHeight : img.height) || 0;
                    if (!iw || !ih) return { x:0, y:0, w:iw, h:ih };
                    const c = document.createElement('canvas'); c.width = iw; c.height = ih;
                    const cx = c.getContext('2d');
                    cx.drawImage(img, 0, 0);
                    const data = cx.getImageData(0, 0, iw, ih).data;
                    let minX = iw, minY = ih, maxX = -1, maxY = -1;
                    for (let y=0; y<ih; y++) {
                        for (let x=0; x<iw; x++) {
                            const a = data[(y*iw + x)*4 + 3];
                            if (a > alphaThreshold) {
                                if (x < minX) minX = x;
                                if (y < minY) minY = y;
                                if (x > maxX) maxX = x;
                                if (y > maxY) maxY = y;
                            }
                        }
                    }
                    if (maxX < 0 || maxY < 0) return { x:0, y:0, w:iw, h:ih };
                    return { x:minX, y:minY, w:(maxX - minX + 1), h:(maxY - minY + 1) };
                } catch(e) { return { x:0, y:0, w: img.width||0, h: img.height||0 }; }
            }
            // Precompute barrier opaque rect for precise collisions
            (function computeBarrierOpaqueRect(){
                const img = window._barrierImage;
                function setRect(){
                    try {
                        // If this enemy is any kind of goose, mark it so no visual fallbacks are drawn.
                        // This prevents transient magenta/yellow fallback artifacts appearing under
                        // the Golden Goose sprite during load/timing races.
                        try { if (enemy && typeof enemy.type === 'string' && /goose/i.test(enemy.type)) { enemy._noFallback = true; } } catch(_) {}
                        if (img && img.complete && !img._broken && img.naturalWidth) {
                            window._barrierOpaqueRect = computeOpaqueBounds(img, 12);
                        }
                    } catch(_) {}
                }
                if (img) {
                    if (img.complete && img.naturalWidth) setRect();
                    else img.addEventListener('load', setRect, { once: true });
                }
            })();
            // Build frames after both images attempt to load (safe if one fails)
            const finalizeTruckFrames = ()=>{
                const spr = window._truckSprite || {};
                if (!spr.frames) spr.frames = {};
                // Only auto-compute if not manually provided
                if ((!spr.frames.drive || !spr.frames.drive.length) && spr.image && spr.image.complete && !spr.image._broken && spr.image.naturalWidth) {
                    spr.frames.drive = [ computeOpaqueBounds(spr.image) ];
                }
                if ((!spr.frames.fire || !spr.frames.fire.length) && spr.fire && spr.fire.complete && !spr.fire._broken && spr.fire.naturalWidth) {
                    spr.frames.fire = [ computeOpaqueBounds(spr.fire) ];
                }
                window._truckSprite = spr;
            };
            truckImg.onload = ()=>{ truckImg._ok = true; finalizeTruckFrames(); };
            truckFireImg.onload = ()=>{ truckFireImg._ok = true; finalizeTruckFrames(); };
            // Allow manual override of frames if precise bounds are known
            window.configureTruckSprites = function configureTruckSprites(meta){
                try {
                    const spr = window._truckSprite || {};
                    spr.frames = spr.frames || {};
                    if (meta && Array.isArray(meta.drive)) spr.frames.drive = meta.drive;
                    if (meta && Array.isArray(meta.fire)) spr.frames.fire = meta.fire;
                    window._truckSprite = spr;
                } catch(e) { console.warn('configureTruckSprites failed', e); }
            };

            // Apply user-specified drive frames (sprite bounding) for truck.png immediately
            // 1) 110,0 -> 909,361  2) 110,510 -> 910,877  3) 117,939 -> 919,1522
            (function seedTruckFrames(){
                try {
                    const spr = window._truckSprite || {}; spr.frames = spr.frames || {};
                    spr.frames.drive = [
                        { x:110, y:0,   w: (909-110), h: (361-0)   },
                        { x:110, y:510, w: (910-110), h: (877-510) },
                        { x:117, y:939, w: (919-117), h: (1522-939) }
                    ];
                    // User-specified fire frames (truck2.png)
                    spr.frames.fire = [
                        { x:105, y:157, w:(913-105), h:(622-157) },
                        { x:81,  y:830, w:(936-81),  h:(1391-830) }
                    ];
                    window._truckSprite = spr;
                } catch(e) { /* noop */ }
            })();

            // Dumpster obstacle spritesheet (3 frames)
            const dumpsterImg = new Image();
            dumpsterImg.onload = ()=>{ dumpsterImg._ok = true; };
            dumpsterImg.onerror = ()=>{ console.warn('[DumpsterSprite] Failed to load assets/DumpsterFire.png'); dumpsterImg._broken = true; };
            dumpsterImg.src = 'assets/DumpsterFire.png';
            // Frames defined by bounding boxes: [ [x1,y1,x2,y2], ... ]
            window._dumpsterSprite = {
                image: dumpsterImg,
                frames: [
                    // Frame 1: 44, 258 and 312, 710
                    { x:44,  y:258, w:312-44,  h:710-258 },
                    // Frame 2: 378, 258 and 645, 712
                    { x:378, y:258, w:645-378, h:712-258 },
                    // Frame 3: 712, 258 and 975, 709
                    { x:712, y:258, w:975-712, h:709-258 }
                ],
                fps: 6 // target animation rate; derived via frame step from game.frame
            };

            // Helper: compute the current on-canvas destination rectangle for a dumpster sprite,
            // matching how we draw it (aspect fit with slight padding). Returns
            // { x, y, w, h, frame } where frame is the source frame rect used.
            window.getDumpsterSpriteRect = function getDumpsterSpriteRect(wall){
                            try {
                                const spr = window._dumpsterSprite;
                                // Fallback to wall footprint if sprite data missing
                                const containerW = (wall && wall.width) ? wall.width : (typeof TILE_SIZE !== 'undefined' ? TILE_SIZE : 22);
                                const containerH = (wall && wall.height) ? wall.height : (typeof TILE_SIZE !== 'undefined' ? TILE_SIZE : 22);
                                if (!spr || !Array.isArray(spr.frames) || !spr.frames.length) {
                                    return { x: wall.x || 0, y: wall.y || 0, w: containerW, h: containerH, frame: null };
                                }
                                // Use a representative source frame to compute aspect-fit scaling into the wall footprint
                                const frame = spr.frames[0] || { w: containerW, h: containerH };
                                const srcW = frame.w || containerW;
                                const srcH = frame.h || containerH;
                                const scale = Math.min(containerW / srcW, containerH / srcH);
                                const drawW = Math.max(1, Math.floor(srcW * scale));
                                const drawH = Math.max(1, Math.floor(srcH * scale));
                                // Center horizontally and align bottom so dumpster sits on ground
                                const x = (wall.x || 0) + Math.round((containerW - drawW) / 2);
                                const y = (wall.y || 0) + Math.round(containerH - drawH);
                                return { x, y, w: drawW, h: drawH, frame };
                            } catch(e) { return { x: wall.x || 0, y: wall.y || 0, w: (wall && wall.width) || (typeof TILE_SIZE !== 'undefined' ? TILE_SIZE : 22), h: (wall && wall.height) || (typeof TILE_SIZE !== 'undefined' ? TILE_SIZE : 22), frame: null }; }
            };

            // Background image list used by window._streetBackgrounds. Kept as a constant so other code can reference it.
            const STREET_BG_PATHS = [
                'assets/streets/street-night.png',
                'assets/streets/street-night-rain.png',
                'assets/streets/street-rain.png',
                'assets/streets/street-school.png',
                'assets/streets/street-trash.png'
            ];

            window._streetBackgrounds = {
                list: STREET_BG_PATHS,
                img: new Image(),
                ready: false,
                currentSrc: null,
                alpha: 1.0,
                // Fit strategy:
                //  - 'contain': shows full image (no crop), may leave borders on sides or top/bottom
                //  - 'cover'  : fills entire canvas (may crop both axes)
                //  - 'fitWidth': scales image so width matches canvas width (left/right flush) and center-crops vertically if needed
                // Default to 'fitWidth' so backgrounds are flush with the left/right canvas edges.
                fit: 'fitWidth',
                // Optional extra zoom multiplier (1 = exact fit). Use <1 to shrink further.
                zoom: 1.0
            };
            // Preload cache and helpers for zero-flash background swaps
            window._streetBackgrounds.cache = new Map(); // src -> { img, bitmap, ready, error }
            window._streetBackgrounds._preloadPromise = null;
            function injectPreloadHints(){
                try {
                    const head = document.head || document.getElementsByTagName('head')[0];
                    if (!head) return;
                    const list = window._streetBackgrounds.list || [];
                    list.forEach(src => {
                        // Avoid duplicating hints
                        if (head.querySelector(`link[rel="preload"][href="${src}"]`)) return;
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.as = 'image';
                        link.href = src;
                        head.appendChild(link);
                    });
                } catch(_) {}
            }
            function loadBgToCache(src){
                const b = window._streetBackgrounds;
                const existing = b.cache.get(src);
                if (existing && (existing.ready || existing.loading)) return existing.promise || Promise.resolve(existing);
                const img = new Image();
                // If images are same-origin, CORS is not required; harmless if left off
                img.decoding = 'async';
                img.src = src;
                const p = new Promise((resolve) => {
                    function finalize(){
                        const done = (bitmap)=>{ const entry = { img, bitmap, ready: true }; b.cache.set(src, entry); resolve(entry); };
                        try {
                            if (typeof createImageBitmap === 'function') {
                                createImageBitmap(img).then(bmp => done(bmp)).catch(()=> done(null));
                            } else {
                                done(null);
                            }
                        } catch(_) { done(null); }
                    }
                    if (img.decode) {
                        img.decode().then(finalize).catch(()=>{ img.onload = finalize; img.onerror = ()=>{ b.cache.set(src,{ error:true }); resolve(null); }; });
                    } else {
                        img.onload = finalize;
                        img.onerror = ()=>{ b.cache.set(src,{ error:true }); resolve(null); };
                    }
                });
                b.cache.set(src, { img, loading: true, promise: p });
                return p;
            }
            window.preloadStreetBackgrounds = function preloadStreetBackgrounds(){
                const b = window._streetBackgrounds;
                if (b._preloadPromise) return b._preloadPromise;
                const list = Array.isArray(b.list) ? b.list : [];
                injectPreloadHints();
                b._preloadPromise = Promise.all(list.map(loadBgToCache)).then(()=>true).catch(()=>false);
                return b._preloadPromise;
            };
            // Generic helper to preload an arbitrary list of background image paths into the street cache
            window.preloadBackgroundList = function preloadBackgroundList(list){
                try {
                    if (!Array.isArray(list) || !list.length) return Promise.resolve(false);
                    injectPreloadHints();
                    const promises = list.map(src => {
                        try { return loadBgToCache(src); } catch(_) { return Promise.resolve(null); }
                    });
                    return Promise.all(promises).then(() => true).catch(() => false);
                } catch(_) { return Promise.resolve(false); }
            };
            // Apply act-specific background lists. If Act II is selected, swap to gooseghetto folder.
            window.applyActBackgrounds = function applyActBackgrounds(){
                try {
                    const b = window._streetBackgrounds;
                    if (!b) return;
                    const act = (game && game._selectedAct) ? String(game._selectedAct) : null;
                    if (act === 'II') {
                        // Replace list with gooseghetto image set (user-provided filenames)
                        b.list = [
                            'assets/streets/gooseghetto/goosestreet1.png',
                            'assets/streets/gooseghetto/goosestreet2.png',
                            'assets/streets/gooseghetto/goosestreet3.png',
                            'assets/streets/gooseghetto/goosestreet4.png',
                            'assets/streets/gooseghetto/goosestreet5.png',
                            'assets/streets/gooseghetto/goosestreet6.png',
                            'assets/streets/gooseghetto/goosestreet7.png',
                            'assets/streets/gooseghetto/goosestreet8.png',
                            'assets/streets/gooseghetto/goosestreet9.jpeg',
                            'assets/streets/gooseghetto/goosestreet10.jpeg',
                            'assets/streets/gooseghetto/goosestreet11.jpeg'
                        ];
                    } else {
                        // If Act III is selected, use the FUTURE list (if provided), otherwise restore default list
                        if (act === 'III') {
                            try { b.list = (window.FUTURE_STREET_BG_PATHS && Array.isArray(window.FUTURE_STREET_BG_PATHS)) ? window.FUTURE_STREET_BG_PATHS.slice() : STREET_BG_PATHS.slice(); } catch(_){ b.list = STREET_BG_PATHS.slice(); }
                        } else {
                            // Restore default list if not Act II or Act III
                            b.list = STREET_BG_PATHS.slice();
                        }
                    }
                    // Reset cache/preload promise so preload can re-run for new list
                    try { b._preloadPromise = null; } catch(_){}
                    // Kick off preloading of the chosen list
                    try { preloadStreetBackgrounds(); } catch(_){}
                } catch(_){}
            };
            window.pickRandomBackground = function pickRandomBackground(){
                const b = window._streetBackgrounds;
                const list = Array.isArray(b.list) ? b.list : [];
                if (!list.length) { return; }
                const src = list[(Math.random() * list.length) | 0];
                const cached = b.cache && b.cache.get(src);
                if (cached && cached.ready && (cached.bitmap || cached.img)) {
                    // Instant swap from cache, no fade
                    b.currentSrc = src;
                    b.img = cached.bitmap || cached.img;
                    b.ready = true;
                    b.alpha = 1.0;
                    return;
                }
                // Start load in background, keep current image displayed until ready
                loadBgToCache(src).then((entry)=>{
                    if (!entry) return;
                    // Only switch when the requested one finishes
                    b.currentSrc = src;
                    b.img = entry.bitmap || entry.img;
                    b.ready = true;
                    b.alpha = 1.0;
                });
            };
            // Kick off preloading immediately; prioritize the first image to minimize first-room flash
            window.preloadStreetBackgrounds();
            // === Dynamic Canvas Scaling Wrapper ===
            // We render at a fixed logical resolution and scale up to fit while leaving room for HUD (right) and stats (bottom if needed) without scrollbars.
            (function initScaledCanvas(){
                // === Layout / Scaling Constants ===
                // SIDE_PANEL_WIDTH: width reserved for right column (health HUD + stats) in CSS pixels. Adjust if panel content widens.
                // LOGICAL_WIDTH/HEIGHT: fixed internal simulation resolution; gameplay, collision, spawn logic use these units.
                //   Expanding increases visible world area per room (ROOM_WIDTH / ROOM_HEIGHT derived from these values).
                // MAX_DPR: clamp on devicePixelRatio to prevent huge backing buffers that can hurt performance / memory.
                // Scaling Strategy: We scale canvas to fit available width (minus side panel) and full window height.
                //   Scale = min( (availW - SIDE_PANEL_WIDTH)/LOGICAL_WIDTH, availH/LOGICAL_HEIGHT ).
                //   This preserves aspect ratio while maximizing playfield without causing scrollbars.
                const SIDE_PANEL_WIDTH = 200; // reduced baseline width for narrower laptop fit
                // Reduced logical width to tighten horizontal span (improves performance & small-screen fit)
                // Make logical width an exact multiple of TILE_SIZE (22) so the right wall aligns to the canvas edge.
                // 22 * 52 = 1144
                const LOGICAL_WIDTH = 1144;
                // Make logical height an exact multiple of TILE_SIZE (22) so the bottom wall aligns with canvas edge.
                // 22 * 32 = 704
                const LOGICAL_HEIGHT = 704;  // was 720
                const MAX_DPR = 1.25; // lowered from 1.5 to reduce backing buffer size and fill cost
                const dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);
                const canvasCSS = cv;
                function configureBuffer(){
                    cv.width = LOGICAL_WIDTH * dpr;
                    cv.height = LOGICAL_HEIGHT * dpr;
                    canvasCSS.style.width = LOGICAL_WIDTH + 'px';
                    canvasCSS.style.height = LOGICAL_HEIGHT + 'px';
                    const ctxLocal = cv.getContext('2d');
                    ctxLocal.setTransform(dpr,0,0,dpr,0,0);
                }
                configureBuffer();
                window.__LOGICAL_CANVAS__ = { w: LOGICAL_WIDTH, h: LOGICAL_HEIGHT, dpr };
                // Apply scale so canvas + side panel fit horizontally within window while maximizing canvas height.
                function applyScale(){
                    const availW = window.innerWidth - 6; // slightly tighter outer margin
                    const availH = window.innerHeight - 6;
                    const GAP = 8;             // reduced gap between canvas and side panel
                    const SAFETY = 4;           // smaller safety margin
                    const CANVAS_BORDER = 3;    // matches CSS border thickness on #gameCanvas
                    // Measure actual side panel width if rendered (more accurate than constant)
                    const panelEl = document.getElementById('statsPanelWrapper');
                    const panelWidth = (panelEl && panelEl.offsetWidth) ? panelEl.offsetWidth : SIDE_PANEL_WIDTH;
                    let scale = availH / LOGICAL_HEIGHT; // start height-first
                    let layoutBelow = false;
                    // Predict total width requirement in side-by-side mode
                    const scaledCandidateWidth = LOGICAL_WIDTH * scale;
                    let totalProjected = scaledCandidateWidth + (2 * CANVAS_BORDER * scale) + panelWidth + GAP + SAFETY;
                    // If width insufficient even after scaling down (or viewport very narrow), switch to panel-below layout
                    if (totalProjected > availW && availW < 1000) {
                        layoutBelow = true;
                    } else if (totalProjected > availW) {
                        // Try reducing scale just enough to fit side-by-side
                        const widthBudgetWithBorder = availW - panelWidth - GAP - SAFETY - (2 * CANVAS_BORDER * scale);
                        const revised = widthBudgetWithBorder / LOGICAL_WIDTH;
                        scale = Math.min(scale, revised * 0.997);
                        totalProjected = (LOGICAL_WIDTH * scale) + (2 * CANVAS_BORDER * scale) + panelWidth + GAP + SAFETY;
                        if (totalProjected > availW * 1.02) {
                            // Still doesn't fit; fall back to below layout
                            layoutBelow = true;
                            scale = Math.min(scale, (availW - SAFETY*2) / LOGICAL_WIDTH); // re-evaluate width usage for centered canvas
                        }
                    }
                    const MIN_SCALE = 0.35; // allow smaller scale on compact laptop displays
                    scale = Math.max(Math.min(scale, 3), MIN_SCALE);
                    // Slight intentional shrink to guarantee no overflow due to fractional rounding
                    scale *= 0.993;
                    const scaledBorderTotal = 2 * CANVAS_BORDER * scale;
                    if (!layoutBelow) {
                        // Final overflow guard in side-by-side mode
                        const totalNeeded = (LOGICAL_WIDTH * scale) + scaledBorderTotal + panelWidth + GAP + SAFETY;
                        if (totalNeeded > availW) {
                            const widthBudgetWithBorder = availW - panelWidth - GAP - SAFETY - scaledBorderTotal;
                            const revised = widthBudgetWithBorder / LOGICAL_WIDTH;
                            scale = Math.max(Math.min(revised * 0.995, scale), 0.40);
                        }
                    }
                    const scaledW = LOGICAL_WIDTH * scale;
                    const scaledH = LOGICAL_HEIGHT * scale;
                    canvasCSS.style.transformOrigin = 'top left';
                    canvasCSS.style.transform = `scale(${scale})`;
                    const gameOuter = document.getElementById('gameOuter');
                    if (gameOuter) {
                        gameOuter.style.width = (scaledW + scaledBorderTotal) + 'px';
                        const layoutHeight = Math.max(LOGICAL_HEIGHT, scaledH) + scaledBorderTotal;
                        gameOuter.style.minHeight = layoutHeight + 'px';
                    }
                    // Toggle layout mode class
                    if (layoutBelow) document.body.classList.add('panel-below'); else document.body.classList.remove('panel-below');
                    // Toggle compact UI class when scale falls below threshold
                    if (scale < 0.52) document.body.classList.add('compact-ui'); else document.body.classList.remove('compact-ui');
                }
                window.addEventListener('resize', applyScale);
                applyScale();
            })();
        });
    let canvas, ctx;
    const TILE_SIZE = 22; // slightly enlarged to make obstacles feel bigger; hitboxes adapt below
    // Derive room tile dimensions from logical canvas size (set in scaling wrapper: 1160x720)
    // If LOGICAL size changes later, these should be recomputed or made reactive.
    const LOGICAL_W = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || 1144;
    const LOGICAL_H = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || 704;
    const ROOM_WIDTH = Math.floor(LOGICAL_W / TILE_SIZE);  // dynamic width in tiles
    const ROOM_HEIGHT = Math.floor(LOGICAL_H / TILE_SIZE); // dynamic height in tiles
        
    const game = {
            player: {
                x: 320, y: 240, health: 100, maxHealth: 100,
                abilities: [], permanentAbilities: [],
                // Initial facing is down; align lastDirection so first shot matches sprite
                facing: 'down',
                lastDirection: { x: 0, y: 1 },
                invulnerable: false, invulnTime: 0,
                speed: 2.5
            },
            _seenAbilitiesLoaded: false,
            _initComplete: false,
            _returningToTitle: false,
            _titleMusicSuppressed: false,
            // User-adjustable runtime settings / visual toggles
            settings: { realityBreakOverlay: false },
            // Unified input state (keyboard/touch/gamepad)
            input: {
                gamepadEnabled: true,
                gpIndex: null,
                gpDeadzone: 0.25, // radial deadzone (0..1)
                gpMove: { x: 0, y: 0 },
                gpAim: { x: 0, y: 0 },
                gpFire: false,
                _lastButtons: null,
                _lastStartAt: 0
            },
            dungeon: 1, room: 1, score: 0,
            enemies: [], chests: [], projectiles: [], walls: [], particles: [],
            transientEffects: [], // short-lived visual cues (rings, flashes)
            duckFlocks: [], // active duck swoop entities (Duck Dynasty)
            // Active reality-distortion fields (used by Reality Break)
            activeRealityFields: [],
            keys: {}, lastAttack: 0, roomCleared: false,
            shotCounter: 0, totalKills: 0, roomsCleared: 0, chestsOpened: 0,
            screenShake: 0, screenShakeIntensity: 0, paused: false,
            sfxEnabled: true,
            musicEnabled: true,
            showFps: false,
            _quackenToastShownRun: false,
            // Potato Mode: aggressively disable non-essential FX for performance
            potatoMode: false,
            disableCosmeticParticles: false, // legacy flag (kept for compatibility)
            // Performance / FX dynamic control
            perf: { frameTimes: [], lastFpsSample: performance.now(), fps: 60, lowFx:false, autoLowFx:true },
            // Fine-grained FX flags (toggled via F3)
            fxFlags: { hideSparks: false, hideSpokes: false, reduceRings: false, reduceBeams: false },
            fxSuppression: { particleSkip: 0 },
            _roomSpawnedEnemies: 0,
            _restartGraceFrames: 0,
            nextDuckFlockFrame: 0 // scheduling for Duck Dynasty flocks
        };
        // Debug helper: dump enemies near a given point (calls from console)
        try {
            game._debugDumpEnemiesAt = function(px, py, radius) {
                try {
                    radius = typeof radius === 'number' ? radius : 120;
                    const out = [];
                    if (!Array.isArray(game.enemies)) return out;
                    for (let i=0;i<game.enemies.length;i++) {
                        const e = game.enemies[i]; if (!e) continue;
                        const dx = (e.x||0) - px; const dy = (e.y||0) - py;
                        const d2 = dx*dx + dy*dy;
                        if (d2 <= radius*radius) {
                            out.push({ i, type: e.type, x: e.x, y: e.y, speed: e.speed, _noFallback: !!e._noFallback, hitbox: e.hitbox || null, hbFromCompute: (game.enemySprites && game.enemySprites[ (e.type==='Golden Goose'?'goldengoose':(e.type||'').toLowerCase().replace(/ /g,'')) ] && game.enemySprites[ (e.type==='Golden Goose'?'goldengoose':(e.type||'').toLowerCase().replace(/ /g,'')) ].computeHitbox ? game.enemySprites[ (e.type==='Golden Goose'?'goldengoose':(e.type||'').toLowerCase().replace(/ /g,'')) ].computeHitbox(e) : null) });
                        }
                    }
                    // debug dump removed in production
                    return out;
                } catch(e) { console.warn('[DEBUG_DUMP_ENEMIES][ERR]', e); return []; }
            };
        } catch(_) {}
    
        // === Projectile System (Phase 2: Structure-of-Arrays) ===
        (function initProjectileSoA(){
            // Bit flag layout (8 bits for now; expand to Uint16 if needed):
            // 1<<0 SINE, 1<<1 WACKY, 1<<2 EKG, 1<<3 SPIRAL, 1<<4 TELEPORT, 1<<5 HOMING, 1<<6 BOUNCE, 1<<7 RESERVED
            const FLAG = {
                SINE:1, WACKY:2, EKG:4, SPIRAL:8, TELEPORT:16, HOMING:32, BOUNCE:64
            };
            const MAX = 6000; // increased after pooling test; adjust with perf data
            // Core numeric channels
            const x = new Float32Array(MAX);
            const y = new Float32Array(MAX);
            const vx = new Float32Array(MAX);
            const vy = new Float32Array(MAX);
            const life = new Uint16Array(MAX);      // remaining life frames
            const lifeMax = new Uint16Array(MAX);   // original life for fade calculations
            const radius = new Uint8Array(MAX);     // <= 255 px (plenty)
            const damage = new Uint16Array(MAX);    // allows big crits
            const flags = new Uint8Array(MAX);
            const colorIdx = new Uint8Array(MAX);   // index into palette
            const targetId = new Int16Array(MAX);   // -1 if none
            const type = new Uint8Array(MAX);       // generic type bucket
            // Active slots bookkeeping
            const alive = new Uint8Array(MAX); // 0 = free, 1 = active
            const freeStack = new Uint32Array(MAX);
            let freeTop = MAX; // points to next free index (stack style)
            for (let i=0;i<MAX;i++) freeStack[i]=i; // fill stack
            let activeCount = 0;
            // Palette (basic for now) - could be expanded or dynamic
            const palette = ['#fff','#ffec6a','#ff6a6a','#6affd2','#6aa8ff','#b86aff'];
            // Export references
            game.projectilesSoA = { x,y,vx,vy,life,lifeMax,radius,damage,flags,colorIdx,targetId,type,alive,FLAG,MAX };
            game.projectilePool = { max: MAX, active:()=>activeCount, free:()=>freeTop };
            // Provide a pool reset hook so room transitions/full resets can cleanly clear all indices
            game.resetProjectilePool = function(){
                for (let i=0;i<MAX;i++) { alive[i]=0; freeStack[i]=i; }
                freeTop = MAX; activeCount = 0;
                // Clear meta if present
                if (game._projMeta && game._projMeta.clear) game._projMeta.clear();
            };
            // Spawn using template
            let _lastPoolWarnTime = 0;
            function spawnProjectile(t){
                if (freeTop === 0) {
                    const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
                    if (now - _lastPoolWarnTime > 2000) {
                        _lastPoolWarnTime = now;
                        try {
                            const sample = [];
                            for (let j=0;j<MAX && sample.length<12;j++) {
                                if (alive[j]) {
                                    const m = game._projMeta && game._projMeta.get(j);
                                    // mark obviously long-lived entries
                                    if ((life[j]||0) > 60000 || (m && (m.indestructible || m._stuck))) {
                                        sample.push({ i:j, life: life[j], meta: m });
                                    }
                                }
                            }
                            console.warn('[ProjectilePool] SPAWN FAILED - pool exhausted', { MAX, activeCount, freeTop, sampleCount: sample.length });
                        } catch(e) { try { console.warn('[ProjectilePool] spawn failure diagnostic threw', e); } catch(_){} }
                    }
                    // Attempt a scavenger pass: try to free obviously stale projectiles (off-screen or extremely long-lived)
                    try {
                        let freed = 0;
                        const W = (typeof LOGICAL_W !== 'undefined') ? LOGICAL_W : ((typeof canvas !== 'undefined' && canvas.width) ? canvas.width : 800);
                        const H = (typeof LOGICAL_H !== 'undefined') ? LOGICAL_H : ((typeof canvas !== 'undefined' && canvas.height) ? canvas.height : 600);
                        for (let j=0;j<MAX && freeTop===0;j++) {
                            if (!alive[j]) continue;
                            const m = game._projMeta && game._projMeta.get(j);
                            const longLife = (life[j]||0) > 30000;
                            const farOff = (x[j] < -300 || x[j] > W + 300 || y[j] < -300 || y[j] > H + 300);
                            const stuckMeta = m && (m._stuck || m.stuck);
                            const canRecycle = !m || !m.indestructible;
                            if (canRecycle && (longLife || farOff || stuckMeta)) {
                                try { recycle(j); freed++; } catch(_){}
                            }
                        }
                        if (freed > 0) {
                            try { console.info('[ProjectilePool] scavenger freed', freed, 'slots'); } catch(_){}
                        }
                    } catch(e) { try { console.warn('[ProjectilePool] scavenger failed', e); } catch(_){} }

                    if (freeTop === 0) return -1;
                }
                // Emergency purge: if scavenger couldn't free anything but pool is still exhausted,
                // try a more aggressive pass to reclaim slots that appear reclaimable (no meta or non-indestructible).
                try {
                    if (freeTop === 0) {
                        let purgeCount = 0;
                        const want = Math.min(512, Math.max(64, Math.floor(MAX * 0.08)));
                        for (let j=0;j<MAX && purgeCount < want;j++) {
                            if (!alive[j]) continue;
                            const m = game._projMeta && game._projMeta.get(j);
                            const canRecycle = !(m && m.indestructible) && !(m && (m._stuck || m.stuck));
                            // Also recycle obvious invalid entries (NaN/Infinite positions) to avoid leaks
                            const posBad = !isFinite(x[j]) || !isFinite(y[j]);
                            if (canRecycle || posBad) {
                                try { recycle(j); purgeCount++; } catch(_){}
                            }
                        }
                        if (purgeCount > 0) {
                            try { console.info('[ProjectilePool] emergency purge freed', purgeCount, 'slots'); } catch(_){}
                        }
                    }
                } catch(e) { try { console.warn('[ProjectilePool] emergency purge failed', e); } catch(_){} }
                if (freeTop === 0) return -1;
                const idx = freeStack[--freeTop];
                alive[idx]=1; activeCount++;
                // Lightweight diagnostic: sample call stacks when pool is critically low so we can
                // identify which code paths are allocating many projectiles at once. Throttle to
                // avoid excessive overhead.
                try {
                    game._debug = game._debug || {};
                    if (!game._debug.spawnStacks) game._debug.spawnStacks = new Map();
                    const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
                    if (!game._debug._lastStackSample) game._debug._lastStackSample = 0;
                    // Only sample when remaining free slots drop below 128 and at most once every 200ms
                    if (freeTop < 128 && (now - game._debug._lastStackSample) > 200) {
                        game._debug._lastStackSample = now;
                        try {
                            const st = (new Error()).stack || 'no-stack';
                            const key = st.split('\n').slice(2,8).join('\n'); // trim top frames for readability
                            const prev = game._debug.spawnStacks.get(key) || 0;
                            game._debug.spawnStacks.set(key, prev + 1);
                            // also keep an example index for quick inspection
                            if (!game._debug.spawnExample) game._debug.spawnExample = [];
                            if (game._debug.spawnExample.length < 12) game._debug.spawnExample.push({ idx, time: now, stack: key });
                        } catch (_) {}
                    }
                } catch(_) {}
                // Clear any stale metadata associated with this index to avoid inheriting flags
                // like timeBomb/smartExplosive/chainExplosion from a previous occupant.
                if (game._projMeta && game._projMeta.has(idx)) {
                    try { game._projMeta.delete(idx); } catch(_) {}
                }
                x[idx] = t.x || 0; y[idx] = t.y || 0;
                vx[idx] = t.vx || 0; vy[idx] = t.vy || 0;
                const r = t.r || t.radius || 3; radius[idx] = r > 255?255:r;
                const lf = t.life || t.maxLife || 120; life[idx]=lf; lifeMax[idx]=lf;
                damage[idx] = t.damage || 1;
                // compose flags
                let f=0; if (t.sineWave) f|=FLAG.SINE; if (t.wackyZigzag) f|=FLAG.WACKY; if (t.ekgWave) f|=FLAG.EKG; if (t.spiralPattern) f|=FLAG.SPIRAL; if (t.teleporting) f|=FLAG.TELEPORT; if (t.homing) f|=FLAG.HOMING; if (t.bouncing) f|=FLAG.BOUNCE;
                flags[idx]=f;
                // naive color mapping (extend later with lookups on damageType / weaponType)
                let cIndex = 0;
                if (t.damageType === 'fire') cIndex=1; else if (t.damageType==='shadow') cIndex=2; else if (t.damageType==='void') cIndex=5; else if (t.damageType==='frost') cIndex=4;
                colorIdx[idx]= cIndex < palette.length? cIndex : 0;
                targetId[idx] = (t.targetId!=null)? t.targetId : -1;
                type[idx] = t.type || 0;
                return idx;
            }
            function recycle(idx){
                if (!alive[idx]) return;
                alive[idx]=0; freeStack[freeTop++]=idx; activeCount--; 
                // Also drop any metadata for this slot so future spawns start clean
                if (game._projMeta && game._projMeta.has(idx)) {
                    try { game._projMeta.delete(idx); } catch(_) {}
                }
            }
            // Precompute trig lookup tables to avoid repeated Math.sin/Math.cos in tight loop
            const TRIG_STEPS = 512; // power of two for cheap masking
            const SIN_TABLE = new Float32Array(TRIG_STEPS);
            const COS_TABLE = new Float32Array(TRIG_STEPS);
            for (let i=0;i<TRIG_STEPS;i++){ const a = (i/TRIG_STEPS)*Math.PI*2; SIN_TABLE[i]=Math.sin(a); COS_TABLE[i]=Math.cos(a); }
            const SIN_MASK = TRIG_STEPS - 1;
            // Helper fast sin/cos with wrapping index (expects non-negative integer input)
            function fsin(idx){ return SIN_TABLE[idx & SIN_MASK]; }
            function fcos(idx){ return COS_TABLE[idx & SIN_MASK]; }
            // Update routine (basic physics + life decrement + simple homing stub)
            function updateProjectiles(dt){
                // Adaptive degradation tiers based on active projectile count
                // Tier 0: < 800 full features
                // Tier 1: 800-1499 reduce sine/wacky amplitude
                // Tier 2: 1500-2499 skip EKG and halve spiral step
                // Tier 3: >= 2500 disable all pattern extras & homing micro-adjust
                let activeNow = activeCount;
                let tier = 0;
                if (activeNow >= 2500) tier = 3; else if (activeNow >= 1500) tier = 2; else if (activeNow >= 800) tier = 1;
                game.projectileDegradeTier = tier;
                // Make Sine Wave much more visible and wild
                // tier 0: extreme; tier 1: very strong; tier 2: strong; tier 3: disabled
                const sineScale = tier === 0 ? 7.0 : tier === 1 ? 4.0 : (tier === 2 ? 2.0 : 0.0);
                // Make Wacky Shot clearly visible; still disable at highest load (tier 3)
                const wackyScale = tier === 0 ? 1.0 : tier === 1 ? 0.65 : (tier === 2 ? 0.35 : 0.0);
                const ekgEnabled = tier < 2;
                const spiralScale = tier < 2 ? 0.5 : (tier === 2 ? 0.25 : 0);
                // Stronger homing: raise base scale significantly (still disabled at highest degradation tier)
                const baseHomingScale = tier < 3 ? 1.6 : 0.0;
                for (let i=0;i<MAX;i++){
                    if (!alive[i]) continue;
                    // Fetch metadata early for special handling
                    const meta = game._projMeta && game._projMeta.get(i);
                    // Record last-frame position for movement-based logic that can't trust vx/vy due to additive patterns
                    if (meta) { meta._lastX = x[i]; meta._lastY = y[i]; }
                    // Note: Time Bomb visuals are handled in renderProjectiles();
                    // update loop only manages physics and timers below.
                    // Indestructible projectiles (e.g., Tumbleweed, Kick the Can): never expire by life
                    if (life[i]===0){
                        if (meta && meta.indestructible) {
                            life[i] = Math.max(life[i], 60000);
                            lifeMax[i] = Math.max(lifeMax[i], 60000);
                        } else {
                            // SIGMA stage 3: detonate on expiry with a strong splash
                            if (meta && meta.sigma3) {
                                const baseDmg = (meta.baseDamage || (damage && damage[i]) || (typeof calculateDamage==='function' && calculateDamage()) || 12);
                                // Compute an explosion radius that matches the on-screen sigma3 sprite/aura
                                let expR = meta._auraRadius;
                                if (typeof expR !== 'number' || !isFinite(expR)) {
                                    // Fallback compute similar to the aura sizing (based on logical view size)
                                    const vw = (typeof LOGICAL_W !== 'undefined' ? LOGICAL_W : (ctx && ctx.canvas && ctx.canvas.width) || 800);
                                    const vh = (typeof LOGICAL_H !== 'undefined' ? LOGICAL_H : (ctx && ctx.canvas && ctx.canvas.height) || 600);
                                    const target = Math.min(vw, vh) * 0.20; // image width target
                                    expR = Math.max(24, target * 0.48);
                                }
                                // Use antimatter-style explosion with custom radius and knockback
                                explodeProjectile({ x: x[i], y: y[i], explosionRadius: expR, antimatter: true, knockback: true }, baseDmg);
                                // Small extra sparkle on detonation (perf-aware)
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                if (!lowFx) for (let p=0;p<6;p++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#BBD7FF','spark');
                            }
                            // Default expire pop cue for standard bullets (skip if beams/enemy)
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings && !(meta && (meta.beam || meta.enemy))) {
                                addParticle(x[i], y[i], '#FFE6CC','ring');
                            }
                            recycle(i); continue;
                        }
                    }
                    if (!(meta && meta.indestructible)) {
                        life[i]--;
                    } else {
                        // Keep a healthy life window to avoid edge cases
                        if (life[i] < 59000) life[i] = 60000;
                        if (lifeMax[i] < 60000) lifeMax[i] = 60000;
                    }
                    // Subtle friction for Tumbleweed/Kick the Can so it coasts to a stop unless re-kicked
                    if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                        const fr = Math.pow(0.992, dt || 1);
                        vx[i] *= fr; vy[i] *= fr;
                        const sp = Math.hypot(vx[i], vy[i]);
                        if (sp < 0.05) { vx[i] = 0; vy[i] = 0; }
                    }
                    // Decay short-lived UI/telegraph timers on metadata
                    if (meta) {
                        if (meta._pierceWarn) { meta._pierceWarn--; if (meta._pierceWarn < 0) meta._pierceWarn = 0; }
                        if (meta._pierceFlash) { meta._pierceFlash--; if (meta._pierceFlash < 0) meta._pierceFlash = 0; }
                        if (meta._bounceFlash) { meta._bounceFlash--; if (meta._bounceFlash < 0) meta._bounceFlash = 0; }
                        // SIGMA stage 3 spinner: accumulate spin and keep stationary
                        if (meta.sigma3) {
                            meta._age = (meta._age||0) + 1;
                            meta._spin = (meta._spin||0) + (meta._spinRate||0.28);
                            // Hold position (in case something injected velocity)
                            vx[i] = 0; vy[i] = 0;
                            // Periodic subtle ring cue while spinning (perf-aware)
                            if (meta._age % 20 === 0) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings && !lowFx) addParticle(x[i], y[i], '#BBD7FF','ring');
                            }
                        }
                    }
                    // Resonant Pulse Core (SoA): emit periodic expanding rings that buff nearby projectiles
                    if (meta && meta.resonantPulseCore && !meta.enemy && !meta.beam && !meta._orbital) {
                        meta._resCoreTimer = (meta._resCoreTimer||0) + 1;
                        const interval = 60; // was 90 — trigger sooner
                        if (meta._resCoreTimer >= interval) {
                            meta._resCoreTimer = 0;
                            if (!meta._resActiveRings) meta._resActiveRings = [];
                            meta._resActiveRings.push({ r:0, max:150, life:38 });
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!lowFx && !hideSparks) {
                                for (let k=0;k<6;k++) addParticle(x[i] + (Math.random()-0.5)*16, y[i] + (Math.random()-0.5)*16, '#C7A4FF','spark');
                            }
                        }
                        // Update active rings and apply buffs to both SoA and object-mode projectiles
                        if (meta._resActiveRings && meta._resActiveRings.length) {
                            for (let ri=meta._resActiveRings.length-1; ri>=0; ri--) {
                                const ring = meta._resActiveRings[ri];
                                ring.r += (ring.max - ring.r) * 0.18;
                                ring.life--;
                                const rad2 = ring.r * ring.r;
                                // SoA projectiles
                                for (let j=0;j<MAX;j++) {
                                    if (!alive[j] || j===i) continue;
                                    const dxj = x[j]-x[i]; const dyj = y[j]-y[i];
                                    if (dxj*dxj + dyj*dyj <= rad2) {
                                        let m2 = game._projMeta && game._projMeta.get(j);
                                        if (!m2) { m2 = {}; if (!game._projMeta) game._projMeta = new Map(); game._projMeta.set(j, m2); }
                                        if (m2.enemy || m2.beam) continue;
                                        m2._resBuffSpeed = Math.max(m2._resBuffSpeed||0, 26);
                                        m2._resBuffDamage = Math.max(m2._resBuffDamage||0, 30);
                                        m2._resBuffHoming = Math.max(m2._resBuffHoming||0, 24);
                                        const lowFx = !!(game.perf && game.perf.lowFx);
                                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                        if (!lowFx && !hideSparks) addParticle(x[j], y[j], '#C7A4FF','spark');
                                    }
                                }
                                // Object-mode projectiles (if any)
                                if (Array.isArray(game.projectiles)) {
                                    for (let p=0;p<game.projectiles.length;p++) {
                                        const p2 = game.projectiles[p];
                                        if (!p2 || p2===meta || p2.enemy || p2.beam) continue;
                                        const dxp = p2.x - x[i]; const dyp = p2.y - y[i];
                                        if (dxp*dxp + dyp*dyp <= rad2) {
                                            p2._resBuffSpeed = Math.max(p2._resBuffSpeed||0, 26);
                                            p2._resBuffDamage = Math.max(p2._resBuffDamage||0, 30);
                                            p2._resBuffHoming = Math.max(p2._resBuffHoming||0, 24);
                                            const lowFx = !!(game.perf && game.perf.lowFx);
                                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                            if (!lowFx && !hideSparks) addParticle(p2.x, p2.y, '#C7A4FF','spark');
                                        }
                                    }
                                }
                                if (ring.life <= 0 || ring.r > ring.max*0.98) meta._resActiveRings.splice(ri,1);
                            }
                        }
                    }
                    // Sigma3 aura + sprite contact: visual radius is stable; hit radius is larger to ensure reliable contact
                    if (meta && meta.sigma3) {
                        // Visual radius ~ 10% of min logical dimension (width ~ 20% of screen's min side)
                        const vw = (typeof LOGICAL_W !== 'undefined' ? LOGICAL_W : (ctx && ctx.canvas && ctx.canvas.width) || 800);
                        const vh = (typeof LOGICAL_H !== 'undefined' ? LOGICAL_H : (ctx && ctx.canvas && ctx.canvas.height) || 600);
                        const minSide = Math.min(vw, vh);
                        const visualR = Math.max(24, minSide * 0.10);
                        // Expanded collision radius: substantially larger than visuals to catch edge grazes
                        const hitR = Math.floor(visualR * 2.0);
                        // Set SoA collision radius to expanded hit radius
                        if (radius && radius[i] != null) {
                            radius[i] = hitR;
                        }
                        // Persist visual radius (not hit radius) for consistent explosion sizing and sprite drawing
                        meta._auraRadius = visualR;

                        // Per-frame contact damage: light tick so brushing any part of the spinner hurts immediately
                            try {
                                const rf = game.enemySprites.cardiBeak.frames.right;
                                if (rf && img && img.naturalWidth && img.naturalHeight && typeof document !== 'undefined') {
                                    try {
                                        const rightC = document.createElement('canvas'); rightC.width = rf.w; rightC.height = rf.h;
                                        const rc = rightC.getContext('2d'); rc.imageSmoothingEnabled = true;
                                        rc.drawImage(img, rf.x, rf.y, rf.w, rf.h, 0, 0, rf.w, rf.h);
                                        const leftC = document.createElement('canvas'); leftC.width = rf.w; leftC.height = rf.h;
                                        const lc = leftC.getContext('2d'); lc.imageSmoothingEnabled = true;
                                        lc.translate(leftC.width, 0); lc.scale(-1,1);
                                        lc.drawImage(rightC, 0, 0);
                                        try { game.enemySprites.cardiBeak._rightCanvas = rightC; } catch(_){ }
                                        try { game.enemySprites.cardiBeak._leftCanvas = leftC; } catch(_){ }
                                        try { game.enemySprites.cardiBeak.frames.right = { x:0,y:0,w:rightC.width,h:rightC.height }; } catch(_){ }
                                        try { game.enemySprites.cardiBeak.frames.left = { x:0,y:0,w:leftC.width,h:leftC.height }; } catch(_){ }
                                    } catch(_){ }
                                }
                            } catch(_){ }
                        // Aura cadence: every 8 frames apply a heavier pulse
                        meta._auraTick = (meta._auraTick||0) + 1;
                        if (meta._auraTick % 8 === 0) {
                            const base = meta.baseDamage || (damage && damage[i]) || (typeof calculateDamage==='function' && calculateDamage()) || 10;
                            const touch = Math.max(2, Math.floor(base * 0.35));
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const en = game.enemies[ei]; if (!en || en.health<=0) continue;
                                const dx = en.x - x[i]; const dy = en.y - y[i];
                                const dist2 = dx*dx + dy*dy;
                                if (dist2 <= hitR*hitR) {
                                    en.health -= touch;
                                    addDamageNumber(touch, en.x, en.y - en.size/2, { type: 'void' });
                                    addParticle(en.x, en.y, '#BBD7FF','impact');
                                }
                            }
                        }
                    }
                    let dx = vx[i];
                    let dy = vy[i];
                    if (meta && meta.quackenTentacle && !meta.enemy && !meta.beam) {
                        if (!meta._tentacleInit) {
                            meta._tentacleInit = true;
                            if (meta._tentacleAnchorPlayer == null && game.player) {
                                meta._tentacleAnchorPlayer = game.player;
                                meta._tentacleAnchorX = game.player.x;
                                meta._tentacleAnchorY = game.player.y;
                            }
                            meta._tentacleTargetSearch = 0;
                        }
                        if (meta._tentacleAnchorPlayer && typeof meta._tentacleAnchorPlayer.x === 'number') {
                            meta._tentacleAnchorX = meta._tentacleAnchorPlayer.x;
                            meta._tentacleAnchorY = meta._tentacleAnchorPlayer.y;
                        } else if (game.player) {
                            meta._tentacleAnchorX = game.player.x;
                            meta._tentacleAnchorY = game.player.y;
                        }
                        meta._tentacleAge = (meta._tentacleAge || 0) + 1;
                        const extendFrames = meta._tentacleExtendFrames || 46;
                        const retractFrames = meta._tentacleRetractFrames || 28;
                        const range = meta._tentacleRange || 420;
                        const range2 = range * range;
                        if (meta._tentacleTarget && (meta._tentacleTarget.health <= 0 || meta._tentacleTarget.dead)) {
                            meta._tentacleTarget = null;
                        }
                        if (meta._tentacleStage === 'retract') {
                            meta._tentacleTarget = null;
                        } else {
                            meta._tentacleTargetSearch = (meta._tentacleTargetSearch || 0) - 1;
                            if (!meta._tentacleTarget || meta._tentacleTargetSearch <= 0) {
                                meta._tentacleTargetSearch = 10;
                                let nearest = null;
                                let best = range2;
                                if (Array.isArray(game.enemies)) {
                                    for (let ei = 0; ei < game.enemies.length; ei++) {
                                        const enemy = game.enemies[ei];
                                        if (!enemy || enemy.health <= 0 || enemy.dead) continue;
                                        const dxT = enemy.x - x[i];
                                        const dyT = enemy.y - y[i];
                                        const d2 = dxT * dxT + dyT * dyT;
                                        if (d2 < best) {
                                            best = d2;
                                            nearest = enemy;
                                        }
                                    }
                                }
                                meta._tentacleTarget = nearest && best <= range2 ? nearest : null;
                            }
                        }
                        if (meta._tentacleStage !== 'retract') {
                            const anchorDx = (meta._tentacleAnchorX != null ? meta._tentacleAnchorX : x[i]) - x[i];
                            const anchorDy = (meta._tentacleAnchorY != null ? meta._tentacleAnchorY : y[i]) - y[i];
                            if (anchorDx * anchorDx + anchorDy * anchorDy >= range2) {
                                meta._tentacleStage = 'retract';
                                meta._tentacleStageTimer = 0;
                            } else if (meta._tentacleAge >= extendFrames || meta._tentacleHit) {
                                meta._tentacleStage = 'retract';
                                meta._tentacleStageTimer = 0;
                            }
                        } else {
                            meta._tentacleStageTimer = (meta._tentacleStageTimer || 0) + 1;
                            if (meta._tentacleStageTimer > retractFrames) {
                                life[i] = Math.min(life[i], 8);
                            }
                        }
                        const flipPeriodMs = 200;
                        const nowMs = (typeof game._frameNow === 'number') ? game._frameNow : ((typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now());
                        if (meta._tentacleFlipSign !== 1 && meta._tentacleFlipSign !== -1) {
                            meta._tentacleFlipSign = 1;
                        }
                        if (meta._tentacleNextFlip == null || !isFinite(meta._tentacleNextFlip)) {
                            meta._tentacleNextFlip = nowMs + flipPeriodMs;
                        } else if (nowMs >= meta._tentacleNextFlip) {
                            do {
                                meta._tentacleFlipSign = (meta._tentacleFlipSign === -1) ? 1 : -1;
                                meta._tentacleNextFlip += flipPeriodMs;
                            } while (nowMs >= meta._tentacleNextFlip);
                        }
                        let aimX;
                        let aimY;
                        if (meta._tentacleStage === 'retract' && meta._tentacleAnchorX != null && meta._tentacleAnchorY != null) {
                            const ax = meta._tentacleAnchorX - x[i];
                            const ay = meta._tentacleAnchorY - y[i];
                            const len = Math.hypot(ax, ay) || 1;
                            aimX = ax / len;
                            aimY = ay / len;
                        } else if (meta._tentacleTarget) {
                            const tx = meta._tentacleTarget.x - x[i];
                            const ty = meta._tentacleTarget.y - y[i];
                            const len = Math.hypot(tx, ty) || 1;
                            aimX = tx / len;
                            aimY = ty / len;
                        } else {
                            const sp = Math.hypot(dx, dy) || 1;
                            aimX = dx / sp;
                            aimY = dy / sp;
                        }
                        const baseSpeed = meta._tentacleBaseSpeed || Math.max(5.8, Math.hypot(vx[i], vy[i]) || 5.8);
                        const stageSpeed = meta._tentacleStage === 'retract' ? baseSpeed * 1.25 : baseSpeed;
                        const wigglePhase = meta._tentacleAge * 0.32 + (meta._tentacleSeed || 0);
                        const wiggle = Math.sin(wigglePhase) * (meta._tentacleStage === 'retract' ? 0.35 : 0.6);
                        const perpX = -aimY;
                        const perpY = aimX;
                        const steerX = aimX * stageSpeed + perpX * wiggle * stageSpeed * 0.45;
                        const steerY = aimY * stageSpeed + perpY * wiggle * stageSpeed * 0.45;
                        const blend = meta._tentacleStage === 'retract' ? 0.45 : 0.30;
                        vx[i] = vx[i] * (1 - blend) + steerX * blend;
                        vy[i] = vy[i] * (1 - blend) + steerY * blend;
                        dx = vx[i];
                        dy = vy[i];
                        meta._tentacleAngle = Math.atan2(vy[i], vx[i]);
                        if (!meta._tentacleTrail) meta._tentacleTrail = [];
                        const trailCapBase = meta._tentacleTrailCap || 18;
                        const trailCap = Math.max(6, trailCapBase - tier * 4);
                        if (meta._tentacleTrail.length >= trailCap) meta._tentacleTrail.shift();
                        meta._tentacleTrail.push({ x: x[i], y: y[i] });
                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                            if ((meta._tentacleAge & 3) === 0) addParticle(x[i] + (Math.random() - 0.5) * 10, y[i] + (Math.random() - 0.5) * 10, '#5F4BCE', 'spark');
                        }
                        if (meta._tentacleStage === 'retract' && meta._tentacleAnchorX != null && meta._tentacleAnchorY != null) {
                            const distBack = Math.hypot(x[i] - meta._tentacleAnchorX, y[i] - meta._tentacleAnchorY);
                            if (distBack < 26) life[i] = Math.min(life[i], 6);
                        }
                    }
                    // Act III swan laser acceleration: laser projectiles speed up as they travel
                    try {
                        const mLaser = game._projMeta && game._projMeta.get(i);
                        if (mLaser && mLaser.laser) {
                            const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const accMul = 1.02; // ~2% speed increase per frame
                            const maxSp = 20; // clamp maximum speed to avoid runaway
                            const newSp = Math.min(maxSp, sp * accMul);
                            vx[i] = (vx[i] / sp) * newSp;
                            vy[i] = (vy[i] / sp) * newSp;
                            // reflect updated velocity into local deltas so movement integration uses new speed
                            dx = vx[i]; dy = vy[i];
                        }
                    } catch(_) {}
                    const prevX = x[i];
                    const prevY = y[i];
                    const f = flags[i];
                    // Replace small-range sin calls with table lookups. We map phases by scaling counters.
                    if (sineScale && (f & FLAG.SINE)) {
                        // Stronger sinusoidal motion perpendicular to current velocity for readability
                        const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                        const px = -vy[i]/sp, py = vx[i]/sp; // perpendicular unit vector
                        // Per-projectile sine parameters for variability (seed once)
                        let m = game._projMeta && game._projMeta.get(i);
                        if (!m) { if (!game._projMeta) game._projMeta = new Map(); m = {}; game._projMeta.set(i, m); }
                        if (m._sineSeed == null) {
                            m._sineSeed = (Math.random()*1024)|0;
                            // Amplitude multiplier 0.85–1.35; frequency multiplier 0.7–1.4
                            m._sineAmp = 0.85 + Math.random()*0.50;
                            m._sineFreq = 0.70 + Math.random()*0.70;
                            // Slow amplitude drift to make motion feel organic
                            m._sineDriftRate = 0.007 + Math.random()*0.010; // radians per frame
                            m._sineDriftAmp = 0.25 + Math.random()*0.45;    // 0.25–0.70 of base
                        }
                        const basePhase = ( (life[i] * 41 * m._sineFreq) + m._sineSeed ) & SIN_MASK;
                        const drift = 1 + m._sineDriftAmp * fsin( ((game.frame||0) * m._sineDriftRate) & SIN_MASK );
                        const wobble = fsin(basePhase) * sineScale * m._sineAmp * drift;
                        dx += px * wobble;
                        dy += py * wobble;
                        // Crest cue (perf-aware)
                        const metaV = game._projMeta && game._projMeta.get(i);
                        if (metaV) {
                            metaV._sineCueCd = (metaV._sineCueCd||0) - 1;
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !reduceRings && Math.abs(wobble / (sineScale||1)) > 0.98 && metaV._sineCueCd <= 0) {
                                addParticle(x[i], y[i], '#AEEFFF','ring');
                                metaV._sineCueCd = 22;
                            }
                        }
                    }
                    if (wackyScale && (f & FLAG.WACKY)) {
                        // Wacky: straight segments with discrete random direction snaps (no jitter)
                        const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                        const fx = vx[i]/sp, fy = vy[i]/sp; // forward unit (for relative pivots & cue)
                        const px = -fy, py = fx;            // perpendicular unit
                        let m = game._projMeta && game._projMeta.get(i);
                        if (!m) { if (!game._projMeta) game._projMeta = new Map(); m = {}; game._projMeta.set(i, m); }
                        if (!m._wackySnapInit) {
                            m._wackySnapInit = true;
                            // Timer: ~0.3s between direction changes based on measured FPS
                            const fps = (game.perf && game.perf.fps) || 60;
                            const baseFrames = Math.max(2, Math.round(fps * 0.30));
                            m._wHold = baseFrames + ((Math.random()*4|0) - 2); // small variation ±2 frames
                            m._wLocal = true;
                            m._wAngle = 0;
                        }
                        // Countdown and pivot on expiry
                        m._wHold--;
                        if (m._wHold <= 0) {
                            // Choose absolute vs relative pivot
                            m._wLocal = Math.random() >= 0.25; // 75% relative, 25% absolute for broader coverage
                            if (m._wLocal) {
                                // Relative pivot up to ±150°
                                const range = 2.62; // ~150° in radians
                                m._wAngle = (Math.random()*2 - 1) * range;
                            } else {
                                // Absolute new heading in full 360°
                                m._wAngle = (Math.random()*Math.PI*2) - Math.PI;
                            }
                            // Reset hold to ~0.3s with tiny randomness
                            const fps = (game.perf && game.perf.fps) || 60;
                            const baseFrames = Math.max(2, Math.round(fps * 0.30));
                            m._wHold = baseFrames + ((Math.random()*4|0) - 2);

                            // Compute target direction
                            let tx, ty;
                            if (m._wLocal) {
                                const c = Math.cos(m._wAngle), s = Math.sin(m._wAngle);
                                tx = fx * c + px * s; ty = fy * c + py * s;
                            } else {
                                tx = Math.cos(m._wAngle); ty = Math.sin(m._wAngle);
                            }
                            // Normalize and snap velocity to preserve speed
                            const n = Math.hypot(tx, ty) || 1; tx /= n; ty /= n;
                            const newVx = tx * sp, newVy = ty * sp;
                            // Snap underlying velocity
                            vx[i] = newVx; vy[i] = newVy;
                            // Also override this frame's displacement so the turn is visible immediately
                            dx = newVx; dy = newVy;

                            // Visual cue only on pivots (perf-aware)
                            const metaV = game._projMeta && game._projMeta.get(i);
                            if (metaV) {
                                metaV._wackyCueCd = (metaV._wackyCueCd||0) - 1;
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!lowFx && metaV._wackyCueCd <= 0) {
                                    if (!hideSparks) addParticle(x[i], y[i], '#CCEEFF','spark');
                                    else if (!reduceRings) addParticle(x[i], y[i], '#CCEEFF','ring');
                                    metaV._wackyCueCd = 10;
                                }
                            }
                        }
                    }
                    // EKG path-relative oscillation (perpendicular to motion):
                    // - Subtle baseline jitter around centerline + occasional large spike outward on a locked side.
                    // - Spikes always go to the same perpendicular side per projectile (no large downward spikes).
                    const metaE = game._projMeta && game._projMeta.get(i);
                    const hasEkg = ((f & FLAG.EKG) || (metaE && metaE.ekgWave));
                    if (hasEkg) {
                        // Per-projectile state in meta map
                        let m = game._projMeta && game._projMeta.get(i);
                        if (!m) { if (!game._projMeta) game._projMeta = new Map(); m = {}; game._projMeta.set(i, m); }
                        if (!m._ekgSmInit) {
                            m._ekgSmInit = true;
                            m._ekgState = 'baseline'; // baseline -> pre -> asc -> desc -> recover
                            m._ekgTimer = 0;
                            m._ekgSeed = Math.random() * Math.PI * 2;
                            m._ekgLastOffset = 0;
                            // Baseline jitter and spike amplitudes
                            m._ekgJitter = 0.8;
                            m._ekgSmallAmp = 3.0 + Math.random()*1.5; // ~3.0–4.5px
                            m._ekgBigAmp = 12 + Math.random()*6;      // ~12–18px
                            // Uniform scale-up so jitter and spikes increase equally
                            const EKG_SCALE = 3.8; // ~+27% stronger scale for jitter + spikes
                            m._ekgJitter *= EKG_SCALE;
                            m._ekgSmallAmp *= EKG_SCALE;
                            m._ekgBigAmp *= EKG_SCALE;
                            m._ekgUseAmp = m._ekgSmallAmp;
                            m._ekgPreDur = 1; // brief telegraph
                            m._ekgAscDur = 4; // longer rise for visibility
                            m._ekgDescDur = 4; // longer fall
                            m._ekgRecoverDur = 1; // one frame settle
                            m._ekgNextSpike = 6 + (Math.random()*6|0); // slightly earlier cadence
                            // Ensure at least one large spike happens early
                            m._ekgGuaranteeBigAt = 6 + ((Math.random()*8)|0);
                            m._ekgBigDone = false;
                            // Lock a perpendicular basis so the big spike has a consistent "up" side for this projectile
                            const sv = Math.hypot(vx[i], vy[i]) || 0.0001;
                            let px0 = -vy[i]/sv, py0 = vx[i]/sv;
                            // Force spikes towards screen-up side: ensure negative Y component
                            if (py0 > 0) { px0 = -px0; py0 = -py0; }
                            m._ekgPx = px0; m._ekgPy = py0;
                            // Ensure at least one spike happens soon after spawn
                            m._ekgGuaranteeAt = 8 + ((Math.random()*10)|0);
                            m._ekgSpikedOnce = false;
                        }
                        m._ekgTimer++;
                        let offset = 0; // target perpendicular offset (px)
                        const st = m._ekgState;
                        if (st === 'baseline') {
                            // Two-phase tiny jitter so it feels alive but stays near 0
                            const a = Math.sin((life[i]*3.1) + m._ekgSeed) * (m._ekgJitter*0.7);
                            const b = Math.sin((life[i]*1.7) + m._ekgSeed*0.53) * (m._ekgJitter*0.3);
                            offset = a + b;
                            if (m._ekgTimer >= m._ekgNextSpike || (!m._ekgSpikedOnce && m._ekgTimer >= m._ekgGuaranteeAt)) {
                                // Decide spike amplitude: large if guarantee window hit or random chance
                                if (!m._ekgBigDone && m._ekgTimer >= m._ekgGuaranteeBigAt) {
                                    m._ekgUseAmp = m._ekgBigAmp; m._ekgBigDone = true;
                                } else {
                                    m._ekgUseAmp = (Math.random() < 0.18 ? m._ekgBigAmp : m._ekgSmallAmp);
                                    if (m._ekgUseAmp === m._ekgBigAmp) m._ekgBigDone = true;
                                }
                                m._ekgState = 'pre'; m._ekgTimer = 0;
                            }
                        } else if (st === 'pre') {
                            // Brief, tiny telegraph
                            const t = m._ekgTimer / Math.max(1,m._ekgPreDur);
                            const teleAmp = m._ekgJitter * (0.8 + t*0.4);
                            offset = Math.sin(m._ekgTimer*3.4 + m._ekgSeed) * teleAmp;
                            if (m._ekgTimer >= m._ekgPreDur) { m._ekgState = 'asc'; m._ekgTimer = 0; }
                        } else if (st === 'asc') {
                            // Linear rise to small peak
                            const t = Math.min(1, m._ekgTimer / m._ekgAscDur);
                            // Always spike to the positive side of our locked perpendicular (screen-up)
                            offset = Math.abs(m._ekgUseAmp) * t;
                            if (m._ekgTimer >= m._ekgAscDur) { m._ekgState = 'desc'; m._ekgTimer = 0; m._ekgSpikedOnce = true; }
                        } else if (st === 'desc') {
                            // Linear fall back to baseline (no undershoot)
                            const t = Math.min(1, m._ekgTimer / m._ekgDescDur);
                            offset = Math.abs(m._ekgUseAmp) * (1 - t);
                            if (m._ekgTimer >= m._ekgDescDur) { m._ekgState = 'recover'; m._ekgTimer = 0; }
                        } else if (st === 'recover') {
                            // Snap to baseline
                            const t = Math.min(1, m._ekgTimer / Math.max(1,m._ekgRecoverDur));
                            offset = m._ekgLastOffset * (1 - t);
                            if (m._ekgTimer >= m._ekgRecoverDur) {
                                m._ekgState = 'baseline';
                                m._ekgTimer = 0;
                                m._ekgLastOffset = 0; // hard reset baseline
                                m._ekgNextSpike = 10 + (Math.random()*8|0);
                            }
                        }
                        // Apply along locked perpendicular direction to keep spikes path-relative
                        let delta = offset - (m._ekgLastOffset || 0);
                        m._ekgLastOffset = offset;
                        // Clamp per-frame step: allow larger steps during spikes for visibility
                        const isSpike = (st === 'asc' || st === 'desc');
                        // Dynamic step clamp during spikes based on target amplitude and phase duration
                        let maxStep;
                        if (isSpike) {
                            const amp = Math.abs(m._ekgUseAmp || 0);
                            const dur = Math.max(1, (st === 'asc' ? m._ekgAscDur : m._ekgDescDur));
                            maxStep = Math.min(31, Math.max(7.7, (amp / dur) * 1.4));
                        } else {
                            maxStep = 2.05; // baseline clamp scaled up ~28% to match amplitude increase
                        }
                        if (delta > maxStep) delta = maxStep; else if (delta < -maxStep) delta = -maxStep;
                        // Directly adjust position perpendicular to motion; scale spikes a bit more
                        const scale = isSpike ? 1.0 : 0.85;
                        const px = (m._ekgPx != null && m._ekgPy != null) ? m._ekgPx : (function(){ const sv=Math.hypot(vx[i],vy[i])||0.0001; return -vy[i]/sv; })();
                        const py = (m._ekgPx != null && m._ekgPy != null) ? m._ekgPy : (function(){ const sv=Math.hypot(vx[i],vy[i])||0.0001; return vx[i]/sv; })();
                        x[i] += px * delta * scale;
                        y[i] += py * delta * scale;
                        // Visual cue at spike apex for readability (fires on entering 'desc')
                        if (st === 'desc' && m._ekgTimer === 0) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx) addParticle(x[i], y[i], '#66FFCC', 'spark');
                        }
                    }
                    // Temporal Drift (SoA): significantly stronger cadence that adjusts BOTH current displacement and underlying velocity
                    if (meta && meta.temporalDrift && !meta.enemy && !meta.beam) {
                        if (!meta._tdInit) {
                            meta._tdInit = true; meta._tdPhase = 0; meta._tdTimer = 0;
                            // Capture a base speed reference for clamping during surge/slow phases
                            const sp0 = Math.hypot(vx[i], vy[i]) || 0.0001;
                            meta._tdBaseSpeed = sp0;
                            // On-spawn ripple cue (fallback to particle ring if transient system unavailable)
                            const col = '#9FE6FF';
                            if (typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:x[i], y:y[i], color: col, radius: Math.max(10, (radius[i]||6) * 1.2), life: 120 });
                            } else {
                                addParticle(x[i], y[i], col, 'ring');
                            }
                        }
                        meta._tdTimer++;
                        const phase = meta._tdPhase;
                        if (phase === 0) { // slow-stretch (heavier decel, a bit longer)
                            const f = 0.94; // was 0.975 — make it clearly slower
                            dx *= f; dy *= f; vx[i] *= f; vy[i] *= f;
                            // Clamp not to stall below 55% of base speed
                            const base = meta._tdBaseSpeed || (Math.hypot(vx[i], vy[i])||0.0001);
                            const spNow = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const minSp = base * 0.55;
                            if (spNow < minSp) { const s = (minSp / spNow); vx[i]*=s; vy[i]*=s; dx*=s; dy*=s; }
                            if (meta._tdTimer > 30) { meta._tdPhase = 1; meta._tdTimer = 0; }
                        } else if (phase === 1) { // hold (shorter)
                            if (meta._tdTimer > 10) { meta._tdPhase = 2; meta._tdTimer = 0; }
                        } else if (phase === 2) { // surge (stronger accel, slightly longer)
                            const f = 1.08; // was 1.035 — make it pop
                            dx *= f; dy *= f; vx[i] *= f; vy[i] *= f;
                            // Clamp to max 2.0x base speed
                            const base = meta._tdBaseSpeed || (Math.hypot(vx[i], vy[i])||0.0001);
                            const spNow = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const maxSp = base * 2.0;
                            if (spNow > maxSp) { const s = (maxSp / spNow); vx[i]*=s; vy[i]*=s; dx*=s; dy*=s; }
                            if (meta._tdTimer > 18) { meta._tdPhase = 0; meta._tdTimer = 0; }
                        }
                        // Pre-beat ring in final frames before phase swap
                        const th = phase === 0 ? 30 : (phase === 1 ? 10 : 18);
                        if (meta._tdTimer >= th - 3) {
                            // Always spawn a minimal ring and, when allowed, a brighter ramping ring
                            const col = phase===2 ? '#A4F5FF' : '#7EDCFF';
                            addParticle(x[i], y[i], col, 'ring');
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings) addParticle(x[i], y[i], col, 'ring');
                        }
                    }
                    // Pendulum swing flip detection: ring cue on sign change of lateral component
                    {
                        const metaP = game._projMeta && game._projMeta.get(i);
                        if (metaP && metaP.pendulumPattern) {
                            // Build perpendicular to spawn forward
                            const fx0 = metaP._initialFx != null ? metaP._initialFx : (vx[i]||1)/Math.hypot(vx[i]||1,vy[i]||0.0001);
                            const fy0 = metaP._initialFy != null ? metaP._initialFy : (vy[i]||0)/Math.hypot(vx[i]||1,vy[i]||0.0001);
                            const px0 = -fy0, py0 = fx0;
                            const lat = dx*px0 + dy*py0; // lateral component this frame
                            const sign = lat >= 0 ? 1 : -1;
                            const prev = metaP._pendPrevSign == null ? sign : metaP._pendPrevSign;
                            metaP._pendPrevSign = sign;
                            metaP._pendCd = (metaP._pendCd||0) - 1;
                            if (sign !== prev && metaP._pendCd <= 0) {
                                metaP._pendCue = 10; // frames to display
                                metaP._pendCd = 14;  // cooldown
                            }
                            if (metaP._pendCue>0) metaP._pendCue--;
                        }
                    }
                    // Vector Pivot: periodic 90° turns with a brief pre-telegraph; choose left/right randomly each turn
                    {
                        const metaV = game._projMeta && game._projMeta.get(i);
                        if (metaV && metaV.pivotPattern && !metaV.beam && !metaV.enemy) {
                            if (!metaV._pivotInit) {
                                metaV._pivotInit = true;
                                metaV._pivotSeg = 16;           // frames between pivots
                                metaV._pivotTimer = metaV._pivotSeg;
                                metaV._pivotDir = (Math.random() < 0.5 ? -1 : 1); // initial side
                                metaV._pivotAngle = Math.PI * 0.5; // 90°
                                metaV._pivotCue = 0;
                                // Remember initial forward
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                metaV._pivotFx = vx[i]/sp; metaV._pivotFy = vy[i]/sp;
                            }
                            metaV._pivotTimer--;
                            // pre-telegraph a few frames before the turn
                            if (metaV._pivotTimer === 3) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#DDEBFF','ring');
                            }
                            if (metaV._pivotTimer <= 0) {
                                // Snap-turn velocity by +/- 90°; keep speed, add slight boost for readability
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                const ang = Math.atan2(vy[i], vx[i]);
                                const newAng = ang + metaV._pivotDir * metaV._pivotAngle;
                                const newSp = sp * 1.06;
                                const nx = Math.cos(newAng), ny = Math.sin(newAng);
                                vx[i] = nx * newSp;
                                vy[i] = ny * newSp;
                                // Apply immediately to this frame's displacement so turn is visible right away
                                dx = nx; dy = ny;
                                // Visual cue
                                metaV._pivotCue = 10;
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#CFE8FF','ring');
                                // Pick a random side for the next pivot and reset timer
                                metaV._pivotDir = (Math.random() < 0.5 ? -1 : 1);
                                metaV._pivotTimer = metaV._pivotSeg;
                            } else if (metaV._pivotTimer < 0) {
                                metaV._pivotTimer = metaV._pivotSeg;
                            }
                            if (metaV._pivotCue>0) metaV._pivotCue--;
                        }
                    }
                    // Uzumaki global spiral: projectile travels in expanding spiral path centered on player position at spawn.
                    {
                        const mU = game._projMeta && game._projMeta.get(i);
                        if (mU && mU.hasUzumaki && mU._uzuCx != null && mU._uzuCy != null) {
                            if (!mU._uzuInit) {
                                mU._uzuInit = true;
                                // derive starting polar coords from current position
                                const dx0 = x[i] - mU._uzuCx, dy0 = y[i] - mU._uzuCy;
                                const r0 = Math.hypot(dx0, dy0) || (mU._uzuRadius||18);
                                mU._uzuRadius = r0;
                                mU._uzuAngle = Math.atan2(dy0, dx0);
                                // Subtle center ping (perf-aware)
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addTransientEffect({ type:'ringFlash', x:mU._uzuCx, y:mU._uzuCy, color:'#FFEEDD', radius: 22, life: 160 });
                            }
                            // evolve swirl
                            mU._uzuRadius += (mU._uzuRadialVel || 1.5);
                            if (mU._uzuDrag) mU._uzuRadialVel *= (1 - mU._uzuDrag);
                            mU._uzuAngle += (mU._uzuAngularVel || 0.2);
                            if (mU._uzuAngularVel) mU._uzuAngularVel *= 1.003;
                            let targetX = mU._uzuCx + Math.cos(mU._uzuAngle) * mU._uzuRadius;
                            let targetY = mU._uzuCy + Math.sin(mU._uzuAngle) * mU._uzuRadius;
                            // Synergy: if Pendulum is also active, apply a pendulum-style lateral swing around the Uzumaki path
                            if (mU.pendulumPattern && !mU._pendDone) {
                                if (!mU._uzuPendInit) {
                                    mU._uzuPendInit = true;
                                    mU._uzuPendAngle = (Math.random()<0.5?-1:1) * 0.65;
                                    mU._uzuPendVel = 0;
                                    mU._uzuPendLen = 32; // lateral swing extent
                                    mU._uzuPendGrav = 0.065; // swing acceleration
                                    mU._uzuPendDamp = 0.992; // damping
                                }
                                // Approximate tangent along swirl using previous target
                                const prevTx = mU._lastUzuTx != null ? mU._lastUzuTx : prevX;
                                const prevTy = mU._lastUzuTy != null ? mU._lastUzuTy : prevY;
                                const tdx = targetX - prevTx; const tdy = targetY - prevTy;
                                const tl = Math.hypot(tdx, tdy) || 1; const tfx = tdx / tl; const tfy = tdy / tl;
                                // Perpendicular to tangent
                                const px = -tfy, py = tfx;
                                // Integrate pendulum swing
                                const angAcc = -mU._uzuPendGrav * Math.sin(mU._uzuPendAngle);
                                mU._uzuPendVel += angAcc;
                                mU._uzuPendVel *= mU._uzuPendDamp;
                                mU._uzuPendAngle += mU._uzuPendVel;
                                const lateral = Math.sin(mU._uzuPendAngle) * mU._uzuPendLen;
                                targetX += px * lateral;
                                targetY += py * lateral;
                                mU._lastUzuTx = targetX; mU._lastUzuTy = targetY;
                            }
                            // Blend Uzumaki target motion additively with any existing displacement (so it can synergize with Spiral, Sine, etc.)
                            const uzDx = (targetX - prevX) / dt;
                            const uzDy = (targetY - prevY) / dt;
                            // If Spiral is also active, reduce Uzumaki authority a bit so local loops remain visible
                            const uzBlend = ((f & FLAG.SPIRAL) ? 0.40 : 0.60);
                            dx += (uzDx - dx) * uzBlend;
                            dy += (uzDy - dy) * uzBlend;
                            // occasional swirl dust (perf-aware)
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !hideSparks && Math.random() < 0.08) addParticle(x[i], y[i], '#FFAaff', 'swirl');
                        }
                    }
                    // True spiral motion: orbit around a forward-moving anchor to create large circular loops
                    if (f & FLAG.SPIRAL) {
                        // Ensure metadata bucket exists
                        if (!game._projMeta) game._projMeta = new Map();
                        let m = game._projMeta.get(i);
                        if (!m) { m = {}; game._projMeta.set(i, m); }
                        if (!m._spiralInit) {
                            m._spiralInit = true;
                            // Base drift direction from current velocity; fallback to player lastDirection for degenerate cases
                            let ang = Math.atan2(vy[i], vx[i]);
                            if (!isFinite(ang) || (Math.abs(vx[i]) < 0.0001 && Math.abs(vy[i]) < 0.0001)) {
                                const ld = (game.player && game.player.lastDirection) || {x:1,y:0};
                                ang = Math.atan2(ld.y, ld.x);
                            }
                            m._spiralBaseAngle = ang;
                            // Start phase randomized for variety between shots
                            m._spiralPhase = Math.random() * Math.PI * 2;
                            // Larger starting loop radius; allow expansion to a generous cap
                            const startR = Math.max(12, (radius[i] || 6) * 2.2);
                            // Scale radii by performance tier (smaller on high load)
                            const tierScale = (tier===0?1.0:(tier===1?0.85:(tier===2?0.7:0.55)));
                            m._spiralRadius = startR * tierScale;
                            m._spiralRadiusMax = 120 * tierScale;
                            m._spiralRadiusGrowth = 0.10 * tierScale; // px/frame growth
                            // Angular speed for visible loops
                            m._spiralAngularSpeed = (0.28 + Math.random()*0.10) * tierScale;
                            // Forward drift along base direction; damped so loops remain large and readable
                            m._spiralForwardSpeed = (Math.hypot(vx[i], vy[i]) || 2.5) * 0.70;
                            m._spiralAnchorX = x[i];
                            m._spiralAnchorY = y[i];
                            // Spawn ring at start (perf-aware)
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFBBFF','ring');
                        }
                        // Advance spiral state
                        m._spiralPhase += m._spiralAngularSpeed;
                        m._spiralRadius = Math.min(m._spiralRadiusMax, m._spiralRadius + m._spiralRadiusGrowth);
                        m._spiralAnchorX += Math.cos(m._spiralBaseAngle) * m._spiralForwardSpeed * dt;
                        m._spiralAnchorY += Math.sin(m._spiralBaseAngle) * m._spiralForwardSpeed * dt;
                        const newX = m._spiralAnchorX + Math.cos(m._spiralPhase) * m._spiralRadius;
                        const newY = m._spiralAnchorY + Math.sin(m._spiralPhase) * m._spiralRadius;
                        // Blend this frame's displacement toward the spiral path (additive, so it can coexist with Uzumaki/global swirl)
                        const spDx = (newX - prevX) / dt;
                        const spDy = (newY - prevY) / dt;
                        const spBlend = (m && m.hasUzumaki) ? 0.62 : 0.80;
                        dx += (spDx - dx) * spBlend;
                        dy += (spDy - dy) * spBlend;
                        // Rim tick at quadrant change (perf-aware)
                        {
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            if (!lowFx && !reduceRings) {
                                const q = Math.floor((m._spiralPhase || 0) / (Math.PI/2));
                                if (m._spiralLastQuad == null) m._spiralLastQuad = q;
                                if (q !== m._spiralLastQuad) {
                                    m._spiralLastQuad = q;
                                    if (Math.random() < 0.18) addParticle(newX, newY, '#FFAAFF','ring');
                                }
                            }
                        }
                    }
                    // Full Homing Shot uses flag; Seeking Shot (weak homing) is carried via metadata. Both supported here.
                    if (baseHomingScale && (game.enemies && game.enemies.length)) {
                        const metaH = game._projMeta && game._projMeta.get(i);
                        const hasFullHoming = !!(f & FLAG.HOMING);
                        const hasWeakHoming = !!(metaH && metaH.weakHoming);
                        if (!(hasFullHoming || hasWeakHoming)) {
                            // Neither homing mode present — skip
                        } else {
                            // Determine effective scale (weak homing is gentler). Allow per-projectile overrides (e.g., SIGMA).
                            let homingScale = hasFullHoming ? baseHomingScale : (baseHomingScale * 0.5);
                            if (metaH && typeof metaH._sigmaHomingFactor === 'number') {
                                homingScale *= metaH._sigmaHomingFactor;
                            }
                        let bestDx=0,bestDy=0,bestD2=1e12;
                        if (game.enemyHash && game.enemyHash.buckets.size) {
                            const cs = game.enemyHash.cell;
                            const cx0 = (x[i]/cs)|0; const cy0 = (y[i]/cs)|0;
                            for (let cyOff=-1; cyOff<=1; cyOff++){
                                for (let cxOff=-1; cxOff<=1; cxOff++){
                                    const key = ((cx0+cxOff)<<16) ^ (cy0+cyOff);
                                    const bucket = game.enemyHash.buckets.get(key); if(!bucket) continue;
                                    for (let bi=0; bi<bucket.length; bi++){
                                        const e = game.enemies[bucket[bi]]; if(!e || e.dead || e.health<=0) continue;
                                        const tx = e.x - x[i]; const ty = e.y - y[i];
                                        const d2 = tx*tx+ty*ty; if (d2 < bestD2){ bestD2=d2; bestDx=tx; bestDy=ty; }
                                    }
                                }
                            }
                        } else {
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const e = game.enemies[ei]; if(!e || e.dead || e.health<=0) continue;
                                const tx = e.x - x[i]; const ty = e.y - y[i];
                                const d2 = tx*tx+ty*ty; if (d2 < bestD2){ bestD2=d2; bestDx=tx; bestDy=ty; }
                            }
                        }
                        if (bestD2 < 1e12) {
                            const len = Math.sqrt(bestD2)||1;
                            // Apply immediate steering to this frame's displacement
                            dx += (bestDx/len)*homingScale;
                            dy += (bestDy/len)*homingScale;
                            // Also gently bias the underlying velocity toward the steered direction
                            const baseSpeed = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const dlen = Math.hypot(dx, dy) || 1;
                            const dirX = dx / dlen, dirY = dy / dlen;
                            let blend = hasFullHoming ? 0.14 : 0.06; // full homing curves harder
                            if (metaH && typeof metaH._sigmaBlendBoost === 'number') {
                                blend += metaH._sigmaBlendBoost;
                            }
                            vx[i] = vx[i]*(1 - blend) + dirX * baseSpeed * blend;
                            vy[i] = vy[i]*(1 - blend) + dirY * baseSpeed * blend;
                            // Mark active homing window for rendering chevrons
                            if (!game._projMeta) game._projMeta = new Map();
                            const mHAct = metaH || game._projMeta.get(i) || {};
                            mHAct._homActive = Math.min(12, (mHAct._homActive||0) + 2); // short accumulating timer
                            game._projMeta.set(i, mHAct);
                            // Homing steer cue metadata: mark when steering angle changes abruptly
                            if (!game._projMeta) game._projMeta = new Map();
                            let mHMeta = metaH; if (!mHMeta) { mHMeta = {}; game._projMeta.set(i, mHMeta); }
                            const aNow = Math.atan2(dy, dx);
                            if (isFinite(aNow)) {
                                if (mHMeta._homLastAng == null) mHMeta._homLastAng = aNow;
                                let dAng = aNow - mHMeta._homLastAng; while (dAng > Math.PI) dAng -= Math.PI*2; while (dAng < -Math.PI) dAng += Math.PI*2;
                                mHMeta._homCd = (mHMeta._homCd||0) - 1;
                                if (Math.abs(dAng) > 0.40 && (mHMeta._homCd||0) <= 0) { // ~23°
                                    mHMeta._homCue = 8; // frames to render chevron
                                    mHMeta._homCd = 14; // cooldown
                                    // Ping ring on current target (perf-aware, skip if reduceRings)
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!lowFx && !reduceRings) {
                                        // find best target again quickly (cheap reuse bestDx/bestDy we already have)
                                        const tx = x[i] + bestDx; const ty = y[i] + bestDy;
                                        addParticle(tx, ty, '#B4F5FF','ring');
                                    }
                                }
                                mHMeta._homLastAng = aNow;
                            }
                        }
                        }
                    }
                    // Decay homing steer cue timers if present
                    {
                        const mH2 = game._projMeta && game._projMeta.get(i);
                        if (mH2) {
                            if (mH2._homCue>0) mH2._homCue--;
                            if (mH2._homCd>0) mH2._homCd--;
                            if (mH2._homActive>0) mH2._homActive--;
                        }
                    }
                    // Apply Resonant Pulse buffs (SoA) just before integrating movement
                    if (meta) {
                        if (meta._resBuffSpeed && meta._resBuffSpeed>0) {
                            meta._resBuffSpeed--;
                            dx *= 1.045; dy *= 1.045;
                        }
                        if (meta._resBuffHoming && meta._resBuffHoming>0) {
                            meta._resBuffHoming--;
                            // mild steering toward nearest enemy
                            let nd2 = Infinity, bx = 0, by = 0;
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const e = game.enemies[ei]; if(!e || e.dead || e.health<=0) continue;
                                const tx = e.x - x[i]; const ty = e.y - y[i]; const d2 = tx*tx+ty*ty; if (d2<nd2){ nd2=d2; bx=tx; by=ty; }
                            }
                            if (nd2 < 1e12) {
                                const len = Math.sqrt(nd2)||1; dx += (bx/len)*0.12; dy += (by/len)*0.12;
                            }
                        }
                        if (meta._resBuffDamage && meta._resBuffDamage>0) {
                            // Apply temporary SoA damage boost while timer remains and decay timer
                            meta._resBuffDamage--;
                            if (!meta._resDmgBoostActive) {
                                meta._resDmgBoostActive = true;
                                meta._resDmgOrig = damage[i];
                            }
                            const base = meta.baseDamage || damage[i] || 1;
                            const boosted = Math.max(1, Math.floor(base * 1.15));
                            damage[i] = boosted;
                        } else if (meta._resDmgBoostActive) {
                            // Restore original damage when buff ends
                            if (typeof meta._resDmgOrig === 'number') damage[i] = meta._resDmgOrig;
                            meta._resDmgBoostActive = false;
                            delete meta._resDmgOrig;
                        }
                    }
                    x[i] += dx * dt; y[i] += dy * dt;

                    // Gold tooth travelling-side sparkles and small AoE tick
                    try {
                        const meta = game._projMeta && game._projMeta.get(i);
                        if (meta && meta.goldTooth && life[i] > 0) {
                            // Per-projectile cooldown to avoid per-frame cost
                            meta._goldTickCd = (meta._goldTickCd || 0) - 16;
                            if (meta._goldTickCd <= 0) {
                                meta._goldTickCd = 160 + Math.floor(Math.random()*80); // ~160ms cadence
                                // Compute perpendicular offsets (both sides)
                                const vx0 = vx[i] || 0; const vy0 = vy[i] || 0;
                                const spd = Math.hypot(vx0, vy0) || 0.0001;
                                const nx = -vy0 / spd; const ny = vx0 / spd; // unit normal
                                // Larger lateral offset so sparkles emit a fair distance from the tooth
                                const off = Math.max(28, (radius[i]||6) * 3.0);
                                const sx1 = x[i] + nx * off; const sy1 = y[i] + ny * off;
                                const sx2 = x[i] - nx * off; const sy2 = y[i] - ny * off;
                                // Visual sparkles that 'shoot out' along the lateral normal: place a short chain of sparks stepping outward
                                if (!(game.perf && game.perf.lowFx)) {
                                    const chainLen = 4;
                                    for (let s=0; s<chainLen; s++) {
                                        const step = s * Math.max(6, off * 0.18);
                                        const jitter = (Math.random()-0.5) * (off * 0.18);
                                        // side 1
                                        const px1 = x[i] + nx * (off + step) + vx[i] * 0.06;
                                        const py1 = y[i] + ny * (off + step) + vy[i] * 0.06;
                                        addParticle(px1 + jitter, py1 + jitter, (Math.random()<0.6? '#FFD780' : '#FFF6C8'), 'spark');
                                        // side 2
                                        const px2 = x[i] - nx * (off + step) + vx[i] * 0.06;
                                        const py2 = y[i] - ny * (off + step) + vy[i] * 0.06;
                                        addParticle(px2 + jitter, py2 + jitter, (Math.random()<0.6? '#FFF6C8' : '#FFD780'), 'spark');
                                        // occasional brighter flare at chain tip
                                        if (Math.random() < 0.12) addParticle(x[i] + nx * (off + step) + (Math.random()-0.5)*8, y[i] + ny * (off + step) + (Math.random()-0.5)*8, '#FFF9E0', 'explosion');
                                    }
                                }
                                // Damage nearby enemies around each side once per tick (avoid double-hitting same enemy this tick)
                                try {
                                    const hitSet = new Set();
                                    const dmgBase = Math.max(1, Math.floor((meta.baseDamage || damage[i] || 8) * 0.14));
                                    const checkRadius = Math.max(18, off * 0.9);
                                    const r2 = checkRadius * checkRadius;
                                    for (let ei=0; ei<game.enemies.length; ei++) {
                                        const e = game.enemies[ei]; if (!e || e.health <= 0) continue;
                                        const dx1 = e.x - sx1; const dy1 = e.y - sy1; if (dx1*dx1 + dy1*dy1 <= r2) { if (!hitSet.has(e)) { e.health -= dmgBase; addDamageNumber(dmgBase, e.x, e.y - (e.size||24)/2, { type: 'gold' }); addParticle(e.x, e.y, '#FFE8A0', 'impact'); hitSet.add(e); } }
                                        const dx2 = e.x - sx2; const dy2 = e.y - sy2; if (dx2*dx2 + dy2*dy2 <= r2) { if (!hitSet.has(e)) { e.health -= dmgBase; addDamageNumber(dmgBase, e.x, e.y - (e.size||24)/2, { type: 'gold' }); addParticle(e.x, e.y, '#FFF3BF', 'impact'); hitSet.add(e); } }
                                    }
                                } catch(_) {}
                            }
                        }
                    } catch(_) {}

                    // Wall/obstacle collisions for SoA projectiles (bounce or consume)
                    // Respect phasing when present in metadata; reflect velocity on axis of collision when bouncing.
                    if (typeof isWall === 'function') {
                        const meta = game._projMeta && game._projMeta.get(i);
                        const sizeArg = Math.max(8, radius[i]);
                        const phasing = !!(meta && meta.phasing);
                        const wasInWall = !!(meta && meta._wasInWall);
                        const nowInWall = !!isWall(x[i], y[i], sizeArg);
                        // Phasing ripple: entering/exiting walls spawns a subtle ring cue (perf-aware)
                        if (phasing) {
                            if (!wasInWall && nowInWall) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#CCB8FF', 'ring');
                            } else if (wasInWall && !nowInWall) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#E6DDFF', 'ring');
                            }
                            if (meta) meta._wasInWall = nowInWall;
                        }
                        if (!phasing && nowInWall) {
                            const canBounce = (meta && meta.bouncing) || (f & FLAG.BOUNCE);
                            if (canBounce) {
                                // Determine collision axis by probing axis-separated movement from previous position
                                const hitX = isWall(prevX + dx * dt, prevY, sizeArg);
                                const hitY = isWall(prevX, prevY + dy * dt, sizeArg);
                                if (hitX) { vx[i] = -vx[i]; x[i] = prevX; }
                                if (hitY) { vy[i] = -vy[i]; y[i] = prevY; }
                                if (!hitX && !hitY) { // corner/ambiguous: invert both
                                    vx[i] = -vx[i]; vy[i] = -vy[i]; x[i] = prevX; y[i] = prevY;
                                }
                                if (meta && typeof meta.bounces === 'number') meta.bounces = Math.max(0, meta.bounces - 1);
                                if (!(game.perf && game.perf.lowFx)) {
                                    addParticle(x[i], y[i], '#AACCFF', 'spark');
                                }
                                // Bounce ring cue (respect reduceRings)
                                if (!(game.fxFlags && game.fxFlags.reduceRings)) {
                                    addParticle(x[i], y[i], '#CFE8FF', 'ring');
                                }
                                // Store a short-lived bounce telegraph (normal vector + timer) for oriented dust puff in renderer
                                if (meta) {
                                    // Approximate normal from which axis(s) collided
                                    let nx = 0, ny = 0;
                                    if (hitX && !hitY) nx = Math.sign(prevX - x[i]);
                                    else if (hitY && !hitX) ny = Math.sign(prevY - y[i]);
                                    else { // corner: derive from velocity flip
                                        const sp = Math.hypot(vx[i], vy[i])||1; nx = -vx[i]/sp; ny = -vy[i]/sp;
                                    }
                                    meta._bounceNx = nx; meta._bounceNy = ny; meta._bounceFlash = 10;
                                }
                                // If no bounces left, consume now (gold tooth explodes into gold dust)
                                if (meta && typeof meta.bounces === 'number' && meta.bounces <= 0) {
                                    try {
                                        if (meta && meta.goldTooth) {
                                            try {
                                                // Create a lingering gold-dust pool with sparkling visuals and periodic splash damage
                                                const poolRadius = Math.max(48, (radius[i]||6) * 6);
                                                const poolDur = 5200; // ms of lingering effect
                                                const baseDmg = damage[i] || 12;
                                                explodeProjectile({ x: x[i], y: y[i], size: Math.max(6, radius[i]||6), enemy: false, damageType: 'solar', goldDust: true, goldDustRadius: poolRadius, goldDustDuration: poolDur, baseDamage: baseDmg }, baseDmg);
                                            } catch(_) {}
                                        }
                                    } catch(_) {}
                                    life[i]=0; recycle(i); continue;
                                }
                            } else {
                                life[i]=0; recycle(i); continue;
                            }
                        }
                    }
                    if (x[i] < -50 || y[i] < -50 || x[i] > LOGICAL_W+50 || y[i] > LOGICAL_H+50) {
                        // Do not recycle indestructible entities; reflect and clamp instead
                        const m = meta; // alias
                        if (m && m.indestructible) {
                            // Clamp to arena bounds with a small inset and reflect velocity
                            const inset = 6;
                            if (x[i] < inset) { x[i] = inset; vx[i] = Math.abs(vx[i]); }
                            if (y[i] < inset) { y[i] = inset; vy[i] = Math.abs(vy[i]); }
                            if (x[i] > LOGICAL_W - inset) { x[i] = LOGICAL_W - inset; vx[i] = -Math.abs(vx[i]); }
                            if (y[i] > LOGICAL_H - inset) { y[i] = LOGICAL_H - inset; vy[i] = -Math.abs(vy[i]); }
                            if (!(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#EED7AA','spark');
                        } else {
                            recycle(i); continue;
                        }
                    }
                    // Metadata special behaviors (Popcorn kernel fuse -> pop spawning puffs & kernel bursts)
                    if (game._projMeta) {
                        const meta = game._projMeta.get(i);
                        // SoA Fragment Wake: emit lingering damaging sparks along path for projectiles with effect
                        if (meta && meta.fragmentWake && !meta.beam && !meta.enemy) {
                            // Initialize per-projectile emission tracking in metadata
                            if (meta._fwPrevX == null) { meta._fwPrevX = x[i]; meta._fwPrevY = y[i]; meta._fwDistAcc = 0; meta._fwRandOff = (Math.random()*6); }
                            const dxFW = x[i] - meta._fwPrevX, dyFW = y[i] - meta._fwPrevY;
                            const distFW = Math.hypot(dxFW, dyFW);
                            meta._fwDistAcc += distFW;
                            meta._fwPrevX = x[i]; meta._fwPrevY = y[i];
                            const spacing = 14 + meta._fwRandOff; // ~14-20px
                            while (meta._fwDistAcc >= spacing) {
                                meta._fwDistAcc -= spacing;
                                const baseDmg = meta.baseDamage || damage[i] || calculateDamage();
                                if (!Array.isArray(game.fragmentSparks)) game.fragmentSparks = [];
                                if (game.fragmentSparks.length > 220) game.fragmentSparks.splice(0, game.fragmentSparks.length - 220);
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                    addParticle(x[i], y[i], '#FFE6AA','spark');
                                }
                                game.fragmentSparks.push({
                                    x: x[i] + (Math.random()-0.5)*6,
                                    y: y[i] + (Math.random()-0.5)*6,
                                    r: Math.max(5, Math.min(10, 6 + Math.random()*3)),
                                    ttl: 38,
                                    maxTtl: 38,
                                    damage: Math.max(1, Math.floor(baseDmg * 0.10)),
                                    dpsTick: 0,
                                    hitMap: new Set(),
                                    pulse: Math.random()*Math.PI*2
                                });
                            }
                        }
                        // (Removed EKG velocity-impulse scheduler; spikes now handled by subtle position offsets only)
                        // SoA Growing Shot
                        if (meta && meta.growing && !meta.beam && !meta.enemy) {
                            if (!meta._growInit) {
                                meta._growInit = true; meta._growTicks = 0;
                                const start = Math.max(2, radius[i]||4);
                                // Higher cap so big growth is possible; scale slightly with pattern synergy
                                let baseCapMult = 7.0; // was 4.0
                                if (flags[i] & FLAG.SPIRAL) baseCapMult += 0.60;
                                if (flags[i] & FLAG.SINE) baseCapMult += 0.40;
                                if (flags[i] & FLAG.WACKY) baseCapMult += 0.25;
                                if (flags[i] & FLAG.EKG) baseCapMult += 0.20;
                                if (meta.infusionElements && meta.infusionElements.length) baseCapMult += Math.min(0.20, 0.06 * meta.infusionElements.length);
                                meta._growHardCap = Math.min(255, Math.floor(start * baseCapMult));
                                meta._growSoftCap = Math.floor(start * (baseCapMult * 0.80));
                            }
                            meta._growTicks++;
                            // Gradual, life-based growth: ramps up then eases as it nears cap
                            const sz = radius[i]; const hard = meta._growHardCap; const soft = meta._growSoftCap;
                            if (sz < hard) {
                                // Progress from 0..1 over most of projectile life
                                const lifeFrac = 1 - (life[i] / Math.max(1, lifeMax[i]));
                                // Base multiplicative growth per tick: slow at first, peaks mid-life, eases late
                                const curve = Math.sin(Math.min(1, lifeFrac) * Math.PI); // 0..1..0
                                // Map to small per-tick percentage; lower tiers reduce growth slightly for perf fairness
                                const tierMul = (tier===0?1.0:(tier===1?0.95:(tier===2?0.9:0.85)));
                                let pct = 0.020 + curve * 0.030; // 2%..5% multiplicative growth
                                pct *= tierMul;
                                // Ease as we pass soft cap
                                if (sz > soft) {
                                    const t = (sz - soft) / Math.max(1, (hard - soft));
                                    const damp = 1 - Math.min(1, t);
                                    pct *= 0.35 + 0.65 * damp; // reduce growth near hard cap
                                }
                                const next = Math.min(hard, Math.max(sz + 1, Math.floor(sz * (1 + pct))));
                                radius[i] = next;
                            }
                        }
                        // SoA Sawtooth Wave (with cusp telegraph)
                        if (meta && meta.sawWave && !meta.beam && !meta.enemy) {
                            if (!meta._sawInit) {
                                meta._sawInit = true; meta._sawT = 0;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._sawFx = vx[i]/sp; meta._sawFy = vy[i]/sp; meta._sawPx = -meta._sawFy; meta._sawPy = meta._sawFx;
                                // Stronger, snappier cadence
                                meta._sawPeriod = 20 + ((Math.random()*12)|0); // was 38-51, now ~20-31 frames
                                meta._sawAmp = 52 + Math.random()*24; // was ~24-34, now ~52-76
                                meta._sawLast = 0;
                            }
                            const prevT = meta._sawT;
                            meta._sawT = (meta._sawT + 1) % meta._sawPeriod;
                            // Sharper cusp segment for a more pronounced snap
                            const tSaw = meta._sawT / meta._sawPeriod; let wave = tSaw; if (tSaw > 0.96) wave = -1 + (tSaw - 0.96)/0.04;
                            const lateral = (wave - 0.46) * 2 * meta._sawAmp; const dl = lateral - (meta._sawLast||0); meta._sawLast = lateral;
                            // Heavier lateral displacement scale
                            x[i] += meta._sawPx * dl * 0.32; y[i] += meta._sawPy * dl * 0.32; // was 0.12
                            // cusp: when period wraps back to 0 (telegraph stronger)
                            if (meta._sawT === 0 && prevT !== 0) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!reduceRings) { addParticle(x[i], y[i], '#AEEBFF','ring'); addParticle(x[i], y[i], '#AEEBFF','ring'); }
                                if (!lowFx && !hideSparks) {
                                    for (let s=0;s<4;s++) addParticle(x[i] + (Math.random()-0.5)*7, y[i] + (Math.random()-0.5)*7, '#D4F3FF','spark');
                                }
                            }
                        }
                        // Drill shot support: maintain a spinning phase and emit subtle sparks.
                        // Note: Full drill sprite now only renders when weaponType === 'drill'.
                        // When meta.drilling is true with another weaponType, we keep only the overlay.
                        if (meta && (meta.drilling || meta.weaponType === 'drill') && !meta.beam && !meta.enemy) {
                            if (!meta._drillInit) { meta._drillInit = true; meta._drillPhase = 0; }
                            meta._drillPhase += 0.35; // radians/frame
                            if (!(game.perf && game.perf.lowFx) && Math.random() < 0.25) {
                                const ang = Math.atan2(vy[i], vx[i]);
                                const bx = x[i] - Math.cos(ang) * Math.max(4, radius[i]*0.6);
                                const by = y[i] - Math.sin(ang) * Math.max(4, radius[i]*0.6);
                                addParticle(bx + (Math.random()-0.5)*3, by + (Math.random()-0.5)*3, '#D0E4FF','spark');
                            }
                        }
                        // Smart Bomb (SoA): explode near enemies
                        if (meta && meta.smartExplosive && !meta.enemy && life[i] > 0) {
                            let closest = Infinity;
                            for (let ei=0; ei<game.enemies.length; ei++) {
                                const en = game.enemies[ei]; if (!en || en.health <= 0) continue;
                                const d = Math.hypot(en.x - x[i], en.y - y[i]);
                                if (d < closest) closest = d;
                            }
                            if (closest < 56) {
                                const dmg = meta.baseDamage || damage[i] || calculateDamage();
                                const projObj = { x: x[i], y: y[i], size: Math.max(6, radius[i]||6) };
                                if (meta.damageType) projObj.damageType = meta.damageType;
                                if (meta.chainExplosion) projObj.chainExplosion = true;
                                if (meta.knockback) { projObj.knockback = true; projObj.knockbackDistance = meta.knockbackDistance; }
                                if (meta.areaEffect) projObj.areaEffect = true;
                                if (meta.vortex) projObj.vortex = true;
                                if (meta.blackHole) projObj.blackHole = true;
                                if (meta.timeWarp) projObj.timeWarp = true;
                                if (meta.dimensional) projObj.dimensional = true;
                                explodeProjectile(projObj, dmg);
                                if (!(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#FFD780','explosion');
                                life[i] = 0; recycle(i); continue;
                            }
                        }
                            // Toenail Clibbins: add independent spin so the shard rotates as it flies (purely visual)
                            // Apply to explicit toenail weaponType and crescent shards (meta.toenail)
                            if (meta && (meta.weaponType === 'toenail' || meta.toenail) && !meta.beam && !meta.enemy) {
                                if (!meta._toeSpinInit) {
                                    meta._toeSpinInit = true;
                                    meta._toeSpin = 0;
                                    // Randomize spin direction/speed; scale slightly with projectile size
                                    const base = 0.12 + Math.random() * 0.20;
                                    const sizeBoost = Math.min(0.18, (radius[i] || 8) * 0.004);
                                    meta._toeSpinSpeed = (Math.random() < 0.5 ? -1 : 1) * (base + sizeBoost);
                                }
                                meta._toeSpin += meta._toeSpinSpeed;
                            }
                        // Slalom pattern (SoA): gated straight segments with sharp alternating turns (intensified)
                        if (meta && meta.slalomPattern && !meta.beam && !meta.enemy) {
                            if (!meta._slaInit) {
                                meta._slaInit = true;
                                meta._slaSeg = 0;
                                meta._slaSegLen = 12; // shorter straight gate for higher cadence
                                meta._slaTurn = 0.62; // stronger snap-turn
                                meta._slaDir = 1;     // next turn sign
                                meta._slaMax = 10;    // more turns before straightening
                                meta._slaMade = 0;
                                meta._slaPrevAng = Math.atan2(vy[i], vx[i]);
                            }
                            meta._slaSeg++;
                            // pre-turn telegraph in last few frames of the segment
                            if (meta._slaSeg >= meta._slaSegLen - 3 && !(game.perf && game.perf.lowFx)) {
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings) addParticle(x[i], y[i], '#88EEFF','ring');
                            }
                            if (meta._slaSeg >= meta._slaSegLen && meta._slaMade < meta._slaMax) {
                                meta._slaSeg = 0; meta._slaMade++;
                                // snap rotate velocity by fixed angle
                                const ang = Math.atan2(vy[i], vx[i]);
                                const newAng = ang + meta._slaDir * meta._slaTurn;
                                const spd = Math.hypot(vx[i], vy[i]) || 2.5;
                                const boost = 1.06; // slight forward boost to accent the zig
                                vx[i] = Math.cos(newAng) * spd * boost;
                                vy[i] = Math.sin(newAng) * spd * boost;
                                meta._slaDir *= -1;
                                if (!(game.perf && game.perf.lowFx)) for (let s=0;s<3;s++) addParticle(x[i], y[i], '#66D6FF','spark');
                            }
                            if (meta._slaMade >= meta._slaMax) {
                                meta.slalomPattern = false; // done zigzagging
                            }
                        }
                        // SoA beam damage ticks along a short forward segment (laser/particle)
                        if (meta && meta.beam && !meta.enemy && game.enemies && game.enemies.length) {
                            let sp = Math.hypot(vx[i], vy[i]) || 0.0001; let fx = vx[i]/sp, fy = vy[i]/sp;
                            // Scribble beams act differently: long-range, jittered path, and chain between enemies
                            const isScrib = !!(meta && meta.scribble);
                            const isWunder = isScrib && !!meta.wunderDoodle;
                            let segLen = isScrib ? (meta.particleBeam ? 220 : 320) : (meta.particleBeam ? 48 : 56);
                            let coreR = isScrib ? Math.max(6, (radius[i]||4)+4) : (meta.particleBeam ? Math.max(7, (radius[i]||4)+3) : Math.max(3, (radius[i]||4)-1));
                            // reduceBeams: cut hit samples to reduce CPU cost
                            const reduce = !!(game.fxFlags && game.fxFlags.reduceBeams);
                            const samples = isScrib ? (reduce ? 8 : 12) : (reduce ? 3 : 5);
                            const step = segLen / Math.max(1, (samples-1));
                            if (isWunder) {
                                if (!meta._wunder) meta._wunder = { reacquire: 0 };
                                if (meta._wunder.reacquire > 0) meta._wunder.reacquire--;
                                const lockRange = meta.lockSeekRange || (meta.scribbleLocked ? 760 : 600);
                                const rangeSq = lockRange * lockRange;
                                const validLock = meta._lockedEnemy && !meta._lockedEnemy.dead && meta._lockedEnemy.health > 0 && game.enemies.includes(meta._lockedEnemy);
                                if (!validLock) {
                                    meta._lockedEnemy = null;
                                    meta.scribbleLocked = false;
                                }
                                if (!meta._lockedEnemy && meta._wunder.reacquire === 0) {
                                    let best = null;
                                    let bestD2 = rangeSq;
                                    for (const enemy of game.enemies) {
                                        if (!enemy || enemy.dead || enemy.health <= 0) continue;
                                        const dxLock = enemy.x - x[i];
                                        const dyLock = enemy.y - y[i];
                                        const d2 = dxLock*dxLock + dyLock*dyLock;
                                        if (d2 < bestD2) {
                                            best = enemy;
                                            bestD2 = d2;
                                        }
                                    }
                                    if (best) {
                                        meta._lockedEnemy = best;
                                        meta.scribbleLocked = true;
                                    }
                                }
                                if (meta._lockedEnemy) {
                                    const lock = meta._lockedEnemy;
                                    const dxLock = lock.x - x[i];
                                    const dyLock = lock.y - y[i];
                                    const distLock = Math.hypot(dxLock, dyLock) || 1;
                                    const dirX = dxLock / distLock;
                                    const dirY = dyLock / distLock;
                                    const bend = 0.38;
                                    const targetSpeed = Math.min(sp * 1.18 + 5, 28);
                                    vx[i] = vx[i]*(1 - bend) + dirX * targetSpeed * bend;
                                    vy[i] = vy[i]*(1 - bend) + dirY * targetSpeed * bend;
                                    sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                    fx = vx[i]/sp; fy = vy[i]/sp;
                                    segLen = Math.max(segLen, 560);
                                    coreR = Math.max(coreR, 9);
                                } else {
                                    segLen = Math.max(segLen, 400);
                                    coreR = Math.max(coreR, 6);
                                }
                            }
                            // Precompute a small random phase for jitter per projectile
                            if (!meta._scribPhase) meta._scribPhase = Math.random()*Math.PI*2;
                            const pPhase = meta._scribPhase; let pAmp = isScrib ? (6 + (radius[i]||4)*0.6) : 0;
                            if (isWunder && meta.scribbleLocked) pAmp *= 1.35;
                            for (let sIdx=0; sIdx<samples; sIdx++){
                                // Base straight sample
                                let bx = x[i] + fx * (sIdx*step);
                                let by = y[i] + fy * (sIdx*step);
                                const rTick = coreR;
                                // Apply scribble jitter perpendicular to forward vector
                                if (isScrib && pAmp > 0) {
                                    const perpX = -fy; const perpY = fx;
                                    const t = (sIdx / samples) * 6.28318; // 2PI
                                    // combine sin wave + small random jitter
                                    const jitter = Math.sin(pPhase + t*1.6) * pAmp + (Math.random()-0.5) * (pAmp*0.5);
                                    bx += perpX * jitter; by += perpY * jitter;
                                }
                                if (game.enemyHash && game.enemyHash.buckets && game.enemyHash.buckets.size){
                                    const csL = game.enemyHash.cell; const cx0=(bx/csL)|0, cy0=(by/csL)|0;
                                    for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){
                                        const key=((cx0+ox)<<16) ^ (cy0+oy); const bucket=game.enemyHash.buckets.get(key); if(!bucket) continue;
                                        for (let bi=0; bi<bucket.length; bi++){
                                            const e = game.enemies[bucket[bi]]; if (!e || e.dead || e.health<=0) continue;
                                            const box=getEnemyAABB(e); let hit=false; if (box) hit=circleIntersectsAABB(bx,by,rTick,box); else { const dx=bx-e.x, dy=by-e.y; hit=(dx*dx+dy*dy < (e.size/2 + rTick)**2); }
                                            if (hit) {
                                                const projObj = { x:bx, y:by, size:rTick, damage:(meta.baseDamage||damage[i]||calculateDamage()), beam:true, damageType: (meta.damageType|| (meta.particleBeam?'plasma':undefined)) };
                                                if (meta.particleBeam) projObj.damage=Math.floor(projObj.damage*0.85);
                                                applyProjectileHit(e, projObj);
                                                if (!(game.perf && game.perf.lowFx) && Math.random()<(reduce?0.15:0.3)) {
                                                    const col = meta && meta.scribble ? (meta.scribbleLocked ? '#FF1A33' : '#FF4F5B') : (meta && meta.particleBeam ? '#77FFEE' : '#99CCFF');
                                                    addParticle(e.x, e.y, col,'spark');
                                                    if (meta && meta.scribble && Math.random() < 0.28) addParticle(e.x + (Math.random()-0.5)*6, e.y + (Math.random()-0.5)*6, meta.scribbleLocked ? '#FF0F27' : '#FF3844', 'ring');
                                                }
                                                // Scribble chaining: attempt to jump from this hit enemy to another nearby enemy
                                                if (isScrib) {
                                                    try {
                                                        // throttle chaining to once per beam projectile frame
                                                        const nowFrame = game._frameNow || 0;
                                                        if (!meta._scribChainFrame || meta._scribChainFrame !== nowFrame) {
                                                            meta._scribChainFrame = nowFrame;
                                                            // find nearest other enemy not equal and within chain radius
                                                            let best=null, bestD=1e9;
                                                            for (const e2 of game.enemies) {
                                                                if (!e2 || e2.dead || e2===e || e2.health<=0) continue;
                                                                const dx2 = e2.x - e.x, dy2 = e2.y - e.y; const d2 = dx2*dx2 + dy2*dy2;
                                                                if (d2 < bestD && d2 < (420*420)) { best = e2; bestD = d2; }
                                                            }
                                                            if (best) {
                                                                // Apply a chained hit with reduced damage and visual scribble lash
                                                                const chainDmg = Math.max(1, Math.floor((projObj.damage||calculateDamage()) * 0.78));
                                                                applyProjectileHit(best, { x: best.x, y: best.y, size: coreR, damage: chainDmg, beam:true, damageType: projObj.damageType, wunderDoodle: !!meta.wunderDoodle });
                                                                // Draw a transient scribble lash between enemies (particles along a jittered line)
                                                                try {
                                                                    const steps = 10; for (let si=0; si<steps; si++) {
                                                                        const t = si/(steps-1);
                                                                        const lx = e.x + (best.x - e.x) * t + (Math.random()-0.5)*8;
                                                                        const ly = e.y + (best.y - e.y) * t + (Math.random()-0.5)*8;
                                                                        addParticle(lx, ly, '#FF1E33', 'spark');
                                                                    }
                                                                    addParticle(best.x, best.y, '#FF0E26', 'ring');
                                                                } catch(_){ }
                                                            }
                                                        }
                                                    } catch(_){}
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    for (let ei=0; ei<game.enemies.length; ei++){
                                        const e = game.enemies[ei]; if(!e || e.dead || e.health<=0) continue;
                                        const box=getEnemyAABB(e); let hit=false; if (box) hit=circleIntersectsAABB(bx,by,rTick,box); else { const dx=bx-e.x, dy=by-e.y; hit=(dx*dx+dy*dy < (e.size/2 + rTick)**2); }
                                        if (hit) {
                                            const projObj = { x:bx, y:by, size:rTick, damage:(meta.baseDamage||damage[i]||calculateDamage()), beam:true, damageType: (meta.damageType|| (meta.particleBeam?'plasma':undefined)) };
                                            if (meta.particleBeam) projObj.damage=Math.floor(projObj.damage*0.85);
                                            applyProjectileHit(e, projObj);
                                            if (isScrib) {
                                                meta.scribbleLocked = true;
                                                if (isWunder) {
                                                    meta._lockedEnemy = e;
                                                    if (meta._wunder) meta._wunder.reacquire = 0;
                                                }
                                            }
                                            if (!(game.perf && game.perf.lowFx) && Math.random()<(reduce?0.15:0.3)) {
                                                const col = meta && meta.scribble ? (meta.scribbleLocked ? '#FF1A33' : '#FF4F5B') : (meta && meta.particleBeam ? '#77FFEE' : '#99CCFF');
                                                addParticle(e.x, e.y, col,'spark');
                                                if (meta && meta.scribble) {
                                                    const ringChance = meta.scribbleLocked ? 0.32 : 0.18;
                                                    if (Math.random() < ringChance) {
                                                        const ringColor = meta.scribbleLocked ? '#FF1029' : '#FF3B46';
                                                        addParticle(e.x + (Math.random()-0.5)*6, e.y + (Math.random()-0.5)*6, ringColor, 'ring');
                                                    }
                                                }
                                            }
                                            if (isScrib) {
                                                const chainRangeSq = isWunder ? (620*620) : (420*420);
                                                let best = null, bestD = chainRangeSq;
                                                for (const e2 of game.enemies) {
                                                    if (!e2 || e2 === e || e2.dead || e2.health <= 0) continue;
                                                    const dx2 = e2.x - e.x;
                                                    const dy2 = e2.y - e.y;
                                                    const d2 = dx2*dx2 + dy2*dy2;
                                                    if (d2 < bestD) { best = e2; bestD = d2; }
                                                }
                                                if (best) {
                                                    const chainDmg = Math.max(1, Math.floor((projObj.damage||calculateDamage()) * 0.78));
                                                    applyProjectileHit(best, { x: best.x, y: best.y, size: coreR, damage: chainDmg, beam:true, damageType: (meta.damageType|| (meta.particleBeam?'plasma':undefined)) });
                                                    meta.scribbleLocked = true;
                                                    if (isWunder) {
                                                        meta._lockedEnemy = best;
                                                        if (meta._wunder) meta._wunder.reacquire = 0;
                                                    }
                                                    try {
                                                        const steps = 10; for (let si=0; si<steps; si++) {
                                                            const t = si/(steps-1);
                                                            const lx = e.x + (best.x - e.x) * t + (Math.random()-0.5)*8;
                                                            const ly = e.y + (best.y - e.y) * t + (Math.random()-0.5)*8;
                                                            addParticle(lx, ly, '#FF2244', 'spark');
                                                        }
                                                        addParticle(best.x, best.y, '#FF1036', 'ring');
                                                    } catch(_){ }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // Spiral Bloom (SoA): tighten into a corkscrew then bloom into rotating petals
                        if (meta && meta.spiralBloom && !meta.enemy && !meta.beam) {
                            if (!meta._sbInit) {
                                meta._sbInit = true;
                                meta._sbPhase = 'tighten';
                                meta._sbTimer = 0;
                                meta._sbRadius = 34;
                                meta._sbAngle = 0;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._sbFx = vx[i]/sp; meta._sbFy = vy[i]/sp;
                                meta._sbPx = -meta._sbFy; meta._sbPy = meta._sbFx;
                            }
                            meta._sbTimer++;
                            if (meta._sbTelegraph && meta._sbTelegraph>0) meta._sbTelegraph--;
                            if (meta._sbPhase === 'tighten') {
                                meta._sbAngle += 0.38;
                                meta._sbRadius *= 0.965;
                                const swirl = meta._sbRadius * 0.12;
                                const sx = Math.cos(meta._sbAngle) * swirl;
                                const sy = Math.sin(meta._sbAngle) * swirl;
                                x[i] += meta._sbPx * sx * 0.08 + meta._sbFx * sy * 0.02;
                                y[i] += meta._sbPy * sx * 0.08 + meta._sbFy * sy * 0.02;
                                // Pre-bloom telegraph shortly before detonating
                                if (!meta._sbTelegraph && (meta._sbTimer>46 || meta._sbRadius<8.5)) {
                                    meta._sbTelegraph = 12;
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                    if (!lowFx && !hideSparks) {
                                        for (let k=0;k<4;k++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFE6AA','spark');
                                    }
                                }
                                if (meta._sbTimer>52 || meta._sbRadius<5.5) { meta._sbPhase = 'bloom'; meta._sbTimer = 0; }
                                if (!(game.perf && game.perf.lowFx) && Math.random()<0.18) addParticle(x[i], y[i], '#FFE6AA','spark');
                            } else if (meta._sbPhase === 'bloom') {
                                if (!meta._sbBloomed) {
                                    meta._sbBloomed = true;
                                    const petals = 8;
                                    const base = meta.baseDamage || damage[i] || calculateDamage();
                                    for (let p=0; p<petals; p++) {
                                        const ang = (p/petals) * Math.PI * 2;
                                        const speed = 2.4 + (p%2)*0.8;
                                        const vxP = Math.cos(ang)*speed;
                                        const vyP = Math.sin(ang)*speed;
                                        const eIdx = game.spawnProjectile({
                                            x: x[i], y: y[i],
                                            vx: vxP, vy: vyP,
                                            life: 75,
                                            r: Math.max(10, Math.floor((radius[i]||6) * 1.10 * 2.0)),
                                            damage: Math.max(1, Math.floor(base*0.42))
                                        });
                                        if (eIdx>=0) {
                                            if (!game._projMeta) game._projMeta = new Map();
                                            // Pick a random bloom sprite for this petal and seed a spin angle
                                            const pick = 1 + Math.floor(Math.random()*6);
                                            const imgKey = 'bloom' + pick;
                                            game._projMeta.set(eIdx, { petal:true, petalImg: imgKey, _petalAngle: Math.random()*Math.PI*2, petalSpin: (Math.random()<0.5?1:-1) * (0.06 + Math.random()*0.04), baseDamage: Math.max(1, Math.floor(base*0.42)) });
                                        }
                                    }
                                    // central burst particles
                                    addParticle(x[i], y[i], '#FFEEAA','explosion');
                                    for (let k=0;k<10;k++) addParticle(x[i], y[i], '#FFC870','spark');
                                }
                                // Remove core projectile
                                life[i] = 0;
                            }
                        }
                        // Lissajous Shot (figure-8 / knot-like path) implemented in SoA using metadata state
                        if (meta && meta.lissajousPattern && !meta.beam) {
                            // Initialize per-projectile Lissajous state
                            if (!meta._lissaInit) {
                                meta._lissaInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                // Forward and perpendicular basis derived from current velocity
                                meta._lFx = vx[i] / sp; meta._lFy = vy[i] / sp;
                                meta._lPx = -meta._lFy; meta._lPy = meta._lFx;
                                meta._lT = 0;
                                // Amplitudes (scaled for clarity) and frequency pairs (intensified)
                                const widen = 2.05;
                                meta._lBaseA = (22 + Math.random()*9) * widen;
                                meta._lBaseB = (16 + Math.random()*6) * (widen * 0.85);
                                meta._lA = meta._lBaseA; meta._lB = meta._lBaseB;
                                meta._lFreqA = 0.16; meta._lFreqB = 0.32;
                                meta._lTargets = [ [0.21,0.31], [0.24,0.40], [0.18,0.27] ];
                                meta._lTargetIdx = 0;
                                meta._lPhase = Math.random()*Math.PI*2;
                                meta._lRot = 0;
                                meta._lLastX = 0; meta._lLastY = 0;
                                meta._lFlipTimer = 80 + (Math.random()*50|0);
                                meta._lPulseTimer = 55 + (Math.random()*40|0);
                                meta._lPulse = 0;
                            }
                            meta._lT++;
                            // Degradation scaling by tier for lateral displacement
                            const lissScale = (tier===0?1.0:(tier===1?0.75:(tier===2?0.55:0.4)));
                            // Periodic target morphing
                            if ((meta._lT % 160) === 0) meta._lTargetIdx = (meta._lTargetIdx + 1) % meta._lTargets.length;
                            const tgt = meta._lTargets[meta._lTargetIdx];
                            meta._lFreqA += (tgt[0] - meta._lFreqA) * 0.015;
                            meta._lFreqB += (tgt[1] - meta._lFreqB) * 0.015;
                            // Light amplitude breathing
                            const ampPulse = 1 + Math.sin(meta._lT*0.02)*0.08;
                            meta._lA = meta._lBaseA * ampPulse;
                            meta._lB = meta._lBaseB * (1 - Math.sin(meta._lT*0.017)*0.06);
                            // Flip/inversion events
                            if (--meta._lFlipTimer <= 0) {
                                const tmp = meta._lBaseA; meta._lBaseA = meta._lBaseB; meta._lBaseB = tmp * (0.90 + Math.random()*0.25);
                                meta._lFlipTimer = 95 + (Math.random()*70|0);
                                if (Math.random()<0.5) meta._lFreqB *= -1;
                                if (!(game.perf && game.perf.lowFx)) {
                                    const spokes = 6 + (Math.random()*3|0);
                                    for (let s=0;s<spokes;s++) addParticle(x[i] + (Math.random()-0.5)*6, y[i] + (Math.random()-0.5)*6, '#66E0FF','spark');
                                    if (!(game.fxFlags && game.fxFlags.reduceRings) && typeof addTransientEffect === 'function') {
                                        addTransientEffect({ type:'ringFlash', x:x[i], y:y[i], color:'#66E0FF', radius: 16, life: 90 });
                                    }
                                }
                            }
                            // Speed pulse event
                            if (--meta._lPulseTimer <= 0) {
                                meta._lPulseTimer = 140 + (Math.random()*70|0);
                                meta._lPulse = 26; // longer, stronger pulse
                                if (!(game.perf && game.perf.lowFx)) {
                                    addParticle(x[i], y[i], '#44F6FF','spark');
                                    // Pulse ring cue (respect reduceRings)
                                    if (!(game.fxFlags && game.fxFlags.reduceRings)) addParticle(x[i], y[i], '#8AE8FF','ring');
                                }
                            }
                            // Sample parametric curve and compute local displacement
                            const ax = Math.sin(meta._lT * meta._lFreqA + meta._lPhase) * meta._lA;
                            const ay = Math.sin(meta._lT * meta._lFreqB) * meta._lB * Math.sin(meta._lT*0.005 + meta._lPhase*0.5);
                            const ddx = ax - meta._lLastX; const ddy = ay - meta._lLastY; meta._lLastX = ax; meta._lLastY = ay;
                            // Slowly rotate local frame to twist the figure
                            meta._lRot += 0.0035;
                            const cosr = Math.cos(meta._lRot), sinr = Math.sin(meta._lRot);
                            const rPxX = meta._lPx * cosr + meta._lFx * sinr * 0.4;
                            const rPxY = meta._lPy * cosr + meta._lFy * sinr * 0.4;
                            const rFxX = meta._lFx * cosr - meta._lPx * sinr * 0.4;
                            const rFxY = meta._lFy * cosr - meta._lPy * sinr * 0.4;
                            // Apply displacement to position (scaled)
                            const pulseScale = (meta._lPulse>0 ? 1.85 : 1.0); if (meta._lPulse>0) meta._lPulse--;
                            // Intensified lateral and forward coupling for clearer motion
                            const lateralScale = 0.34 * lissScale; const forwardScale = 0.18 * lissScale;
                            x[i] += (rPxX * ddx * lateralScale + rFxX * ddy * forwardScale) * pulseScale;
                            y[i] += (rPxY * ddx * lateralScale + rFxY * ddy * forwardScale) * pulseScale;
                        }
                        // Pendulum pattern (SoA): heavy initial swing with decay and final forward boost
                        if (meta && meta.pendulumPattern && !meta._pendDone && !meta.beam && !meta.enemy) {
                            if (!meta._pendInit) {
                                meta._pendInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._pendBaseSpeed = sp;
                                meta._pendFx = vx[i]/sp; meta._pendFy = vy[i]/sp;
                                meta._pendPx = -meta._pendFy; meta._pendPy = meta._pendFx;
                                meta._pendAnchorX = x[i]; meta._pendAnchorY = y[i];
                                meta._pendAngle = (Math.random()<0.5?1:-1) * 0.85;
                                meta._pendAngVel = 0;
                                meta._pendLength = 42 + Math.random()*14;
                                meta._pendGravity = 0.07;
                                meta._pendDamp = 0.991;
                                meta._pendFrame = 0;
                                meta._pendMaxFrames = 240;
                                meta._pendMinSwingVel = 0.0022;
                                meta._pendLastSign = Math.sign(meta._pendAngle);
                                meta._pendPeaks = 0;
                                // Telegraph: brief arc ring indicating upcoming swing
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings) {
                                    const color = '#CFE8FF';
                                    if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:x[i], y:y[i], color, radius: Math.max(12, (radius[i]||6) * 1.8), life: 120 });
                                    else if (!(lowFx)) addParticle(x[i], y[i], color, 'ring');
                                }
                            }
                            meta._pendFrame++;
                            // Integrate "pendulum" angle
                            const angAcc = -meta._pendGravity * Math.sin(meta._pendAngle);
                            meta._pendAngVel += angAcc;
                            meta._pendAngVel *= meta._pendDamp;
                            meta._pendAngle += meta._pendAngVel;
                            // Detect peaks via angular velocity sign change
                            if (meta._pendLastSign !== 0) {
                                const curSign = Math.sign(meta._pendAngVel);
                                if (curSign !== 0 && curSign !== meta._pendLastSign) {
                                    meta._pendPeaks++;
                                    for (let k=0;k<5;k++) addParticle(x[i] + (Math.random()-0.5)*12, y[i] + (Math.random()-0.5)*12, '#FFD580','spark');
                                }
                                meta._pendLastSign = curSign;
                            }
                            // Advance anchor more slowly near swing peaks
                            const fScale = Math.max(0.15, Math.abs(Math.cos(meta._pendAngle)));
                            const fStep = meta._pendBaseSpeed * 0.9 * fScale;
                            meta._pendAnchorX += meta._pendFx * fStep;
                            meta._pendAnchorY += meta._pendFy * fStep;
                            // Lateral displacement + small vertical sag
                            const lateral = Math.sin(meta._pendAngle) * meta._pendLength;
                            const sag = (1 - Math.cos(meta._pendAngle)) * (meta._pendLength * 0.20);
                            x[i] = meta._pendAnchorX + meta._pendPx * lateral;
                            y[i] = meta._pendAnchorY + meta._pendPy * lateral + sag * 0.25;
                            // Instantaneous velocity approximation, update vx/vy for downstream systems
                            const latVel = Math.cos(meta._pendAngle) * meta._pendLength * meta._pendAngVel;
                            const instVx = meta._pendFx * fStep + meta._pendPx * latVel;
                            const instVy = meta._pendFy * fStep + meta._pendPy * latVel + (sag * 0.25 - (meta._pendPrevSag||0))*0.9;
                            vx[i] = instVx; vy[i] = instVy; meta._pendPrevSag = sag * 0.25;
                            // Trail more intense near center
                            const trailIntensity = 0.06 + Math.abs(Math.cos(meta._pendAngle))*0.12;
                            if (Math.random() < trailIntensity) addParticle(x[i], y[i], '#FFC899','spark');
                            // End condition: minimal swing OR time cap
                            if ((Math.abs(meta._pendAngVel) < meta._pendMinSwingVel && Math.abs(meta._pendAngle) < 0.12) || meta._pendFrame >= meta._pendMaxFrames) {
                                const boost = 1 + Math.min(0.35, meta._pendPeaks * 0.05);
                                const finalSp = meta._pendBaseSpeed * boost;
                                vx[i] = meta._pendFx * finalSp;
                                vy[i] = meta._pendFy * finalSp;
                                for (let b=0;b<8;b++) addParticle(x[i] + (Math.random()-0.5)*14, y[i] + (Math.random()-0.5)*14, '#FFD9AA','spark');
                                meta._pendDone = true; meta.pendulumPattern = false;
                            }
                        }
                        // Cascade Burst (SoA): pulsing forward micro-bursts
                        if (meta && meta.cascadeBurst && !meta.enemy && !meta.beam) {
                            if (!meta._cascInit) { meta._cascInit=true; meta._cascTimer=10; }
                            meta._cascTimer--;
                            // Pre-burst telegraph once a few frames before emission
                            if (meta._cascTimer === 3) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFE6CC','ring');
                            }
                            if (meta._cascTimer<=0) {
                                meta._cascTimer = 12; // cadence
                                const ang = Math.atan2(vy[i], vx[i]);
                                const parts = 7; const spd = Math.hypot(vx[i], vy[i]) || 0.0001;
                                const base = meta.baseDamage || damage[i] || 1;
                                const spreadStep = 0.16; // wider spread between children
                                for (let k=0;k<parts;k++) {
                                    const off = (k - (parts-1)/2)*spreadStep;
                                    const speedMul = 1.25;
                                    const nvx = Math.cos(ang+off) * (spd*speedMul + 1.2);
                                    const nvy = Math.sin(ang+off) * (spd*speedMul + 1.2);
                                    const lifeK = 70; // farther travel
                                    const radK = Math.max(3, Math.floor((radius[i]||6)*0.60));
                                    const dmgK = Math.max(1, Math.floor(base*0.34));
                                    const idxK = game.spawnProjectile({ x:x[i] + Math.cos(ang)*10, y:y[i] + Math.sin(ang)*10, vx:nvx, vy:nvy, life:lifeK, r: radK, damage: dmgK });
                                    if (idxK>=0) { if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(idxK,{ cascadeChild:true, _initialFx:Math.cos(ang+off), _initialFy:Math.sin(ang+off), baseDamage: dmgK }); }
                                }
                                // Stronger visual cue per burst (perf-aware)
                                {
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                    if (!reduceRings) addParticle(x[i], y[i], '#FFD4AA','ring');
                                    if (!lowFx && !hideSparks) {
                                        const count = 3;
                                        for (let q=0;q<count;q++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFB866','spark');
                                    }
                                }
                            }
                        }
                        if (meta && meta.isPopcornKernel && !meta._popDid) {
                            meta._popFuse--;
                            if (meta._popFuse < 10 && Math.random()<0.3 && !(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#FFF5AA','spark');
                            // Pre-pop ring cue just before detonation
                            if (meta._popFuse === 3) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFF2BB','ring');
                            }
                            if (meta._popFuse <= 0) {
                                meta._popDid = true;
                                const base = meta.baseDamage || damage[i];
                                // kernel burst mini shots (scaled)
                                const burstN = Math.max(2, Math.min(6, (meta._popBursts||2)));
                                for (let b=0;b<burstN;b++) {
                                    const angB = Math.random()*Math.PI*2;
                                    const speedB = 4.2 + Math.random()*1.6;
                                    const kbIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:Math.cos(angB)*speedB, vy:Math.sin(angB)*speedB, life:48+Math.floor(Math.random()*18), r:7, damage: Math.max(1, Math.floor(base*0.55)) });
                                    if (kbIdx>=0){ if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(kbIdx,{ popcornKernelBurst:true, baseDamage: Math.max(1, Math.floor(base*0.55)), realityBreak: !!(meta && meta.realityBreak) }); }
                                }
                                // puffs (scaled)
                                const puffN = Math.max(2, Math.min(6, (meta._popPuffs||2)));
                                for (let k=0;k<puffN;k++) {
                                    const baseAng = Math.atan2(dy, dx);
                                    const ang = (isFinite(baseAng)? baseAng : 0) + (Math.random()*0.9 - 0.45);
                                    const speed = (Math.hypot(dx,dy) * 0.85) + Math.random()*1.2;
                                    const pIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, life:40+Math.floor(Math.random()*18), r:12, damage: Math.max(1, Math.floor(base*0.75)) });
                                    if (pIdx>=0){ if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(pIdx,{ popcornPuff:true, baseDamage: Math.max(1, Math.floor(base*0.75)), _puffSpin: Math.random()*Math.PI*2, _puffDir:(Math.random()<0.5?-1:1), realityBreak: !!(meta && meta.realityBreak) }); }
                                }
                                if (!(game.perf && game.perf.lowFx)) for (let s=0;s<10;s++) addParticle(x[i] + (Math.random()-0.5)*12, y[i] + (Math.random()-0.5)*12, '#FFEFA0','spark');
                                // Remove kernel
                                life[i]=0; recycle(i); continue;
                            }
                        }
                        // Harmonic Split (SoA): split twice at set life points; parent continues after each split
                        if (meta && meta.harmonicSplit && !meta._harmDoneAll) {
                            if (!meta._harmInit) {
                                meta._harmInit = true;
                                // Define thresholds at fractions of original life (remaining life values)
                                const L = Math.max(1, lifeMax[i] || life[i] || 120);
                                // Even earlier splits: 96% and 80% of original life
                                meta._harmThresholds = [ Math.floor(L * 0.96), Math.floor(L * 0.80) ];
                                meta._harmDone = {};
                                meta._harmTele = 0;
                            }
                            // Pre-split telegraph when within a few frames above an upcoming threshold
                            if (Array.isArray(meta._harmThresholds)) {
                                for (let t=0; t<meta._harmThresholds.length; t++) {
                                    const th = meta._harmThresholds[t];
                                    if (!meta._harmDone[th] && life[i] <= th + 8 && life[i] > th) {
                                        meta._harmTele = Math.max(meta._harmTele||0, 6);
                                        const lowFx = !!(game.perf && game.perf.lowFx);
                                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                        if (!lowFx && !hideSparks && Math.random() < 0.25) addParticle(x[i], y[i], '#FFE2BB','spark');
                                        if (!reduceRings && Math.random() < 0.18) addParticle(x[i], y[i], '#FFE6CC','ring');
                                    }
                                }
                                if (meta._harmTele>0) meta._harmTele--;
                            }
                            // Perform splits whose thresholds have been reached
                            if (Array.isArray(meta._harmThresholds)) {
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                let ang = Math.atan2(vy[i], vx[i]);
                                if (!isFinite(ang)) {
                                    const fx0 = (meta._initialFx!=null?meta._initialFx:1), fy0=(meta._initialFy!=null?meta._initialFy:0);
                                    ang = Math.atan2(fy0, fx0);
                                }
                                for (let t=0; t<meta._harmThresholds.length; t++) {
                                    const th = meta._harmThresholds[t];
                                    if (life[i] <= th && !meta._harmDone[th]) {
                                        meta._harmDone[th] = true;
                                        const base = meta.baseDamage || damage[i] || 1;
                                        const childSpeed = sp * 0.92 + 0.6; // small bias so kids move out clearly
                                        const spread = 0.34; // ~19.5°
                                        for (let dir=-1; dir<=1; dir+=2) {
                                            const cAng = ang + dir*spread;
                                            const idxC = game.spawnProjectile({
                                                x: x[i], y: y[i],
                                                vx: Math.cos(cAng) * childSpeed,
                                                vy: Math.sin(cAng) * childSpeed,
                                                life: Math.max(12, Math.floor(life[i] * 0.78)),
                                                r: Math.max(2, Math.floor((radius[i]||6) * 0.65)),
                                                damage: Math.max(1, Math.floor(base * 0.58)),
                                                // Propagate key motion flags
                                                sineWave: !!(flags[i] & FLAG.SINE),
                                                wackyZigzag: !!(flags[i] & FLAG.WACKY),
                                                ekgWave: !!(flags[i] & FLAG.EKG),
                                                spiralPattern: !!(flags[i] & FLAG.SPIRAL)
                                            });
                                            if (idxC>=0) {
                                                if (!game._projMeta) game._projMeta = new Map();
                                                game._projMeta.set(idxC, { harmonicChild:true, baseDamage: Math.max(1, Math.floor(base * 0.58)) });
                                            }
                                        }
                                        // Visual burst
                                        if (!(game.perf && game.perf.lowFx)) {
                                            for (let k=0;k<6;k++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFE2BB','spark');
                                        }
                                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                        if (!reduceRings) addParticle(x[i], y[i], '#FFC070','trail');
                                        // Slightly trim parent damage so total DPS doesn't overscale
                                        damage[i] = Math.max(1, Math.floor(damage[i] * 0.9));
                                        if (meta.baseDamage) meta.baseDamage = Math.max(1, Math.floor(meta.baseDamage * 0.9));
                                    }
                                }
                                // If all thresholds handled, mark done
                                let doneCount = 0; for (const th of meta._harmThresholds) if (meta._harmDone[th]) doneCount++;
                                if (doneCount === meta._harmThresholds.length) { meta._harmDoneAll = true; if (!(game.perf && game.perf.lowFx)) addParticle(x[i], y[i], '#FFCC88','ambient'); }
                            }
                        }
                        // Meteor explosion cue on detonation/expiry
                        if (meta && meta.meteor && !meta._meteorCueDone) {
                            // Check for nearing detonation or just expired; add visual cue and shake
                            if ((meta._meteorDetonateAt && game.frame >= meta._meteorDetonateAt) || life[i] <= 0) {
                                meta._meteorCueDone = true;
                                // SFX: retro explosion on impact
                                try { if (typeof playMeteorExplosionSfx === 'function') playMeteorExplosionSfx(); } catch(_) {}
                                // Explosion ring and embers
                                if (!(game.perf && game.perf.lowFx)) {
                                    for (let k=0;k<12;k++) addParticle(x[i], y[i], '#FFDD88','ring');
                                    for (let s=0;s<18;s++) addParticle(x[i] + (Math.random()-0.5)*18, y[i] + (Math.random()-0.5)*18, '#FFB064','spark');
                                }
                                // Brief screen shake
                                game.screenShake = Math.max(game.screenShake || 0, 8);
                                game.screenShakeIntensity = Math.max(game.screenShakeIntensity || 0, 0.9);
                            }
                        }
                        // Umbrella core split behavior
                        if (meta && meta.umbrellaCore && !meta._umbDidSplit) {
                            // Accumulate travel distance using current velocity magnitude
                            const stepDist = Math.hypot(vx[i], vy[i]);
                            meta._umbTravel += stepDist;
                            meta._umbCoreAge = (meta._umbCoreAge||0)+1;
                            const lowLife = life[i] <= 10;
                            const forceSplit = (meta._umbCoreAge > 80) || stepDist < 0.5 || lowLife;
                            if (meta._umbTravel >= (meta._umbSplitDistance || 160) || forceSplit) {
                                meta._umbDidSplit = true;
                                const base = meta.baseDamage || damage[i];
                                let ang = Math.atan2(vy[i], vx[i]);
                                if (!isFinite(ang) || (Math.abs(vx[i]) < 0.0001 && Math.abs(vy[i]) < 0.0001)) {
                                    const ld = (game.player && game.player.lastDirection) || {x:1,y:0};
                                    ang = Math.atan2(ld.y, ld.x);
                                }
                                const arcRadius = 140;
                                for (let side=-1; side<=1; side+=2) {
                                    const aIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:0, vy:0, life:110, r: Math.max(5, radius[i]*0.9), damage: Math.max(1, Math.floor(base*0.65)) });
                                    if (aIdx>=0) {
                                        if (!game._projMeta) game._projMeta = new Map();
                                        game._projMeta.set(aIdx, {
                                            umbrellaArc:true,
                                            _arcSide:side,
                                            _arcOriginX:x[i],
                                            _arcOriginY:y[i],
                                            _arcBaseAngle: ang,
                                            _arcProgress: 0,
                                            _arcRadius: arcRadius,
                                            _arcAngularSpan: Math.PI * 0.5,
                                            _arcSpeed: 0.028,
                                            _arcDone:false,
                                            baseDamage: Math.max(1, Math.floor(base*0.65)),
                                            sineWave: !!(flags[i] & FLAG.SINE),
                                            wackyZigzag: !!(flags[i] & FLAG.WACKY),
                                            ekgWave: !!(flags[i] & FLAG.EKG),
                                            spiral: !!(flags[i] & FLAG.SPIRAL)
                                        });
                                    }
                                }
                                if (!(game.perf && game.perf.lowFx)) {
                                    for (let p=0;p<18;p++) addParticle(x[i] + (Math.random()-0.5)*24, y[i] + (Math.random()-0.5)*24, '#FFDFAA','spark');
                                    addParticle(x[i], y[i], '#FFAA55','ambient');
                                    addParticle(x[i], y[i], '#FFE8CC','trail');
                                }
                                // Remove core after splitting
                                life[i]=0; recycle(i); continue;
                            }
                        }
                        // Umbrella arc motion (advance along sweep). After 90° (half-arc), convert to tangent flight continuing past the player.
                        if (meta && meta.umbrellaArc && !meta._arcDone) {
                            meta._arcProgress += meta._arcSpeed;
                            const sweep = meta._arcAngularSpan || (Math.PI * 0.5); // 90°
                            // IMPORTANT: lock arc to the original split origin, do NOT follow live player position
                            const originX = meta._arcOriginX;
                            const originY = meta._arcOriginY;
                            if (meta._arcProgress >= 1) {
                                // Finish arc exactly at 90°, then convert to free-flight along tangent back across/past the player
                                meta._arcProgress = 1; meta._arcDone = true;
                                const endAng = meta._arcBaseAngle + (meta._arcSide * sweep);
                                // Tangent direction at end of arc equals baseAngle + PI, regardless of side
                                const tanAng = meta._arcBaseAngle + Math.PI;
                                const tx = Math.cos(tanAng), ty = Math.sin(tanAng);
                                const speed = 5.2; // speed after arc
                                vx[i] = tx * speed; vy[i] = ty * speed;
                                // Place at arc endpoint, then proceed along tangent
                                x[i] = originX + Math.cos(endAng) * meta._arcRadius;
                                y[i] = originY + Math.sin(endAng) * meta._arcRadius;
                                // Give it healthy life to pass the player and keep going
                                life[i] = Math.max(life[i], 90); lifeMax[i] = Math.max(lifeMax[i], life[i]);
                                // Clear arc markers so normal physics takes over
                                meta.umbrellaArc = false; delete meta._arcDone; delete meta._arcProgress;
                            } else {
                                const localAng = meta._arcBaseAngle + (meta._arcSide * (meta._arcProgress * sweep));
                                x[i] = originX + Math.cos(localAng) * meta._arcRadius;
                                y[i] = originY + Math.sin(localAng) * meta._arcRadius;
                            }
                        }
                        // Helix Pair motion: offset twin projectiles around forward axis with expanding/contracting radius
                        if (meta && meta.helixPair && meta._helixSide) {
                            // Initialize forward/perp basis once
                            if (!meta._helixInit) {
                                meta._helixInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                                meta._hFx = vx[i]/sp; meta._hFy = vy[i]/sp;
                                meta._hPx = -meta._hFy; meta._hPy = meta._hFx;
                                meta._helixPhase = meta._helixPhase || 0;
                                meta._helixRadius = meta._helixRadius || 26;
                                meta._helixTargetRadius = meta._helixTargetRadius || 42;
                            }
                            // Slightly steer basis toward current velocity to track course
                            const sp = Math.hypot(vx[i], vy[i]) || 0.0001;
                            const nFx = vx[i]/sp, nFy = vy[i]/sp;
                            meta._hFx = meta._hFx*0.9 + nFx*0.1; meta._hFy = meta._hFy*0.9 + nFy*0.1;
                            const nl = Math.hypot(meta._hFx, meta._hFy)||1; meta._hFx/=nl; meta._hFy/=nl;
                            meta._hPx = -meta._hFy; meta._hPy = meta._hFx;
                            // Evolve radius toward target then flip
                            meta._helixRadius += (meta._helixTargetRadius - meta._helixRadius) * 0.06;
                            if (Math.abs(meta._helixTargetRadius - meta._helixRadius) < 0.5) {
                                meta._helixTargetRadius = 26 + Math.random()*24;
                            }
                            meta._helixPhase += 0.24;
                            const swirl = Math.sin(meta._helixPhase) * meta._helixRadius;
                            const offX = meta._hPx * swirl * meta._helixSide;
                            const offY = meta._hPy * swirl * meta._helixSide;
                            x[i] += offX * 0.08; y[i] += offY * 0.08;
                        }
                        // Boomerang: outbound arc then return to player, with mild lateral curve and return acceleration
                        if (meta && meta.boomerang && !meta._boomConsumed) {
                            if (!meta._boomInit) {
                                meta._boomInit = true;
                                const sp = Math.hypot(vx[i], vy[i]) || 1;
                                meta._boomFx = vx[i]/sp; meta._boomFy = vy[i]/sp;
                                meta._boomSide = (Math.random()<0.5?-1:1);
                                meta._boomMaxLat = 90 + Math.random()*30;
                                meta._boomOutboundDist = 180 + Math.random()*40;
                                meta._boomTravel = 0; meta._boomReturn=false; meta._boomChained=false; meta._boomOriginX=x[i]; meta._boomOriginY=y[i]; meta._boomAge=0;
                                // Pre-return cue state
                                meta._boomPreCue = 0; // frames remaining to show pre-return ring/arrow
                                meta._boomPreWarned = false;
                            }
                            meta._boomAge++;
                            const speed = Math.hypot(vx[i], vy[i]) || 0.01;
                            const stepForward = vx[i]*meta._boomFx + vy[i]*meta._boomFy;
                            meta._boomTravel += Math.max(0, stepForward * 0.9);
                            if (!meta._boomReturn) {
                                const ox = x[i]-meta._boomOriginX; const oy = y[i]-meta._boomOriginY;
                                const radial = Math.hypot(ox,oy);
                                if (radial > meta._boomOutboundDist*0.95) meta._boomReturn = true;
                            }
                            if (!meta._boomReturn && meta._boomTravel >= meta._boomOutboundDist) meta._boomReturn = true;
                            if (!meta._boomReturn && meta._boomAge > 90) { meta._boomReturn = true; meta._boomForced = true; }
                            // Prime pre-return cue shortly before reaching outbound limit
                            if (!meta._boomReturn && !meta._boomPreWarned) {
                                const frac = meta._boomTravel / Math.max(1, meta._boomOutboundDist);
                                if (frac >= 0.78) { // ~last 22% of outbound
                                    meta._boomPreCue = 16 + (Math.random()*8|0);
                                    meta._boomPreWarned = true;
                                }
                            }
                            // Return cue: emit a ring + a couple sparks once when switching to return state
                            if (meta._boomReturn && !meta._boomCueDid) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!reduceRings) addParticle(x[i], y[i], '#FFE6CC','ring');
                                if (!lowFx && !hideSparks) { for (let s=0;s<2;s++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFC899','spark'); }
                                meta._boomCueDid = true;
                            }
                            if (meta._boomPreCue > 0) meta._boomPreCue--;
                            let fxB = meta._boomFx, fyB = meta._boomFy;
                            if (meta._boomReturn) {
                                const dxp = (game.player?game.player.x:x[i]) - x[i];
                                const dyp = (game.player?game.player.y:y[i]) - y[i];
                                const dpl = Math.hypot(dxp,dyp)||1;
                                const tFx = dxp/dpl, tFy = dyp/dpl;
                                const blend = meta._boomForced ? 0.25 : 0.12;
                                fxB = fxB*(1-blend) + tFx*blend; fyB = fyB*(1-blend) + tFy*blend;
                                const nrm = Math.hypot(fxB,fyB)||1; fxB/=nrm; fyB/=nrm; meta._boomFx=fxB; meta._boomFy=fyB;
                                meta._boomReturnSide = (typeof meta._boomReturnSide==='number')?meta._boomReturnSide: -meta._boomSide;
                                if (!meta._boomLifeExtended) { life[i] = Math.max(life[i], 60); lifeMax[i]=Math.max(lifeMax[i], life[i]); meta._boomLifeExtended=true; }
                            }
                            const phaseFrac = Math.min(1, meta._boomTravel / Math.max(1, meta._boomOutboundDist));
                            let lateralFrac = !meta._boomReturn ? Math.sin(phaseFrac*Math.PI*0.9) : Math.sin((1-phaseFrac)*Math.PI*0.9);
                            lateralFrac = Math.max(0, lateralFrac);
                            const latMag = meta._boomMaxLat * lateralFrac;
                            const pxB = -fyB, pyB = fxB;
                            const side = meta._boomReturn ? meta._boomReturnSide : meta._boomSide;
                            meta._boomLat = latMag * side;
                            const lateralStrength = 0.12;
                            vx[i] = fxB * speed * 0.97 + pxB * (meta._boomLat/ Math.max(1, meta._boomMaxLat)) * lateralStrength * speed;
                            vy[i] = fyB * speed * 0.97 + pyB * (meta._boomLat/ Math.max(1, meta._boomMaxLat)) * lateralStrength * speed;
                            const curSp = Math.hypot(vx[i], vy[i]) || 0.01;
                            if (curSp < 2) { const boost = (meta._boomReturn?1.25:1.12); vx[i] = (vx[i]/curSp)*(curSp*boost+0.05); vy[i]=(vy[i]/curSp)*(curSp*boost+0.05); }
                            if (meta._boomReturn) { vx[i]*=1.012; vy[i]*=1.012; }
                            if (meta._boomReturn && game.player) {
                                const dxp2 = x[i]-game.player.x; const dyp2 = y[i]-game.player.y;
                                if (Math.hypot(dxp2,dyp2) < 22) { life[i]=0; recycle(i); meta._boomConsumed=true; continue; }
                            }
                        }
                        // Converge Pair: manage twin phases and fusion
                        if (meta && meta.convergePair && meta._convTwin != null && !meta._convFused) {
                            meta._convTimer = (meta._convTimer||0)+1;
                            const phase = meta._convPhase || 'diverge';
                            const j = meta._convTwin; if (j>=0 && j<MAX && alive[j]) {
                                const pm = game._projMeta.get(j);
                                // compute forward dir blend
                                const spx = (vx[i]+vx[j])*0.5; const spy = (vy[i]+vy[j])*0.5; const sp = Math.hypot(spx,spy)||0.0001;
                                const fBx = spx/sp, fBy = spy/sp;
                                if (phase === 'diverge') {
                                    if (meta._convTimer > 14) {
                                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                        if (!(game.perf && game.perf.lowFx) && !reduceRings) addParticle(x[i], y[i], '#AEEBFF','ring');
                                        meta._convPhase='curveIn'; meta._convTimer=0; }
                                } else if (phase === 'curveIn') {
                                    // steer each toward blended forward
                                    const ang = Math.atan2(vy[i], vx[i]); const targ = Math.atan2(fBy, fBx);
                                    const blend=0.08+Math.min(0.18, meta._convTimer*0.004);
                                    // normalize smallest angular difference to avoid wrap issues when aiming left
                                    let delta = targ - ang; delta = (delta + Math.PI) % (Math.PI*2); if (delta < 0) delta += Math.PI*2; delta -= Math.PI;
                                    const newAng = ang + delta*blend; const spd=Math.hypot(vx[i],vy[i])||0.0001;
                                    vx[i]=Math.cos(newAng)*spd; vy[i]=Math.sin(newAng)*spd;
                                    if (meta._convTimer > 26) { meta._convPhase='fuseCheck'; meta._convTimer=0; }
                                } else if (phase === 'fuseCheck') {
                                    if (meta._convPrimary) {
                                        const dx2 = x[j]-x[i]; const dy2 = y[j]-y[i]; const d2 = dx2*dx2+dy2*dy2;
                                        const fuseRadius = 110 - Math.min(70, meta._convTimer*2);
                                        if (d2 <= fuseRadius*fuseRadius) {
                                            if (d2 < 38*38) {
                                                const baseCombined = (meta.baseDamage||damage[i]) + ((pm&&pm.baseDamage)||damage[j]);
                                                const fuseX = (x[i]+x[j])/2; const fuseY = (y[i]+y[j])/2;
                                                const fuseVx = (vx[i]+vx[j])/2; const fuseVy = (vy[i]+vy[j])/2;
                                                const fusedDmg = Math.max(1, Math.floor(baseCombined * 0.95));
                                                const fIdx = game.spawnProjectile({ x:fuseX, y:fuseY, vx:fuseVx, vy:fuseVy, life: Math.max(life[i], life[j]) + 40, r: Math.max(radius[i], radius[j]) + 4, damage: fusedDmg });
                                                if (fIdx>=0) {
                                                    if (!game._projMeta) game._projMeta = new Map();
                                                    game._projMeta.set(fIdx, { fusedTwin:true, _fuseAuraTimer:0, baseDamage:fusedDmg });
                                                }
                                                // mark twins consumed
                                                life[i]=0; recycle(i); if (alive[j]) { life[j]=0; recycle(j); }
                                                // burst AoE
                                                const burstR=90; const burstDamage=Math.max(2, Math.floor(fusedDmg*0.45));
                                                if (game.enemies && game.enemies.length) {
                                                    for (const en of game.enemies) {
                                                        if (!en) continue; const ex=en.x-fuseX; const ey=en.y-fuseY; if (ex*ex+ey*ey <= burstR*burstR) { en.health -= burstDamage; addDamageNumber(burstDamage, en.x, en.y - en.size/2, { type:'arcane' }); }
                                                    }
                                                }
                                                addParticle(fuseX, fuseY, '#BBAAFF','explosion');
                                                meta._convFused = true;
                                                continue;
                                            }
                                        }
                                        if (!meta._convFused && meta._convTimer > 40) {
                                            const dx3 = x[j]-x[i]; const dy3 = y[j]-y[i]; const d = Math.hypot(dx3,dy3)||1; const pull = Math.min(0.35, 12/d);
                                            vx[i] += dx3/d * pull * 0.5; vy[i] += dy3/d * pull * 0.5;
                                            vx[j] -= dx3/d * pull * 0.5; vy[j] -= dy3/d * pull * 0.5;
                                        }
                                    }
                                    meta._convTimer++;
                                    if (meta._convTimer > 160) meta._convPhase='expired';
                                }
                            }
                        }
                        // Echo Bloom: staged echo spawns and converge-triggered bloom
                        if (meta && meta.echoBloom && !meta._echoDone) {
                            if (!meta._echoInit) {
                                meta._echoInit = true; meta._echoStage=0; meta._echoMaxStages=2; meta._echoNextLifePoint = Math.floor(life[i]*0.70); meta._echoTelegraph=0; meta._echoTelegraphMax=42;
                            }
                            if (life[i] <= meta._echoNextLifePoint && meta._echoStage < meta._echoMaxStages) {
                                const scale = 0.55 + meta._echoStage*0.15; const dmgScale = 0.30 + meta._echoStage*0.10;
                                const baseDmgLocal = meta.baseDamage || damage[i];
                                const eIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:vx[i]*(0.35+meta._echoStage*0.1), vy:vy[i]*(0.35+meta._echoStage*0.1), life: life[i] + 18 + meta._echoStage*6, r: Math.max(2, Math.floor((radius[i]||6)*scale)), damage: Math.max(1, Math.floor(baseDmgLocal*dmgScale)) });
                                if (eIdx>=0) { if(!game._projMeta) game._projMeta=new Map(); game._projMeta.set(eIdx,{ echoChild:true, _parentId:i, baseDamage: Math.max(1, Math.floor(baseDmgLocal*dmgScale)) }); }
                                for (let k=0;k<6;k++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFC8FF','spark');
                                meta._echoStage++; meta._echoNextLifePoint = Math.floor(life[i] * (0.55 - meta._echoStage*0.10));
                            }
                            if (meta._echoStage === meta._echoMaxStages && !meta._echoBloomed) {
                                let converged=true; let echoCount=0;
                                const { alive:al2 } = game.projectilesSoA; for (let si=0; si<MAX; si++) if (al2[si]) { const m2 = game._projMeta.get(si); if (!m2 || !m2.echoChild || m2._parentId !== i) continue; echoCount++; const dx=x[si]-x[i]; const dy=y[si]-y[i]; if (dx*dx+dy*dy>36) { converged=false; break; } }
                                if (echoCount && !meta._echoBloomed) { meta._echoTelegraph = Math.min(meta._echoTelegraph+1, meta._echoTelegraphMax); if (meta._echoTelegraph > meta._echoTelegraphMax*0.65 && Math.random()<0.25) addParticle(x[i] + (Math.random()-0.5)*20, y[i] + (Math.random()-0.5)*20, '#FFD6FF','spark'); }
                                if (echoCount && converged) {
                                    meta._echoBloomed=true; const base = meta.baseDamage || damage[i]; const burstDmg = Math.max(1, Math.floor(base*1.10));
                                    explodeProjectile({ x:x[i], y:y[i], size:radius[i], enemy:false }, burstDmg); addScreenShake(6);
                                    const petals = 10 + Math.floor(Math.random()*4);
                                    for (let p=0;p<petals;p++) { const ang=(p/petals)*Math.PI*2; game.spawnProjectile({ x:x[i], y:y[i], vx: Math.cos(ang)*(2.8 + Math.random()*0.6), vy: Math.sin(ang)*(2.8 + Math.random()*0.6), life:65, r: Math.max(2, radius[i]*0.55), damage: Math.max(1, Math.floor(base*0.42)) }); }
                                    // Tuned resonance field: slightly larger, pulses a bit faster, lasts slightly longer
                                    const field = { x:x[i], y:y[i], radius:140, createdAt:Date.now(), duration:2000, tickEvery:260, lastTick:0, baseDamage: Math.max(1, Math.floor(base*0.30)), type:'echoBloom' };
                                    if (!game.echoBloomFields) game.echoBloomFields=[]; game.echoBloomFields.push(field);
                                    for (let si=0; si<MAX; si++) if (al2[si]) { const m2=game._projMeta.get(si); if (m2 && m2.echoChild && m2._parentId === i) { life[si]=0; } }
                                }
                            }
                        }
                        // Phase Echo (SoA): spawn stationary ghost afterimages that pop on expiry
                        if (meta && meta.phaseEcho) {
                            if (!meta._echoInit) { meta._echoInit = true; meta._echoTimer = 10; meta._echoesSpawned = 0; }
                            meta._echoTimer--;
                            if (meta._echoTimer <= 0) {
                                meta._echoTimer = 26; // cadence between ghosts
                                if ((meta._echoesSpawned||0) < 3) {
                                    const baseDmgLocal = meta.baseDamage || damage[i] || calculateDamage();
                                    const gDmg = Math.max(1, Math.floor(baseDmgLocal * 0.25));
                                    const gIdx = game.spawnProjectile({ x:x[i], y:y[i], vx:0, vy:0, life:22, r: Math.max(2, Math.floor((radius[i]||6)*0.6)), damage: gDmg });
                                    if (gIdx>=0) {
                                        if (!game._projMeta) game._projMeta = new Map();
                                        game._projMeta.set(gIdx, { phaseGhost:true, baseDamage:gDmg });
                                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) addParticle(x[i], y[i], '#DDE8FF','spark');
                                    }
                                    meta._echoesSpawned = (meta._echoesSpawned||0) + 1;
                                }
                            }
                        }
                        // Phase Echo: afterimage ghost telegraph and pop-on-expire (metadata-driven)
                        if (meta && meta.phaseGhost) {
                            // gentle ambient flicker while alive
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks) && Math.random()<0.10) addParticle(x[i] + (Math.random()-0.5)*6, y[i] + (Math.random()-0.5)*6, '#AACCFF','spark');
                            // final telegraph shortly before pop
                            if (!meta._ghostWarn && life[i] <= 6) { meta._ghostWarn = true; if(!(game.perf&&game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) for (let k=0;k<3;k++) addParticle(x[i], y[i], '#DDE8FF','ring'); }
                            // burst on expiry
                            if (!meta._ghostPopped && life[i] <= 0) {
                                meta._ghostPopped = true;
                                const base = meta.baseDamage || damage[i] || 1;
                                const burstDmg = Math.max(1, Math.floor(base * 0.40));
                                explodeProjectile({ x:x[i], y:y[i], size: Math.max(4, radius[i]||6), enemy:false }, burstDmg);
                                addScreenShake(3);
                            }
                        }
                        // Veering Fan: timed mid-flight multi-shot conversion
                        if (meta && meta.veeringFan && !meta._veered) {
                            if (meta._veeringTimer === undefined) { meta._veeringTimer = 22; meta._veerMinDist = 80; meta._spawnX = x[i]; meta._spawnY = y[i]; }
                            const dxs = x[i]-meta._spawnX; const dys = y[i]-meta._spawnY; const distSq = dxs*dxs + dys*dys;
                            if (distSq >= (meta._veerMinDist||0)*(meta._veerMinDist||0)) meta._veeringTimer--;
                            // subtle pre-split telegraph in last few frames
                            if (meta._veeringTimer !== undefined && meta._veeringTimer <= 6 && !(game.perf && game.perf.lowFx)) {
                                addParticle(x[i], y[i], '#FFF2CC','ring');
                            }
                            if (meta._veeringTimer === 0 && !meta._veered) {
                                meta._veered = true;
                                // Use last-frame displacement if available (patterns like Uzumaki may not reflect into vx/vy)
                                let mvx = (meta && typeof meta._lastX === 'number') ? (x[i] - meta._lastX) : vx[i];
                                let mvy = (meta && typeof meta._lastY === 'number') ? (y[i] - meta._lastY) : vy[i];
                                // Fallback: if movement vector is too small, derive from facing via vx/vy
                                let spd = Math.hypot(mvx, mvy);
                                if (spd < 0.001) { mvx = vx[i]; mvy = vy[i]; spd = Math.hypot(mvx, mvy) || 0.0001; }
                                const ang = Math.atan2(mvy, mvx);
                                const base=(meta.baseDamage||damage[i]);
                                const sideCount=4; const maxSpread=0.55;
                                // adjust center
                                const newDmg = Math.max(1, Math.floor(base*0.65)); damage[i]=newDmg; meta.baseDamage=newDmg; radius[i]=Math.max(2, Math.floor(radius[i]*0.75));
                                for (let k=0;k<sideCount;k++) {
                                    const t = (k/(sideCount-1))*2-1; const eased = t*Math.abs(t); const offset = eased*(maxSpread/2); if (Math.abs(offset)<0.0001) continue;
                                    const nvx = Math.cos(ang+offset) * spd*0.97; const nvy = Math.sin(ang+offset) * spd*0.97;
                                    const idxK = game.spawnProjectile({
                                        x:x[i], y:y[i],
                                        vx:nvx, vy:nvy,
                                        life: Math.floor(life[i]*0.85),
                                        r: Math.max(2, Math.floor(radius[i]*0.60)),
                                        damage: Math.max(1, Math.floor(base*0.45)),
                                        // Inherit common pattern flags so child motion matches the parent context
                                        sineWave: !!(meta && meta.sineWave),
                                        wackyZigzag: !!(meta && meta.wackyZigzag),
                                        ekgWave: !!(meta && meta.ekgWave),
                                        spiralPattern: !!(meta && (meta.spiral || meta.spiralPattern))
                                    });
                                    if (idxK>=0) {
                                        if(!game._projMeta) game._projMeta = new Map();
                                        const md = { veerChild:true, _initialFx: Math.cos(ang+offset), _initialFy: Math.sin(ang+offset) };
                                        // Propagate additive patterns
                                        if (meta && meta.pendulumPattern) md.pendulumPattern = true;
                                        if (meta && meta.pivotPattern) md.pivotPattern = true;
                                        if (meta && meta.hasUzumaki) {
                                            md.hasUzumaki = true;
                                            md._uzuCx = (meta._uzuCx!=null?meta._uzuCx:game.player.x);
                                            md._uzuCy = (meta._uzuCy!=null?meta._uzuCy:game.player.y);
                                            md._uzuAngle = ang + offset;
                                            md._uzuRadius = 16;
                                            md._uzuAngularVel = 0.18 + Math.random()*0.05;
                                            md._uzuRadialVel = 1.35 + Math.random()*0.35;
                                            md._uzuDrag = 0.000;
                                        }
                                        game._projMeta.set(idxK, md);
                                    }
                                }
                                // subtle fan guide lines (perf-aware)
                                if (!(game.perf && game.perf.lowFx)) {
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!reduceRings) addParticle(x[i], y[i], '#FFF2CC','ring');
                                }
                                addParticle(x[i], y[i], '#FFF2CC','spark');
                            }
                        }
                        // Bloom Ring: periodically emit an expanding pellet ring from this projectile
                        if (meta && meta.bloomRing && !meta._bloomDone && !meta.beam && !meta.enemy) {
                            if (!meta._bloomInit) {
                                meta._bloomInit = true;
                                meta._bloomTimer = 28;          // cadence between blooms
                                meta._bloomWarnFrames = 4;      // pre-emit telegraph
                                meta._bloomPellets = 12;        // number of pellets in ring
                                meta._bloomSpeed = 3.4;         // pellet speed
                                meta._bloomLife = 60;           // pellet life
                            }
                            meta._bloomTimer--;
                            if (meta._bloomTimer === meta._bloomWarnFrames) {
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!lowFx && !reduceRings) addParticle(x[i], y[i], '#FFE6CC','ring');
                            }
                            if (meta._bloomTimer <= 0) {
                                meta._bloomTimer = 28;
                                const pellets = Math.max(6, meta._bloomPellets|0);
                                const base = meta.baseDamage || damage[i] || 1;
                                for (let p=0; p<pellets; p++) {
                                    const ang = (p / pellets) * Math.PI * 2;
                                    const nvx = Math.cos(ang) * meta._bloomSpeed;
                                    const nvy = Math.sin(ang) * meta._bloomSpeed;
                                    const idxB = game.spawnProjectile && game.spawnProjectile({ x:x[i], y:y[i], vx:nvx, vy:nvy, life: meta._bloomLife, r: Math.max(10, Math.floor((radius[i]||6)*1.10)), damage: Math.max(1, Math.floor(base*0.40)) });
                                    if (idxB>=0) {
                                        if (!game._projMeta) game._projMeta = new Map();
                                        game._projMeta.set(idxB, { bloomChild:true, _initialFx:Math.cos(ang), _initialFy:Math.sin(ang), baseDamage: Math.max(1, Math.floor(base*0.40)) });
                                    }
                                }
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                if (!reduceRings) addParticle(x[i], y[i], '#FFD9AA','ring');
                                if (!lowFx && !hideSparks) for (let s=0;s<4;s++) addParticle(x[i] + (Math.random()-0.5)*10, y[i] + (Math.random()-0.5)*10, '#FFCC88','spark');
                            }
                        }
                        // Decay transient cue timers if present
                        if (meta && meta._pierceFlash) { meta._pierceFlash--; if (meta._pierceFlash <= 0) meta._pierceFlash = 0; }
                        if (meta && meta._bounceFlash) { meta._bounceFlash--; if (meta._bounceFlash <= 0) meta._bounceFlash = 0; }
                        // Time Bomb: mirror fuse glow intensity into SoA meta when countdown exists on meta
                        if (meta && meta.timeBomb) {
                            if (typeof meta._timeBombTimer === 'number') {
                                if (typeof meta._tbFuseMax !== 'number') meta._tbFuseMax = meta._timeBombTimer;
                                const maxF = Math.max(1, meta._tbFuseMax || 54);
                                const tLeft = Math.max(0, meta._timeBombTimer);
                                const frac = 1 - Math.min(1, tLeft / maxF);
                                meta._tbGlowI = Math.min(1, frac*frac * (meta._timeBombArmed ? 1.2 : 1));
                                meta._timeBombTimer--; // SoA countdown for SoA-based projectiles
                                if (meta._timeBombTimer <= 0 && alive[i] && !meta._timeBombExploded) {
                                    meta._timeBombExploded = true;
                                    // Compute explosion damage similar to object path
                                    const baseD = meta.baseDamage || damage[i] || calculateDamage();
                                    const dmg = Math.floor(baseD * (meta._timeBombExplosionMult || 2.0));
                                    // Trigger explosion using centralized handler; mark as timeBomb for enhanced FX/shards
                                    explodeProjectile({ x: x[i], y: y[i], size: radius[i], timeBomb: true, baseDamage: baseD, enemy: false }, dmg);
                                    life[i] = 0; // remove SoA projectile after detonation
                                }
                            }
                        }
                    }
                }
                // After iterating through active projectiles, check SIGMA sigma2 trackers for completion
                if (game._sigma && game._sigma.trackers && game._sigma.trackers.size) {
                    // Count remaining alive kids by checking SoA alive[] flags
                    for (const [token, tr] of game._sigma.trackers.entries()) {
                        if (!tr || !tr.kids || tr._spawned) continue;
                        let remaining = 0; let cx = 0, cy = 0, cnt = 0;
                        for (let k=0; k<tr.kids.length; k++) {
                            const idx = tr.kids[k];
                            if (typeof idx === 'number' && idx >= 0 && idx < MAX) {
                                if (alive[idx]) {
                                    // Validate that this alive projectile is still one of our sigma2 children (token match)
                                    const metaK = game._projMeta && game._projMeta.get(idx);
                                    if (metaK && metaK.sigma2 && metaK._sigmaToken === token) {
                                        remaining++; cx += x[idx]; cy += y[idx]; cnt++;
                                    }
                                }
                            }
                        }
                        const nowF = (typeof game.frame==='number') ? game.frame : 0;
                        // Fallback timeout: if tracker has existed > 420 frames (~7s) and still not resolved, force spawn
                        const force = tr.createdFrame != null && (nowF - tr.createdFrame > 420);
                        if (remaining === 0 || force) {
                            tr._spawned = true;
                            const sx = (tr._centroidX != null) ? tr._centroidX : (cnt>0 ? cx/cnt : tr.originX);
                            const sy = (tr._centroidY != null) ? tr._centroidY : (cnt>0 ? cy/cnt : tr.originY);
                            const power = Math.max(1, Math.floor(calculateDamage() * 1.3));
                            spawnSigma3(sx, sy, power);
                            // Clean up tracker to avoid leaks
                            game._sigma.trackers.delete(token);
                        }
                    }
                }
            }
            // Render (batched by color to reduce state churn)
            // Pre-render small circle sprites (r 1..10) for each palette color
            const spriteCache = [];
            (function buildSprites(){
                for (let c=0;c<palette.length;c++){
                    spriteCache[c] = [];
                    for (let r=1;r<=10;r++){
                        const off = document.createElement('canvas');
                        const sz = r*2; off.width = sz; off.height = sz;
                        const ictx = off.getContext('2d');
                        ictx.fillStyle = palette[c];
                        ictx.beginPath(); ictx.arc(r, r, r, 0, Math.PI*2); ictx.fill();
                        spriteCache[c][r] = off;
                    }
                }
            })();
            function renderProjectiles(ctx){
                for (let i=0;i<MAX;i++){
                    if (!alive[i]) continue;
                    const r = radius[i];
                    const cx = x[i]; const cy = y[i];
                    const cIndex = colorIdx[i];
                    const meta = game._projMeta && game._projMeta.get(i);
                    // Enemy bullets are drawn in a dedicated top-layer pass for visibility; skip here
                    // but allow enemy beams to be rendered in this pass so lasers stay visible.
                    if (meta && meta.enemy && !meta.beam) {
                        continue;
                    }
                    // Void travel visuals: purple lensing aura + faint trailing ribbon
                    // Applies to any projectile marked as Void (damageType/energyType or _isVoid flag)
                    {
                        const isVoid = !!(meta && (meta._isVoid || meta.damageType === 'void' || meta.energyType === 'void'));
                        if (isVoid && !(meta && meta.quackenTentacle)) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            // Subtle lensing aura (drawn beneath bodies)
                            if (!lowFx && !game.potatoMode) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const rr = Math.max(10, r * 1.6);
                                const g = ctx.createRadialGradient(cx, cy, rr*0.20, cx, cy, rr);
                                g.addColorStop(0, 'rgba(20, 0, 30, 0.70)');
                                g.addColorStop(0.55, 'rgba(136, 68, 170, 0.22)');
                                g.addColorStop(1, 'rgba(136, 68, 170, 0.00)');
                                ctx.fillStyle = g;
                                ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            // Trailing ribbon (perf-aware, respects hideSpokes)
                            const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                            if (!lowFx && !hideSpokes) {
                                // Maintain a tiny trail buffer in metadata (per projectile)
                                if (!meta._voidTrail) { meta._voidTrail = []; meta._vtLastFrame = -1; meta._vtCap = 12; }
                                const nowFrame = (game && game.frame) || 0;
                                if (meta._vtLastFrame !== nowFrame) {
                                    meta._voidTrail.push({ x: cx, y: cy });
                                    // Degrade gracefully under load
                                    const tier = (typeof game.projectileDegradeTier === 'number') ? game.projectileDegradeTier : 0;
                                    const cap = tier >= 3 ? 5 : (tier >= 2 ? 8 : meta._vtCap);
                                    while (meta._voidTrail.length > cap) meta._voidTrail.shift();
                                    meta._vtLastFrame = nowFrame;
                                }
                                const pts = meta._voidTrail;
                                if (pts && pts.length >= 2) {
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'lighter';
                                    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                                    for (let t=1; t<pts.length; t++) {
                                        const p0 = pts[t-1], p1 = pts[t];
                                        const f = t / pts.length; // older -> smaller f
                                        const alpha = 0.08 + 0.22 * f;
                                        const w = Math.max(1.0, (r * 0.22) * f + 0.6);
                                        ctx.strokeStyle = `rgba(136, 68, 170, ${alpha.toFixed(3)})`;
                                        ctx.lineWidth = w;
                                        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                                    }
                                    ctx.restore();
                                }
                            }
                        }
                    }
                    // Shadow travel visuals: dark-violet aura + wispy smoky trail
                    {
                        const isShadow = !!(meta && (meta._isShadow || meta.damageType === 'shadow' || meta.energyType === 'shadow'));
                        if (isShadow) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            // Lensing aura (darker, slightly smaller than Void to differentiate)
                            if (!lowFx && !game.potatoMode) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const rr = Math.max(10, r * 1.45);
                                const g = ctx.createRadialGradient(cx, cy, rr*0.18, cx, cy, rr);
                                g.addColorStop(0, 'rgba(5, 0, 10, 0.80)');
                                g.addColorStop(0.55, 'rgba(170, 102, 255, 0.20)');
                                g.addColorStop(1, 'rgba(170, 102, 255, 0.00)');
                                ctx.fillStyle = g;
                                ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            // Wispy trail (thinner, smokier than Void)
                            const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                            if (!lowFx && !hideSpokes) {
                                if (!meta._shadowTrail) { meta._shadowTrail = []; meta._stLastFrame = -1; meta._stCap = 10; }
                                const nowFrame = (game && game.frame) || 0;
                                if (meta._stLastFrame !== nowFrame) {
                                    meta._shadowTrail.push({ x: cx, y: cy });
                                    const tier = (typeof game.projectileDegradeTier === 'number') ? game.projectileDegradeTier : 0;
                                    const cap = tier >= 3 ? 4 : (tier >= 2 ? 7 : meta._stCap);
                                    while (meta._shadowTrail.length > cap) meta._shadowTrail.shift();
                                    meta._stLastFrame = nowFrame;
                                }
                                const pts = meta._shadowTrail;
                                if (pts && pts.length >= 2) {
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'lighter';
                                    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                                    for (let t=1; t<pts.length; t++) {
                                        const p0 = pts[t-1], p1 = pts[t];
                                        const f = t / pts.length;
                                        const alpha = 0.06 + 0.18 * f;
                                        const w = Math.max(0.8, (r * 0.18) * f + 0.5);
                                        ctx.strokeStyle = `rgba(170, 102, 255, ${alpha.toFixed(3)})`;
                                        ctx.lineWidth = w;
                                        ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                                    }
                                    ctx.restore();
                                }
                            }
                            // Vignette pulse (darken surroundings) — multiply blend, stronger than before
                            if (!lowFx && !game.potatoMode) {
                                const t = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const pulse = 0.65 + 0.35 * Math.sin((t + (cx*0.3 + cy*0.2)) * 0.12);
                                const rrV = Math.max(16, r * 2.2);
                                ctx.save();
                                ctx.globalCompositeOperation = 'multiply';
                                // Outer vignette
                                let vg = ctx.createRadialGradient(cx, cy, rrV*0.50, cx, cy, rrV);
                                vg.addColorStop(0, 'rgba(0,0,0,0)');
                                vg.addColorStop(1, `rgba(0,0,0,${(0.22 * pulse).toFixed(3)})`);
                                ctx.fillStyle = vg;
                                ctx.beginPath(); ctx.arc(cx, cy, rrV, 0, Math.PI*2); ctx.fill();
                                // Inner dark core for shadow (subtle)
                                const innerR = Math.max(8, r * 1.0);
                                const ig = ctx.createRadialGradient(cx, cy, 0, cx, cy, innerR);
                                ig.addColorStop(0, 'rgba(0,0,0,0.25)');
                                ig.addColorStop(1, 'rgba(0,0,0,0)');
                                ctx.fillStyle = ig;
                                ctx.beginPath(); ctx.arc(cx, cy, innerR, 0, Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            // Animated shadow tendrils curling around/behind projectile
                            if (!lowFx && !(game.fxFlags && game.fxFlags.hideSpokes)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const ang = Math.atan2(vy[i], vx[i]);
                                const baseLen = Math.max(14, r * 1.4);
                                const tendrils = 2; // keep light
                                for (let td=0; td<tendrils; td++) {
                                    const seed = (i*37 + td*97);
                                    const tNow = (game && typeof game.frame==='number') ? game.frame : Math.floor(Date.now()/16);
                                    const wave = Math.sin((tNow + seed) * 0.08 + td) * 0.6;
                                    const curl = 0.6 + 0.4 * Math.sin((tNow + seed*0.5) * 0.05);
                                    const len = baseLen * (1.0 + 0.35 * Math.sin((tNow + seed) * 0.06 + td*0.7));
                                    const width = Math.max(1.0, r * 0.18);
                                    // Control points create a slight S-curve behind the projectile
                                    const back = Math.max(4, r * 0.6);
                                    const p0x = cx - Math.cos(ang) * back;
                                    const p0y = cy - Math.sin(ang) * back;
                                    const p1x = p0x - Math.cos(ang + 0.6 + wave*0.3) * (len * 0.5);
                                    const p1y = p0y - Math.sin(ang + 0.6 + wave*0.3) * (len * 0.5);
                                    const p2x = p0x - Math.cos(ang + 1.4 * curl + wave*0.2) * len;
                                    const p2y = p0y - Math.sin(ang + 1.4 * curl + wave*0.2) * len;
                                    ctx.strokeStyle = 'rgba(170, 102, 255, 0.22)';
                                    ctx.lineWidth = width;
                                    ctx.beginPath();
                                    ctx.moveTo(p0x, p0y);
                                    ctx.quadraticCurveTo(p1x, p1y, p2x, p2y);
                                    ctx.stroke();
                                }
                                ctx.restore();
                            }
                            // Emit occasional shadow wisp particles behind projectile
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!lowFx && !hideSparks) {
                                const sp = Math.hypot(vx[i], vy[i]);
                                const baseProb = 0.06 + Math.min(0.10, sp * 0.01); // faster -> slightly more wisps
                                if (Math.random() < baseProb) {
                                    const ang = Math.atan2(vy[i], vx[i]);
                                    const back = Math.max(4, r * 0.6);
                                    const px = cx - Math.cos(ang) * back + (Math.random()-0.5)*2;
                                    const py = cy - Math.sin(ang) * back + (Math.random()-0.5)*2;
                                    // Prefer 'swirl' for wispy look; fall back to 'dust' occasionally
                                    if (Math.random() < 0.75) addParticle(px, py, '#B07AFF', 'swirl');
                                    else addParticle(px, py, '#A46BFF', 'dust');
                                }
                            }
                        }
                    }
                    // Spiral Bloom petals: render with random bloom sprites and independent spin
                    if (meta && meta.petal && !meta.enemy && !meta.beam) {
                        // Initialize spin angle storage
                        if (typeof meta._petalAngle !== 'number') meta._petalAngle = 0;
                        const spin = (typeof meta.petalSpin === 'number') ? meta.petalSpin : 0.08;
                        meta._petalAngle += spin;
                        // Resolve image key (random at spawn or fallback now)
                        const key = meta.petalImg || ('bloom' + (1 + Math.floor(Math.random()*6)));
                        meta.petalImg = key; // persist choice
                        const img = window._bulletImages && window._bulletImages[key];
                        const ang = meta._petalAngle || 0;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Scale sprite so the larger drawn dimension has half-size equal to r
                            // This keeps collision radius (r) matched to the sprite’s max side.
                            const iw = img.naturalWidth, ih = img.naturalHeight;
                            const maxSide = Math.max(iw, ih) || 1;
                            const s = Math.max(0.1, (r * 2) / maxSide);
                            const w = iw * s;
                            const h = ih * s;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                        } else {
                            // Fallback simple petal: small rotated ellipse
                            const rx = Math.max(4, r * 1.4);
                            const ry = Math.max(3, r * 0.9);
                            ctx.fillStyle = '#FFE6AA';
                            ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        // Optional faint glow for petals (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx && !game.potatoMode) {
                            ctx.save(); ctx.globalCompositeOperation = 'lighter';
                            const rr = Math.max(8, r * 1.2);
                            const g = ctx.createRadialGradient(cx, cy, rr*0.25, cx, cy, rr);
                            g.addColorStop(0, 'rgba(255, 220, 160, 0.12)');
                            g.addColorStop(1, 'rgba(255, 220, 160, 0)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        continue;
                    }
                    if (meta && meta.quackenTentacle && !meta.enemy && !meta.beam) {
                        const store = window._bulletImages;
                        if (store && (!store.quackenTentacle || (store.quackenTentacle && !store.quackenTentacle.src)) && typeof store.loadQuackenTentacle === 'function') {
                            try { store.loadQuackenTentacle(); } catch(_) {}
                        }
                        const img = store ? store.quackenTentacle : null;
                        const anchorX = (meta._tentacleAnchorPlayer && typeof meta._tentacleAnchorPlayer.x === 'number') ? meta._tentacleAnchorPlayer.x : (typeof meta._tentacleAnchorX === 'number' ? meta._tentacleAnchorX : cx);
                        const anchorY = (meta._tentacleAnchorPlayer && typeof meta._tentacleAnchorPlayer.y === 'number') ? meta._tentacleAnchorPlayer.y : (typeof meta._tentacleAnchorY === 'number' ? meta._tentacleAnchorY : cy);
                        const dxTent = cx - anchorX;
                        const dyTent = cy - anchorY;
                        let length = Math.hypot(dxTent, dyTent);
                        if (!isFinite(length) || length < 4) length = 4;
                        const angle = Math.atan2(dyTent, dxTent);
                        const thicknessBase = Math.max(18, (r || 14) * 2.2);
                        ctx.save();
                        ctx.translate(anchorX, anchorY);
                        if (isFinite(angle)) ctx.rotate(angle);
                        const flipSign = (meta && meta._tentacleFlipSign === -1) ? -1 : 1;
                        if (flipSign < 0) ctx.scale(1, -1);
                        ctx.imageSmoothingEnabled = true;
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const iw = img.naturalWidth;
                            const ih = img.naturalHeight || 1;
                            const scaleY = thicknessBase / ih;
                            const drawH = ih * scaleY;
                            ctx.drawImage(img, 0, -drawH / 2, length, drawH);
                        } else {
                            const grad = ctx.createLinearGradient(0, 0, length, 0);
                            grad.addColorStop(0, 'rgba(89,72,210,0.95)');
                            grad.addColorStop(1, 'rgba(61,41,150,0.65)');
                            ctx.fillStyle = grad;
                            const h = thicknessBase;
                            const radius = Math.min(h * 0.4, 18);
                            ctx.beginPath();
                            ctx.moveTo(0, -h / 2);
                            ctx.lineTo(length - radius, -h / 2);
                            ctx.quadraticCurveTo(length, -h / 2, length, -h / 2 + radius);
                            ctx.lineTo(length, h / 2 - radius);
                            ctx.quadraticCurveTo(length, h / 2, length - radius, h / 2);
                            ctx.lineTo(radius, h / 2);
                            ctx.quadraticCurveTo(0, h / 2, 0, h / 2 - radius);
                            ctx.lineTo(0, -h / 2 + radius);
                            ctx.quadraticCurveTo(0, -h / 2, radius, -h / 2);
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.restore();
                        if (meta._tentacleTrail && meta._tentacleTrail.length > 1) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            let last = { x: anchorX, y: anchorY };
                            for (let t = 0; t < meta._tentacleTrail.length; t++) {
                                const p1 = meta._tentacleTrail[t];
                                if (!p1) continue;
                                const alpha = (t + 1) / (meta._tentacleTrail.length + 1);
                                ctx.strokeStyle = 'rgba(84,66,196,' + Math.min(0.30, 0.08 + 0.22 * alpha).toFixed(3) + ')';
                                ctx.lineWidth = Math.max(1.8, (r * 0.18) * (alpha + 0.3) + 1);
                                ctx.beginPath();
                                ctx.moveTo(last.x, last.y);
                                ctx.lineTo(p1.x, p1.y);
                                ctx.stroke();
                                last = p1;
                            }
                            ctx.restore();
                        }
                        if (!(game.perf && game.perf.lowFx) && !game.potatoMode) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            const glowR = Math.max(20, thicknessBase * 0.55);
                            const gradAnchor = ctx.createRadialGradient(anchorX, anchorY, glowR * 0.18, anchorX, anchorY, glowR);
                            gradAnchor.addColorStop(0, 'rgba(98,78,220,0.32)');
                            gradAnchor.addColorStop(1, 'rgba(98,78,220,0)');
                            ctx.fillStyle = gradAnchor;
                            ctx.beginPath(); ctx.arc(anchorX, anchorY, glowR, 0, Math.PI * 2); ctx.fill();
                            ctx.restore();
                        }
                        continue;
                    }
                    // SIGMA sprites rendering
                    if (meta && (meta.sigma1 || meta.sigma2 || meta.sigma3)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save();
                        ctx.translate(cx, cy);
                        if (meta.sigma3) {
                            // Spinner rotates in place; use meta._spin for rotation
                            const img = window._bulletImages && window._bulletImages.sigma3;
                            const rot = typeof meta._spin === 'number' ? meta._spin : 0;
                            ctx.rotate(rot);
                            if (img && img._ok && img.complete && img.naturalWidth) {
                                // Draw size based on stored visual radius (meta._auraRadius), not collision radius
                                const vr = (meta && typeof meta._auraRadius === 'number') ? meta._auraRadius : (Math.min((ctx.canvas&&ctx.canvas.width)||800,(ctx.canvas&&ctx.canvas.height)||600) * 0.10);
                                const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                                let w = vr * 2, h = w / aspect;
                                ctx.imageSmoothingEnabled = true;
                                ctx.drawImage(img, -w/2, -h/2, w, h);
                            } else {
                                // Fallback: bright rotating star
                                const rr = Math.max(12, ((meta && meta._auraRadius) ? meta._auraRadius : r) * 1.0);
                                ctx.fillStyle = '#BBD7FF';
                                ctx.beginPath(); ctx.arc(0,0,rr,0,Math.PI*2); ctx.fill();
                            }
                        } else if (meta.sigma1) {
                            // Large, strong-homing stage 1
                            const img = window._bulletImages && window._bulletImages.sigma1;
                            if (isFinite(ang)) ctx.rotate(ang);
                            if (img && img._ok && img.complete && img.naturalWidth) {
                                const base = Math.max(22, r * 2.2);
                                const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                                let w = base * 1.1, h = w / aspect;
                                ctx.imageSmoothingEnabled = true;
                                ctx.drawImage(img, -w*0.1, -h/2, w, h);
                            } else {
                                // Fallback ellipse
                                const rr = Math.max(8, r * 1.1);
                                ctx.fillStyle = '#CCE6FF';
                                ctx.beginPath(); ctx.ellipse(0, 0, rr*1.4, rr*0.9, 0, 0, Math.PI*2); ctx.fill();
                            }
                        } else if (meta.sigma2) {
                            // Smaller homing fragments
                            const img = window._bulletImages && window._bulletImages.sigma2;
                            if (isFinite(ang)) ctx.rotate(ang);
                            if (img && img._ok && img.complete && img.naturalWidth) {
                                const base = Math.max(14, r * 1.8);
                                const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                                let w = base, h = w / aspect;
                                ctx.imageSmoothingEnabled = true;
                                ctx.drawImage(img, -w*0.1, -h/2, w, h);
                            } else {
                                const rr = Math.max(6, r * 0.9);
                                ctx.fillStyle = '#DDEBFF';
                                ctx.beginPath(); ctx.ellipse(0, 0, rr*1.2, rr*0.8, 0, 0, Math.PI*2); ctx.fill();
                            }
                        }
                        ctx.restore();
                        // Subtle glow for all SIGMA projectiles (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx && !game.potatoMode) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            const glowR = meta.sigma3 ? Math.max(20, (Math.min((ctx.canvas&&ctx.canvas.width)||800,(ctx.canvas&&ctx.canvas.height)||600) * 0.11)) : Math.max(12, r * 1.2);
                            const g = ctx.createRadialGradient(cx, cy, glowR*0.25, cx, cy, glowR);
                            g.addColorStop(0, meta.sigma3 ? 'rgba(180,210,255,0.22)' : 'rgba(200,230,255,0.18)');
                            g.addColorStop(1, 'rgba(180,210,255,0)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        continue;
                    }
                    // EKG trail: leave a short trailing polyline to sell motion during spikes
                    if ((flags[i] & FLAG.EKG) || (meta && meta.ekgWave)) {
                        if (meta) {
                            // Initialize or append to a small ring buffer of previous positions
                            const nowFrame = (game && game.frame) || 0;
                            if (!meta._ekgTrail) { meta._ekgTrail = []; meta._ekgTrailMax = 14; meta._ekgTrailLast = nowFrame; }
                            // Add a point every 1-2 frames to avoid overdraw
                            if (nowFrame !== meta._ekgTrailLast) {
                                meta._ekgTrail.push({ x: cx, y: cy });
                                if (meta._ekgTrail.length > meta._ekgTrailMax) meta._ekgTrail.shift();
                                meta._ekgTrailLast = nowFrame;
                            }
                            // Also emit damaging trail segments from recent path points
                            if (meta._ekgTrail && meta._ekgTrail.length >= 2) {
                                const pts = meta._ekgTrail;
                                const p0 = pts[pts.length-2], p1 = pts[pts.length-1];
                                if (!Array.isArray(game.ekgTrailSegments)) game.ekgTrailSegments = [];
                                if (game.ekgTrailSegments.length > 160) game.ekgTrailSegments.splice(0, game.ekgTrailSegments.length - 160);
                                const baseDmg = (meta.baseDamage || damage && damage[i]) || calculateDamage && calculateDamage() || 8;
                                game.ekgTrailSegments.push({ x1:p0.x, y1:p0.y, x2:p1.x, y2:p1.y, ttl: 28, maxTtl: 28, w: Math.max(4, r*0.35), dps: Math.max(1, Math.floor(baseDmg*0.15)), hitMap: new Map() });
                            }
                            // Render trail as a tapered green line (lighter compositing)
                            if (meta._ekgTrail && meta._ekgTrail.length >= 2) {
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                const lowFx = !!(game.perf && game.perf.lowFx);
                                if (!(lowFx && reduceRings)) {
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'lighter';
                                    ctx.lineCap = 'round';
                                    ctx.lineJoin = 'round';
                                    // Draw segments with decreasing alpha and width
                                    const pts = meta._ekgTrail;
                                    for (let t=1; t<pts.length; t++) {
                                        const p0 = pts[t-1], p1 = pts[t];
                                        const f = t / pts.length; // older -> smaller f
                                        const alpha = 0.10 + 0.35 * f;
                                        const w = Math.max(1.2, (r*0.22) * f + 0.8);
                                        ctx.strokeStyle = `rgba(120, 255, 180, ${alpha.toFixed(3)})`;
                                        ctx.lineWidth = w;
                                        ctx.beginPath();
                                        ctx.moveTo(p0.x, p0.y);
                                        ctx.lineTo(p1.x, p1.y);
                                        ctx.stroke();
                                    }
                                    ctx.restore();
                                }
                            }
                        }
                    }
                    // Time Bomb: sprite + fuse glow
                    if (meta && meta.timeBomb) {
                        const img = window._bulletImages && window._bulletImages.timebomb;
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save();
                        ctx.translate(cx, cy);
                        if (isFinite(ang)) ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(18, r * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base, h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                            // Fuse-tip spark: place a small glow near front/top-right of the sprite along facing
                            const tbI = (meta._tbGlowI != null ? meta._tbGlowI : 0);
                            const fuseOff = Math.max(6, w * 0.28);
                            const fx = Math.cos(0) * fuseOff; // after rotation, (1,0) points forward
                            const fy = -Math.max(2, h * 0.08);
                            const sparkAlpha = 0.35 + 0.45 * Math.min(1, tbI * 1.2);
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = sparkAlpha;
                            const sR = Math.max(1.8, Math.min(4.0, w * 0.08 + tbI * 2));
                            const grad = ctx.createRadialGradient(fx, fy, 0, fx, fy, sR);
                            grad.addColorStop(0, 'rgba(255,220,140,0.95)');
                            grad.addColorStop(1, 'rgba(255,160,60,0)');
                            ctx.fillStyle = grad;
                            ctx.beginPath(); ctx.arc(fx, fy, sR, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        } else {
                            // Fallback: dark shell circle
                            const rr = Math.max(10, r * 1.2);
                            ctx.fillStyle = '#443322';
                            ctx.beginPath(); ctx.arc(0,0,rr,0,Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#AA7744'; ctx.lineWidth = Math.max(1.2, rr*0.12);
                            ctx.beginPath(); ctx.arc(0,0,rr*0.7,0,Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                        // Fuse glow overlay (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx && !game.potatoMode) {
                            const tbI = (meta._tbGlowI != null ? meta._tbGlowI : 0.0);
                            const intensity = Math.max(0, Math.min(1, tbI));
                            if (intensity > 0.02) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const glowR = Math.max(12, r * (1.4 + 0.9*intensity));
                                const g = ctx.createRadialGradient(cx, cy, glowR*0.25, cx, cy, glowR);
                                g.addColorStop(0, `rgba(255, 210, 120, ${(0.10 + 0.28*intensity).toFixed(3)})`);
                                g.addColorStop(1, 'rgba(255, 210, 120, 0)');
                                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();
                                if (intensity > 0.55) {
                                    ctx.globalAlpha = 0.25 + 0.45*(intensity - 0.55);
                                    ctx.strokeStyle = '#FFB366'; ctx.lineWidth = 2;
                                    ctx.beginPath(); ctx.arc(cx, cy, Math.max(r+5, glowR*0.55), 0, Math.PI*2); ctx.stroke();
                                }
                                ctx.restore();
                            }
                            // Ambient micro-sparks cadence speeds up near detonation
                            if (meta._tbGlowI && Math.random() < (0.06 + meta._tbGlowI * 0.12)) {
                                addParticle(cx + (Math.random()-0.5)*6, cy + (Math.random()-0.5)*6, '#FFD98A','spark');
                            }
                        }
                        continue;
                    }
                    // Tumbleweed / Kick the Can: sprite-based rolling with spin proportional to speed
                    if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                        const img = (window._bulletImages && (meta.kickTheCan ? window._bulletImages.beans : window._bulletImages.tumbleweed));
                        const sp = Math.hypot(vy[i], vx[i]);
                        if (typeof meta._rollAngle !== 'number') meta._rollAngle = 0;
                        // roll speed scaled by pixel speed and radius; clamp to avoid excessive spin
                        const spinRate = Math.min(0.45, 0.06 + sp * 0.025);
                        meta._rollAngle += spinRate;
                        const ang = meta._rollAngle;
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(22, r * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base, h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                        } else {
                            // Fallback: simple textured circle
                            const rr = Math.max(10, r * 1.15);
                            const g = ctx.createRadialGradient(0, 0, rr*0.2, 0, 0, rr);
                            g.addColorStop(0, 'rgba(230,200,150,0.9)');
                            g.addColorStop(1, 'rgba(180,140,90,0.95)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,rr,0,Math.PI*2); ctx.fill();
                            ctx.strokeStyle = 'rgba(120,90,60,0.45)'; ctx.lineWidth = Math.max(1, rr*0.12);
                            ctx.beginPath(); ctx.arc(0,0, rr*0.65, 0, Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                        // Optional subtle dust puffs when rolling fast (perf-aware)
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!lowFx && !hideSparks && sp > 2.8 && Math.random()<0.08) {
                            addParticle(cx - Math.sign(vx[i]) * r*0.4 + (Math.random()-0.5)*4, cy - Math.sign(vy[i]) * r*0.4 + (Math.random()-0.5)*4, '#EFDDBF','dust');
                        }
                        continue;
                    }
                    // Ion Cannon: initial release ring (first few frames after spawn)
                    if (meta && meta.energyType === 'ion') {
                        // Draw the ion projectile sprite aligned to travel
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.ion;
                        const ch = Math.max(0, Math.min(1, (meta.charge||0))); // 0..1
                        ctx.save(); ctx.translate(cx, cy); if (isFinite(ang)) ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Base scales with radius and increases further with charge
                            const base = Math.max(18, r * 2.0) * (1.0 + ch * 0.8);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base * 1.15; let h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            // Slight forward offset so the sprite nose leads
                            ctx.drawImage(img, -w*0.1, -h/2, w, h);
                        } else {
                            // Fallback: small cyan capsule
                            const rr = Math.max(6, r * 0.9);
                            ctx.fillStyle = '#B3EEFF';
                            ctx.beginPath(); ctx.ellipse(0, 0, rr*1.3, rr*0.9, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        const age = (lifeMax[i] - life[i]) | 0; // frames since spawn
                        if (age < 8) {
                            const fade = 1 - age / 8;
                            const baseR = Math.max(10, r * 1.2);
                            const rr = baseR + ch * 10;
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            // Outer white ring
                            ctx.strokeStyle = 'rgba(255,255,255,' + (0.55 * fade).toFixed(3) + ')';
                            ctx.lineWidth = 2.5;
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.stroke();
                            // Soft cyan glow
                            const g = ctx.createRadialGradient(cx, cy, rr*0.35, cx, cy, rr);
                            g.addColorStop(0, 'rgba(180,245,255,' + (0.12 + 0.25 * fade).toFixed(3) + ')');
                            g.addColorStop(1, 'rgba(180,245,255,0)');
                            ctx.fillStyle = g;
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        // Done rendering Ion Cannon; skip default projectile draw
                        continue;
                    }
                    // Resonant Pulse overlay rings (SoA) — expanding/fading ring at pulse; perf-gated
                    if (meta && meta._resActiveRings && meta._resActiveRings.length && !(game.perf && game.perf.lowFx)) {
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        for (let ri=0; ri<meta._resActiveRings.length; ri++) {
                            const ring = meta._resActiveRings[ri];
                            const rr = Math.max(4, ring.r || 0);
                            const lifeNorm = Math.max(0, Math.min(1, (ring.life != null ? ring.life : 0) / 38));
                            const alpha = 0.60 * lifeNorm;
                            ctx.strokeStyle = `rgba(199,164,255,${alpha.toFixed(3)})`;
                            ctx.lineWidth = 2 + 1.4 * lifeNorm;
                            if (!reduceRings && ctx.setLineDash) ctx.setLineDash([6, 6]);
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.stroke();
                            if (!reduceRings && ctx.setLineDash) ctx.setLineDash([]);
                        }
                        ctx.restore();
                    }
                    // Slalom visual cue: alternating chevrons when pattern active (skip for Diarrhea to keep brown-only)
                    if (meta && meta.slalomPattern && !(meta && meta._diarrheaBrown)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const chevronLen = Math.max(8, r * 1.6);
                        const chevronW = Math.max(1.5, r * 0.35);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        ctx.strokeStyle = 'rgba(120,220,255,0.7)'; ctx.lineWidth = Math.max(1, chevronW*0.5);
                        // draw two chevrons offset on either side
                        ctx.beginPath();
                        ctx.moveTo(-chevronLen*0.8, -chevronW);
                        ctx.lineTo(-chevronLen*0.4, 0);
                        ctx.lineTo(-chevronLen*0.8, chevronW);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-chevronLen*0.3, -chevronW);
                        ctx.lineTo(chevronLen*0.1, 0);
                        ctx.lineTo(-chevronLen*0.3, chevronW);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // Sawtooth wave overlay: small jagged tick ahead of travel (perf-gated)
                    if (meta && meta.sawWave && !(game.perf && game.perf.lowFx)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const len = Math.max(8, r * 1.4);
                        const amp = Math.max(2, r * 0.35);
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!hideSpokes) {
                            ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                            ctx.strokeStyle = 'rgba(255,220,140,0.75)'; ctx.lineWidth = 1.2;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(len*0.35, -amp);
                            ctx.lineTo(len*0.7, amp);
                            ctx.lineTo(len, 0);
                            ctx.stroke();
                            ctx.restore();
                        } else if (!reduceRings) {
                            addParticle(cx, cy, '#FFD280','ring');
                        }
                    }
                    // Pendulum arc cue: brief inner arc when swing flips (perf-gated by reduceRings)
                    if (meta && meta.pendulumPattern && meta._pendCue > 0) {
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!reduceRings && !lowFx) {
                            const ang = Math.atan2(vy[i], vx[i]);
                            const arcR = Math.max(8, r * 1.4);
                            ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                            ctx.strokeStyle = 'rgba(200,235,255,0.8)'; ctx.lineWidth = 1.6;
                            ctx.beginPath();
                            ctx.arc(0, 0, arcR, -0.6, 0.6);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                    // Vector Pivot cue: quick tick perpendicular to velocity when large pivot detected
                    if (meta && meta.pivotPattern && meta._pivotCue > 0 && !(game.perf && game.perf.lowFx)) {
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const ang = Math.atan2(vy[i], vx[i]);
                        if (!hideSpokes) {
                            const len = Math.max(6, r * 1.2);
                            ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + Math.PI/2);
                            ctx.strokeStyle = 'rgba(180,245,255,0.9)'; ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.moveTo(0, -len*0.5); ctx.lineTo(0, len*0.5); ctx.stroke();
                            ctx.restore();
                        } else if (!reduceRings) {
                            addParticle(cx, cy, '#B4F5FF','ring');
                        }
                    }
                    // Void projectile aura/trail: subtle purple lensing + short back trail
                    if (meta && (meta._isVoid || meta.damageType === 'void' || meta.energyType === 'void')) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const ang = Math.atan2(vy[i], vx[i]);
                        // Soft lensing aura
                        if (!lowFx && !game.potatoMode) {
                            const col = getDamageTypeColor('void') || '#8844AA';
                            const rr = Math.max(10, r * 1.5);
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            const g = ctx.createRadialGradient(cx, cy, rr*0.15, cx, cy, rr);
                            g.addColorStop(0, 'rgba(20, 0, 30, 0.45)');
                            g.addColorStop(0.55, 'rgba(136, 68, 170, 0.22)');
                            g.addColorStop(1, 'rgba(136, 68, 170, 0)');
                            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        }
                        // Short faint trail behind
                        if (!hideSpokes && !lowFx) {
                            const len = Math.max(8, r * 1.6);
                            const wid = Math.max(1.2, r * 0.22);
                            const alpha = 0.18 + Math.min(0.35, Math.hypot(vx[i], vy[i]) * 0.03);
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.translate(cx, cy); ctx.rotate(ang + Math.PI);
                            ctx.strokeStyle = `rgba(160,120,200,${alpha.toFixed(3)})`;
                            ctx.lineWidth = wid;
                            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.stroke();
                            ctx.restore();
                        } else if (!reduceRings && !lowFx) {
                            addParticle(cx, cy, '#C7A4FF','ring');
                        }
                    }
                    // Temporal Drift visual overlays (SoA): stronger pre-beat rings and surge glow/afterimage
                    if (meta && meta.temporalDrift) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const phase = meta._tdPhase || 0;
                        const timer = meta._tdTimer || 0;
                        // thresholds synced with logic
                        const th = phase === 0 ? 30 : (phase === 1 ? 10 : 18);
                        if (timer >= th - 4) {
                            ctx.save();
                            ctx.globalAlpha = 0.45;
                            ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                            ctx.lineWidth = 2.2;
                            ctx.beginPath(); ctx.arc(cx, cy, Math.max(8, r + 4), 0, Math.PI*2); ctx.stroke();
                            ctx.restore();
                            if (!lowFx && !reduceRings) {
                                const tight = Math.max(0, Math.min(1, (timer - (th - 4)) / 4));
                                ctx.save();
                                ctx.globalAlpha = 0.30 + 0.65 * tight;
                                ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                                ctx.lineWidth = 2.6;
                                ctx.beginPath(); ctx.arc(cx, cy, Math.max(10, r + 6), 0, Math.PI*2); ctx.stroke();
                                ctx.restore();
                            }
                        }
                        if (!lowFx && phase === 2) {
                            const t = (performance.now()/220) + (cx+cy)*0.002;
                            const pulse = 0.5 + 0.5*Math.sin(t*2*Math.PI);
                            const rr = Math.max(10, r * (1.35 + 0.35*pulse));
                            ctx.save();
                            const g = ctx.createRadialGradient(cx, cy, rr*0.10, cx, cy, rr);
                            g.addColorStop(0, 'rgba(170,250,255,' + (0.58 + 0.30*pulse).toFixed(3) + ')');
                            g.addColorStop(1, 'rgba(170,250,255,0)');
                            ctx.fillStyle = g;
                            ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                            // Afterimage trail
                            meta._tdTrail = meta._tdTrail || [];
                            const buf = meta._tdTrail; buf.push({ x: cx, y: cy, t: performance.now() });
                            while (buf.length > 8) buf.shift();
                            ctx.save(); ctx.globalCompositeOperation = 'lighter';
                            for (let k=1; k<buf.length; k++) {
                                const p0 = buf[k-1], p1 = buf[k];
                                const ageMs = performance.now() - p0.t; const a = Math.max(0, 1 - ageMs/140);
                                if (a <= 0) continue;
                                ctx.strokeStyle = `rgba(164,245,255,${(0.20*a).toFixed(3)})`;
                                ctx.lineWidth = Math.max(1.2, r * 0.22 * a);
                                ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                            }
                            ctx.restore();
                        }
                    }
                    // Boomerang pre-return cue: faint ring + arrow toward player just before flip
                    if (meta && meta.boomerang && !meta._boomReturn && meta._boomPreCue > 0) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!lowFx && !reduceRings) {
                            const angToPlayer = (game.player ? Math.atan2(game.player.y - cy, game.player.x - cx) : Math.atan2(-vy[i], -vx[i]));
                            ctx.save();
                            ctx.translate(cx, cy);
                            // subtle ring
                            ctx.globalAlpha = 0.35;
                            ctx.strokeStyle = '#FFE6CC';
                            ctx.lineWidth = Math.max(1.2, r * 0.22);
                            ctx.beginPath(); ctx.arc(0, 0, Math.max(8, r*1.2), 0, Math.PI*2); ctx.stroke();
                            // arrow facing predicted return vector (toward player)
                            ctx.rotate(angToPlayer);
                            ctx.strokeStyle = 'rgba(255, 230, 180, 0.85)';
                            ctx.lineWidth = Math.max(1.2, r * 0.2);
                            const len = Math.max(8, r * 1.5);
                            ctx.beginPath();
                            ctx.moveTo(len*0.2, 0);
                            ctx.lineTo(len*0.8, 0);
                            ctx.moveTo(len*0.8, 0);
                            ctx.lineTo(len*0.55, -len*0.25);
                            ctx.moveTo(len*0.8, 0);
                            ctx.lineTo(len*0.55, len*0.25);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                    // Boomerang return chevrons: small inwards chevrons to indicate it's heading back
                    if (meta && meta.boomerang && meta._boomReturn && !(game.perf && game.perf.lowFx)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + Math.PI);
                        ctx.strokeStyle = 'rgba(255, 230, 180, 0.8)';
                        ctx.lineWidth = Math.max(1, r * 0.18);
                        const len = Math.max(6, r * 1.3);
                        // draw two inward-pointing small chevrons behind the projectile
                        ctx.beginPath();
                        ctx.moveTo(-len*0.2, -r*0.3);
                        ctx.lineTo(-len*0.6, 0);
                        ctx.lineTo(-len*0.2, r*0.3);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-len*0.6, -r*0.25);
                        ctx.lineTo(-len*0.95, 0);
                        ctx.lineTo(-len*0.6, r*0.25);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // Orbitals: no leash/spoke lines — keep the view clean while circling
                    // (intentionally no-op for meta._orbital)
                    // Teleport Shot shimmer: brief portal outline after spawn (perf-aware)
                    if (meta && meta.teleporting) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const age = (lifeMax[i] - life[i]) | 0; // frames since spawn/teleport
                        if (age >= 0 && age < 10) {
                            if (lowFx || hideSpokes) {
                                // Lightweight fallback: a couple of quick rings in the first few frames
                                if (!reduceRings && (age === 0 || age === 2)) {
                                    addParticle(cx, cy, '#FFE4AA', 'ring');
                                }
                            } else {
                                // Subtle portal ring + two rotating arc dashes with fading alpha
                                const fade = 1 - age / 10;
                                const rr = Math.max(10, r * 1.5);
                                ctx.save();
                                ctx.translate(cx, cy);
                                ctx.globalCompositeOperation = 'lighter';
                                // Outer soft ring
                                ctx.strokeStyle = `rgba(255, 230, 180, ${ (0.5 * fade).toFixed(3) })`;
                                ctx.lineWidth = Math.max(1.2, r * 0.25);
                                ctx.beginPath(); ctx.arc(0, 0, rr, 0, Math.PI*2); ctx.stroke();
                                // Rotating short arcs for shimmer feel
                                const t = (((window.game && window.game.frame) || 0) * 0.22 + i * 0.37);
                                ctx.rotate(t);
                                ctx.strokeStyle = `rgba(255, 215, 150, ${ (0.7 * fade).toFixed(3) })`;
                                ctx.lineWidth = Math.max(1.0, r * 0.2);
                                ctx.beginPath(); ctx.arc(0, 0, rr * 0.85, -0.55, -0.20); ctx.stroke();
                                ctx.beginPath(); ctx.arc(0, 0, rr * 0.85, 0.20, 0.55); ctx.stroke();
                                ctx.restore();
                            }
                        }
                    }
                    // Homing steer chevron: brief forward tick when homing makes a sharp turn
                    if (meta && meta._homCue > 0) {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        if (!lowFx) {
                            const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            const ang = Math.atan2(vy[i], vx[i]);
                            if (!hideSpokes) {
                                const len = Math.max(6, r * 1.3);
                                ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                                ctx.strokeStyle = 'rgba(170,235,255,0.9)'; ctx.lineWidth = 1.8;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(len, 0);
                                ctx.stroke();
                                ctx.restore();
                            } else if (!reduceRings) {
                                addParticle(cx, cy, '#AEEBFF','ring');
                            }
                        }
                    }
                    // EKG spike overlay (draw early so it appears with any base shape). Skip for Diarrhea so it stays brown-only.
                    if (((flags[i] & FLAG.EKG) || (meta && meta.ekgWave)) && meta && meta._ekgSpikeVis > 0 && !(meta && meta._diarrheaBrown)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const len = Math.max(34, r * 5.2);
                        const w = Math.max(4.2, r * 0.92);
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(ang);
                        // Neon spike triangle pointing ahead of travel
                        const grd = ctx.createLinearGradient(0, -len, 0, 0);
                        grd.addColorStop(0, 'rgba(120,255,180,1.0)');
                        grd.addColorStop(1, 'rgba(120,255,180,0.22)');
                        ctx.fillStyle = grd;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(w, -len);
                        ctx.lineTo(-w, -len*0.75);
                        ctx.closePath();
                        ctx.fill();
                        // subtle outline for readability
                        ctx.strokeStyle = 'rgba(100,240,170,0.92)';
                        ctx.lineWidth = Math.max(2.2, w*0.24);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // BIG EKG spike overlay: larger and brighter glyph
                    if (((flags[i] & FLAG.EKG) || (meta && meta.ekgWave)) && meta && meta._ekgBigVis > 0 && !(meta && meta._diarrheaBrown)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const len = Math.max(46, r * 6.4);
                        const w = Math.max(4.8, r * 1.10);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const grd = ctx.createLinearGradient(0, -len, 0, 0);
                        grd.addColorStop(0, 'rgba(160,255,215,1.0)');
                        grd.addColorStop(1, 'rgba(160,255,215,0.28)');
                        ctx.fillStyle = grd;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(w, -len);
                        ctx.lineTo(-w, -len*0.86);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(120,255,190,0.98)';
                        ctx.lineWidth = Math.max(2.8, w*0.26);
                        ctx.stroke();
                        // Small inner core line to sell the sharp peak
                        ctx.strokeStyle = 'rgba(255,255,255,0.80)';
                        ctx.lineWidth = Math.max(1.8, w*0.16);
                        ctx.beginPath();
                        ctx.moveTo(0, -len*0.97);
                        ctx.lineTo(0, -len*0.60);
                        ctx.stroke();
                        ctx.restore();
                    }
                    // Special beam rendering: draw elongated capsule along velocity
                    if (meta && meta.beam) {
                        const sp = Math.hypot(vx[i], vy[i]) || 0.0001; const fx=vx[i]/sp, fy=vy[i]/sp;
                        const isScribble = !!(meta && meta.scribble);
                        const treatAsParticle = !!(meta && meta.particleBeam) && !isScribble;
                        const len = treatAsParticle ? 42 : 56; const core = treatAsParticle ? Math.max(6, r+2) : Math.max(4, r);
                        const reduce = !!(game.fxFlags && game.fxFlags.reduceBeams);
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(Math.atan2(fy, fx));
                        // outer glow
                        const glowAlpha = reduce ? 0.12 : 0.20;
                        const isEnemyBeam = !!meta.enemy;
                        // particle beams keep their warm palette; enemy beams use a red palette; others keep cyan/blue
                        ctx.fillStyle = treatAsParticle ? `rgba(255,200,80,${glowAlpha})` : (isScribble ? `rgba(255,70,100,${glowAlpha})` : (isEnemyBeam ? `rgba(255,120,120,${glowAlpha})` : `rgba(120,220,255,${glowAlpha})`));
                        const glowH = core * (reduce ? 1.4 : 1.9);
                        ctx.fillRect(0, -core*0.70, len, glowH);
                        // inner core
                        let coreColor;
                        if (treatAsParticle) coreColor = '#FFD466';
                        else if (isScribble) coreColor = meta.scribbleLocked ? '#FF1A33' : '#FF4F5B';
                        else if (isEnemyBeam) coreColor = '#FF4444';
                        else coreColor = '#B3EEFF';
                        ctx.fillStyle = coreColor;
                        const coreH = core * (reduce ? 0.8 : 1.1);
                        ctx.fillRect(0, -coreH*0.5, len, coreH);
                        // Laser heat gradient accents (non-particle beams): subtle hot spots along beam
                        if (!treatAsParticle || isScribble) {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            ctx.globalCompositeOperation = 'lighter';
                            if (lowFx || reduce) {
                                // Simple linear gradient overlay across beam height
                                const lg = ctx.createLinearGradient(0, -core, 0, core);
                                const g0 = reduce ? 0.04 : 0.06;
                                const g1 = reduce ? 0.12 : 0.18;
                                lg.addColorStop(0, `rgba(255,255,255,${g0})`);
                                lg.addColorStop(0.5, `rgba(255,255,255,${g1})`);
                                lg.addColorStop(1, `rgba(255,255,255,${g0})`);
                                ctx.fillStyle = lg;
                                ctx.fillRect(0, -core, len, core*2);
                            } else {
                                // A few small radial "hot cores" that flicker slightly
                                const t = performance.now() * 0.002;
                                const hotspots = reduce ? 2 : 4;
                                for (let h=0; h<hotspots; h++) {
                                    const frac = (h + 0.5) / hotspots;
                                    const hx = frac * len;
                                    const pulse = 0.8 + 0.2 * Math.sin(t + h*1.7);
                                    const rr = core * ((reduce?0.28:0.35) + 0.15 * pulse);
                                    const g = ctx.createRadialGradient(hx, 0, rr*0.15, hx, 0, rr);
                                    g.addColorStop(0, 'rgba(255,255,255,0.28)');
                                    if (isScribble) {
                                        g.addColorStop(0.5, `rgba(255,90,115,${reduce?0.14:0.21})`);
                                        g.addColorStop(1, 'rgba(255,70,100,0)');
                                    } else if (isEnemyBeam) {
                                        g.addColorStop(0.5, `rgba(255,150,150,${reduce?0.12:0.18})`);
                                        g.addColorStop(1, 'rgba(255,120,120,0)');
                                    } else {
                                        g.addColorStop(0.5, `rgba(170,235,255,${reduce?0.12:0.18})`);
                                        g.addColorStop(1, 'rgba(170,235,255,0)');
                                    }
                                    ctx.fillStyle = g;
                                    ctx.beginPath(); ctx.arc(hx, 0, rr, 0, Math.PI*2); ctx.fill();
                                }
                            }
                        }
                        ctx.restore();
                        continue;
                    }
                    // Diarrhea: always brown; render using sprite if available, else fallback to ellipse
                    if (meta && meta._diarrheaBrown) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const img = window._bulletImages && window._bulletImages.diarrhea;
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Base size derived from radius; slight forward stretch
                            const base = Math.max(14, r * 2.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                            let w = base * 1.15; let h = w / aspect;
                            // Draw centered, pointing forward
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w*0.15, -h/2, w, h);
                        } else {
                            // Fallback brown ellipse
                            const stretch = Math.max(1.0, Math.min(1.8, r * 0.12 + 1.0));
                            ctx.fillStyle = '#8B4513';
                            const rx = Math.max(4, r * stretch);
                            const ry = Math.max(3, r * 0.85);
                            ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2); ctx.fill();
                            ctx.fillStyle = '#6F3A11';
                            ctx.beginPath(); ctx.ellipse(-rx*0.12, 0, rx*0.55, ry*0.55, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Popcorn puff sprite (SoA) – draw if metadata marks this projectile as a puff
                    if (meta && meta.popcornPuff) {
                        const ang = (meta._puffSpin||0);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const img = window._bulletImages && window._bulletImages.popcorn;
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(14, r * 2.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                            let w = base; let h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w/2, -h/2, w, h);
                        } else {
                            // Fallback vector puff
                            const rr = Math.max(6, r * 0.9);
                            ctx.fillStyle = '#FFF9D6';
                            for (let l=0;l<5;l++) {
                                const a = l/5 * Math.PI*2;
                                const lr = rr * (0.55 + ((l%2)*0.15));
                                const lx = Math.cos(a)*rr*0.55;
                                const ly = Math.sin(a)*rr*0.55;
                                ctx.beginPath(); ctx.arc(lx, ly, lr, 0, Math.PI*2); ctx.fill();
                            }
                            ctx.fillStyle = 'rgba(255,180,60,0.35)';
                            ctx.beginPath(); ctx.arc(-rr*0.15, -rr*0.1, rr*0.65, 0, Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#E8D490'; ctx.lineWidth = 1.2;
                            ctx.beginPath(); ctx.arc(0,0,rr*0.95,0,Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Sword throw: sprite-based; points blade-first (no spin)
                    if (meta && meta.weaponType === 'sword') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.sword;
                        ctx.save(); ctx.translate(cx, cy); if (isFinite(ang)) ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(20, r * 3.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            // Slight forward offset so the blade tip leads
                            ctx.drawImage(img, -drawW * 0.05, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to previous vector sword if sprite not ready
                            const bladeLen = Math.max(18, r * 3.0);
                            const bladeW = Math.max(3, r * 0.5);
                            ctx.fillStyle = '#E6EEF8';
                            ctx.fillRect(0, -bladeW*0.5, bladeLen, bladeW);
                            ctx.fillStyle = '#C9D6E8';
                            ctx.fillRect(0, -bladeW*0.5, bladeLen, Math.max(1, bladeW*0.18));
                            ctx.beginPath();
                            ctx.moveTo(bladeLen, -bladeW*0.5);
                            ctx.lineTo(bladeLen + bladeW*0.9, 0);
                            ctx.lineTo(bladeLen, bladeW*0.5);
                            ctx.closePath();
                            ctx.fillStyle = '#F2F7FF';
                            ctx.fill();
                            const guardW = bladeW * 2.2; const guardH = Math.max(2, bladeW * 0.5);
                            ctx.fillStyle = '#C89B3C';
                            ctx.fillRect(-bladeW*0.4, -guardH*0.5, guardW, guardH);
                            const gripLen = bladeW * 1.8; ctx.fillStyle = '#6B4E28';
                            ctx.fillRect(-bladeW*0.4 - gripLen, -bladeW*0.25, gripLen, Math.max(2, bladeW*0.5));
                            ctx.fillStyle = '#C89B3C'; ctx.beginPath();
                            ctx.arc(-bladeW*0.4 - gripLen - bladeW*0.2, 0, Math.max(1.5, bladeW*0.3), 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Toenail Clibbins: sprite-based rendering
                    if (meta && (meta.weaponType === 'toenail' || meta.toenail)) {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const spin = meta && typeof meta._toeSpin === 'number' ? meta._toeSpin : 0;
                        const img = window._bulletImages && window._bulletImages.toenail;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + spin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Scale sprite by projectile radius; tune multipliers to taste
                            const baseSize = Math.max(14, r * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight;
                            const aspect = iw / ih;
                            let drawW = baseSize;
                            let drawH = baseSize / aspect;
                            // Slight stretch along travel to accent motion
                            drawW *= 1.05;
                            // Draw centered, pointing forward (rotate already applied)
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW * 0.1, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to vector crescent if image not ready
                            const baseR = Math.max(8, r * 1.2);
                            const innerR = baseR * 0.55;
                            const arcSweep = Math.PI * 1.05;
                            const cutX = baseR * 0.38;
                            ctx.beginPath();
                            const startA = -arcSweep/2; const endA = arcSweep/2;
                            ctx.arc(0,0,baseR,startA,endA,false);
                            ctx.arc(cutX,0, innerR, endA, startA, true);
                            ctx.closePath();
                            const grad = ctx.createLinearGradient(-baseR, -baseR, baseR, baseR);
                            grad.addColorStop(0,'#FFF8D7');
                            grad.addColorStop(0.45,'#FFE684');
                            grad.addColorStop(0.8,'#F3D266');
                            grad.addColorStop(1,'#D8B850');
                            ctx.fillStyle = grad; ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Dagger: short triangular blade + small guard and grip
                    if (meta && meta.weaponType === 'dagger') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const bladeLen = Math.max(12, r * 2.2);
                        const bladeW = Math.max(2, r * 0.45);
                        ctx.fillStyle = '#F1F6FF';
                        ctx.beginPath();
                        ctx.moveTo(0, -bladeW*0.5);
                        ctx.lineTo(bladeLen, 0);
                        ctx.lineTo(0, bladeW*0.5);
                        ctx.closePath(); ctx.fill();
                        // Tiny cross-guard
                        ctx.fillStyle = '#B3954A';
                        ctx.fillRect(-bladeW*0.25, -bladeW*0.35, bladeW*1.2, bladeW*0.7);
                        // Grip
                        const gripLen = bladeW * 1.2;
                        ctx.fillStyle = '#5A3E20';
                        ctx.fillRect(-bladeW*0.25 - gripLen, -bladeW*0.25, gripLen, bladeW*0.5);
                        ctx.restore();
                        continue;
                    }
                    // Drill: spinning bit with ring and motion streaks
                    // Only render the full drill sprite when weaponType is explicitly 'drill'.
                    // If meta.drilling is true but another weaponType is set (e.g., bread),
                    // we skip this replacement and add a light overlay after that weapon's draw.
                    if (meta && meta.weaponType === 'drill') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const phase = meta._drillPhase || 0;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                            // Can body — reuse chest variant spec for consistent irradiated visuals
                            const spec = CHEST_VARIANT_SPECS['irradiated'];
                        ctx.fillStyle = '#B8C7E0';
                        ctx.beginPath(); ctx.ellipse(0, 0, r*0.9, r*0.6, 0, 0, Math.PI*2); ctx.fill();
                        // dark tip wedge
                        ctx.fillStyle = '#6E7A8C';
                            const g = ctx.createLinearGradient(-12, -10, 12, 12);
                            g.addColorStop(0, spec.top);
                            g.addColorStop(0.5, spec.mid);
                            g.addColorStop(1, spec.bot);
                            ctx.fillStyle = g;
                        // rotating ring
                        const ringR = r*1.2; const wob = Math.sin(phase)*0.4;
                            ctx.fillStyle = spec.handle;
                        ctx.beginPath(); ctx.ellipse(-r*0.2, 0, ringR*0.95, ringR*0.55, wob, 0, Math.PI*2); ctx.stroke();
                        // motion streaks behind
                        ctx.strokeStyle = 'rgba(160,190,235,0.7)'; ctx.lineWidth = Math.max(1, r*0.14);
                        ctx.beginPath();
                        ctx.moveTo(-r*1.0, -r*0.7);
                        ctx.lineTo(-r*2.0, -r*0.2);
                        ctx.moveTo(-r*1.0,  r*0.7);
                        ctx.lineTo(-r*2.0,  r*0.2);
                        ctx.stroke();
                        ctx.restore();
                        continue;
                    }
                    // Drilling overlay (non-replacing): if drilling flag is set but another weaponType already rendered,
                    // add a faint rotating ring and occasional spark to suggest drilling without changing the sprite.
                    if (meta && meta.drilling && meta.weaponType && meta.weaponType !== 'drill') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const phase = meta._drillPhase || 0;
                        // faint ring around the projectile
                        ctx.save();
                        ctx.translate(cx, cy);
                        const rr = Math.max(10, r * 1.0);
                        ctx.rotate(ang + phase*0.15);
                        ctx.strokeStyle = 'rgba(190,220,255,0.35)';
                        ctx.lineWidth = Math.max(1, r*0.12);
                        ctx.beginPath(); ctx.ellipse(0, 0, rr*0.95, rr*0.60, 0.25*Math.sin(phase*0.5), 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                        // occasional back-spark
                        if (!(game.perf && game.perf.lowFx) && Math.random() < 0.18) {
                            const bx = cx - Math.cos(ang) * Math.max(4, r*0.6);
                            const by = cy - Math.sin(ang) * Math.max(4, r*0.6);
                            addParticle(bx + (Math.random()-0.5)*3, by + (Math.random()-0.5)*3, '#D0E4FF','spark');
                        }
                        // do not continue; allow other overlays to run
                    }
                    // Spear: long shaft with metal tip and small rear feather
                    if (meta && meta.weaponType === 'spear') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        const shaftLen = Math.max(26, r * 3.6);
                        const shaftW = Math.max(2, r * 0.35);
                        // Shaft
                        ctx.fillStyle = '#8B5E3B';
                        ctx.fillRect(-shaftLen*0.6, -shaftW*0.5, shaftLen, shaftW);
                        // Metal tip
                        ctx.fillStyle = '#DDE6F2';
                        ctx.beginPath();
                        ctx.moveTo(shaftLen*0.4, -shaftW*0.7);
                        ctx.lineTo(shaftLen*0.7, 0);
                        ctx.lineTo(shaftLen*0.4, shaftW*0.7);
                        ctx.closePath(); ctx.fill();
                        // Rear feather
                        ctx.fillStyle = 'rgba(255,240,180,0.9)';
                        ctx.beginPath();
                        ctx.moveTo(-shaftLen*0.6, 0);
                        ctx.lineTo(-shaftLen*0.75, -shaftW*1.0);
                        ctx.lineTo(-shaftLen*0.45, 0);
                        ctx.lineTo(-shaftLen*0.75, shaftW*1.0);
                        ctx.closePath(); ctx.fill();
                        ctx.restore();
                        continue;
                    }
                    // Axe: sprite-based; spins as it flies
                    if (meta && meta.weaponType === 'axe') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.axe;
                        // Maintain a spin angle on meta
                        if (typeof meta._axeSpin !== 'number') meta._axeSpin = 0;
                        const spinSpeed = meta._axeSpinSpeed || (0.22 + Math.min(0.18, (r||8) * 0.01));
                        meta._axeSpin += spinSpeed;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + meta._axeSpin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(22, r * 3.0);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to previous vector axe if sprite not ready
                            const handleLen = Math.max(20, r * 3.0);
                            const handleW = Math.max(2, r * 0.35);
                            ctx.strokeStyle = '#8B5A2B'; ctx.lineWidth = handleW; ctx.lineCap = 'round';
                            ctx.beginPath(); ctx.moveTo(-handleLen*0.6, 0); ctx.lineTo(handleLen*0.35, 0); ctx.stroke();
                            const headL = Math.max(10, r*1.2); const headH = Math.max(8, r*0.9);
                            ctx.fillStyle = '#D0D6E0'; ctx.beginPath();
                            ctx.moveTo(handleLen*0.2, -headH*0.7);
                            ctx.lineTo(handleLen*0.2 + headL*0.9, -headH*0.35);
                            ctx.lineTo(handleLen*0.2 + headL*0.9, headH*0.35);
                            ctx.lineTo(handleLen*0.2, headH*0.7);
                            ctx.lineTo(handleLen*0.12, 0); ctx.closePath(); ctx.fill();
                        }
                        ctx.restore();
                        continue;
                    }
                    // Hammer: sprite-based; spins as it flies
                    if (meta && meta.weaponType === 'hammer') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.hammer;
                        if (typeof meta._hammerSpin !== 'number') meta._hammerSpin = 0;
                        const spinSpeed = meta._hammerSpinSpeed || (0.18 + Math.min(0.16, (r||8) * 0.009));
                        meta._hammerSpin += spinSpeed;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + meta._hammerSpin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(22, r * 2.8);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback to previous vector hammer if sprite not ready
                            const handleLen = Math.max(18, r * 2.8);
                            const handleW = Math.max(2, r * 0.38);
                            ctx.strokeStyle = '#7B4A1A'; ctx.lineWidth = handleW; ctx.lineCap = 'round';
                            ctx.beginPath(); ctx.moveTo(-handleLen*0.6, 0); ctx.lineTo(handleLen*0.25, 0); ctx.stroke();
                            const headW = Math.max(12, r*1.4); const headH = Math.max(10, r*1.0);
                            ctx.fillStyle = '#BFC8D4'; ctx.fillRect(handleLen*0.10, -headH*0.5, headW, headH);
                            ctx.fillStyle = '#E6ECF4'; ctx.fillRect(handleLen*0.10, -headH*0.5, Math.max(4, headW*0.35), headH);
                        }
                        ctx.restore();
                        continue;
                    }
                    // Bread: sprite-based; spins as it flies (baguette)
                    if (meta && meta.weaponType === 'bread') {
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.bread;
                        if (typeof meta._breadSpin !== 'number') meta._breadSpin = 0;
                        // Slower spin for a weightier feel
                        const spinSpeed = meta._breadSpinSpeed || (0.11 + Math.min(0.10, (r||8) * 0.006));
                        meta._breadSpin += spinSpeed;
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang + meta._breadSpin);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            const base = Math.max(26, r * 3.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let drawW = base; let drawH = drawW / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                        } else {
                            // Fallback: elongated brown ellipse with lighter scoring lines
                            const stretch = Math.max(1.0, Math.min(2.0, r * 0.18 + 1.2));
                            const rx = Math.max(6, r * stretch);
                            const ry = Math.max(4, r * 0.6);
                            ctx.fillStyle = '#9C6B3E';
                            ctx.beginPath(); ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#D9B384'; ctx.lineWidth = Math.max(1, r*0.1);
                            ctx.beginPath();
                            ctx.moveTo(-rx*0.6, -ry*0.2); ctx.lineTo(rx*0.6, ry*0.2);
                            ctx.moveTo(-rx*0.6, 0); ctx.lineTo(rx*0.6, 0);
                            ctx.moveTo(-rx*0.6, ry*0.2); ctx.lineTo(rx*0.6, -ry*0.2);
                            ctx.stroke();
                        }
                        ctx.restore();
                        // Crumb trail: subtle dust puffs with warm bread color
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduce = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!lowFx && Math.random() < (reduce ? 0.06 : 0.12)) {
                            const bx = cx - Math.cos(ang) * (r * 0.6 + 4);
                            const by = cy - Math.sin(ang) * (r * 0.6 + 4);
                            const hue = 35 + Math.random()*8; // warm golden crumb
                            const col = `hsl(${hue}, 70%, ${70 + Math.random()*10}%)`;
                            addParticle(bx + (Math.random()-0.5)*3, by + (Math.random()-0.5)*3, col, 'dust');
                        }
                        continue;
                    }
                    // Antimatter aura overlay: dark core with bright rim (skip if Diarrhea to avoid color tint)
                    if (meta && meta.antimatter && !(meta && meta._diarrheaBrown)) {
                        ctx.save();
                        const inner = Math.max(1, r*0.6);
                        const g = ctx.createRadialGradient(cx, cy, inner*0.2, cx, cy, r*1.2);
                        g.addColorStop(0, 'rgba(10,10,10,0.95)');
                        g.addColorStop(0.6, 'rgba(40,0,60,0.35)');
                        g.addColorStop(1, 'rgba(160,100,240,0.25)');
                        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, r*1.2, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                    // Meteor custom rendering (rocky body + fiery trail)
                    if (meta && meta.meteor) {
                        // Ground reticle in final 350ms before impact (approx ~21 frames at 60fps)
                        if (typeof meta._meteorDetonateAt==='number' && typeof game.frame==='number') {
                            const framesLeft = meta._meteorDetonateAt - game.frame;
                            if (framesLeft <= 21 && framesLeft >= 0 && !(game.perf && game.perf.lowFx)) {
                                const aoe = meta._meteorAoeRadius || 80;
                                const t = 1 - framesLeft / 21; // 0 -> 1 as we approach impact
                                const alpha = 0.2 + 0.3 * t;
                                const rr = Math.max(aoe, r*1.2) * (0.95 + 0.1*Math.sin((21-framesLeft)/2));
                                ctx.save();
                                ctx.translate(meta._meteorTargetX || cx, meta._meteorTargetY || cy);
                                ctx.globalAlpha = Math.max(0, Math.min(0.6, alpha));
                                ctx.strokeStyle = '#FFCF40';
                                ctx.lineWidth = Math.max(2, aoe * 0.05);
                                ctx.beginPath(); ctx.arc(0, 0, rr, 0, Math.PI*2); ctx.stroke();
                                // Crosshair ticks
                                const tick = Math.max(6, aoe*0.15);
                                ctx.beginPath();
                                ctx.moveTo(-rr, 0); ctx.lineTo(-rr + tick, 0);
                                ctx.moveTo(rr, 0); ctx.lineTo(rr - tick, 0);
                                ctx.moveTo(0, -rr); ctx.lineTo(0, -rr + tick);
                                ctx.moveTo(0, rr); ctx.lineTo(0, rr - tick);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                        const ang = Math.atan2(vy[i], vx[i]);
                        const img = window._bulletImages && window._bulletImages.meteor;
                        const bodyR = Math.max(8, r * 1.4);
                        ctx.save(); ctx.translate(cx, cy); ctx.rotate(ang);
                        if (img && img._ok && img.complete && img.naturalWidth) {
                            // Draw meteor sprite with slight forward stretch
                            const base = Math.max(22, bodyR * 2.2);
                            const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih || 1;
                            let w = base * 1.05; let h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(img, -w*0.4, -h/2, w, h);
                        } else {
                            // Fallback: simple ellipse body if image not ready
                            ctx.fillStyle = '#6A5548';
                            ctx.beginPath(); ctx.ellipse(0, 0, bodyR*1.1, bodyR*0.85, 0, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                        // Optional ember particles behind
                        if (!(game.perf && game.perf.lowFx)) {
                            const emberChance = 0.5;
                            if (Math.random()<emberChance) addParticle(cx - Math.cos(ang)*bodyR*0.8 + (Math.random()-0.5)*6, cy - Math.sin(ang)*bodyR*0.8 + (Math.random()-0.5)*6, '#FFC064','spark');
                        }
                        continue;
                    }
                    // Default projectile: draw using plain bullet sprite if available; fallback to simple circle
                    {
                        let img = null;
                        let spriteKey = null;
                        try {
                            if (meta) {
                                if (meta.spriteKey) spriteKey = meta.spriteKey;
                                else if (meta.goldTooth) spriteKey = 'goldtooth';
                                else if (meta.laser) spriteKey = 'swanlaser';
                            }
                            if (spriteKey && window._bulletImages) {
                                img = window._bulletImages[spriteKey] || null;
                            }
                            if (spriteKey === 'goldtooth' && window._bulletImages && typeof window._bulletImages.loadGoldTooth === 'function') {
                                const gimg = window._bulletImages.goldtooth;
                                const needsLoad = !gimg || !gimg.src;
                                const already = meta ? meta._goldLoadRequested : window._bulletImages._goldRequested;
                                if (needsLoad && !already) {
                                    try { window._bulletImages.loadGoldTooth(); } catch(_){ }
                                    if (meta) meta._goldLoadRequested = true; else window._bulletImages._goldRequested = true;
                                }
                                if (!img) img = gimg || null;
                            }
                            if (!img) {
                                if (meta && meta.goldTooth) {
                                    const gimg = window._bulletImages && window._bulletImages.goldtooth;
                                    if (gimg && !gimg.src && typeof window._bulletImages.loadGoldTooth === 'function') {
                                        const already = meta ? meta._goldLoadRequested : window._bulletImages._goldRequested;
                                        if (!already) {
                                            try { window._bulletImages.loadGoldTooth(); } catch(_){ }
                                            if (meta) meta._goldLoadRequested = true; else window._bulletImages._goldRequested = true;
                                        }
                                    }
                                    img = gimg || (window._bulletImages && window._bulletImages.plain);
                                } else if (meta && meta.laser) {
                                    img = window._bulletImages && window._bulletImages.swanlaser;
                                } else if (spriteKey && window._bulletImages) {
                                    img = window._bulletImages[spriteKey] || null;
                                } else {
                                    img = window._bulletImages && window._bulletImages.plain;
                                }
                            }
                        } catch(_) { img = window._bulletImages && window._bulletImages.plain; }
                        if (img && (img._ok || (img.complete && img.naturalWidth))) {
                            const ang = Math.atan2(vy[i], vx[i]);
                            ctx.save();
                            ctx.translate(cx, cy);
                            // For gold tooth projectiles, add a slow spin on top of facing angle
                            if (meta && meta.goldTooth) {
                                if (typeof meta._goldSpin !== 'number') meta._goldSpin = Math.random() * Math.PI * 2;
                                if (typeof meta._goldSpinSpeed !== 'number') {
                                    const spd = Math.hypot(vx[i], vy[i]);
                                    meta._goldSpinSpeed = 0.18 + Math.min(0.22, Math.max(0, spd) * 0.035);
                                }
                                meta._goldSpin += meta._goldSpinSpeed;
                                if (meta._goldSpin > Math.PI * 2) meta._goldSpin -= Math.PI * 2;
                                const drawAng = (isFinite(ang) ? ang : 0) + meta._goldSpin;
                                if (isFinite(drawAng)) ctx.rotate(drawAng);
                            } else {
                                if (isFinite(ang)) ctx.rotate(ang);
                            }
                            // Scale sprite relative to projectile radius; make lasers and gold teeth larger for visibility
                            const base = (meta && meta.laser) ? Math.max(48, r * 3.5) : ((meta && meta.goldTooth) ? Math.max(28, r * 3.2) : Math.max(10, r * 2.0));
                            const iw = img.naturalWidth || 16, ih = img.naturalHeight || 8;
                            const aspect = iw / ih || 1;
                            // base width before stretching
                            let w = base * 1.25;
                            // Stretch proportionally to speed for laser projectiles (visually elongates as they accelerate)
                            const spImg = Math.hypot(vx[i], vy[i]) || 0.0001;
                            if (meta && meta.laser) {
                                // Stronger stretch so lasers feel long and visible; clamp to prevent runaway
                                const stretch = 1 + Math.min(8, spImg * 0.22);
                                w *= stretch;
                                // Ensure a hard minimum width for visibility (slightly reduced per request)
                                w = Math.max(w, 64);
                            }
                            let h = w / aspect;
                            // Expiry blink: fade and slight scale pulse in the last few frames of life (skip very high lifeMax like indestructibles)
                            const lm = lifeMax[i];
                            const lf = life[i];
                            let alpha = 1.0; let scalePulse = 1.0;
                            if (lm > 0 && lm < 10000 && lf <= Math.min(14, Math.floor(lm * 0.12))) {
                                const t = Math.max(0, lf) / Math.max(1, Math.min(14, Math.floor(lm * 0.12)));
                                // Blink faster as it nears zero
                                const blink = (Math.sin(((1-t)*10 + i*0.3)) * 0.5 + 0.5);
                                alpha = 0.55 + 0.45 * blink;
                                scalePulse = 1.0 + 0.12 * (1 - t) * blink;
                            }
                            // Growing shot soft aura: subtle glow proportional to radius growth flag
                            if (meta && meta.growing && !(game.perf && game.perf.lowFx)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.globalAlpha = 0.16;
                                const gr = Math.max(base*0.8, r*1.6);
                                const g = ctx.createRadialGradient(0,0,gr*0.25,0,0,gr);
                                g.addColorStop(0, 'rgba(255,220,160,0.55)');
                                g.addColorStop(1, 'rgba(255,220,160,0)');
                                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,gr,0,Math.PI*2); ctx.fill();
                                ctx.restore();
                            }
                            ctx.globalAlpha = Math.max(0.1, Math.min(1, alpha));
                            ctx.scale(scalePulse, scalePulse);
                            // Draw centered, pointing forward (+X after rotate)
                            ctx.imageSmoothingEnabled = true;
                            // Slight forward offset for laser sprite to feel directional
                            const forwardOffset = (meta && meta.laser) ? -w * 0.24 : -w * 0.1;
                            try {
                                if (meta && meta.laser) {
                                    // Mirror sprite horizontally so it visually points forward correctly
                                    ctx.scale(-1, 1);
                                    const foff = -forwardOffset; // flip because of horizontal scale
                                    ctx.drawImage(img, foff, -h/2, w, h);
                                } else {
                                    ctx.drawImage(img, forwardOffset, -h/2, w, h);
                                }
                            } catch(_) { /* drawImage may throw if image not ready */ }
                            // Pierce streak flash: quick forward chevron when _pierceFlash is active
                            if (meta && meta._pierceFlash > 0 && !(game.perf && game.perf.lowFx)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                const len = Math.max(10, r * 1.8);
                                const fade = meta._pierceFlash / 9;
                                ctx.strokeStyle = `rgba(170, 255, 220, ${ (0.6 * fade).toFixed(3) })`;
                                ctx.lineWidth = Math.max(1.2, r * 0.22);
                                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.stroke();
                                ctx.restore();
                            }
                            ctx.restore();
                            // Pierce-last-hit warning aura: faint ring when only one pierce remains
                            if (meta && meta._pierceWarn > 0 && !(game.perf && game.perf.lowFx)) {
                                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                if (!reduceRings) {
                                    const warnA = Math.min(0.85, meta._pierceWarn / 18);
                                    const rr = Math.max(12, r * 1.6);
                                    ctx.save();
                                    ctx.globalAlpha = 0.20 + 0.35 * warnA;
                                    ctx.strokeStyle = '#CFF8EE';
                                    ctx.lineWidth = Math.max(1.2, r * 0.20);
                                    ctx.beginPath(); ctx.arc(cx, cy, rr, 0, Math.PI*2); ctx.stroke();
                                    ctx.restore();
                                }
                            }
                            // Bounce oriented dust puff near impact side when _bounceFlash is active
                            if (meta && meta._bounceFlash > 0 && !(game.perf && game.perf.lowFx)) {
                                const nx = meta._bounceNx||0, ny = meta._bounceNy||0;
                                const off = Math.max(2, r*0.6);
                                const px = cx - nx * off; const py = cy - ny * off;
                                addParticle(px + (Math.random()-0.5)*2, py + (Math.random()-0.5)*2, '#E6F2FF', 'dust');
                            }
                            // Speed streaks for very fast shots (perf-aware)
                            const spVis = Math.hypot(vx[i], vy[i]);
                            if (spVis > 6.5 && !(game.perf && game.perf.lowFx)) {
                                ctx.save();
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.globalAlpha = Math.min(0.45, (spVis - 6.5) * 0.06);
                                const len = Math.min(28, 8 + (spVis - 6.5) * 3);
                                const wid = Math.max(1, r * 0.25);
                                const ang = Math.atan2(vy[i], vx[i]);
                                ctx.translate(cx, cy); ctx.rotate(ang + Math.PI); // point backward
                                ctx.strokeStyle = 'rgba(200,230,255,0.8)';
                                ctx.lineWidth = wid;
                                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.stroke();
                                ctx.restore();
                            }
                        } else {
                            // If this is a laser and no sprite is available, draw a bright elongated fallback streak
                            if (meta && meta.laser) {
                                const ang = Math.atan2(vy[i], vx[i]) || 0;
                                ctx.save();
                                ctx.translate(cx, cy);
                                ctx.rotate(ang);
                                // Make fallback markedly larger so it's clearly visible
                                const len = Math.max(120, (Math.hypot(vx[i], vy[i])||6) * 6);
                                const wid = Math.max(12, r * 2.5);
                                // core
                                ctx.fillStyle = '#FF99EE';
                                ctx.beginPath(); ctx.ellipse(len*0.15, 0, len*0.36, wid, 0, 0, Math.PI*2); ctx.fill();
                                ctx.restore();
                            } else if (r <= 10){
                                const sImg = spriteCache[cIndex][r];
                                ctx.drawImage(sImg, cx - r, cy - r);
                            } else {
                                ctx.fillStyle = palette[cIndex];
                                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
                            }
                        }
                    }
                }
            }
            // Top-most pass: render enemy bullets bright red above all other scene elements
            function renderEnemyProjectilesTop(ctx){
                if (!ctx) return;
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                for (let i=0;i<MAX;i++){
                    if (!alive[i]) continue;
                    const meta = game._projMeta && game._projMeta.get(i);
                    if (!meta || !meta.enemy) continue;
                    // Skip beam projectiles here — beams have their own elongated rendering earlier
                    if (meta && meta.beam) continue;
                    // If an explicit sprite key is present (e.g. Golden Goose gold tooth), render it here instead of the red orb
                    if (meta && (meta.spriteKey || meta.goldTooth)) {
                        let spriteKey = meta.spriteKey || null;
                        if (!spriteKey && meta.goldTooth) spriteKey = 'goldtooth';
                        let img = null;
                        if (spriteKey && window._bulletImages) {
                            img = window._bulletImages[spriteKey] || null;
                        }
                        if (spriteKey === 'goldtooth' && window._bulletImages && typeof window._bulletImages.loadGoldTooth === 'function') {
                            const gimg = window._bulletImages.goldtooth;
                            const needsLoad = !gimg || !gimg.src;
                            const already = meta ? meta._goldLoadRequested : window._bulletImages._goldRequested;
                            if (needsLoad && !already) {
                                try { window._bulletImages.loadGoldTooth(); } catch(_){ }
                                if (meta) meta._goldLoadRequested = true; else window._bulletImages._goldRequested = true;
                            }
                            if (!img) img = gimg || null;
                        }
                        if (img && (img._ok || (img.complete && img.naturalWidth))) {
                            const cx = x[i], cy = y[i];
                            ctx.save();
                            ctx.translate(cx, cy);
                            let drawAngBase = Math.atan2(vy[i], vx[i]);
                            if (meta && meta.goldTooth) {
                                if (typeof meta._goldSpin !== 'number') meta._goldSpin = Math.random() * Math.PI * 2;
                                if (typeof meta._goldSpinSpeed !== 'number') {
                                    const spd = Math.hypot(vx[i], vy[i]);
                                    meta._goldSpinSpeed = 0.18 + Math.min(0.22, Math.max(0, spd) * 0.035);
                                }
                                if (typeof meta._goldSpinSpeed === 'number') {
                                    meta._goldSpin += meta._goldSpinSpeed;
                                    if (meta._goldSpin > Math.PI * 2) meta._goldSpin -= Math.PI * 2;
                                }
                            }
                            if (!isFinite(drawAngBase)) drawAngBase = 0;
                            if (meta && meta.goldTooth) {
                                const spin = (typeof meta._goldSpin === 'number') ? meta._goldSpin : 0;
                                ctx.rotate(drawAngBase + spin);
                            } else if (isFinite(drawAngBase)) {
                                ctx.rotate(drawAngBase);
                            }
                            const rad = Math.max(1, radius[i] || 1);
                            const base = (meta && meta.laser) ? Math.max(48, rad * 3.5) : ((meta && meta.goldTooth) ? Math.max(28, rad * 3.2) : Math.max(10, rad * 2.0));
                            const iw = img.naturalWidth || 16;
                            const ih = img.naturalHeight || 8;
                            const aspect = iw / ih || 1;
                            let w = base * 1.25;
                            if (meta && meta.laser) {
                                const spImg = Math.hypot(vx[i], vy[i]) || 0.0001;
                                const stretch = 1 + Math.min(8, spImg * 0.22);
                                w *= stretch;
                                w = Math.max(w, 64);
                            }
                            let h = w / aspect;
                            ctx.imageSmoothingEnabled = true;
                            const forwardOffset = (meta && meta.laser) ? -w * 0.24 : -w * 0.1;
                            try {
                                if (meta && meta.laser) {
                                    ctx.scale(-1, 1);
                                    const foff = -forwardOffset;
                                    ctx.drawImage(img, foff, -h/2, w, h);
                                } else {
                                    ctx.drawImage(img, forwardOffset, -h/2, w, h);
                                }
                            } catch(_) {}
                            ctx.restore();
                            continue;
                        }
                    }
                    // If this is an Act III swan laser, render its sprite on the top-most layer so it's always visible
                    if (meta && meta.laser) {
                        try {
                            const img = window._bulletImages && window._bulletImages.swanlaser;
                            if (img && (img._ok || (img.complete && img.naturalWidth))) {
                                const cx = x[i], cy = y[i];
                                const ang = Math.atan2(vy[i], vx[i]);
                                const sp = Math.hypot(vx[i], vy[i]) || 1;
                                const iw = img.naturalWidth || 16, ih = img.naturalHeight || 8;
                                const aspect = iw / ih || 1;
                                // Determine draw width from speed and base radius so it stretches as it accelerates
                                // Increased base and multipliers to make Act III lasers much larger and highly visible
                                // Slightly reduced size per request
                                const drawW = Math.max(80, Math.min( (sp * 6) + (radius[i]||6) * 3, 1536 ));
                                const drawH = drawW / aspect;
                                ctx.save();
                                ctx.translate(cx, cy);
                                if (isFinite(ang)) ctx.rotate(ang);
                                // Draw normally (no additive glow) so the sprite reads clearly above other effects
                                ctx.globalCompositeOperation = 'source-over';
                                // Draw sprite centered, pointing forward (+X after rotate) with a nose offset
                                // Increase base size so lasers are visually larger
                                const forwardOffset = -drawW * 0.22;
                                try {
                                    // Mirror horizontally so sprite faces correctly
                                    ctx.scale(-1, 1);
                                    const foff = -forwardOffset;
                                    ctx.drawImage(img, foff, -drawH/2, drawW, drawH);
                                } catch(_) {}
                                ctx.restore();
                                // Skip the default red core rendering for this projectile
                                continue;
                            }
                        } catch(_) {}
                    }
                    const cx = x[i], cy = y[i];
                    const baseR = Math.max(2, radius[i] || 3);
                    // Inflate visual size for readability without touching collision radius
                    const drawR = Math.max(7, baseR + 4);
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const glowR = drawR * (lowFx || game.potatoMode ? 1.6 : 2.2);
                    // Outer glow (lighter composite) — soft, wide red bloom
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const g = ctx.createRadialGradient(cx, cy, drawR*0.2, cx, cy, glowR);
                    g.addColorStop(0, 'rgba(255, 80, 80, 0.65)');
                    g.addColorStop(0.6, 'rgba(255, 40, 40, 0.25)');
                    g.addColorStop(1, 'rgba(255, 20, 20, 0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                    // Core bright red body
                    ctx.fillStyle = '#FF2A2A';
                    ctx.beginPath(); ctx.arc(cx, cy, drawR, 0, Math.PI*2); ctx.fill();
                    // Small hot core highlight to pop against busy backgrounds
                    if (!lowFx) {
                        ctx.fillStyle = 'rgba(255,255,255,0.30)';
                        ctx.beginPath(); ctx.arc(cx, cy, Math.max(1.5, drawR * 0.35), 0, Math.PI*2); ctx.fill();
                    }
                    // Thin dark outline for contrast
                    ctx.strokeStyle = '#300000';
                    ctx.lineWidth = Math.max(1, Math.min(2.5, drawR * 0.22));
                    ctx.beginPath(); ctx.arc(cx, cy, Math.max(1, drawR - ctx.lineWidth*0.5), 0, Math.PI*2); ctx.stroke();
                }
                ctx.restore();
            }
            // Legacy compatibility proxy removed: direct object iteration deprecated.
            // Provide defensive getter that logs once (optional) to help catch stale uses.
            let _projWarned = false;
            Object.defineProperty(game, 'projectiles', {
                get(){
                    if (!_projWarned) { _projWarned = true; console.warn('[SoA] game.projectiles proxy removed – migrate logic to SoA arrays or metadata.'); }
                    return [];
                },
                set(v){}
            });
            game._markProjectilesDirty = ()=>{};
            game.spawnProjectile = (t)=>{ 
                        const idx = spawnProjectile(t); 
                // Attach basic metadata for element typing so render/logic can query it reliably
                try {
                    if (idx >= 0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        let m = game._projMeta.get(idx);
                        if (!m) { m = {}; game._projMeta.set(idx, m); }
                        if (t) {
                                    if (gg && gg.image && (!gg.image.src || !gg.image.src.includes('goldengoose-sheet.png'))) {
                                        try { gg.image.src = 'assets/geese/goldengoose-sheet.png'; console.info('[GoldenGooseSprite][spawn] set existing image.src to assets/geese/goldengoose-sheet.png'); } catch(_){ }
                                if (t.damageType === 'void') m._isVoid = true;
                                if (t.damageType === 'shadow') m._isShadow = true;
                            }
                            if (t.energyType) {
                                m.energyType = t.energyType;
                                if (t.energyType === 'void') m._isVoid = true;
                                if (t.energyType === 'shadow') m._isShadow = true;
                            }
                            if (t.spriteKey) m.spriteKey = t.spriteKey;
                            if (t.goldTooth) m.goldTooth = true;
                            if (t.laser) m.laser = true;
                            if (t.beam) m.beam = true;
                            if (t.weakHoming) m.weakHoming = true;
                            if (t.bouncing) m.bouncing = true;
                            if (typeof t.bounces === 'number') m.bounces = t.bounces;
                            if (t.owner) m.owner = t.owner;
                        }
                    }
                } catch(_) {}
                // Spawn-time standardized elemental cue (perf-aware) + Void-specific telegraph
                try {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                    const dmgType = t && (t.damageType || t.energyType);
                    const hex = getDamageTypeColor(dmgType) || null;
                    if (hex && !hideSparks) {
                        // small back-trail spark and optional faint ring
                        addParticle((t.x||0) - (t.vx||0)*0.5, (t.y||0) - (t.vy||0)*0.5, hex, 'spark');
                        if (!lowFx && !reduceRings) addParticle((t.x||0), (t.y||0), hex, 'ring');
                    }
                    // Distinct Void spawn flash: brief ringFlash/lensing pulse
                    if (dmgType === 'void') {
                        const col = getDamageTypeColor('void') || '#8844AA';
                        // Favor transient effect if available and not heavily reduced
                        if (typeof addTransientEffect === 'function' && !lowFx && !reduceRings) {
                            const baseR = Math.max(10, (t.r || t.radius || t.size || 6) * 1.8);
                            addTransientEffect({ type:'ringFlash', x:(t.x||0), y:(t.y||0), color: col, radius: baseR, life: 120 });
                        } else if (!reduceRings) {
                            addParticle((t.x||0), (t.y||0), col, 'ring');
                        }
                    }
                    // Distinct Shadow spawn flash: darker pulse to differentiate from Void
                    if (dmgType === 'shadow') {
                        const col = getDamageTypeColor('shadow') || '#AA66FF';
                        if (typeof addTransientEffect === 'function' && !lowFx && !reduceRings) {
                            const baseR = Math.max(10, (t.r || t.radius || t.size || 6) * 1.6);
                            addTransientEffect({ type:'ringFlash', x:(t.x||0), y:(t.y||0), color: col, radius: baseR, life: 110 });
                        } else if (!reduceRings) {
                            addParticle((t.x||0), (t.y||0), col, 'ring');
                        }
                    }
                } catch(_) {}
                game._markProjectilesDirty(); 
                // Debug: log spawn result (helps detect pool exhaustion or missing metadata)
                try {
                    if (typeof console !== 'undefined') {
                        if (idx < 0) {
                            // spawn failed, pool full or invalid params
                        }
                            } else {
                                try {
                                    const gg = game.enemySprites.goldengoose;
                                    // If an image src already exists (including blob: or data: URLs), don't overwrite it.
                                    // Overwriting can replace a valid blob/data fallback with a plain asset path
                                    // which may trigger unintended fallback behavior. Only set src when absent.
                                    if (gg && gg.image && !gg.image.src) {
                                        try { gg.image.src = 'assets/geese/goldengoose-sheet.png'; } catch(_){ }
                                    }
                                } catch(_){ }
                            }
                } catch(_) {}
                return idx; 
            };
            game.recycleProjectile = (objOrIndex)=>{ const idx = (typeof objOrIndex === 'number')? objOrIndex : objOrIndex._i; recycle(idx); game._markProjectilesDirty(); };
            game.updateProjectilesSoA = updateProjectiles;
            game.renderProjectilesSoA = renderProjectiles;
            game.renderEnemyProjectilesTop = renderEnemyProjectilesTop;
            // --- Spatial Hash (shared for projectiles & enemies) ---
            const HASH_CELL = 64; // tune later
            game._spatial = { buckets:new Map(), cell:HASH_CELL };
            function hashKey(cx,cy){ return (cx<<16) ^ cy; }
            function rebuildProjectileHash(){
                const buckets = game._spatial.buckets; buckets.clear();
                for (let i=0;i<MAX;i++) if (alive[i]) {
                    const cx = (x[i]/HASH_CELL)|0; const cy = (y[i]/HASH_CELL)|0;
                    const key = hashKey(cx,cy);
                    let arr = buckets.get(key); if (!arr){ arr = []; buckets.set(key,arr);} 
                    arr.push(i);
                }
            }
            game.rebuildProjectileHash = rebuildProjectileHash;
            game.queryProjectilesRadius = function(qx,qy,r,out){
                out = out || [];
                const cellR = ((r/HASH_CELL)|0)+1;
                const baseCx = (qx/HASH_CELL)|0; const baseCy = (qy/HASH_CELL)|0;
                const r2 = r*r;
                for (let cyOff=-cellR; cyOff<=cellR; cyOff++){
                    for (let cxOff=-cellR; cxOff<=cellR; cxOff++){
                        const key = hashKey(baseCx+cxOff, baseCy+cyOff);
                        const bucket = game._spatial.buckets.get(key); if (!bucket) continue;
                        for (let b=0;b<bucket.length;b++){ const i=bucket[b];
                            const dx = x[i]-qx; const dy = y[i]-qy; if (dx*dx+dy*dy<=r2) out.push(i);
                        }
                    }
                }
                return out;
            };
            // Hook hash rebuild after projectile update (lightweight; can throttle later)
            const prevUpdate = game.updateProjectilesSoA;
            let _hashFrameToggle = 0;
            game.updateProjectilesSoA = function(dt){
                prevUpdate(dt);
                // Adaptive hash rebuild throttling: if projectile count is modest, rebuild every other frame.
                const active = game.projectilePool.active();
                if (active < 400) {
                    _hashFrameToggle ^= 1;
                    if (_hashFrameToggle) return; // skip this frame
                } else if (active < 1200) {
                    // Rebuild 2/3 frames: skip 1 in 3
                    _hashFrameToggle = (_hashFrameToggle + 1) % 3;
                    if (_hashFrameToggle === 0) return;
                }
                rebuildProjectileHash();
            };
            // High-performance iteration helper (avoids proxy object creation)
            game.eachProjectile = function(cb){
                for (let i=0;i<MAX;i++) if (alive[i]) cb(i, x[i], y[i]);
            };
            game.getProjectileData = function(i){
                return { x:x[i], y:y[i], vx:vx[i], vy:vy[i], r:radius[i], life:life[i], damage:damage[i], flags:flags[i] };
            };
        })();
        // === End Projectile System Phase 2 ===
    // Expose globally so external debug or delayed handlers can access before start
    // [edit] write-verify: modified by automated patch at 2025-10-12T00:00:00Z
    window.game = game;

    // Unified guarded start to prevent double init / double RAF loops.
    game._started = false;
    game._loopStarted = false;
    function safeStartGame(source='manual') {
        if (game._started) return; // already started
        game._started = true;
        try { game._returningToTitle = false; game._titleMusicSuppressed = false; } catch(_){ }
        document.body.classList.remove('title-active');
        // Defensive: remove title overlay if still present (e.g., alternate start trigger)
        const to = document.getElementById('titleOverlay');
        if (to && to.parentElement) try { to.parentElement.removeChild(to); } catch(e) {}
        // Apply act-specific background choices (Act selection may set game._selectedAct)
        try { if (typeof applyActBackgrounds === 'function') applyActBackgrounds(); } catch(_){}
        if (!game._initComplete) {
            if (typeof init === 'function') init();
            try { game._initComplete = true; } catch(_){ }
        } else {
            try { resetGame(); } catch(_){ }
        }
        // Attempt music start (safe if already playing)
        ensureBackgroundMusic();
        // Title overlay removal (if still present)
        const existingTitle = document.getElementById('titleOverlay');
        if (existingTitle) existingTitle.parentElement.removeChild(existingTitle);
    // Game start event (source logged in debug builds)
    }
    // Removed auto-start watchdog so title screen persists until fire (space) pressed.

// Load stored audio prefs immediately so title screen & auto-start reflect choices
loadAudioPreferences();

// Persist selected act across sessions so restart/title flows honor the player's choice
function loadSelectedAct() {
    try {
        const v = localStorage.getItem('selected_act');
        if (v) {
            game._selectedAct = v;
            // Apply act-specific visuals & music now that act is known
            try { applyActBackgrounds(); } catch(_){}
            try { ensureActMusic(game._selectedAct); } catch(_){}
        }
    } catch(_) {}
}
function saveSelectedAct() {
    try {
        if (game && game._selectedAct) localStorage.setItem('selected_act', String(game._selectedAct));
        else localStorage.removeItem('selected_act');
        // If switching to Act II, ensure act music is applied. If switching away, clear act flag and swap back to default if needed.
        try {
            if (game && String(game._selectedAct) === 'II') {
                try { ensureActMusic('II'); } catch(_){}
            } else {
                try { game._actMusicSet = false; } catch(_){ }
                // If currently playing GooseGhetto but user chose another act, swap back to default
                try {
                    const cur = game && game.bgMusic && game.bgMusic.src ? String(game.bgMusic.src) : '';
                    if (cur && cur.includes('GooseGhetto')) {
                        try { if (game.bgMusic) { game._prevMusicSrc = game.bgMusic.src; try { game.bgMusic.pause(); } catch(_){} } } catch(_){ }
                        game.bgMusic = new Audio('assets/audio/QuackshotChronicles.mp3');
                        game.bgMusic.loop = true; game.bgMusic.volume = 0.55;
                        try { applyMusicPreference(); } catch(_){}
                        try { if (game.musicEnabled) game.bgMusic.play().catch(()=>{}); } catch(_){}
                    }
                } catch(_){}
            }
        } catch(_){}
    } catch(_) {}
}
// Immediately restore selected act before title overlay appears so ensureBackgroundMusic can respect it
try { loadSelectedAct(); } catch(_) {}

// ===== Input Preference Persistence (Gamepad) =====
function loadInputPreferences() {
    try {
        const gp = localStorage.getItem('pref_gamepad_enabled');
        const dz = localStorage.getItem('pref_gamepad_deadzone');
        if (gp !== null) game.input.gamepadEnabled = gp === '1';
        if (dz !== null) {
            const v = parseFloat(dz);
            if (isFinite(v)) game.input.gpDeadzone = Math.min(0.6, Math.max(0.05, v));
        }
        // Load optional manual mapping
        const mapStr = localStorage.getItem('pref_gp_map');
        if (mapStr) {
            try {
                const m = JSON.parse(mapStr);
                if (m && typeof m === 'object') game.input.gpMap = m;
            } catch(_) {}
        }

    } catch(_) {}
}
function saveInputPreferences() {
    try {
        localStorage.setItem('pref_gamepad_enabled', game.input.gamepadEnabled ? '1' : '0');
        localStorage.setItem('pref_gamepad_deadzone', String(game.input.gpDeadzone));
        if (game.input && game.input.gpMap) {
            try { localStorage.setItem('pref_gp_map', JSON.stringify(game.input.gpMap)); } catch(_) {}
        }
    } catch(_) {}
}
loadInputPreferences();

// ===== Gamepad: connect/disconnect + per-frame polling =====
window.addEventListener('gamepadconnected', (e)=>{
    // Prefer the first connected pad if none selected
    if (game && game.input && (game.input.gpIndex === null || game.input.gpIndex === undefined)) {
        game.input.gpIndex = e.gamepad.index;
    }
});
window.addEventListener('gamepaddisconnected', (e)=>{
    if (!game || !game.input) return;
    if (game.input.gpIndex === e.gamepad.index) {
        game.input.gpIndex = null;
        game.input.gpMove.x = game.input.gpMove.y = 0;
        game.input.gpAim.x = game.input.gpAim.y = 0;
        game.input.gpFire = false;
    }
});

function _applyDeadzone(ax, ay, deadzone) {
    // radial deadzone, then rescale to 0..1 beyond dz
    const mag = Math.hypot(ax, ay);
    if (mag < deadzone) return { x: 0, y: 0 };
    const n = (mag - deadzone) / (1 - deadzone);
    const scale = n / (mag || 1);
    return { x: ax * scale, y: ay * scale };
}

// ===== Manual Mapping Helpers =====
// Mapping entry format examples:
// { type:'button', index:0 } => button index
// { type:'axis', index:9, dir:'hat' } => POV hat axis, use __gp_hatToVec
// { type:'axis', index:6, threshold:0.5, sign:1 } => axis to digital (e.g., dpadRight)
// { type:'buttons', any:[0,1] } => pressed if any of listed
function __gp_mappingPressed(pad, entry) {
    try {
        if (!entry || !pad) return false;
        if (entry.any && Array.isArray(entry.any)) {
            return entry.any.some(e => __gp_mappingPressed(pad, e));
        }
        if (entry.type === 'button') {
            const i = entry.index|0; const b = pad.buttons && pad.buttons[i];
            return !!(b && (b.pressed || ((b.value||0) > 0.5)));
        }
        if (entry.type === 'axis') {
            const i = entry.index|0; const v = (pad.axes && typeof pad.axes[i] === 'number') ? pad.axes[i] : 0;
            if (entry.dir === 'hat') {
                const vec = __gp_hatToVec(v);
                if (!vec) return false;
                const want = entry.want || 'any'; // 'up','down','left','right','any'
                if (want === 'any') return (vec.x!==0 || vec.y!==0);
                if (want === 'up') return vec.y < 0;
                if (want === 'down') return vec.y > 0;
                if (want === 'left') return vec.x < 0;
                if (want === 'right') return vec.x > 0;
                return false;
            }
            const thr = (typeof entry.threshold==='number') ? Math.abs(entry.threshold) : 0.5;
            const sign = (entry.sign===-1)?-1:1;
            return sign>0 ? (v > thr) : (v < -thr);
        }
    } catch(_) {}
    return false;
}
function __gp_hatToVec(hat) {
    if (typeof hat !== 'number' || !isFinite(hat)) return null;
    // Ignore invalid range
    if (hat < -1.1 || hat > 1.1) return null;
    // Treat small as neutral
    if (Math.abs(hat) <= 0.08) return { x:0, y:0 };
    // Bin to 8-way values seen on Windows/Firefox
    const bins = [ -1.00, -0.71, -0.43, -0.14, 0.14, 0.43, 0.71, 1.00 ];
    const dir8 = [ [0,-1], [1,-1], [1,0], [1,1], [0,1], [-1,1], [-1,0], [-1,-1] ];
    const idx = bins.reduce((best, v, i) => (Math.abs(hat - v) < Math.abs(hat - bins[best]) ? i : best), 0);
    const v = dir8[idx] || [0,0];
    return { x: v[0], y: v[1] };
}

// Controller fixes applied 2025-10-10: D-Pad override, A-only fire, Start pause toggle, ignore stick clicks
function updateGamepadInput() {
    const inp = game.input;
    if (!inp || !inp.gamepadEnabled) return;
    const get = (navigator.getGamepads && navigator.getGamepads()) || [];
    let pad = null;
    if (inp.gpIndex != null && get[inp.gpIndex]) {
        pad = get[inp.gpIndex];
    }
    if (!pad) {
        // pick first connected standard-mapped pad
        for (let i=0;i<get.length;i++) { if (get[i] && get[i].connected) { pad = get[i]; inp.gpIndex = i; break; } }
    }
    if (!pad) return;
    // Axes: standard mapping: 0=LX,1=LY, 2=RX,3=RY
    const ax0 = pad.axes[0] || 0, ay0 = pad.axes[1] || 0;
    const ax1 = pad.axes[2] || 0, ay1 = pad.axes[3] || 0;
    const dz = Math.min(0.6, Math.max(0.05, inp.gpDeadzone||0.25));
    const mv = _applyDeadzone(ax0, ay0, dz);
    const av = _applyDeadzone(ax1, ay1, dz);
    // Clamp to [-1,1] to avoid rare >1 magnitudes from browser quirks
    function clamp1(v){ return v>1?1:(v<-1?-1:v); }
    mv.x = clamp1(mv.x); mv.y = clamp1(mv.y);
    av.x = clamp1(av.x); av.y = clamp1(av.y);
    // Some pads (e.g., MOGA XP5-A Plus) report right-stick Y as -1 at rest; treat this as invalid aim so movement can control facing
    if (Math.abs(av.x) < 0.2 && (Math.abs(av.y + 1) < 0.12 || Math.abs(av.y) > 0.98)) {
        // If aim appears pegged vertically with near-zero X, ignore it
        av.x = 0; av.y = 0;
    }
    inp.gpMove.x = mv.x; inp.gpMove.y = mv.y;
    inp.gpAim.x = av.x; inp.gpAim.y = av.y;
    // Buttons: 0=A, 1=B, 2=X, 3=Y, 4=LB, 5=RB, 6=LT, 7=RT, 8=Back, 9=Start, 10=LS, 11=RS
    const btn = (i)=>{ const b = pad.buttons[i]; return !!(b && (b.pressed || (b.value!=null && b.value>0.5))); };
    // Manual mapping support
    const map = (game.input && game.input.gpMap) || null;
    // Resolve D-Pad state either via mapping or fallbacks
    let dpx = 0, dpy = 0;
    if (map && (map.dpadUp || map.dpadDown || map.dpadLeft || map.dpadRight)) {
        const up = __gp_mappingPressed(pad, map.dpadUp);
        const down = __gp_mappingPressed(pad, map.dpadDown);
        const left = __gp_mappingPressed(pad, map.dpadLeft);
        const right = __gp_mappingPressed(pad, map.dpadRight);
        dpx = (right?1:0) - (left?1:0);
        dpy = (down?1:0) - (up?1:0);
    } else {
        // D-Pad digital movement (12=Up, 13=Down, 14=Left, 15=Right)
        const dUp = btn(12), dDown = btn(13), dLeft = btn(14), dRight = btn(15);
        dpx = (dRight?1:0) - (dLeft?1:0);
        dpy = (dDown?1:0) - (dUp?1:0);
    }
    // Fallback: D-Pad via POV "hat" (axis 9)
    if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length > 9) {
        const hat = pad.axes[9];
        const vec = __gp_hatToVec(hat);
        if (vec) { dpx = vec.x; dpy = vec.y; }
    }
    // Fallback 2: older/alt mappings use separate axes 6 (horizontal) and 7 (vertical) for the D-Pad
    if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length >= 8) {
        const dax = pad.axes[6] || 0, day = pad.axes[7] || 0;
        if (Math.abs(dax) > 0.5) dpx = dax > 0 ? 1 : -1;
        if (Math.abs(day) > 0.5) dpy = day > 0 ? 1 : -1; // +1 down, -1 up (matches standard)
    }
    if (dpx !== 0 || dpy !== 0) {
        // Override analog move when D-Pad is pressed for crisp digital control (no deadzone)
        inp.gpMove.x = dpx;
        inp.gpMove.y = dpy;
    }
    // Clamp tiny drift post-deadzone
    if (Math.abs(inp.gpMove.x) < 0.001) inp.gpMove.x = 0;
    if (Math.abs(inp.gpMove.y) < 0.001) inp.gpMove.y = 0;
    if (Math.abs(inp.gpAim.x) < 0.001) inp.gpAim.x = 0;
    if (Math.abs(inp.gpAim.y) < 0.001) inp.gpAim.y = 0;
    // Fire: manual mapping takes precedence; else A (0) only
    let fireNow = false;
    if (map && map.fire) fireNow = __gp_mappingPressed(pad, map.fire);
    else fireNow = btn(0);
    inp.gpFire = !!fireNow;
    // Start toggles pause on rising edge; ignore if a modal is open.
    // Also guard against triggers mistakenly toggling by checking their raw values and mapping.
    const trigBtnL = btn(6), trigBtnR = btn(7);
    const trigValL = (pad.buttons[6] && typeof pad.buttons[6].value === 'number') ? pad.buttons[6].value : 0;
    const trigValR = (pad.buttons[7] && typeof pad.buttons[7].value === 'number') ? pad.buttons[7].value : 0;
    const startNow = (map && map.pause) ? __gp_mappingPressed(pad, map.pause) : btn(9);
    const last = inp._lastButtons || {};
    if (startNow && !last.start && trigValL < 0.1 && trigValR < 0.1 && !trigBtnL && !trigBtnR) {
        const now = performance.now ? performance.now() : Date.now();
        if (!inp._lastStartAt || now - inp._lastStartAt > 250) {
            if (!(typeof isAnyAbilityModalOpen === 'function' && isAnyAbilityModalOpen())) {
                if (typeof togglePause === 'function') togglePause();
            }
            inp._lastStartAt = now;
        }
    }
    // Snapshot for edge detection; explicitly track LS/RS to filter accidental actions
    inp._lastButtons = {
        start: startNow,
        ls: btn(10),
        rs: btn(11),
        lt: trigBtnL,
        rt: trigBtnR
    };
}

// --- Permanent Ability System ---
function loadPermanentAbilities() {
    const saved = localStorage.getItem('permanentAbilities');
    if (saved) {
        try {
            const arr = JSON.parse(saved);
            if (Array.isArray(arr)) {
                // Migrate old ability name if present (legacy key: 'Goosey Grilla')
                try {
                    for (let i=0;i<arr.length;i++) {
                        if (arr[i] === 'Goosey Grilla') arr[i] = 'Gooster Teeth';
                    }
                } catch(_){}
                game.player.permanentAbilities = arr;
            }
        } catch (e) {}
    }
}

// Persisted seen-abilities helpers (remember which ability tooltips the player has viewed)
function saveSeenAbilities(){
    try {
        if (!game) return;
        try { if (!game._seenAbilitiesLoaded) ensureSeenAbilitiesLoaded(); } catch(_){ }
        if (!game.player || !game.player._seenAbilities) return;
        try { console.info('[SEEN_SAVE]', new Date().toISOString(), 'entries=', Object.keys(game.player._seenAbilities).length); } catch(_) {}
        localStorage.setItem('seenAbilities_v1', JSON.stringify(game.player._seenAbilities));
    } catch(_) {}
}

function loadSeenAbilities(){
    try {
        if (!game) return;
        // ensure player object exists
        game.player = game.player || { abilities: [], permanentAbilities: [], _seenAbilities: {} };
        const raw = localStorage.getItem('seenAbilities_v1');
        try { console.info('[SEEN_LOAD] raw_len=', raw ? raw.length : 0); } catch(_) {}
        if (!raw) {
            game.player._seenAbilities = game.player._seenAbilities || {};
            try { game._seenAbilitiesLoaded = true; } catch(_){ }
            return;
        }
        const obj = JSON.parse(raw);
        if (obj && typeof obj === 'object') {
            game.player._seenAbilities = game.player._seenAbilities || {};
            // Migrate legacy seen key from 'Goosey Grilla' to 'Gooster Teeth' if present
            try {
                if (obj['Goosey Grilla'] && !obj['Gooster Teeth']) {
                    obj['Gooster Teeth'] = obj['Goosey Grilla'];
                    delete obj['Goosey Grilla'];
                }
            } catch(_){ }
            Object.assign(game.player._seenAbilities, obj);
            try {
                const released = localStorage.getItem('quackenReleased');
                if (released === '1') {
                    game.player._seenAbilities['Release the Quacken!'] = true;
                }
            } catch(_){ }
            try { console.info('[SEEN_LOAD] merged_count=', Object.keys(game.player._seenAbilities).length); } catch(_) {}
        }
        try { game._seenAbilitiesLoaded = true; } catch(_){ }
    } catch(_) {
        try { game.player._seenAbilities = game.player._seenAbilities || {}; } catch(_){}
        try { game._seenAbilitiesLoaded = true; } catch(_){ }
    }
}

function ensureSeenAbilitiesLoaded(){
    try {
        if (!game) return;
        const seenObj = game && game.player && game.player._seenAbilities;
        if (game._seenAbilitiesLoaded && seenObj && typeof seenObj === 'object') return;
        if (typeof loadSeenAbilities === 'function') loadSeenAbilities();
    } catch(_) {}
}

// Apply any persisted permanent abilities to the current run and mark them as seen
function grantPermanentAbilities(){
    try {
        if (!game) return;
        game.player = game.player || { abilities: [], permanentAbilities: [], _seenAbilities: {} };
        if (!Array.isArray(game.player.permanentAbilities)) game.player.permanentAbilities = [];
        if (!Array.isArray(game.player.abilities)) game.player.abilities = [];
        try { if (!game._seenAbilitiesLoaded) ensureSeenAbilitiesLoaded(); } catch(_){ }
        game.player._seenAbilities = game.player._seenAbilities || {};
        let updated = false;
        game.player.permanentAbilities.forEach(ability => {
            try {
                if (!ABILITY || typeof ABILITIES === 'undefined') {}
            } catch(_){ }
            try {
                if (ABILITIES && ABILITIES[ability]) {
                    if (!game.player.abilities.includes(ability)) {
                        game.player.abilities.push(ability);
                        try { if (typeof window._onAbilityAdded === 'function') window._onAbilityAdded(ability); } catch(_){ }
                    }
                    if (!game.player._seenAbilities[ability]) {
                        game.player._seenAbilities[ability] = true;
                        updated = true;
                    }
                }
            } catch(_){ }
        });
        if (updated) {
            try { saveSeenAbilities(); } catch(_){ }
        }
    } catch(_){ }
}

// (Duplicate/displaced version of showDiscoveredAbilities removed — canonical implementation appears later.)

        function showDiscoveredAbilities() {
            try {
                if (document.getElementById('discoveredAbilitiesOverlay')) return;
            } catch(_){ }

            const overlay = document.createElement('div'); overlay.id = 'discoveredAbilitiesOverlay';
            overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.88);z-index:20005;padding:18px;font-family:Courier New,monospace;';
            const panel = document.createElement('div');
            panel.style.cssText = 'width:min(1100px,94vw);max-height:86vh;overflow:auto;background:#0e0e0e;border:2px solid #444;border-radius:10px;padding:14px;display:flex;flex-direction:column;gap:12px;color:#eee;';
            const hdr = document.createElement('div'); hdr.textContent = 'Discovered Abilities'; hdr.style.cssText = 'font-weight:800;letter-spacing:1px;color:#fff;font-size:18px;';
            const note = document.createElement('div'); note.textContent = 'Abilities you have not yet discovered are grayed out.'; note.style.cssText = 'color:#bbb;font-size:12px;margin-top:-6px;';
            const grid = document.createElement('div');
            grid.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px;margin-top:8px;';

            try {
                // Ensure persisted seen map is loaded (harmless if already loaded)
                try { if (typeof loadSeenAbilities === 'function') loadSeenAbilities(); } catch(_){ }

                // Build array of abilities with tier info, sort by tier then name
                const list = Object.keys(ABILITIES || {}).map(name => {
                    const meta = ABILITIES[name] || {};
                    const tier = meta && meta.tier ? meta.tier : 1;
                    return { name, meta, tier };
                }).sort((a,b) => {
                    if (a.tier !== b.tier) return a.tier - b.tier;
                    return a.name.localeCompare(b.name);
                });

                // Render grouped by tier
                let currentTier = null;
                const seenMap = game && game.player && game.player._seenAbilities ? game.player._seenAbilities : {};
                list.forEach(item => {
                    try {
                        const name = item.name;
                        const meta = item.meta || {};
                        const tier = item.tier || 1;

                        // Consider an ability discovered if:
                        //  - it was explicitly seen (tooltip displayed), OR
                        //  - the player currently has it in this run, OR
                        //  - it exists in the persisted permanent abilities list.
                        const ownedNow = game && game.player && Array.isArray(game.player.abilities) && game.player.abilities.includes(name);
                        const isPermanent = game && game.player && Array.isArray(game.player.permanentAbilities) && game.player.permanentAbilities.includes(name);
                        const discovered = !!seenMap[name] || !!ownedNow || !!isPermanent;

                        if (currentTier !== tier) {
                            currentTier = tier;
                            const th = document.createElement('div');
                            th.textContent = 'Tier ' + String(tier);
                            th.style.cssText = 'grid-column:1/-1;font-weight:800;color:#eee;margin-top:6px;margin-bottom:4px;';
                            grid.appendChild(th);
                        }

                        const card = document.createElement('div');
                        card.style.cssText = 'padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(0,0,0,0.04));border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:6px;min-height:80px;';
                        if (!discovered) card.style.opacity = '0.42';

                        const title = document.createElement('div'); title.textContent = name; title.style.cssText = 'font-weight:700;';
                        if (tier === 2) title.style.color = '#88b8ff'; else if (tier === 3) title.style.color = '#ff88ff'; else title.style.color = '#dceecf';
                        const desc = document.createElement('div'); desc.textContent = meta && meta.desc ? meta.desc : ''; desc.style.cssText = 'color:#cfcfcf;font-size:13px;line-height:1.2;';

                        if (!discovered) {
                            const badge = document.createElement('div'); badge.textContent = 'NOT ACQUIRED'; badge.style.cssText = 'align-self:flex-start;background:transparent;color:#999;border:1px solid #333;border-radius:6px;padding:2px 6px;font-size:11px;letter-spacing:0.4px;';
                            card.appendChild(badge);
                        }

                        card.appendChild(title); card.appendChild(desc);
                        grid.appendChild(card);
                    } catch(_){ }
                });
            } catch(_){ }

            const actions = document.createElement('div'); actions.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;margin-top:8px;';
            const btnClose = document.createElement('button'); btnClose.textContent = 'Close'; btnClose.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #666;color:#ddd;border-radius:6px;cursor:pointer;';
            btnClose.onclick = ()=>{ try { overlay.remove(); } catch(_){} };
            actions.appendChild(btnClose);
            panel.appendChild(hdr); panel.appendChild(note); panel.appendChild(grid); panel.appendChild(actions);
            overlay.appendChild(panel); document.body.appendChild(overlay);

            // keyboard: ESC to close
            const esc = (e)=>{ if (e.key === 'Escape') { e.preventDefault(); try{ overlay.remove(); } catch(_){} window.removeEventListener('keydown', esc, true); } };
            window.addEventListener('keydown', esc, true);
        }

    function saveAchievements(){
        try {
            const payload = { unlocked: game.achv.unlocked, p: {
                diarrheaKills: game.achv.diarrheaKills,
                autoAimKills: game.achv.autoAimKills,
                trapDamage: game.achv.trapDamage,
                hammerKills: game.achv.hammerKills,
                toenailHits: game.achv.toenailHits,
                vectorKills: game.achv.vectorKills,
                beansShots: game.achv.beansShots,
                breadEaten: game.achv.breadEaten,
                popcornHits: game.achv.popcornHits
            }};
            try { localStorage.setItem('achievements_v1', JSON.stringify(payload)); } catch(_) {}
            try { if (typeof devLog === 'function') devLog('[ACH] saved: ' + JSON.stringify(Object.keys(payload.p).map(k => k + '=' + (payload.p[k]||0)) )); } catch(_){}
            try { console.info('[ACH] saved', payload.p); } catch(_){}
        } catch(_) {}
    }
    function ensureState(){
        try {
            if (!window.game) window.game = {};
            if (!game.achv || typeof game.achv !== 'object') {
                game.achv = {
                    unlocked: {},
                    // debug: note initialization time
                    __initedAt: Date.now(),
                    diarrheaKills: 0,
                    autoAimKills: 0,
                    trapDamage: 0,
                    hammerKills: 0,
                    toenailHits: 0,
                    vectorKills: 0,
                    beansShots: 0,
                    breadEaten: 0,
                    popcornHits: 0
                };
            } else {
                // Ensure fields exist
                game.achv.unlocked = game.achv.unlocked || {};
                game.achv.diarrheaKills = game.achv.diarrheaKills || 0;
                game.achv.autoAimKills = game.achv.autoAimKills || 0;
                game.achv.trapDamage = game.achv.trapDamage || 0;
                game.achv.hammerKills = game.achv.hammerKills || 0;
                game.achv.toenailHits = game.achv.toenailHits || 0;
                game.achv.vectorKills = game.achv.vectorKills || 0;
                game.achv.beansShots = game.achv.beansShots || 0;
                game.achv.breadEaten = game.achv.breadEaten || 0;
                game.achv.popcornHits = game.achv.popcornHits || 0;
            }
        } catch(_){}
    }
    function loadAchievements(){
        ensureState();
        try {
            const raw = localStorage.getItem('achievements_v1');
            if (!raw) return;
            const obj = JSON.parse(raw);
            if (obj && obj.unlocked) game.achv.unlocked = obj.unlocked;
            if (obj && obj.p) Object.assign(game.achv, obj.p);
        } catch(_) {}
    }

    // Banner toast queue
    function ensureToastContainer(){
        if (document.getElementById('achvToastContainer')) return;
        const c = document.createElement('div');
        c.id = 'achvToastContainer';
        c.style.cssText = 'position:fixed;z-index:26000;display:flex;flex-direction:column;gap:8px;pointer-events:none;transform:translateX(-50%);';
        document.body.appendChild(c);
        try { positionAchvToastContainer(); } catch(_) {}
    }
    function ensureAchvFxStyles(){
        if (document.getElementById('achvFxStyles')) return;
        const st = document.createElement('style');
        st.id = 'achvFxStyles';
        st.textContent = `
            @keyframes achv-pop-in { 0% { transform: translateY(-8px) scale(0.96); opacity: 0; } 100% { transform: translateY(0) scale(1); opacity: 1; } }
            @keyframes achv-sparkle { 0% { transform: translate(0,0) scale(0.4) rotate(0deg); opacity: 1; }
                                       80% { opacity: 1; }
                                       100% { transform: translate(var(--dx, 0px), var(--dy, -24px)) scale(0.8) rotate(180deg); opacity: 0; } }
            .achvToast { position: relative; overflow: visible; }
            .achvFlourish {
                position: absolute; inset: -6px; border-radius: 14px; pointer-events:none;
                box-shadow: 0 0 18px rgba(0,255,136,0.25), 0 0 32px rgba(0,255,136,0.18) inset;
            }
            .achvSparkle { position:absolute; width:6px; height:6px; border-radius:50%;
                background: radial-gradient(circle at 30% 30%, #fff, #aaffdd 40%, rgba(0,0,0,0) 70%);
                box-shadow: 0 0 8px rgba(255,255,255,0.6);
                pointer-events:none; filter: saturate(1.2);
            }
            .achvToast.achvToast-secondary {
                border-color:#66c2ff;
                color:#d9f0ff;
                background:rgba(10,18,36,0.96);
            }
        `;
        document.head.appendChild(st);
    }
    // Position toast container at top-center of the game canvas (not viewport)
    function positionAchvToastContainer(){
        try {
            const c = document.getElementById('achvToastContainer');
            const canvasEl = document.getElementById('gameCanvas');
            if (!c || !canvasEl) return;
            const rect = canvasEl.getBoundingClientRect();
            const viewportH = window.innerHeight || document.documentElement.clientHeight || 0;
            let top = Math.round(rect.top + 14);
            if (top < 8) top = 8;
            const maxTop = Math.max(8, viewportH - 50);
            if (top > maxTop) top = maxTop;
            c.style.top = top + 'px';
            c.style.left = Math.round(rect.left + rect.width/2) + 'px';
            c.style.transform = 'translateX(-50%)';
        } catch(_) {}
    }
    try { window.addEventListener('resize', function(){ try { positionAchvToastContainer(); } catch(_) {} }); } catch(_) {}
    function ensureAchvAudio(){
        try {
            if (window._achvAudio) return window._achvAudio;
            const a = new Audio('assets/audio/484513__neilraouf__small-group-applauding-4824.wav');
            a.preload = 'auto'; a.volume = 0.55; // keep subtle
            window._achvAudio = a; return a;
        } catch(_) { return null; }
    }
    function playAchvSound(){
        try {
            if (game && game.sfxEnabled === false) return; // respect SFX toggle
            const a = ensureAchvAudio(); if (!a) return;
            // If playing already, clone to avoid cutting off
            if (!a.paused) { const b = a.cloneNode(); b.volume = a.volume; b.play().catch(()=>{}); }
            else { a.currentTime = 0; a.play().catch(()=>{}); }
        } catch(_) {}
    }
    function showAchievementToast(key){
        ensureToastContainer(); ensureAchvFxStyles();
        const meta = ACH[key]; if (!meta) return;
        const el = document.createElement('div');
        el.className = 'achvToast';
        el.style.cssText = 'min-width:260px;max-width:520px;margin:auto;background:rgba(20,20,20,0.95);border:2px solid #66ff88;border-radius:10px;padding:10px 14px;color:#eaffef;font-family:Courier New,monospace;box-shadow:0 8px 20px rgba(0,0,0,0.5);pointer-events:auto;animation: achv-pop-in 380ms cubic-bezier(.2, .9, .2, 1) both;';
        el.innerHTML = '<div style="font-weight:700;color:#66ff88;letter-spacing:0.5px;margin-bottom:4px;">Achievement Unlocked</div>'+
                       `<div style="font-weight:700;font-size:16px;margin-bottom:2px;">${meta.name}</div>`+
                       `<div style="font-size:12px;color:#cfe8d6;">${meta.desc}</div>`;
    const c = document.getElementById('achvToastContainer');
    try { positionAchvToastContainer(); } catch(_) {}
        c.appendChild(el);
        // Decorative flourish rim
        const flour = document.createElement('div'); flour.className = 'achvFlourish'; el.appendChild(flour);
        // Sparkles (reduced on low FX)
        const lowFx = !!(game && game.perf && game.perf.lowFx);
        const sparkCount = lowFx ? 6 : 14;
        for (let i=0;i<sparkCount;i++){
            const s = document.createElement('div'); s.className='achvSparkle';
            const ang = Math.random()*Math.PI*2; const dist = (lowFx? 26: 42) + Math.random()*18;
            const dx = Math.cos(ang)*dist; const dy = Math.sin(ang)*dist;
            s.style.setProperty('--dx', dx.toFixed(1)+'px'); s.style.setProperty('--dy', dy.toFixed(1)+'px');
            s.style.left = (el.clientWidth/2 + (Math.random()*30-15)) + 'px';
            s.style.top = (el.clientHeight/2 + (Math.random()*6-3)) + 'px';
            const dur = (0.6 + Math.random()*0.6).toFixed(2);
            s.style.animation = `achv-sparkle ${dur}s ease-out forwards`;
            el.appendChild(s);
            // Cleanup each sparkle after animation
            setTimeout(()=>{ try { s.remove(); } catch(_) {} }, Math.ceil(parseFloat(dur)*1000)+120);
        }
        // Play applause
        playAchvSound();
        setTimeout(()=>{ try{ el.style.transition='opacity .4s ease, transform .4s ease'; el.style.opacity='0'; el.style.transform='translateY(-8px)'; setTimeout(()=>{ el.remove(); }, 450);}catch(_){ } }, 10000);
    }

    function unlock(key){
        ensureState();
        if (game.achv.unlocked[key]) return;
        game.achv.unlocked[key] = Date.now();
        showAchievementToast(key);
        saveAchievements();
    }
    // Ensure ACH registry exists and add custom entries (safe to re-run)
    try {
        window.ACH = window.ACH || {};
        window.ACH.gooseGoldenTeeth = window.ACH.gooseGoldenTeeth || { name: 'The Goose that had the Golden Teeth', desc: 'Find and defeat the Golden Goose' };
        window.ACH.releaseTheQuacken = window.ACH.releaseTheQuacken || { name: 'Release the Quacken!', desc: 'Defeat The Quacken' };
        window.ACH.wunderbar = window.ACH.wunderbar || { name: 'Wunderbar', desc: 'Defeat the Wunderswan' };
        window.ACH.oneFrame = window.ACH.oneFrame || { name: 'I live my life one frame at a time', desc: 'Drop the framerate to a single frame per second.' };
        // Ensure global ACH alias exists for older code paths
        if (typeof ACH === 'undefined' || !ACH) {
            ACH = window.ACH;
        } else {
            ACH.gooseGoldenTeeth = ACH.gooseGoldenTeeth || window.ACH.gooseGoldenTeeth;
            ACH.releaseTheQuacken = ACH.releaseTheQuacken || window.ACH.releaseTheQuacken;
        }
        if (typeof ACH !== 'undefined' && ACH) {
            ACH.wunderbar = ACH.wunderbar || window.ACH.wunderbar;
            ACH.oneFrame = ACH.oneFrame || window.ACH.oneFrame;
            ACH.releaseTheQuacken = ACH.releaseTheQuacken || window.ACH.releaseTheQuacken;
        }
    } catch(_) {}
    function maybeUnlockCounter(counterKey, achKey){
        const meta = ACH[achKey]; if (!meta || !meta.target) return;
        if ((game.achv[counterKey]|0) >= meta.target) {
            try { if (typeof devLog === 'function') devLog('[ACH] unlocking ' + achKey + ' (counter ' + counterKey + ' = ' + (game.achv[counterKey]|0) + ')'); } catch(_){}
            try { console.info('[ACH] unlocking', achKey, counterKey, game.achv[counterKey]); } catch(_){}
            unlock(achKey);
        }
    }

    // Public helpers hooked from gameplay
    window.initAchievements = function(){ loadAchievements(); };
    window.achv_onAbilityAcquired = function(name){
        try {
            if (!name) return;
            if (name === 'Rizz') unlock('sonsIdea');
            // Combos can also be checked on acquisition
            window.achv_checkCombos && window.achv_checkCombos();
        } catch(_){}

        // DEBUG: Forced top-layer overlay for Golden Goose (ensures sprite draws above everything)
        try {
            if (game.enemies && Array.isArray(game.enemies)) {
                const frameId = (game && game.frame) || 0;
                const boss = game.enemies.find(e => e && (e.type === 'Golden Goose' || e.type === 'goldengoose') && e.health > 0);
                if (boss && typeof boss._goldenSpriteDrawnFrame === 'number') {
                    const delta = frameId - boss._goldenSpriteDrawnFrame;
                    if (delta >= 0 && delta <= 1) {
                        return;
                    }
                }
                if (boss) {
                    if (!game || !game._forceGoldenOverlay) {
                        return;
                    }
                    const gg = (game.enemySprites && (game.enemySprites.goldengoose || game.enemySprites['Golden Goose'])) ? (game.enemySprites.goldengoose || game.enemySprites['Golden Goose']) : null;
                    if (gg) {
                        // Prefer a previously-forced ImageBitmap if available
                        if (boss && boss._goldenSpriteNeedsOverlay !== true) {
                            return;
                        }
                        const bitmap = gg._forcedBitmap || null;
                        const srcImg = !bitmap ? (gg._gg_img_ref || gg.image) : null;

                            const imgToUse = bitmap || srcImg;
                            // Compute optional alignment offsets from the sprite's computeHitbox (keep overlay and in-world draw consistent)
                            let _hitOffsetX = 0;
                            let _hitOffsetY = 0;
                            try {
                                if (gg && typeof gg.computeHitbox === 'function') {
                                    const hb = gg.computeHitbox(boss) || null;
                                    if (hb) {
                                        if ('ox' in hb || 'oy' in hb) {
                                            // computeHitbox historically returned ox/oy as top-left offsets
                                            // (eg. ox = -w/2). Convert to a center offset so drawing
                                            // translations (which expect a sprite-center offset) align
                                            // with the collision AABB center: centerOffset = ox + w/2
                                            const halfW = (hb.w || 0) / 2;
                                            const halfH = (hb.h || 0) / 2;
                                            _hitOffsetX = (hb.ox || 0) + halfW; _hitOffsetY = (hb.oy || 0) + halfH;
                                        } else if ('x' in hb && 'y' in hb) {
                                            // hb expressed in absolute coordinates: compute center offset
                                            _hitOffsetX = (hb.x + (hb.w||0)/2) - (boss && boss.x || 0);
                                            _hitOffsetY = (hb.y + (hb.h||0)/2) - (boss && boss.y || 0);
                                        }
                                    }
                                }
                            } catch(_) {}
                            // Determine horizontal facing relative to the sprite's world center so overlay faces the player
                            const _centerX = boss.x + _hitOffsetX;
                            const _playerOnRight = (game && game.player) ? (game.player.x >= _centerX) : ((boss.facing || 'left') === 'right');
                            const _facingDir = _playerOnRight ? 'right' : 'left';
                            try { boss.facing = _facingDir; } catch(_) {}
                        if (imgToUse) {
                            // Build a drawable box from frames if present, else fallback to natural size
                            const animFrames = (gg && gg.anim && Array.isArray(gg.anim.frames) && gg.anim.frames.length) ? gg.anim.frames : null;
                            let box = null;
                            if (animFrames) {
                                const frameStep = Math.max(1, gg.anim.frameStep || 5);
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                if (boss) {
                                    if (typeof boss._goldenAnimStartFrame !== 'number') boss._goldenAnimStartFrame = nowFrame;
                                    if (typeof boss._goldenAnimPhase !== 'number') boss._goldenAnimPhase = Math.floor(Math.random() * animFrames.length) | 0;
                                    const elapsed = Math.max(0, nowFrame - boss._goldenAnimStartFrame);
                                    const idx = Math.floor(elapsed / frameStep);
                                    const frameIndex = (boss._goldenAnimPhase + idx) % animFrames.length;
                                    box = animFrames[frameIndex] || animFrames[0];
                                    try { boss._goldenAnimFrame = frameIndex; } catch(_){ }
                                } else {
                                    const fallbackIndex = Math.floor(nowFrame / frameStep) % animFrames.length;
                                    box = animFrames[fallbackIndex] || animFrames[0];
                                }
                            }
                            if (!box || !box.w || !box.h) {
                                box = (gg && gg.frames && (gg.frames.down || gg.frames.right || gg.frames.up)) || box;
                            }
                            if (!box || !box.w || !box.h) {
                                const w = (imgToUse && imgToUse.naturalWidth) ? imgToUse.naturalWidth : (imgToUse && imgToUse.width) ? imgToUse.width : 0;
                                const h = (imgToUse && imgToUse.naturalHeight) ? imgToUse.naturalHeight : (imgToUse && imgToUse.height) ? imgToUse.height : 0;
                                box = { x:0, y:0, w: Math.max(1, w), h: Math.max(1, h) };
                            }
                            const scale = (gg && gg.baseScaleForSize) ? gg.baseScaleForSize(boss.size) : ((boss.size*2)/(box.h||1));
                            const drawW = box.w * scale; const drawH = box.h * scale;
                            // anchor handling
                            const anchorX = (box && typeof box.anchorX === 'number') ? box.anchorX : (box ? box.w/2 : ((imgToUse && (imgToUse.naturalWidth||imgToUse.width))/2));
                            const anchorY = (box && typeof box.anchorY === 'number') ? box.anchorY : (box ? box.h/2 : ((imgToUse && (imgToUse.naturalHeight||imgToUse.height))/2));
                            const anchorOffsetX = (anchorX - (box ? box.w/2 : ((imgToUse && (imgToUse.naturalWidth||imgToUse.width))/2))) * scale;
                            const anchorOffsetY = (anchorY - (box ? box.h/2 : ((imgToUse && (imgToUse.naturalHeight||imgToUse.height))/2))) * scale;
                            const destX = -drawW/2 + anchorOffsetX;
                            const destY = -drawH/2 + anchorOffsetY;
                            let _overlayActuallyDrew = false;
                                try {
                                ctx.save();
                                ctx.globalAlpha = 0.98;
                                // Translate to the sprite-aligned center so overlay uses same anchor as in-world draw
                                ctx.translate(boss.x + _hitOffsetX, boss.y + _hitOffsetY);
                                // Mirror is applied per-draw below; avoid pre-scaling here which could double-scale
                                try {
                                    const _mirroredOv = !_playerOnRight;
                                    const _drawXOv = _mirroredOv ? (-(destX + drawW)) : destX;
                                    if (bitmap) {
                                        if (_mirroredOv) ctx.scale(-1,1);
                                        ctx.drawImage(bitmap, box.x, box.y, box.w, box.h, _drawXOv, destY, drawW, drawH);
                                        _overlayActuallyDrew = true;
                                    } else if (imgToUse && imgToUse.complete && (imgToUse.naturalWidth || imgToUse.width)) {
                                        if (_mirroredOv) ctx.scale(-1,1);
                                        ctx.drawImage(imgToUse, box.x, box.y, box.w, box.h, _drawXOv, destY, drawW, drawH);
                                        _overlayActuallyDrew = true;
                                    }
                                } catch (e) {
                                    try { console.warn('[GoldenGooseSprite][OVERLAY][ERROR] draw failed', e); } catch(_){ }
                                }
                                // Outline removed to avoid visible flashes during overlay drawing
                            } finally { try { ctx.restore(); } catch(_){} }

                            // Mark that this specific enemy got an overlay draw this frame so per-enemy fallback can skip duplicate markers
                            try { if (_overlayActuallyDrew) boss._overlayDrawnFrame = (game.frame || 0); } catch(_){ }

                            // Log once-per-second to confirm overlay drawing
                            try { game._debug = game._debug || {}; const now = performance.now(); if (!game._debug._lastGoldenOverlay || now - game._debug._lastGoldenOverlay > 1000) { game._debug._lastGoldenOverlay = now; /* overlay diagnostic suppressed */ } } catch(_){ }
                        }
                    }
                }
            }
        } catch(_){ }
    };
    window.achv_checkCombos = function(){
        try {
            const has = (n)=> game.player && Array.isArray(game.player.abilities) && game.player.abilities.includes(n);
            if (has('Uzumaki') && has('Diarrhea')) unlock('downTheDrain');
            if (has('Diarrhea') && has('Poison Shot')) unlock('apothecary');
        } catch(_){}
    };
    window.achv_onBeansHit = function(){ ensureState(); game.achv.beansShots = (game.achv.beansShots|0) + 1; maybeUnlockCounter('beansShots','giveItTheBeans'); saveAchievements(); };
    window.achv_onBreadCollected = function(){ ensureState(); game.achv.breadEaten = (game.achv.breadEaten|0) + 1; maybeUnlockCounter('breadEaten','diabeetus'); saveAchievements(); };
    window.achv_addTrapDamage = function(amount){ ensureState(); game.achv.trapDamage = (game.achv.trapDamage|0) + Math.max(0, Math.floor(amount||0)); maybeUnlockCounter('trapDamage','noKnock'); saveAchievements(); };
    window.achv_onHit = function(proj){
        try {
            if (!proj) return;
            ensureState();
            if (proj._diarrheaBrown) {
                game.achv.diarrheaKills = (game.achv.diarrheaKills|0) + 1; maybeUnlockCounter('diarrheaKills','madPooper'); try{ if (typeof devLog === 'function') devLog('[ACH] diarrheaKills -> ' + game.achv.diarrheaKills); } catch(_){}
            }
            if (proj.autoAimShot) {
                game.achv.autoAimKills = (game.achv.autoAimKills|0) + 1; maybeUnlockCounter('autoAimKills','aimBot'); try{ if (typeof devLog === 'function') devLog('[ACH] autoAimKills -> ' + game.achv.autoAimKills); } catch(_){}
            }
            if (proj.weaponType === 'hammer' || proj._hammer) {
                game.achv.hammerKills = (game.achv.hammerKills|0) + 1; maybeUnlockCounter('hammerKills','worthy'); try{ if (typeof devLog === 'function') devLog('[ACH] hammerKills -> ' + game.achv.hammerKills); } catch(_){}
            }
            if (proj.pivotPattern) {
                game.achv.vectorKills = (game.achv.vectorKills|0) + 1; maybeUnlockCounter('vectorKills','vectorMan'); try{ if (typeof devLog === 'function') devLog('[ACH] vectorKills -> ' + game.achv.vectorKills); } catch(_){}
            }
            try { saveAchievements(); } catch(_){ }
        } catch(_){}
    };

    // Utility for one-off event achievements
    window.achv_unlock = function(key){ unlock(key); };

    // Hook initialization on load
    try { window.addEventListener('load', function(){ try{ initAchievements(); }catch(_){}}); } catch(_) {}

// ===== Audio Preference Persistence =====
function loadAudioPreferences() {
    try {
        const sfx = localStorage.getItem('pref_sfx');
        const music = localStorage.getItem('pref_music');
        // Potato mode (new) and legacy cosmetic toggle (old)
        const potato = localStorage.getItem('pref_potato_mode');
        const cosmeticOff = localStorage.getItem('pref_disable_cosmetic');
        if (sfx !== null) game.sfxEnabled = sfx === '1';
        if (music !== null) game.musicEnabled = music === '1';
        if (potato !== null) game.potatoMode = potato === '1';
        // Back-compat: if new key missing, fall back to old cosmetic flag
        if (potato === null && cosmeticOff !== null) {
            game.potatoMode = cosmeticOff === '1';
        }
        // Keep legacy flag in sync for any older checks
        game.disableCosmeticParticles = !!game.potatoMode;
        // Apply FX clamps immediately based on loaded state
    if (game.potatoMode) applyPotatoFxClamps(true); else applyPotatoFxClamps(false);
    updatePotatoBadge();
    } catch(e) {}
}
function saveAudioPreferences() {
    try {
        localStorage.setItem('pref_sfx', game.sfxEnabled ? '1' : '0');
        localStorage.setItem('pref_music', game.musicEnabled ? '1' : '0');
        // Persist both keys for compatibility; new UI reads pref_potato_mode
        localStorage.setItem('pref_potato_mode', game.potatoMode ? '1' : '0');
        localStorage.setItem('pref_disable_cosmetic', game.potatoMode ? '1' : '0');
    } catch(e) {}
    applyMusicPreference(false);
}

// Apply or clear FX clamps when Potato Mode changes
function applyPotatoFxClamps(on){
    try {
        // Clamp particle/transient emission and simplify special FX
        game.disableCosmeticParticles = !!on; // legacy path
        if (game.perf) {
            game.perf.lowFx = !!on;
            // When user explicitly sets potato, freeze autoLowFx
            game.perf.autoLowFx = !on ? game.perf.autoLowFx : false;
        }
        if (game.fxFlags) {
            game.fxFlags.hideSparks = !!on;
            game.fxFlags.hideSpokes = !!on;
            game.fxFlags.reduceRings = !!on;
            game.fxFlags.reduceBeams = !!on;
        }
    } catch(_) {}
}

// Keep the LOW FX badge in sync with current settings
function updatePotatoBadge() {
    try {
        const el = document.getElementById('potatoBadge');
        if (!el) return;
        const active = !!(game && (game.potatoMode || (game.perf && game.perf.lowFx)));
        el.style.display = active ? 'block' : 'none';
        // Label priority: explicit Potato Mode overrides wording
        el.textContent = game && game.potatoMode ? 'POTATO MODE' : 'LOW FX';
        // Soften color when auto low FX vs explicit potato
        el.style.color = game && game.potatoMode ? '#ffd27f' : '#d6e8ff';
        el.style.borderColor = game && game.potatoMode ? '#aa8844' : '#6688aa';
    } catch(_) {}
}

// Idempotent background music starter
function ensureBackgroundMusic() {
    if (game && game._titleMusicSuppressed) return;
    if (!game.musicEnabled) return; // respect preference
    try {
        // If an act-specific music was explicitly set, avoid overwriting it here.
        // Apply preference and ensure it is playing, then return early.
        try {
            if (game && game._actMusicSet) {
                // Act-specific music already set; apply preference and skip default init
                try { applyMusicPreference(true); } catch(_){}
                try { if (game.bgMusic && game.bgMusic.paused) { game.bgMusic.play().catch(()=>{}); } } catch(_){}
                return;
            }
        } catch(_){ }
        if (!game.bgMusic) {
            // Prefer act-specific theme when an act is selected (Act II uses GooseGhetto)
            let src = 'assets/audio/QuackshotChronicles.mp3';
            try { if (game && game._selectedAct && String(game._selectedAct) === 'II') src = 'assets/audio/GooseGhetto.mp3'; } catch(_){}
            // initializing bgMusic with chosen source
            const m = new Audio(src);
            m.loop = true; m.volume = 0.55; game.bgMusic = m;
        }
        if (game.bgMusic.paused) {
            game.bgMusic.play().catch(()=>{});
        }
        // If the player has selected Act II but an earlier default track was created, swap it now.
        try {
            if (game && game._selectedAct && String(game._selectedAct) === 'II') {
                try {
                    const cur = game.bgMusic && game.bgMusic.src ? String(game.bgMusic.src) : '';
                    if (!cur.includes('GooseGhetto')) {
                        // swapping existing bgMusic to GooseGhetto due to selectedAct=II
                        try { if (game.bgMusic) { game._prevMusicSrc = game.bgMusic.src; try { game.bgMusic.pause(); } catch(_){} } } catch(_){}
                        game.bgMusic = new Audio('assets/audio/GooseGhetto.mp3');
                        game.bgMusic.loop = true; game.bgMusic.volume = 0.55;
                        applyMusicPreference();
                        try { game.bgMusic.play().catch(()=>{}); } catch(_){}
                        try { game._actMusicSet = true; } catch(_){}
                    }
                } catch(_){}
            }
        } catch(_){}
    } catch(e) {}
}
// Manual Low FX toggle: press 'L' to toggle, Shift+L to re-enable auto mode
window.addEventListener('keydown', (e)=>{
    if (e.key === 'l' || e.key === 'L') {
        if (game && game.perf) {
            if (e.shiftKey) {
                game.perf.autoLowFx = true; // re-enable auto management
            } else {
                game.perf.lowFx = !game.perf.lowFx;
                game.perf.autoLowFx = false; // manual override
            }
            updatePotatoBadge();
        }
    }
});

// =============================================================
// DEV: Starting Ability Picker (press '0') — temporary, easily removable
// To remove: delete this block or set ENABLE_STARTING_ABILITY_PICKER = false
window.ENABLE_STARTING_ABILITY_PICKER = true;

// Apply the chosen starting ability to the current player, keeping permanent abilities
function applyStartingAbility(abName) {
    if (!game || !game.player) return;
    try {
        const perms = Array.isArray(game.player.permanentAbilities) ? game.player.permanentAbilities.slice() : [];
        const next = [];
        // Keep permanents first
        perms.forEach(a => { if (ABILITIES[a]) next.push(a); });
        // Then add the chosen ability (if valid and not duplicate)
        if (abName && ABILITIES[abName] && !next.includes(abName)) next.push(abName);
        game.player.abilities = next;
        // Persist clean state (filter out any removed/unknown abilities defensively)
        game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
        // Small visual cue in console
    // Starting ability applied (debug log suppressed)
        // Achievements: record acquisition and check combos
        try {
            if (window.achv_onAbilityAcquired) achv_onAbilityAcquired(abName);
            if (window.achv_checkCombos) achv_checkCombos();
        } catch(_) {}
        // Refresh any UI that lists abilities
        if (typeof updatePauseMenu === 'function') {
            try { updatePauseMenu(); } catch(_) {}
        }
    } catch (err) {
        console.warn('[Start Ability] Failed to apply ability', abName, err);
    }
}

function showStartingAbilityMenu() {
    if (!window.ENABLE_STARTING_ABILITY_PICKER) return;
    // Prevent multiple overlays
    const existing = document.getElementById('startAbilityOverlay');
    if (existing) { try { existing.remove(); } catch(_) {} }

    const wasPaused = !!game.paused;
    game.paused = true;

    const overlay = document.createElement('div');
    overlay.id = 'startAbilityOverlay';
    overlay.style.cssText = [
        'position:fixed', 'inset:0', 'z-index:10050', 'display:flex', 'align-items:center', 'justify-content:center',
        'background:rgba(0,0,0,0.82)', 'font-family:Courier New,monospace'
    ].join(';');

    const panel = document.createElement('div');
    panel.style.cssText = [
        'width:min(1000px,92vw)', 'max-height:min(85vh,900px)', 'background:#1b1b1b', 'border:2px solid #555', 'border-radius:10px',
        'box-shadow:0 12px 34px rgba(0,0,0,0.6)', 'padding:16px', 'display:flex', 'flex-direction:column', 'gap:12px'
    ].join(';');

    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;';
    header.innerHTML = '<div style="color:#fff;font-weight:700;letter-spacing:1px">Pick Starting Ability</div>'+
        '<button id="startAbClose" data-gp-focus="1" style="background:#222;color:#ddd;border:1px solid #666;padding:6px 10px;border-radius:6px;cursor:pointer">Close (Esc)</button>';

    const controls = document.createElement('div');
    controls.style.cssText = 'display:flex;gap:10px;align-items:center;flex-wrap:wrap;';
    const search = document.createElement('input');
    search.type = 'text';
    search.placeholder = 'Search abilities...';
    search.style.cssText = 'flex:1;min-width:240px;padding:8px 10px;border:1px solid #555;border-radius:6px;background:#111;color:#eee;outline:none';
    const onlyWeapons = document.createElement('label');
    onlyWeapons.style.cssText = 'display:flex;align-items:center;gap:6px;color:#bbb;font-size:12px;user-select:none;';
    const onlyWeaponsChk = document.createElement('input');
    onlyWeaponsChk.type = 'checkbox';
    onlyWeapons.appendChild(onlyWeaponsChk);
    onlyWeapons.appendChild(document.createTextNode('Weapon-type only'));
    controls.appendChild(search);
    controls.appendChild(onlyWeapons);

    const grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px;overflow:auto;flex:1;padding-right:4px;';

    function tierStyle(tier){
        if (tier === 3) return { border:'#c68b1a', bg:'#2a1d05', name:'#ffd37a' };
        if (tier === 2) return { border:'#3d7dd9', bg:'#0a1d33', name:'#aaccff' };
        return { border:'#5aa84d', bg:'#0d2a0d', name:'#b9e8b2' };
    }

    function buildItem(name, meta){
        const t = (meta && meta.tier) || 1; const st = tierStyle(t);
        const owned = Array.isArray(game?.player?.abilities) && game.player.abilities.includes(name);
        const d = document.createElement('div');
        d.style.cssText = [
            'border:2px solid '+st.border, 'background:'+st.bg, 'border-radius:8px', 'padding:10px',
            'display:flex', 'flex-direction:column', 'gap:6px', 'box-shadow:inset 0 0 8px #000, 0 0 8px rgba(0,0,0,0.35)'
        ].join(';');
        if (!owned) {
            d.style.cursor = 'pointer';
            d.onmouseenter = ()=> d.style.transform = 'translateY(-2px)';
            d.onmouseleave = ()=> d.style.transform = 'none';
        } else {
            d.style.cursor = 'not-allowed';
            d.style.filter = 'grayscale(0.6) opacity(0.65)';
            d.setAttribute('aria-disabled','true');
            d.title = 'Already owned';
        }
        const title = document.createElement('div');
        title.textContent = name;
        title.style.cssText = 'font-weight:700;color:'+st.name+';text-shadow:0 0 6px rgba(0,0,0,.6)';
        const desc = document.createElement('div');
        desc.textContent = meta && meta.desc ? meta.desc : '';
        desc.style.cssText = 'color:#ddd;font-size:12px;min-height:32px;line-height:1.25';
        d.appendChild(title);
        if (owned) {
            const badge = document.createElement('div');
            badge.textContent = 'OWNED';
            badge.style.cssText = 'align-self:flex-start;background:#2a2a2a;color:#bbb;border:1px solid #555;border-radius:4px;padding:2px 6px;font-size:11px;letter-spacing:0.5px;';
            d.appendChild(badge);
        }
        d.appendChild(desc);
        if (!owned) {
            d.setAttribute('data-gp-focus','1');
            d.onclick = () => {
                applyStartingAbility(name);
                try { document.body.removeChild(overlay); } catch(_) {}
                game.paused = wasPaused;
            };
        }
        return d;
    }

    function getAllAbilityKeys(){
        return Object.keys(ABILITIES);
    }

    function filterAndRender(){
        const q = (search.value || '').trim().toLowerCase();
        const wantWeapons = !!onlyWeaponsChk.checked;
        grid.innerHTML = '';
        const keys = getAllAbilityKeys().filter(k => {
            if (q && !(k.toLowerCase().includes(q) || (ABILITIES[k].desc||'').toLowerCase().includes(q))) return false;
            if (wantWeapons && !(ABILITIES[k] && ABILITIES[k].effect && ABILITIES[k].effect.weaponType)) return false;
            return true;
        }).sort((a,b)=>{
            const ta = (ABILITIES[a].tier||1), tb=(ABILITIES[b].tier||1);
            if (ta!==tb) return ta-tb; // tier asc
            return a.localeCompare(b);
        });
        if (keys.length === 0) {
            const empty = document.createElement('div');
            empty.textContent = 'No abilities match your filter.';
            empty.style.cssText = 'color:#aaa;font-size:13px;padding:8px;grid-column:1/-1';
            grid.appendChild(empty);
        } else {
            keys.forEach(k => grid.appendChild(buildItem(k, ABILITIES[k])));
        }
    }

    panel.appendChild(header);
    panel.appendChild(controls);
    panel.appendChild(grid);
    overlay.appendChild(panel);
    document.body.appendChild(overlay);
    // (Act transition overlay + preload utilities were moved to global scope so
    // they are accessible from title/start functions. See functions defined
    // before showTitleScreen() below.)

    // Wire events
    document.getElementById('startAbClose').onclick = () => { try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; };
    search.oninput = filterAndRender;
    onlyWeaponsChk.onchange = filterAndRender;
    // Do not auto-focus the search input so controller can immediately navigate

    // ESC to close
    const escHandler = (ev)=>{ if (ev.key === 'Escape') { ev.preventDefault(); try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; window.removeEventListener('keydown', escHandler, true);} };
    window.addEventListener('keydown', escHandler, true);

    filterAndRender();
    // Default controller focus to the first selectable card (skip owned/disabled); fall back to Close
    try {
        setTimeout(() => {
            const cont = document.getElementById('startAbilityOverlay');
            if (!cont) return;
            const items = gatherFocusables(cont);
            if (items && items.length) {
                game.uiNav = game.uiNav || {};
                game.uiNav.container = cont;
                game.uiNav.items = items;
                let idx = 0;
                for (let i=0;i<items.length;i++) {
                    const el = items[i];
                    if (el.getAttribute && el.getAttribute('data-gp-focus')==='1' && grid.contains(el)) { idx=i; break; }
                }
                game.uiNav.index = idx;
                applyGpFocus();
            }
        }, 0);
    } catch(_) {}
}

// Simple debug enemy spawn overlay (toggle with '9')
window.ENABLE_ENEMY_SPAWN_DEBUG_MENU = true;
let enemySpawnDebugState = null;

function spawnEnemyDebug(typeName, opts) {
    if (typeof game === 'undefined' || typeof ENEMY_TYPES === 'undefined') {
        try { console.warn('[EnemyDebugSpawn] Missing prerequisites', { hasGame: typeof game !== 'undefined', hasTypes: typeof ENEMY_TYPES !== 'undefined' }); } catch(_) {}
        return null;
    }
    const base = ENEMY_TYPES[typeName];
    if (!base) {
        try { console.warn('[EnemyDebugSpawn] Unknown enemy', typeName); } catch(_) {}
        return null;
    }
    const dungeon = (typeof game.dungeon === 'number') ? game.dungeon : 1;
    const healthMult = Math.pow(1.35, Math.max(0, dungeon - 1));
    const scaledHealth = Math.max(1, Math.floor((base.health || 1) * healthMult));
    const logicalW = (typeof LOGICAL_W !== 'undefined') ? LOGICAL_W : ((typeof canvas !== 'undefined' && canvas && canvas.width) ? canvas.width : 800);
    const logicalH = (typeof LOGICAL_H !== 'undefined') ? LOGICAL_H : ((typeof canvas !== 'undefined' && canvas && canvas.height) ? canvas.height : 600);
    const player = (typeof game.player === 'object' && game.player) ? game.player : { x: logicalW / 2, y: logicalH / 2, size: 24 };
    const defaultOffset = (base.size || 32) + (player.size || 24) + 20;
    const offsetX = (opts && typeof opts.offsetX === 'number') ? opts.offsetX : defaultOffset;
    let spawnX = player.x + offsetX;
    let spawnY = player.y;
    if (spawnX > logicalW - 40) spawnX = player.x - offsetX;
    const margin = Math.max(32, base.size || 24);
    spawnX = Math.max(margin, Math.min(logicalW - margin, spawnX));
    spawnY = Math.max(margin, Math.min(logicalH - margin, spawnY));
    const enemy = {
        x: spawnX,
        y: spawnY,
        type: typeName,
        facing: base.ranged ? 'right' : 'down',
        health: scaledHealth,
        maxHealth: scaledHealth,
        speed: base.speed || 0.6,
        baseSpeed: base.speed || 0.6,
        damage: base.damage || 1,
        color: base.color || '#ffffff',
        size: base.size || 24,
        xp: base.xp || 0,
        ranged: !!base.ranged,
        rangedCooldown: base.ranged ? (base.rangedCooldown || 2000) : 0,
        armor: base.armor || 0,
        lastAttack: 0,
        poisoned: false,
        poisonTime: 0,
        slowed: false,
        slowTime: 0,
        burning: false,
        burnTime: 0,
        wunderScribble: false,
        wunderScribbleTime: 0,
        wunderScribbleInterval: 0,
        wunderScribbleTickDamage: 0,
        _wunderScribbleTick: 0,
        quackenSnared: false,
        quackenSnareTime: 0,
        _quackenStack: 0,
        _quackenTick: 0,
        _quackenBaseDamage: 0,
        _quackenDotScale: 0,
        _quackenRingCd: 0,
        elite: !!(opts && opts.elite),
        debugSpawn: true
    };
    if (enemy.elite) {
        enemy.health = Math.floor(enemy.health * 5.0);
        enemy.maxHealth = enemy.health;
        enemy.speed *= 1.10;
        enemy.damage = Math.ceil(enemy.damage * 1.4);
        enemy.eliteGlow = 1.0;
    }
    if (base.boss || base.bossFinal || base.bossSecret) {
        enemy.finalBoss = true;
    }
    if (!Array.isArray(game.enemies)) game.enemies = [];
    game.enemies.push(enemy);
    try { console.info('[EnemyDebugSpawn] spawned', typeName, { x: enemy.x, y: enemy.y, elite: enemy.elite }); } catch(_) {}
    return enemy;
}

function hideEnemySpawnDebugMenu() {
    if (enemySpawnDebugState && typeof enemySpawnDebugState.close === 'function') {
        enemySpawnDebugState.close();
    }
}

function showEnemySpawnDebugMenu() {
    if (!window.ENABLE_ENEMY_SPAWN_DEBUG_MENU) return;
    if (enemySpawnDebugState) {
        hideEnemySpawnDebugMenu();
        return;
    }
    if (typeof ENEMY_TYPES === 'undefined') {
        try { console.warn('[EnemyDebugSpawn] ENEMY_TYPES not ready'); } catch(_) {}
        return;
    }
    const names = Object.keys(ENEMY_TYPES || {}).sort((a,b)=>a.localeCompare(b));
    if (!names.length) {
        try { console.warn('[EnemyDebugSpawn] No enemy types available'); } catch(_) {}
        return;
    }
    const overlay = document.createElement('div');
    overlay.id = 'enemySpawnDebugOverlay';
    overlay.style.cssText = [
        'position:fixed','inset:0','z-index:10060','display:flex','align-items:center','justify-content:center',
        'background:rgba(0,0,0,0.78)','font-family:Courier New,monospace'
    ].join(';');
    const panel = document.createElement('div');
    panel.style.cssText = [
        'width:min(900px,92vw)','max-height:min(85vh,880px)','background:#141414','border:2px solid #555','border-radius:10px',
        'box-shadow:0 12px 32px rgba(0,0,0,0.6)','padding:16px','display:flex','flex-direction:column','gap:12px'
    ].join(';');
    overlay.appendChild(panel);
    const title = document.createElement('div');
    title.style.cssText = 'color:#f5f5f5;font-weight:700;letter-spacing:1px;font-size:18px;';
    title.textContent = 'Enemy Spawn Debugger';
    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.textContent = 'Close (Esc)';
    closeBtn.style.cssText = 'background:#222;color:#ddd;border:1px solid #666;padding:6px 10px;border-radius:6px;cursor:pointer;font-size:13px;';
    closeBtn.onclick = () => hideEnemySpawnDebugMenu();
    const headerWrap = document.createElement('div');
    headerWrap.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;';
    headerWrap.appendChild(title);
    headerWrap.appendChild(closeBtn);
    const filterInput = document.createElement('input');
    filterInput.type = 'text';
    filterInput.placeholder = 'Filter enemies...';
    filterInput.style.cssText = 'padding:8px 10px;border:1px solid #555;border-radius:6px;background:#111;color:#eee;outline:none;font-size:13px;';
    const info = document.createElement('div');
    info.style.cssText = 'color:#999;font-size:12px;';
    info.textContent = 'Click an enemy to spawn near the player. Hold Shift to spawn as elite.';
    const list = document.createElement('div');
    list.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:8px;overflow:auto;flex:1;padding-right:4px;';
    panel.appendChild(headerWrap);
    panel.appendChild(filterInput);
    panel.appendChild(info);
    panel.appendChild(list);
    function renderList(){
        const query = (filterInput.value || '').trim().toLowerCase();
        list.innerHTML = '';
        const filtered = names.filter(name => !query || name.toLowerCase().includes(query));
        if (!filtered.length) {
            const empty = document.createElement('div');
            empty.textContent = 'No enemies match.';
            empty.style.cssText = 'color:#aaa;font-size:13px;padding:8px;grid-column:1/-1;text-align:center;';
            list.appendChild(empty);
            return;
        }
        filtered.forEach(name => {
            const meta = ENEMY_TYPES[name] || {};
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.style.cssText = [
                'background:#1e1e1e','color:#ddd','border:1px solid #555','border-radius:6px','padding:8px 10px',
                'text-align:left','cursor:pointer','font-size:13px','transition:background 120ms ease'
            ].join(';');
            btn.innerHTML = '<div style="font-weight:600;margin-bottom:4px;color:#f0f0f0">' + name + '</div>' +
                '<div style="font-size:11px;color:#aaa">HP ' + (meta.health || '?') + ' | Size ' + (meta.size || '?') + (meta.boss || meta.bossFinal || meta.bossSecret ? ' | Boss' : '') + '</div>';
            btn.onmouseenter = () => { btn.style.background = '#2a2a2a'; };
            btn.onmouseleave = () => { btn.style.background = '#1e1e1e'; };
            btn.onclick = (ev) => {
                const spawned = spawnEnemyDebug(name, { elite: !!(ev && ev.shiftKey) });
                if (spawned) hideEnemySpawnDebugMenu();
            };
            list.appendChild(btn);
        });
    }
    filterInput.addEventListener('input', renderList);
    panel.addEventListener('click', (ev)=> ev.stopPropagation());
    overlay.addEventListener('click', ()=> hideEnemySpawnDebugMenu());
    document.body.appendChild(overlay);
    const wasPaused = (typeof game !== 'undefined' && game) ? !!game.paused : false;
    if (typeof game !== 'undefined' && game) game.paused = true;
    const escHandler = (ev)=> {
        if (ev.key === 'Escape') {
            ev.preventDefault();
            hideEnemySpawnDebugMenu();
        }
    };
    window.addEventListener('keydown', escHandler, true);
    function closeMenu() {
        try { window.removeEventListener('keydown', escHandler, true); } catch(_) {}
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        if (typeof game !== 'undefined' && game) game.paused = wasPaused;
        enemySpawnDebugState = null;
    }
    enemySpawnDebugState = { overlay, close: closeMenu };
    renderList();
    setTimeout(() => { try { filterInput.focus(); } catch(_) {} }, 0);
}

window.addEventListener('keydown', (e) => {
    if (!window.ENABLE_ENEMY_SPAWN_DEBUG_MENU) return;
    if (e.key === '9') {
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : '';
        if (tag === 'INPUT' || tag === 'TEXTAREA' || (e.target && e.target.isContentEditable)) return;
        e.preventDefault();
        if (enemySpawnDebugState) hideEnemySpawnDebugMenu(); else showEnemySpawnDebugMenu();
    }
});

// Bind global hotkey: '0' opens the starting ability picker
window.addEventListener('keydown', (e) => {
    if (!window.ENABLE_STARTING_ABILITY_PICKER) return;
    // Use e.key so numpad 0 also works if it reports '0'
    if (e.key === '0') {
        e.preventDefault();
        try { showStartingAbilityMenu(); } catch(_) {}
    }
});

// FX toggle: Press F3 to cycle visual intensity presets
window.addEventListener('keydown', (e)=>{
    if (e.key === 'F3') {
        const f = game.fxFlags || (game.fxFlags = { hideSparks:false, hideSpokes:false, reduceRings:false, reduceBeams:false });
        // Sequence: Full FX -> Reduced Rings/Spokes -> Hide Sparks -> Low FX (global) -> Full FX
        if (!game.perf.lowFx && !f.reduceRings && !f.hideSpokes && !f.hideSparks) {
            f.reduceRings = true; f.hideSpokes = true; console.info('[FX] Reduced rings/spokes');
        } else if (f.reduceRings && f.hideSpokes && !f.hideSparks) {
            f.hideSparks = true; console.info('[FX] Hide sparks');
        } else if (!game.perf.lowFx) {
            game.perf.lowFx = true; console.info('[FX] Low FX mode ON'); updatePotatoBadge();
        } else {
            // reset to full
            game.perf.lowFx = false; f.reduceRings=false; f.hideSpokes=false; f.hideSparks=false; console.info('[FX] Full FX restored'); updatePotatoBadge();
        }
    }
});

function toggleCosmeticParticles() {
    game.disableCosmeticParticles = !game.disableCosmeticParticles;
    saveAudioPreferences();
    updateAudioButtons();
}

// --- Act transition overlay + preload utility (global scope) ---
function _createActTransitionOverlay(){
    if (document.getElementById('actTransitionOverlay')) { try { console.info('[ActTransition] overlay already exists'); } catch(_){}; return document.getElementById('actTransitionOverlay'); }
    const ov = document.createElement('div'); ov.id = 'actTransitionOverlay';
    Object.assign(ov.style, {
        position: 'fixed', inset: '0', background: '#000', display:'flex', alignItems:'center', justifyContent:'center',
        zIndex: 10050, opacity: '0', transition: 'opacity 240ms ease', pointerEvents: 'none'
    });
    const txt = document.createElement('div'); txt.id = 'actTransitionOverlayText';
    Object.assign(txt.style, { color:'#fff', fontFamily:'Courier New, monospace', fontSize:'42px', fontWeight:800, letterSpacing:'2px', textAlign:'center', padding:'6px 14px' });
    ov.appendChild(txt);
    try { console.info('[ActTransition] creating overlay element'); } catch(_){ }
    document.body.appendChild(ov);
    return ov;
}

function preloadActSprites(actId, timeoutMs){
    return new Promise((resolve)=>{
        try {
            try { console.info('[preloadActSprites] start', actId); } catch(_){ }
            if (!window.ENEMY_TYPES || !window.game) { resolve(); return; }
            const keys = Object.keys(ENEMY_TYPES).filter(k=>{ try{ return (ENEMY_TYPES[k] && (''+ENEMY_TYPES[k].act) === (''+actId)); } catch(e){ return false; } });
            if (!keys || keys.length === 0) { resolve(); return; }
            const checks = keys.map(t => {
                return new Promise((res)=>{
                    try {
                        const variants = [t, t.toLowerCase(), t.replace(/\s+/g,''), t.toLowerCase().replace(/\s+/g,'')];
                        let cont = null;
                        for (let v of variants){ if (game.enemySprites && game.enemySprites[v]) { cont = game.enemySprites[v]; break; } }
                        if (!cont) { res(); return; }
                        // Consider the sprite ready if loaded flag set, fallback bitmap present, or image decoded (naturalWidth available)
                        const isImgReady = (cont.image && (cont.image.naturalWidth || cont.image.width));
                        if (cont.loaded || cont._forcedBitmap || isImgReady) { res(); return; }

                        let done = false;
                        const finish = ()=>{ try{ if (done) return; done = true; clearInterval(iv); res(); }catch(_){ try{ res(); }catch(_){} } };

                        // Prefer the modern decode() API to ensure the image is fully decoded before resolving
                        try {
                            if (cont.image && typeof cont.image.decode === 'function') {
                                // race decode against the polling/timeout; decode may reject, fall back to polling
                                cont.image.decode().then(()=>{ finish(); }).catch(()=>{});
                            }
                        } catch(_){}

                        // If the image isn't actively decoding/loading, proactively fetch a bitmap fallback so the renderer
                        // has something usable during the transition. This helps when image loading is deferred by the
                        // environment or when decode() doesn't begin until rendering resumes.
                        try {
                            const href = (cont.image && cont.image.src) ? String(cont.image.src) : null;
                            if (href && href.indexOf('file:') !== 0 && typeof fetch === 'function' && typeof createImageBitmap === 'function') {
                                // Start a background fetch→createImageBitmap; this may duplicate network work but ensures
                                // a drawable ImageBitmap is available quickly. Abort after a short timeout.
                                try {
                                    const ac2 = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                                    const sig2 = ac2 ? ac2.signal : null;
                                    const to2 = setTimeout(()=>{ try{ if (ac2) ac2.abort(); }catch(_){} }, 900);
                                    fetch(href, { signal: sig2 }).then(r=>{ clearTimeout(to2); if (!r.ok) throw new Error('status '+r.status); return r.blob(); }).then(b=>createImageBitmap(b)).then(bmp=>{
                                        try { cont._forcedBitmap = bmp; cont.loaded = true; } catch(_){}
                                        try { finish(); } catch(_){}
                                    }).catch(()=>{});
                                } catch(_){}
                            } else if (href) {
                                // Fallback for file:// or environments without fetch/createImageBitmap: create a small Image to nudge loading
                                try {
                                    const tmp = new Image();
                                    tmp.onload = function(){ try{ cont.loaded = true; finish(); }catch(_){} };
                                    tmp.onerror = function(){ try{ finish(); }catch(_){} };
                                    tmp.src = href;
                                } catch(_){}
                            }
                        } catch(_){}

                        const onCheck = ()=>{ try{ if (done) return; const rdy = (cont.loaded || cont._forcedBitmap || (cont.image && (cont.image.naturalWidth || cont.image.width))); if (rdy) finish(); }catch(_){} };
                        const iv = setInterval(onCheck, 80);
                        // timeout fallback
                        setTimeout(()=>{ try{ if (done) return; finish(); }catch(_){ try{ res(); }catch(_){} } }, timeoutMs || 1600);
                    } catch(e){ res(); }
                });
            });
            Promise.all(checks).then(()=> resolve()).catch(()=> resolve());
        } catch(e){ resolve(); }
    });
}

function showActTransition(actId, options){
    options = options || {};
    const minMs = typeof options.minMs === 'number' ? options.minMs : 2000;
    const preloadTimeout = typeof options.preloadTimeout === 'number' ? options.preloadTimeout : 1800;
    try { const ov = _createActTransitionOverlay(); const txt = document.getElementById('actTransitionOverlayText');
    const label = (''+actId) === 'I' ? 'New Quack City' : ((''+actId) === 'II' ? 'Goose Ghetto' : ((''+actId) === 'III' ? 'Wunderswans Domain' : (''+actId)));
        if (txt) txt.textContent = label;
        try { console.info('[ActTransition] show', actId, label); } catch(_){ }
        ov.style.pointerEvents = 'auto'; ov.style.opacity = '1';
        try { console.info('[ActTransition] overlay set visible — element present?', !!ov, 'text=', (txt?txt.textContent:null)); } catch(_){ }
        const start = Date.now();
        return Promise.all([ preloadActSprites(actId, preloadTimeout), new Promise(r=>setTimeout(r, minMs)) ]).then(()=>{
            // ensure minimum display time passed
            const passed = Date.now() - start; const remain = Math.max(0, 120 - (Date.now()-start));
            setTimeout(()=>{ try { ov.style.opacity = '0'; ov.style.pointerEvents = 'none'; try { console.info('[ActTransition] hide overlay'); } catch(_){} } catch(_){}; setTimeout(()=>{ try{ if (ov && ov.parentElement) {} }catch(_){} },240); }, remain);
        }).catch(()=>{ try{ ov.style.opacity='0'; ov.style.pointerEvents='none'; }catch(_){} });
    } catch(e) { return Promise.resolve(); }
}

// ================= Simplified Title Screen =================
function showTitleScreen() {
    if (document.getElementById('titleOverlay') || game._started) return;
    document.body.classList.add('title-active');
    const overlay = document.createElement('div');
    overlay.id = 'titleOverlay';
    Object.assign(overlay.style, {
        position:'fixed', inset:'0', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center',
        background:'radial-gradient(circle at center,#111 0%,#000 70%)', zIndex:9999, gap:'32px',
        fontFamily:'Courier New,monospace', transition:'opacity 380ms ease', opacity:'1'
    });
    overlay.innerHTML = `
        <img id="titleLogo" src="assets/title.png" alt="Quack Noir" style="width:clamp(300px,60vw,780px);max-height:70vh;object-fit:contain;image-rendering:pixelated;filter:drop-shadow(0 0 12px #400060);" />
        <div id="pressStartPrompt" style="color:#bbb;font-size:22px;letter-spacing:2px;animation:pulsePrompt 2.8s ease-in-out infinite;">PRESS SPACE / CLICK TO START</div>
        <div style="position:absolute;bottom:12px;right:16px;font-size:11px;color:#444;">Build: Simplified Title v4</div>`;
    if (!document.getElementById('pulsePromptStyle')) {
        const st = document.createElement('style'); st.id='pulsePromptStyle';
        st.textContent='@keyframes pulsePrompt{0%{opacity:.35}50%{opacity:1}100%{opacity:.35}}';
        document.head.appendChild(st);
    }
    document.body.appendChild(overlay);
    // Try autoplay (may be blocked; we'll retry on input)
    try { ensureActMusic(game._selectedAct); } catch(_){}
    ensureBackgroundMusic();
    let started = false;
    // Track an in-title Act menu state when open so input handlers can route appropriately.
    let actMenuState = null;
    function begin(source){
        try { console.info('[begin] called, selectedAct=', game && game._selectedAct); } catch(_){}
        if (started) return; started = true;
        overlay.style.opacity='0';
        // Kick music again explicitly on gesture for browsers that require it
        const suppressTitleMusic = !!(game && game._titleMusicSuppressed);
        if (!suppressTitleMusic) {
            try { ensureActMusic(game._selectedAct); } catch(_){ }
            ensureBackgroundMusic();
        } else {
            try { if (game && game.bgMusic) game.bgMusic.pause(); } catch(_){ }
        }
        // Show act transition overlay and preload sprites (minimum display: 2s)
        try {
            try { console.info('[begin] calling showActTransition, typeof=', typeof showActTransition); } catch(_){}
            const p = showActTransition(game._selectedAct, { minMs: 2000, preloadTimeout: 1800 });
            try { console.info('[begin] showActTransition returned', !!p); } catch(_){}
            if (p && typeof p.then === 'function') {
                p.then(()=>{ try{ setTimeout(()=> safeStartGame(source), 220); }catch(_){ setTimeout(()=> safeStartGame(source), 420); } });
                p.catch(()=>{ setTimeout(()=> safeStartGame(source), 220); });
            } else {
                setTimeout(()=> safeStartGame(source), 220);
            }
        } catch(e) {
            try { console.warn('[begin] showActTransition threw', e); } catch(_){ }
            setTimeout(()=> safeStartGame(source), 420);
        }
    }
    // Show Act selection menu (Act II & Act III locked by default)
    function showActMenu(){
        if (actMenuState) return; // already open
        const menu = document.createElement('div');
        menu.id = 'titleActMenu';
        menu.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);min-width:280px;max-width:86vw;padding:18px 20px;border-radius:10px;background:rgba(6,6,8,0.92);border:2px solid #444;z-index:10001;display:flex;flex-direction:column;gap:12px;font-family:Courier New,monospace;color:#eee;text-align:center;box-shadow:0 8px 40px rgba(0,0,0,0.6);';
        const hdr = document.createElement('div'); hdr.textContent = 'SELECT ACT'; hdr.style.cssText = 'font-weight:800;letter-spacing:2px;color:#fff;font-size:16px;';
    const list = document.createElement('div'); list.style.cssText = 'display:flex;flex-direction:column;gap:8px;margin-top:6px;';

        // Evaluate unlocked state from runtime flags or persisted progress
        let actIIUnlocked = false; let actIIIUnlocked = false;
    try { actIIUnlocked = !!(game && game._actIIUnlocked) || (localStorage && localStorage.getItem && localStorage.getItem('actIIUnlocked') === '1'); } catch(_) { actIIUnlocked = !!(game && game._actIIUnlocked); }
    try { actIIIUnlocked = !!(game && game._actIIIUnlocked) || (localStorage && localStorage.getItem && localStorage.getItem('actIIIUnlocked') === '1'); } catch(_) { actIIIUnlocked = !!(game && game._actIIIUnlocked); }

        let acts = [ 
            { id: 'I', label: 'Act I', locked: false }, 
            { id: 'II', label: 'Act II', locked: !actIIUnlocked, lockReason: 'Find and defeat the Golden Goose' }, 
            { id: 'III', label: 'Act III', locked: !actIIIUnlocked, lockReason: 'Survive the Wunderswan' } 
        ];
    const items = [];
    const actions = []; // parallel array of actions to invoke for keyboard/enter presses
        acts.forEach((a, idx) => {
            const it = document.createElement('div');
            it.className = 'title-act-item';
            it.setAttribute('data-idx', idx);
            it.style.cssText = 'padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.04));cursor:pointer;font-size:15px;display:flex;align-items:center;justify-content:center;gap:10px;';
            if (a.locked) {
                it.style.opacity = '0.45';
                it.style.cursor = 'default';
            }
            const lockSpan = document.createElement('span');
            lockSpan.textContent = a.locked ? '🔒' : '';
            lockSpan.style.cssText = 'margin-right:6px;font-size:14px;';
            const lbl = document.createElement('span'); lbl.textContent = a.label;
            it.appendChild(lockSpan); it.appendChild(lbl);
            // Click handling
            it.onclick = (ev) => {
                if (a.locked) {
                    // small pulse to indicate locked
                    it.style.transform = 'scale(1.02)'; setTimeout(()=>{ it.style.transform='none'; },120);
                    // Show a short contextual tooltip inside the menu explaining how to unlock
                    try {
                        let hint = a.lockReason || 'Locked';
                        // Reuse or create a transient hint element on the menu
                        let hintEl = menu.querySelector('.act-locked-hint');
                        if (!hintEl) {
                            hintEl = document.createElement('div');
                            hintEl.className = 'act-locked-hint';
                            hintEl.style.cssText = 'position:absolute;left:50%;bottom:16px;transform:translateX(-50%);background:rgba(16,16,16,0.96);color:#ffd;padding:10px 14px;border-radius:8px;border:1px solid #444;box-shadow:0 6px 20px rgba(0,0,0,0.6);font-family:Courier New,monospace;font-size:13px;z-index:10002;opacity:0;transition:opacity .18s';
                            menu.appendChild(hintEl);
                        }
                        hintEl.textContent = hint;
                        // Fade in then out
                        requestAnimationFrame(()=>{ hintEl.style.opacity = '1'; });
                        clearTimeout(hintEl._hideTimeout);
                        hintEl._hideTimeout = setTimeout(()=>{ try { hintEl.style.opacity='0'; setTimeout(()=>{ try{ if(hintEl && hintEl.parentElement) hintEl.parentElement.removeChild(hintEl); }catch(_){} },220); } catch(_){} }, 2000);
                    } catch(_){}
                    return;
                }
                // Start corresponding act; set act music if applicable then begin
                try { game._selectedAct = a.id; try { ensureActMusic(game._selectedAct); } catch(_){} try { saveSelectedAct(); } catch(_){} } catch(_){}
                closeActMenu(); cleanup(); begin('title-space');
            };
            // Also register an actions entry for keyboard handling that simply triggers the click
            actions.push(()=> { try { it.click(); } catch(_){} });
            items.push(it);
            list.appendChild(it);
        });

        // Add a utility entry: Discovered Abilities (opens an overlay listing all abilities)
        try {
            const dis = document.createElement('div');
            dis.className = 'title-act-item';
            dis.style.cssText = 'padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.04));cursor:pointer;font-size:15px;display:flex;align-items:center;justify-content:center;gap:10px;';
            const icon = document.createElement('span'); icon.textContent='📜'; icon.style.cssText='margin-right:6px;';
            const lbl = document.createElement('span'); lbl.textContent = 'Discovered Abilities';
            dis.appendChild(icon); dis.appendChild(lbl);
            dis.onclick = ()=>{ try { showDiscoveredAbilities(); } catch(_){} };
            items.push(dis);
            actions.push(()=>{ try { dis.click(); } catch(_){} });
            list.appendChild(dis);
        } catch(_) {}

        // Expose a refresh method so external code (e.g. unlock handler) can update the menu
        menu._refresh = function(){
            try {
                // Re-evaluate persisted/unlocked state
                try { actIIUnlocked = !!(game && game._actIIUnlocked) || (localStorage && localStorage.getItem && localStorage.getItem('actIIUnlocked') === '1'); } catch(_) { actIIUnlocked = !!(game && game._actIIUnlocked); }
                try { actIIIUnlocked = !!(game && game._actIIIUnlocked) || (localStorage && localStorage.getItem && localStorage.getItem('actIIIUnlocked') === '1'); } catch(_) { actIIIUnlocked = !!(game && game._actIIIUnlocked); }
                // Update acts and DOM items
                acts[1].locked = !actIIUnlocked; acts[2].locked = !actIIIUnlocked;
                items.forEach((el, i)=>{
                    const a = acts[i];
                    const lockSpan = el.querySelector('span');
                    if (a.locked) { el.style.opacity='0.45'; el.style.cursor='default'; if(lockSpan) lockSpan.textContent='🔒'; }
                    else { el.style.opacity='1'; el.style.cursor='pointer'; if(lockSpan) lockSpan.textContent=''; }
                });
            } catch(_){}
        };

        const hint = document.createElement('div'); hint.textContent = 'Use ▲ ▼ to navigate — Press SPACE / ENTER / A to select — ESC to go back'; hint.style.cssText = 'color:#bdbdbd;font-size:12px;margin-top:6px;';
        menu.appendChild(hdr); menu.appendChild(list); menu.appendChild(hint);
        document.body.appendChild(menu);

        // Prefetch Act II backgrounds (gooseghetto) when the Act menu opens or when user hovers Act II.
        try {
            const gooseList = [
                'assets/streets/gooseghetto/goosestreet1.png',
                'assets/streets/gooseghetto/goosestreet2.png',
                'assets/streets/gooseghetto/goosestreet3.png',
                'assets/streets/gooseghetto/goosestreet4.png',
                'assets/streets/gooseghetto/goosestreet5.png',
                'assets/streets/gooseghetto/goosestreet6.png',
                'assets/streets/gooseghetto/goosestreet7.png',
                'assets/streets/gooseghetto/goosestreet8.png',
                'assets/streets/gooseghetto/goosestreet9.jpeg',
                'assets/streets/gooseghetto/goosestreet10.jpeg',
                'assets/streets/gooseghetto/goosestreet11.jpeg'
            ];
            const futureList = [
                'assets/streets/future/future1.png',
                'assets/streets/future/future2.png',
                'assets/streets/future/future3.png',
                'assets/streets/future/future4.jpeg',
                'assets/streets/future/future5.jpeg',
                'assets/streets/future/future6.jpeg',
                'assets/streets/future/future7.jpeg',
                'assets/streets/future/future8.jpeg',
                'assets/streets/future/future9.jpeg',
                'assets/streets/future/future10.jpeg'
            ];
            // Expose the Act III background list globally so other systems (applyActBackgrounds, preload, etc.) can use it
            try { window.FUTURE_STREET_BG_PATHS = Array.isArray(futureList) ? futureList.slice() : []; } catch(_){ }
            function startGoosePreload(){ try { if (!window._goosePreloadPromise) window._goosePreloadPromise = preloadBackgroundList(gooseList); } catch(_){} }
            function startFuturePreload(){ try { if (!window._futurePreloadPromise) window._futurePreloadPromise = preloadBackgroundList(window.FUTURE_STREET_BG_PATHS || futureList); } catch(_){} }
            const actIIItem = items[1];
            if (actIIItem) {
                try { actIIItem.tabIndex = 0; } catch(_){}
                if (!acts[1].locked) startGoosePreload();
                else { actIIItem.addEventListener('mouseenter', startGoosePreload, { passive:true }); actIIItem.addEventListener('focus', startGoosePreload, { passive:true }); }
            }
            const actIIIItem = items[2];
            if (actIIIItem) {
                try { actIIIItem.tabIndex = 0; } catch(_){ }
                // If unlocked, kick preload immediately; otherwise, preload when user hovers the locked item
                if (!acts[2].locked) startFuturePreload();
                else { actIIIItem.addEventListener('mouseenter', startFuturePreload, { passive:true }); actIIIItem.addEventListener('focus', startFuturePreload, { passive:true }); }
            }
        } catch(_){}

        // Keyboard handling for menu navigation
        let idx = 0; items[idx].style.outline = '2px solid rgba(180,120,255,0.9)'; items[idx].style.boxShadow = '0 4px 18px rgba(120,80,200,0.18)';
        function updateFocus(){
            items.forEach((el,i)=>{ el.style.outline='none'; el.style.boxShadow='none'; });
            items[idx].style.outline = '2px solid rgba(180,120,255,0.9)'; items[idx].style.boxShadow = '0 4px 18px rgba(120,80,200,0.18)';
            try { /* do not auto-scroll here to avoid fighting user scroll; controller navigation will scroll when moving focus */ } catch(_){ }
        }
        function menuKeyHandler(ev){
            const code = ev.code || ev.key;
            if (code === 'ArrowUp' || code === 'KeyW') { ev.preventDefault(); idx = (idx - 1 + items.length) % items.length; updateFocus(); return; }
            if (code === 'ArrowDown' || code === 'KeyS') { ev.preventDefault(); idx = (idx + 1) % items.length; updateFocus(); return; }
            if (code === 'Enter' || code === 'Space') { ev.preventDefault(); try { if (typeof actions[idx] === 'function') { actions[idx](); } else if (items[idx] && typeof items[idx].click === 'function') { items[idx].click(); } } catch(_) { try { items[idx].style.transform='scale(1.02)'; setTimeout(()=>{ items[idx].style.transform='none'; },120); } catch(_){} } return; }
            if (code === 'Escape') { ev.preventDefault(); closeActMenu(); return; }
        }

        // Gamepad polling for menu (separate small poller)
        let gpMenuInterval = (function(){
            // Track last axis direction per-pad to implement simple rising-edge behaviour for analog sticks
            // Use maps so multiple controllers don't clobber one another and so each pad's neutral state and cooldown are tracked independently.
            let gpLastDir = {};
            let gpLastMoveTs = {};
            const AXIS_SEARCH_MIN = 0.4; // if primary axis is small, search other axes
            const AXIS_MOVE_THRESH = 0.6; // require stronger deflection to count as a move
            const MOVE_COOLDOWN_MS = 180; // prevent rapid repeat movements
            return setInterval(()=>{
            try {
                const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
                for (let i=0;i<pads.length;i++){
                    const p = pads[i]; if (!p || !p.connected) continue;
                        const up = p.buttons && p.buttons[12];
                        const down = p.buttons && p.buttons[13];
                        const a = p.buttons && p.buttons[0];
                        // Read primary vertical axis (left stick Y) and any additional axes
                        let axisY = 0;
                        try { if (p.axes && p.axes.length >= 2) axisY = Number(p.axes[1]) || 0; } catch(_){ }
                        // Some controllers expose a hat via axes; if small axis, search for any large vertical axis
                        if (Math.abs(axisY) < AXIS_SEARCH_MIN && p.axes && p.axes.length) {
                            for (let ai=0; ai<p.axes.length; ai++) {
                                try { const v = Number(p.axes[ai]) || 0; if (Math.abs(v) > Math.abs(axisY)) axisY = v; } catch(_){ }
                            }
                        }
                        // Determine direction: -1 up, 1 down, 0 neutral
                        let dir = 0;
                        if (axisY < -AXIS_MOVE_THRESH) dir = -1;
                        else if (axisY > AXIS_MOVE_THRESH) dir = 1;
                        // If dpad buttons exist, prefer them for crisp nav
                        try { if (up && (up.pressed || up.value>0.5)) dir = -1; } catch(_){ }
                        try { if (down && (down.pressed || down.value>0.5)) dir = 1; } catch(_){ }

                        // Rising-edge: only move when dir changes from neutral to a direction for THIS pad
                        const lastDir = gpLastDir[i] || 0;
                        const now = Date.now();
                        const lastMove = gpLastMoveTs[i] || 0;
                        if (dir !== 0 && dir !== lastDir && (now - lastMove) > MOVE_COOLDOWN_MS) {
                            if (dir === -1) { idx = (idx - 1 + items.length) % items.length; updateFocus(); gpLastDir[i] = dir; gpLastMoveTs[i] = now; return; }
                            if (dir === 1) { idx = (idx + 1) % items.length; updateFocus(); gpLastDir[i] = dir; gpLastMoveTs[i] = now; return; }
                        }
                        if (dir === 0) gpLastDir[i] = 0;

                        if (a && (a.pressed || a.value>0.5)) { try { clearInterval(gpMenuInterval); try { if (items[idx] && typeof items[idx].click === 'function') items[idx].click(); else if (typeof actions[idx] === 'function') actions[idx](); } catch(_){} } catch(_){} return; }
                }
            } catch(_){ }
        }, 140);
        })();

        function closeActMenu(){
            try { window.removeEventListener('keydown', menuKeyHandler, true); } catch(_){}
            try { clearInterval(gpMenuInterval); } catch(_){}
            try { if (menu.parentElement) menu.parentElement.removeChild(menu); } catch(_){}
            actMenuState = null;
        }

        // Open a modal listing all abilities, grouped by tier and alphabetized.
        // Abilities are considered "discovered" if the player has seen the tooltip (persisted),
        // currently owns them this run, or owns them as a permanent ability.
        function showDiscoveredAbilities() {
            try { if (document.getElementById('discoveredAbilitiesOverlay')) { return; } } catch(_){ }
            const overlay = document.createElement('div'); overlay.id = 'discoveredAbilitiesOverlay';
            overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.88);z-index:20005;padding:18px;font-family:Courier New,monospace;';
            const panel = document.createElement('div');
            panel.style.cssText = 'width:min(1100px,94vw);max-height:86vh;overflow:auto;background:#0e0e0e;border:2px solid #444;border-radius:10px;padding:14px;display:flex;flex-direction:column;gap:12px;color:#eee;';
            const hdr = document.createElement('div'); hdr.textContent = 'Discovered Abilities'; hdr.style.cssText = 'font-weight:800;letter-spacing:1px;color:#fff;font-size:18px;';
            const note = document.createElement('div'); note.textContent = 'Abilities you have not yet discovered are grayed out.'; note.style.cssText = 'color:#bbb;font-size:12px;margin-top:-6px;';
            const grid = document.createElement('div');
            grid.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px;margin-top:8px;';
            try {
                // Ensure persisted seen map is loaded (harmless if already loaded)
                try { if (typeof loadSeenAbilities === 'function') loadSeenAbilities(); } catch(_){ }

                // Build array of abilities with tier info, sort by tier then name
                const list = Object.keys(ABILITIES || {}).map(name => {
                    const meta = ABILITIES[name] || {};
                    const tier = meta && meta.tier ? meta.tier : 1;
                    return { name, meta, tier };
                }).sort((a,b) => {
                    if (a.tier !== b.tier) return a.tier - b.tier;
                    return a.name.localeCompare(b.name);
                });

                // Render grouped by tier
                let currentTier = null;
                const seenMap = game && game.player && game.player._seenAbilities ? game.player._seenAbilities : {};
                list.forEach(item => {
                    try {
                        const name = item.name;
                        const meta = item.meta || {};
                        const tier = item.tier || 1;

                        // Consider an ability discovered if:
                        //  - it was explicitly seen (tooltip displayed), OR
                        //  - the player currently has it in this run, OR
                        //  - it exists in the persisted permanent abilities list.
                        const ownedNow = game && game.player && Array.isArray(game.player.abilities) && game.player.abilities.includes(name);
                        const isPermanent = game && game.player && Array.isArray(game.player.permanentAbilities) && game.player.permanentAbilities.includes(name);
                        const discovered = !!seenMap[name] || !!ownedNow || !!isPermanent;

                        if (currentTier !== tier) {
                            currentTier = tier;
                            const th = document.createElement('div');
                            th.textContent = 'Tier ' + String(tier);
                            th.style.cssText = 'grid-column:1/-1;font-weight:800;color:#eee;margin-top:6px;margin-bottom:4px;';
                            grid.appendChild(th);
                        }

                        const card = document.createElement('div');
                        card.style.cssText = 'padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(0,0,0,0.04));border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:6px;min-height:80px;';
                        if (!discovered) card.style.opacity = '0.42';

                        const title = document.createElement('div'); title.textContent = name; title.style.cssText = 'font-weight:700;';
                        if (tier === 2) title.style.color = '#88b8ff'; else if (tier === 3) title.style.color = '#ff88ff'; else title.style.color = '#dceecf';
                        const desc = document.createElement('div'); desc.textContent = meta && meta.desc ? meta.desc : ''; desc.style.cssText = 'color:#cfcfcf;font-size:13px;line-height:1.2;';

                        if (!discovered) {
                            const badge = document.createElement('div'); badge.textContent = 'NOT ACQUIRED'; badge.style.cssText = 'align-self:flex-start;background:transparent;color:#999;border:1px solid #333;border-radius:6px;padding:2px 6px;font-size:11px;letter-spacing:0.4px;';
                            card.appendChild(badge);
                        }

                        card.appendChild(title); card.appendChild(desc);
                        grid.appendChild(card);
                    } catch(_){ }
                });
            } catch(_){ }
            const actions = document.createElement('div'); actions.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;margin-top:8px;';
            const btnClose = document.createElement('button'); btnClose.textContent = 'Close'; btnClose.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #666;color:#ddd;border-radius:6px;cursor:pointer;';
            btnClose.onclick = ()=>{ try { overlay.remove(); } catch(_){} };
            actions.appendChild(btnClose);
            panel.appendChild(hdr); panel.appendChild(note); panel.appendChild(grid); panel.appendChild(actions);
            overlay.appendChild(panel); document.body.appendChild(overlay);

            // keyboard: ESC to close
            const esc = (e)=>{ if (e.key === 'Escape') { e.preventDefault(); try{ overlay.remove(); } catch(_){} window.removeEventListener('keydown', esc, true); } };
            window.addEventListener('keydown', esc, true);
        }

        // Expose a minimal control so other handlers can query presence
        actMenuState = { close: closeActMenu };
        // Add key listener (capture so it wins before other handlers)
        window.addEventListener('keydown', menuKeyHandler, true);
    }
    function keyHandler(ev){
        if (ev.code==='Space') { ev.preventDefault(); // open Act menu instead of starting immediately
            showActMenu(); }
    }
    function clickHandler(){
        // Open Act menu instead of immediately starting
        showActMenu();
    }
    function gamepadHandler(){
        try {
            const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
            for (let i=0;i<pads.length;i++){
                const p = pads[i];
                if (!p || !p.connected) continue;
                const a = p.buttons && p.buttons[0];
                const start = p.buttons && p.buttons[9];
                if ((a && (a.pressed || (a.value>0.5))) || (start && (start.pressed || (start.value>0.5)))) {
                    // If Act menu is open, ignore the global begin and let the menu poller handle selection
                    if (actMenuState) return;
                    // Controller 'A' / Start should open the Act selection menu (same as Space / click)
                    try { showActMenu(); } catch(e) { try { cleanup(); begin('title-gamepad'); } catch(_) {} }
                    return;
                }
            }
        } catch(_){ }
    }

    // Centralized Act III unlock handler — use this to ensure runtime flag, persistence, and UI refresh occur together.
    function unlockActIII(source) {
        try { if (!game) window.game = window.game || {}; } catch(_){}
        try { game._actIIIUnlocked = true; } catch(_){}
        try { if (localStorage && localStorage.setItem) localStorage.setItem('actIIIUnlocked', '1'); } catch(_){}
        try {
            try { if (localStorage && localStorage.setItem) localStorage.setItem('lastUnlockEvent', JSON.stringify({ ts: Date.now(), source: source || 'unknown' })); } catch(_){ }
            // Record an explicit persistent event so it can be inspected after spam
            // Briefly suppress noisy console.info flood so the unlock log is visible in console
            try {
                if (!console._origInfo) console._origInfo = console.info;
                console._silencedUntil = Math.max(console._silencedUntil || 0, Date.now() + 1600);
                console.info = function(){ if (Date.now() < (console._silencedUntil||0)) return; try { return console._origInfo.apply(console, arguments); } catch(e){} };
            } catch(_){}
            // Visible developer log
            try { if (typeof devLog === 'function') devLog('[Progress] Act III unlocked (' + (source||'unknown') + ')'); } catch(_){}
            try { console.info('[Progress] Act III unlocked', source || 'unknown'); } catch(_){}
        } catch(_){}
        // If act menu is open, refresh it so the unlocked state shows immediately
        try {
            const menu = document.getElementById('titleActMenu');
            if (menu && typeof menu._refresh === 'function') menu._refresh();
        } catch(_){ }
        // Show toast (with fallback) to ensure player sees the unlock regardless of overlay state
        try {
            const toastMsg = 'Act III unlocked!';
            try { if (typeof showToast === 'function') showToast(toastMsg); } catch(_){ }
            try {
                const now = Date.now();
                try { window._last_toast_shown_ts = window._last_toast_shown_ts || 0; } catch(_){ }
                if (!window._last_toast_shown_ts || (now - window._last_toast_shown_ts) > 2800) {
                    setTimeout(()=>{
                        try {
                            if (!window._qn_toast_el && !document.getElementById('qn_toast')) {
                                const fel = document.createElement('div');
                                fel.id = 'qn_toast_fallback';
                                fel.textContent = toastMsg;
                                fel.style.cssText = 'position:fixed;left:50%;top:14px;transform:translateX(-50%);padding:10px 16px;background:rgba(24,24,28,0.98);color:#ffd;border-radius:8px;border:1px solid rgba(255,255,255,0.06);z-index:45000;font-family:Courier New,monospace;font-size:14px;box-shadow:0 8px 30px rgba(0,0,0,0.6);';
                                try { document.body.appendChild(fel); } catch(_){ }
                                setTimeout(()=>{ try { fel.style.opacity='0'; fel.remove(); } catch(_){} }, 2200);
                            }
                        } catch(_){ }
                    }, 60);
                    try { window._last_toast_shown_ts = now; } catch(_){ }
                }
            } catch(_){ }
        } catch(_){ }
    }

    // Lightweight on-screen toast used for unlock notifications. If a more advanced
    // implementation exists elsewhere, this will not clobber it.
    function showToast(msg, opts) {
        try {
            if (typeof msg !== 'string') msg = String(msg || '');
            if (window._qn_toast_el) {
                try {
                    if (window._qn_toast_el._repositionHandler) {
                        window.removeEventListener('resize', window._qn_toast_el._repositionHandler);
                    }
                } catch(_) {}
                try { window._qn_toast_el.remove(); } catch(_) {}
                window._qn_toast_el = null;
            }
            const el = document.createElement('div');
            el.id = 'qn_toast';
            el.style.cssText = 'position:fixed;left:50%;transform:translateX(-50%);padding:12px 18px;background:rgba(20,20,24,0.96);color:#ffd;border-radius:8px;border:1px solid rgba(255,255,255,0.06);z-index:40000;font-family:Courier New,monospace;font-size:14px;box-shadow:0 8px 30px rgba(0,0,0,0.6);opacity:0;transition:opacity .28s,transform .28s;display:flex;flex-direction:column;align-items:center;text-align:center;gap:4px;';
            const title = document.createElement('div');
            title.textContent = msg;
            title.style.cssText = 'font-weight:700;letter-spacing:0.5px;color:#ffeb9d;';
            el.appendChild(title);
            if (opts && opts.subtitle) {
                const sub = document.createElement('div');
                sub.textContent = String(opts.subtitle || '');
                sub.style.cssText = 'font-size:12px;color:#b8e6ff;opacity:0.88;letter-spacing:0.2px;';
                el.appendChild(sub);
            }
            document.body.appendChild(el);
            window._qn_toast_el = el;
            const reposition = () => {
                try {
                    const viewportH = window.innerHeight || document.documentElement.clientHeight || 0;
                    let top = 14;
                    const achContainer = document.getElementById('achvToastContainer');
                    if (achContainer) {
                        const rect = achContainer.getBoundingClientRect();
                        if (rect && rect.bottom) top = Math.round(rect.bottom + 12);
                    } else {
                        const canvasEl = document.getElementById('gameCanvas');
                        if (canvasEl) {
                            const rect = canvasEl.getBoundingClientRect();
                            if (rect && rect.top) top = Math.round(rect.top + 14);
                        }
                    }
                    if (viewportH) {
                        const maxTop = Math.max(12, viewportH - 120);
                        if (top > maxTop) top = maxTop;
                        if (top < 8) top = 8;
                    }
                    el.style.top = top + 'px';
                } catch(_) {
                    el.style.top = '14px';
                }
            };
            reposition();
            try {
                el._repositionHandler = reposition;
                window.addEventListener('resize', reposition);
                requestAnimationFrame(reposition);
            } catch(_) {}
            // entrance
            requestAnimationFrame(()=>{ try { el.style.opacity='1'; el.style.transform='translateX(-50%) translateY(0)'; } catch(_){} });
            const ttl = opts && typeof opts.ttl === 'number' ? opts.ttl : (opts && opts.subtitle ? 3200 : 2400);
            setTimeout(()=>{
                try { el.style.opacity='0'; el.style.transform='translateX(-50%) translateY(-6px)'; } catch(_){ }
                setTimeout(()=>{
                    try {
                        if (el && el._repositionHandler) window.removeEventListener('resize', el._repositionHandler);
                    } catch(_){ }
                    try { if (el && el.parentElement) el.parentElement.removeChild(el); } catch(_){ }
                    try { if (window._qn_toast_el === el) window._qn_toast_el = null; } catch(_){ }
                }, 320);
            }, ttl);
        } catch(_){ }
    }
    try {
        if (typeof window !== 'undefined' && window) {
            if (typeof window.showToast !== 'function') window.showToast = showToast;
        }
    } catch(_){ }

    function showStackedToast(msg, opts){
        try {
            ensureToastContainer();
            ensureAchvFxStyles();
            const container = document.getElementById('achvToastContainer');
            if (!container) { showToast(msg, opts); return; }
            try { console.info('[ToastStack] stacking toast', { msg, hasContainer:true }); } catch(_){ }
            const el = document.createElement('div');
            el.className = 'achvToast achvToast-secondary';
            el.style.pointerEvents = 'none';
            const title = document.createElement('div');
            title.style.cssText = 'font-weight:700;color:#66c2ff;letter-spacing:0.4px;margin-bottom:4px;';
            title.textContent = msg;
            el.appendChild(title);
            if (opts && opts.subtitle) {
                const sub = document.createElement('div');
                sub.style.cssText = 'font-size:12px;color:#c9eaff;opacity:0.92;letter-spacing:0.2px;';
                sub.textContent = String(opts.subtitle || '');
                el.appendChild(sub);
            }
            container.appendChild(el);
            try { positionAchvToastContainer(); } catch(_){ }
            el.style.opacity = '0';
            el.style.transform = 'translateY(-6px)';
            requestAnimationFrame(()=>{
                try {
                    el.style.transition = 'opacity .28s ease, transform .28s ease';
                    el.style.opacity = '1';
                    el.style.transform = 'translateY(0)';
                } catch(_){ }
            });
            const ttl = (opts && typeof opts.ttl === 'number') ? opts.ttl : 12000;
            setTimeout(()=>{
                try {
                    el.style.opacity = '0';
                    el.style.transform = 'translateY(-8px)';
                    setTimeout(()=>{ try { el.remove(); } catch(_){ } }, 320);
                } catch(_){ try { el.remove(); } catch(__){} }
            }, ttl);
        } catch(err){
            try { console.warn('[ToastStack] fallback to showToast', err); } catch(_){ }
            try { showToast(msg, opts); } catch(_){ }
        }
    }
    try {
        if (typeof window !== 'undefined' && window) {
            if (typeof window.showStackedToast !== 'function') window.showStackedToast = showStackedToast;
        }
    } catch(_){ }

    // Centralized Act II unlock handler — use this to ensure runtime flag, persistence, and UI refresh occur together.
    function unlockActII(source) {
        try { if (!game) window.game = window.game || {}; } catch(_){ }
        try { game._actIIUnlocked = true; } catch(_){ }
        try { if (localStorage && localStorage.setItem) localStorage.setItem('actIIUnlocked', '1'); } catch(_){ }
        try { if (localStorage && localStorage.setItem) localStorage.setItem('lastUnlockEvent', JSON.stringify({ ts: Date.now(), source: source || 'unknown' })); } catch(_){ }
        try { if (typeof devLog === 'function') devLog('[Progress] Act II unlocked (' + (source||'unknown') + ')'); } catch(_){ }
        try { console.info('[Progress] Act II unlocked', source || 'unknown'); } catch(_){ }
        // Allow callers to suppress the toast for special contexts (e.g. Act II final boss sequence)
        try {
            const s = source && String(source || '').toLowerCase();
            const suppressToast = s && (s.indexOf('no-toast') !== -1 || s.indexOf('suppress') !== -1 || s.indexOf('final-boss') !== -1);
            if (!suppressToast) {
                try { if (typeof showToast === 'function') showToast('Act II unlocked!'); } catch(_){ }
                // Robustness: if showToast failed or the toast was swallowed, create a lightweight fallback toast.
                try {
                    const now = Date.now();
                    try { window._last_toast_shown_ts = window._last_toast_shown_ts || 0; } catch(_){}
                    // Only show fallback if we haven't shown a toast very recently
                    if (!window._last_toast_shown_ts || (now - window._last_toast_shown_ts) > 2800) {
                        setTimeout(()=>{
                            try {
                                // If the main toast element isn't present, create a simple fallback
                                if (!window._qn_toast_el && !document.getElementById('qn_toast')) {
                                    const fel = document.createElement('div');
                                    fel.id = 'qn_toast_fallback';
                                    fel.textContent = 'Act II unlocked!';
                                    fel.style.cssText = 'position:fixed;left:50%;top:14px;transform:translateX(-50%);padding:10px 16px;background:rgba(20,20,24,0.96);color:#ffd;border-radius:8px;border:1px solid rgba(255,255,255,0.06);z-index:45000;font-family:Courier New,monospace;font-size:14px;box-shadow:0 8px 30px rgba(0,0,0,0.6);';
                                    try { document.body.appendChild(fel); } catch(_){}
                                    setTimeout(()=>{ try { fel.style.opacity='0'; fel.remove(); } catch(_){} }, 2200);
                                }
                            } catch(_){}
                        }, 60);
                        try { window._last_toast_shown_ts = now; } catch(_){}
                    }
                } catch(_){}
            }
        } catch(_){}
        try {
            const menu = document.getElementById('titleActMenu');
            if (menu && typeof menu._refresh === 'function') menu._refresh();
        } catch(_){ }
        // After authoritative handler runs, flush any queued early unlock attempts
        try { if (typeof window._flushUnlockActIIQueue === 'function') { try { window._flushUnlockActIIQueue(); } catch(_){} } } catch(_){ }
    }

    // Lightweight on-screen developer event log to survive console spam.
    function devLog(msg) {
        try {
            if (!window._devLogEl) {
                const el = document.createElement('div');
                el.id = 'devEventLog';
                el.style.cssText = 'position:fixed;right:12px;top:12px;max-width:34vw;min-width:220px;max-height:40vh;overflow:auto;padding:8px 10px;background:rgba(6,6,8,0.85);color:#ffd;border:1px solid rgba(255,255,255,0.06);border-radius:8px;font-family:monospace;font-size:12px;line-height:1.25;z-index:20002;box-shadow:0 6px 30px rgba(0,0,0,0.6);backdrop-filter: blur(3px);';
                el.innerHTML = '<div style="font-weight:700;margin-bottom:6px;color:#fff">DEV LOG</div>';
                document.body.appendChild(el);
                window._devLogEl = el;
            }
            const el = window._devLogEl;
            const row = document.createElement('div');
            row.style.cssText = 'padding:3px 0;border-top:1px dashed rgba(255,255,255,0.03);font-size:12px;color:#ffd;';
            const time = new Date().toISOString().replace('T',' ').replace('Z','');
            row.textContent = time + ' — ' + String(msg || '');
            el.appendChild(row);
            // keep last 30 entries
            while (el.children.length > 35) el.removeChild(el.children[1]);
            try { el.scrollTop = el.scrollHeight; } catch(_){}
        } catch(_){}
    }

    // Developer hotkey: Ctrl+Alt+U to force-unlock Act III for testing
    try {
        window.addEventListener('keydown', function(e){
            try {
                if (e && e.ctrlKey && e.altKey && (e.key === 'u' || e.key === 'U')) {
                    try { unlockActIII('hotkey'); } catch(_){}
                    try { devLog('Force unlock hotkey used'); } catch(_){}
                }
            } catch(_){}
        }, false);
    } catch(_){}
    function cleanup(){
        window.removeEventListener('keydown', keyHandler);
        overlay.removeEventListener('click', clickHandler);
        overlay.removeEventListener('touchstart', clickHandler);
    }
    window.addEventListener('keydown', keyHandler);
    overlay.addEventListener('click', clickHandler, { passive:true });
    overlay.addEventListener('touchstart', clickHandler, { passive:true });
    // Allow A/Start to begin on title screen (polling while overlay visible)
    // Poll for A/Start on title overlay but require a rising-edge (release then press)
    // and avoid starting the run if the Act menu is already open. This prevents
    // accidental skips when switching input methods (keyboard -> controller).
    (function(){
        let lastPressed = false;
        const gpInterval = setInterval(()=>{
            const to = document.getElementById('titleOverlay');
            if (!to) { clearInterval(gpInterval); return; }
            // If Act selection already open, don't interpret A/Start here
            if (document.getElementById('titleActMenu')) return;
            try {
                const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
                let anyPressed = false;
                for (let i=0; i<pads.length; i++) {
                    const p = pads[i];
                    if (!p || !p.connected) continue;
                    const a = p.buttons && p.buttons[0];
                    const start = p.buttons && p.buttons[9];
                    if ((a && (a.pressed || (a.value>0.5))) || (start && (start.pressed || (start.value>0.5)))) {
                        anyPressed = true; break;
                    }
                }
                // rising edge detection: only act when button is pressed now but wasn't pressed last poll
                if (anyPressed && !lastPressed) {
                    cleanup();
                    try { showActMenu(); } catch(e) { try { begin('title-gamepad'); } catch(_){} }
                }
                lastPressed = anyPressed;
            } catch(_) {}
        }, 120);
    })();
    // Also react to a newly connected pad (poller above will handle the input)
    window.addEventListener('gamepadconnected', ()=>{});
}
window.addEventListener('load', showTitleScreen);

// ================= Touch Controls (Adaptive) =================
// Provide an on-screen joystick + fire button if the user is on a touch-capable device
// and no keyboard / mouse input has been detected yet. Hides automatically on first
// hardware keyboard/mouse interaction to avoid clutter for desktop users.
(() => {
    game._hardwareInputDetected = false;
    game._touchControlsInitialized = false;
    game._touchFireInterval = null; // legacy (no longer used)
    // Removed game.touchFireActive flag; touch fire now directly toggles the spacebar key state for unified cooldown logic.
    const hwHandler = () => {
        game._hardwareInputDetected = true;
        // If touch controls are visible, hide them (user clearly has hardware input)
        const tc = document.getElementById('touchControlsContainer');
        if (tc) tc.style.display = 'none';
        window.removeEventListener('keydown', hwHandler, { passive: true });
    };
    // Only key presses count as hardware (keyboard) input now; mouse movement/clicks no longer disable touch controls.
    // This prevents normal screen taps (which some engines surface as synthetic mouse events) from hiding the overlay.
    window.addEventListener('keydown', hwHandler, { passive: true });

    function shouldUseTouchControls() {
        const touchCapable = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
        return touchCapable && !game._hardwareInputDetected;
    }

    // Removed ensureTouchFireLoop & per-frame touchFireActive polling; we now just set game.keys[' '] on press/release.

    function setDirectionalKeys(dx, dy) {
        // Reset movement keys
        const k = game.keys;
        k['w'] = k['a'] = k['s'] = k['d'] = false;
        if (Math.abs(dy) > 0.25) { if (dy < 0) k['w'] = true; else k['s'] = true; }
        if (Math.abs(dx) > 0.25) { if (dx < 0) k['a'] = true; else k['d'] = true; }
    }

    function initTouchControls() {
        if (game._touchControlsInitialized) return;
        game._touchControlsInitialized = true;
        const container = document.createElement('div');
        container.id = 'touchControlsContainer';
        container.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:12000;';

        // Joystick base
        const joyBase = document.createElement('div');
        joyBase.id = 'touchJoyBase';
        joyBase.style.cssText = 'position:absolute;left:24px;bottom:24px;width:110px;height:110px;border:2px solid #444;background:rgba(0,0,0,0.35);border-radius:50%;pointer-events:auto;touch-action:none;';
        const joyStick = document.createElement('div');
        joyStick.id = 'touchJoyStick';
        joyStick.style.cssText = 'position:absolute;left:50%;top:50%;width:48px;height:48px;transform:translate(-50%,-50%);background:rgba(0,255,136,0.55);border:2px solid #0f8;border-radius:50%;box-shadow:0 0 6px #0f8;';
        joyBase.appendChild(joyStick);

        // Fire button
        const fireBtn = document.createElement('div');
        fireBtn.id = 'touchFireBtn';
        fireBtn.textContent = 'FIRE';
        fireBtn.style.cssText = 'position:absolute;right:34px;bottom:40px;width:100px;height:100px;border:2px solid #aa2222;border-radius:50%;background:rgba(255,40,40,0.4);display:flex;align-items:center;justify-content:center;font:700 16px Courier New,monospace;color:#fff;box-shadow:0 0 8px #f33;pointer-events:auto;touch-action:none;user-select:none;';

        container.appendChild(joyBase);
        container.appendChild(fireBtn);
        document.body.appendChild(container);

        let activeJoyId = null;
        let joyCenter = { x: 0, y: 0 };

        function handleJoyStart(e) {
            const touch = (e.changedTouches ? e.changedTouches[0] : e);
            activeJoyId = touch.identifier !== undefined ? touch.identifier : 'mouse';
            const rect = joyBase.getBoundingClientRect();
            joyCenter.x = rect.left + rect.width/2;
            joyCenter.y = rect.top + rect.height/2;
            updateJoy(touch);
            e.preventDefault();
        }
        function updateJoy(touch) {
            const dx = touch.clientX - joyCenter.x;
            const dy = touch.clientY - joyCenter.y;
            const maxR = 44; // radius limit for stick movement
            let dist = Math.sqrt(dx*dx + dy*dy);
            let nx = 0, ny = 0;
            if (dist > 0) {
                nx = dx / dist; ny = dy / dist;
                if (dist > maxR) dist = maxR;
            }
            joyStick.style.left = (50 + (dist * nx) / maxR * 50) + '%';
            joyStick.style.top  = (50 + (dist * ny) / maxR * 50) + '%';
            setDirectionalKeys(nx, ny);
        }
        function handleJoyMove(e) {
            if (activeJoyId === null) return;
            const touches = e.changedTouches ? Array.from(e.changedTouches) : [e];
            for (const t of touches) {
                const id = t.identifier !== undefined ? t.identifier : 'mouse';
                if (id === activeJoyId) { updateJoy(t); break; }
            }
            e.preventDefault();
        }
        function handleJoyEnd(e) {
            const touches = e.changedTouches ? Array.from(e.changedTouches) : [e];
            for (const t of touches) {
                const id = t.identifier !== undefined ? t.identifier : 'mouse';
                if (id === activeJoyId) {
                    activeJoyId = null;
                    joyStick.style.left = '50%';
                    joyStick.style.top = '50%';
                    setDirectionalKeys(0,0);
                    break;
                }
            }
        }

        // Attach joystick listeners
        joyBase.addEventListener('touchstart', handleJoyStart, { passive: false });
        joyBase.addEventListener('touchmove', handleJoyMove, { passive: false });
        joyBase.addEventListener('touchend', handleJoyEnd, { passive: false });
        joyBase.addEventListener('touchcancel', handleJoyEnd, { passive: false });
        // (Optional mouse support for debugging on desktop)
        joyBase.addEventListener('mousedown', handleJoyStart);
        window.addEventListener('mousemove', handleJoyMove);
        window.addEventListener('mouseup', handleJoyEnd);

    function fireStart(e) { game.keys[' '] = true; e.preventDefault(); }
    function fireEnd(e) { game.keys[' '] = false; e.preventDefault(); }
        fireBtn.addEventListener('touchstart', fireStart, { passive: false });
        fireBtn.addEventListener('touchend', fireEnd, { passive: false });
        fireBtn.addEventListener('touchcancel', fireEnd, { passive: false });
        fireBtn.addEventListener('mousedown', fireStart);
        window.addEventListener('mouseup', fireEnd);
    }

    // Defer initialization slightly so hardware inputs can register first.
    document.addEventListener('DOMContentLoaded', () => {
           const cv = document.getElementById('gameCanvas');
           if (cv) { cv.style.display='block'; cv.style.visibility='visible'; }
    });

    // Public hook if we ever need to re-evaluate after a reset
    window.__maybeInitTouch = () => { if (shouldUseTouchControls()) initTouchControls(); };
})();
// =============================================================

// Apply current preference to an existing or newly created bgMusic element without flipping state
function applyMusicPreference(autoPlayIfEnabled=true) {
    if (!game.bgMusic) return;
    if (game._titleMusicSuppressed) {
        game.bgMusic.muted = !game.musicEnabled;
        if (game.musicEnabled) {
            try { game.bgMusic.pause(); } catch(_){ }
            try { game.bgMusic.currentTime = 0; } catch(_){ }
        }
        return;
    }
    game.bgMusic.muted = !game.musicEnabled;
    if (game.musicEnabled && autoPlayIfEnabled) {
        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
    } else if (!game.musicEnabled) {
        try { game.bgMusic.pause(); } catch(e) {}
    }
}

// Ensure act-specific music is set when a new act is chosen.
function ensureActMusic(actId) {
    if (game && game._titleMusicSuppressed) {
        try { if (game.bgMusic) game.bgMusic.pause(); } catch(_){ }
        return;
    }
    try {
        // Normalize input
        const act = (typeof actId === 'undefined' || actId === null) ? '' : String(actId);
        // Map act to desired source
        let desired = 'assets/audio/QuackshotChronicles.mp3';
        if (act === 'II') desired = 'assets/audio/GooseGhetto.mp3';
        else if (act === 'III') desired = 'assets/audio/MetalHeartsCollide.mp3';

        // Helper: compare only filename portion (URL may be absolute)
        const curSrc = (game && game.bgMusic && game.bgMusic.src) ? String(game.bgMusic.src) : '';
        const curHas = curSrc.indexOf(desired) !== -1 || curSrc.indexOf(desired.replace(/^assets\//,'')) !== -1;

        // If the current bgMusic already matches desired, just apply prefs and return
        if (curHas) {
            try { applyMusicPreference(); } catch(_){}
            try { updateAudioButtons(); } catch(_){}
            try { game._actMusicSet = (act === 'II' || act === 'III'); } catch(_){}
            return;
        }

        // Otherwise, switch to the desired track explicitly
        try { if (game && game.bgMusic) { try { game._prevMusicSrc = game.bgMusic.src; try { game.bgMusic.pause(); } catch(_){} } catch(_){} } } catch(_){}
        try {
            const m = new Audio(desired);
            m.loop = true;
            // Keep default volume/handoff consistent with other code paths
            try { m.volume = (typeof game.bgMusic !== 'undefined' && game.bgMusic && typeof game.bgMusic.volume === 'number') ? game.bgMusic.volume : 0.55; } catch(_){}
            game.bgMusic = m;
            try { applyMusicPreference(); } catch(_){}
            try { updateAudioButtons(); } catch(_){}
            try { game._actMusicSet = (act === 'II' || act === 'III'); } catch(_){}
        } catch(e) {
            console.warn('[ensureActMusic] failed to set bgMusic', e);
        }
    } catch(_){}
}

/*
 Attributions:
 Powerup 10.wav by LilMati -- https://freesound.org/s/523654/ -- License: Creative Commons 0
*/
function ensurePowerupSfx() {
    try {
        if (!game._powerupSfx) {
            const a = new Audio('assets/audio/523654__lilmati__powerup-10.wav');
            a.preload = 'auto';
            a.volume = 0.85;
            game._powerupSfx = a;
        }
    } catch(_) {}
}
function playPowerupSfx() {
    if (!game.sfxEnabled) return;
    try {
        ensurePowerupSfx();
        const a = game._powerupSfx;
        if (!a) return;
        // Restart from beginning for rapid successive pickups
        try { a.currentTime = 0; } catch(_) {}
        a.play().catch(()=>{});
    } catch(_) {}
}

/*
 Attributions:
 Retro, Explosion 07.wav by LilMati -- https://freesound.org/s/521105/ -- License: Creative Commons 0
*/
function ensureNukeExplosionSfx() {
    try {
        if (!game._sfxNukeExplosion) {
            const a = new Audio('assets/audio/521105__lilmati__retro-explosion-07.wav');
            a.preload = 'auto';
            a.volume = 0.95;
            game._sfxNukeExplosion = a;
        }
    } catch(_) {}
}
function playNukeExplosionSfx() {
    if (!game.sfxEnabled) return;
    try {
        ensureNukeExplosionSfx();
        const a = game._sfxNukeExplosion;
        if (!a) return;
        try { a.currentTime = 0; } catch(_) {}
        a.play().catch(()=>{});
    } catch(_) {}
}
/*
 Attributions:
 retro explosion by EtherAudio -- https://freesound.org/s/815348/ -- License: Attribution 4.0
*/
function ensureMeteorExplosionSfx() {
    try {
        if (!game._sfxMeteorExplosion) {
            const a = new Audio('assets/audio/815348__etheraudio__retro-explosion.wav');
            a.preload = 'auto';
            a.volume = 0.9;
            game._sfxMeteorExplosion = a;
        }
    } catch(_) {}
}
function playMeteorExplosionSfx() {
    if (!game.sfxEnabled) return;
    try {
        ensureMeteorExplosionSfx();
        const a = game._sfxMeteorExplosion;
        if (!a) return;
        try { a.currentTime = 0; } catch(_) {}
        a.play().catch(()=>{});
    } catch(_) {}
}

/*
 Attributions (commented per request):
 // Crunch by qubodup -- https://freesound.org/s/816237/ -- License: Creative Commons 0
*/
function ensureBreadCrunchSfx() {
    try {
        if (!game._sfxBreadCrunch) {
            const a = new Audio('assets/audio/816237__qubodup__crunch.wav');
            a.preload = 'auto';
            a.volume = 0.85;
            game._sfxBreadCrunch = a;
        }
    } catch(_) {}
}
function playBreadCrunchSfx() {
    if (!game.sfxEnabled) return;
    try {
        ensureBreadCrunchSfx();
        const a = game._sfxBreadCrunch;
        if (!a) return;
        try { a.currentTime = 0; } catch(_) {}
        a.play().catch(()=>{});
    } catch(_) {}
}

// Unified UI sync for any audio controls present (legacy + pause menu)
function updateAudioButtons() {
    try {
        // Legacy top-level buttons (if any)
        const bs = document.getElementById('btnToggleSfx');
        const bm = document.getElementById('btnToggleMusic');
        if (bs) bs.textContent = (game.sfxEnabled ? 'SFX: ON' : 'SFX: OFF');
        if (bm) bm.textContent = (game.musicEnabled ? 'Music: ON' : 'Music: OFF');
        // Pause overlay options buttons
        const sfxBtn = document.getElementById('optToggleSfx');
        const musicBtn = document.getElementById('optToggleMusic');
        const cosBtn = document.getElementById('optToggleCosmetic');
        if (sfxBtn) sfxBtn.textContent = 'SFX: ' + (game.sfxEnabled ? 'ON' : 'OFF');
        if (musicBtn) musicBtn.textContent = 'Music: ' + (game.musicEnabled ? 'ON' : 'OFF');
        if (cosBtn) cosBtn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF');
        // Also reuse the more detailed reflect method if present (updates gamepad labels, too)
        if (typeof reflectOptionStates === 'function') {
            try { reflectOptionStates(); } catch(_) {}
        }
    } catch(_) {}
}

// Toggle helpers for Options UI
function toggleSfx() {
    game.sfxEnabled = !game.sfxEnabled;
    saveAudioPreferences();
    updateAudioButtons();
}

function toggleMusic() {
    game.musicEnabled = !game.musicEnabled;
    saveAudioPreferences();
    // Apply immediately; allow autoplay when enabling from a user gesture
    if (game.musicEnabled) {
        // Ensure bgMusic exists when turning music ON mid-session
        try { ensureBackgroundMusic(); } catch(_) {}
    }
    applyMusicPreference(true);
    updateAudioButtons();
}

function showAbilityChoiceUI(options) {
    const overlay = document.createElement('div');
    overlay.id = 'abilityChoiceOverlay';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center;
        z-index: 1001; font-family: 'Courier New', monospace;
    `;

    const container = document.createElement('div');
    container.style.cssText = `
        display: flex; gap: 20px; background: #222; padding: 20px; border-radius: 10px;
        border: 2px solid #666;
    `;

    const tierStyles = {
        1: { border:'#5aa84d', glow:'#5aa84d88', bg:'#0d2a0d', label:'Tier I' },
        2: { border:'#3d7dd9', glow:'#3d7dd988', bg:'#0a1d33', label:'Tier II' },
        3: { border:'#c68b1a', glow:'#c68b1acc', bg:'#2a1d05', label:'Tier III' }
    };
    // Inject one-time keyframe styles if not present
    if (!document.getElementById('permAbilityFXStyles')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'permAbilityFXStyles';
        styleEl.textContent = `@keyframes badgePop {0%{transform:scale(.4) translateY(-8px);opacity:0}60%{transform:scale(1.08) translateY(0);opacity:1}100%{transform:scale(1) translateY(0);opacity:1}}
        @keyframes flairFloat {0%{transform:translateY(0) scale(.6);opacity:0}20%{opacity:1}80%{opacity:1}100%{transform:translateY(-38px) scale(1.1);opacity:0}}
        .synergy-tip {position:absolute;left:50%;top:100%;transform:translate(-50%,12px);background:#111;padding:8px 10px;border:1px solid #555;border-radius:6px;color:#eee;font:11px/1.3 'Courier New',monospace;width:220px;pointer-events:none;opacity:0;transition:opacity .18s;z-index:40;box-shadow:0 0 6px #000}
        .ability-card.permanent:hover .synergy-tip {opacity:1}
        `;
        document.head.appendChild(styleEl);
    }
    // Simple synergy hint generator (lightweight heuristic)
    function buildSynergyHint(ab){
        const meta = ABILITIES[ab]; if(!meta||!meta.effect) return 'Passive enhancement.';
        const eff = meta.effect; const tips = [];
        if (eff.damageType) tips.push(`Combines with other ${eff.damageType} sources for amplified status.`);
        if (eff.projectileCount) tips.push('Stacks with multi-shot to flood patterns.');
        if (eff.spiralPattern || eff.sineWave || eff.wackyZigzag || eff.ekgWave) tips.push('Motion pattern contributes to resonance combos.');
        if (eff.explosive || eff.chainExplosion || eff.novaBlast) tips.push('Explosion effects can trigger combust synergies.');
        if (eff.dimensional) tips.push('Rifts manipulate and duplicate passing projectiles.');
        if (eff.timeWarp) tips.push('Time Warp can extend airborne telegraphs (meteors / bombs).');
        if (!tips.length) return 'General utility ability.';
        return tips.slice(0,3).join(' ');
    }
    const flairIntervals = [];
    options.forEach((ability, idx) => {
        const meta = ABILITIES[ability];
        const tier = meta && meta.tier || 1;
        const style = tierStyles[tier] || tierStyles[1];
        const card = document.createElement('div');
        card.className = 'ability-card permanent';
        card.style.cssText = `min-width:200px;max-width:240px;padding:14px 16px;background:${style.bg};`+
            `border:3px solid ${style.border};border-radius:10px;position:relative;`+
            `box-shadow:0 0 10px ${style.glow}, inset 0 0 8px #000;display:flex;flex-direction:column;gap:8px;`+
            `transition:transform .15s, box-shadow .2s;`;
        card.onmouseenter = ()=>{ card.style.transform='translateY(-4px)'; card.style.boxShadow=`0 0 16px ${style.glow}, 0 0 4px ${style.border}`; };
        card.onmouseleave = ()=>{ card.style.transform='none'; card.style.boxShadow=`0 0 10px ${style.glow}, inset 0 0 8px #000`; };

    const badge = document.createElement('div');
        badge.textContent = style.label;
        badge.style.cssText = `position:absolute;top:-12px;left:12px;padding:2px 8px;`+
            `background:${style.border};color:#fff;font:600 11px 'Courier New',monospace;`+
            `border-radius:4px;text-shadow:0 0 4px #000;letter-spacing:1px;`+
            `animation:badgePop .42s cubic-bezier(.25,1.4,.45,1) ${idx*0.08}s both;`;
        card.appendChild(badge);

        const nameDiv = document.createElement('div');
        nameDiv.className = 'ability-card-name';
        nameDiv.textContent = ability;
        nameDiv.style.cssText = 'font:700 18px Courier New,monospace;color:#fff;text-shadow:0 0 6px '+style.glow+';';
        const descDiv = document.createElement('div');
        descDiv.className = 'ability-card-desc';
        descDiv.textContent = meta ? meta.desc : '';
        descDiv.style.cssText = 'font:13px/1.3 Courier New,monospace;color:#ddd;min-height:48px;';

        card.appendChild(nameDiv);
        card.appendChild(descDiv);
        // Synergy tooltip
        const tip = document.createElement('div');
        tip.className = 'synergy-tip';
        tip.textContent = buildSynergyHint(ability);
        card.appendChild(tip);
        // Tier III flair particles (ambient floating sparks)
        if (tier === 3) {
            const flairLayer = document.createElement('div');
            flairLayer.style.cssText = 'position:absolute;inset:0;overflow:visible;pointer-events:none;';
            card.appendChild(flairLayer);
            const spawnFlair = () => {
                if (!document.body.contains(card)) return; // stop if overlay gone
                const f = document.createElement('div');
                const size = 4 + Math.random()*4;
                f.style.cssText = `position:absolute;bottom:4px;left:${6+Math.random()* (card.clientWidth-14)}px;`+
                    `width:${size}px;height:${size}px;border-radius:50%;background:radial-gradient(circle,#ffd37a,#c68b1a);`+
                    `opacity:0;animation:flairFloat ${2.6+Math.random()*1.4}s linear forwards;box-shadow:0 0 6px #c68b1a,0 0 2px #fff inset;`;
                flairLayer.appendChild(f);
                // Auto remove after animation
                setTimeout(()=>{ if(f.parentElement) f.parentElement.removeChild(f); }, 4000);
            };
            // Initial burst
            for (let i=0;i<3;i++) setTimeout(spawnFlair, i*160 + Math.random()*120);
            const intId = setInterval(spawnFlair, 650 + Math.random()*400);
            flairIntervals.push(intId);
        }
    card.style.cursor = 'pointer';
    card.setAttribute('data-gp-focus','1');
        card.onclick = () => {
            if (!game.player.permanentAbilities.includes(ability)) {
                game.player.permanentAbilities.push(ability);
                try { if (typeof window._onAbilityAdded === 'function') window._onAbilityAdded(ability); } catch(_){}
                localStorage.setItem('permanentAbilities', JSON.stringify(game.player.permanentAbilities));
            }
            document.body.removeChild(overlay);
            // Clear intervals
            flairIntervals.forEach(id=>clearInterval(id));
            if (game && game._bigQuackDefeated) {
                if (!document.getElementById('postFinalPlayAgain')) {
                    const btn = document.createElement('button');
                    btn.id = 'postFinalPlayAgain';
                    btn.textContent = 'Play Again';
                    btn.style.cssText = 'position:fixed;bottom:40px;left:50%;transform:translateX(-50%);padding:12px 28px;font-size:18px;background:#222;color:#fff;border:2px solid #666;border-radius:6px;z-index:30010;cursor:pointer;';
                    btn.onclick = () => { btn.remove(); resetGame(); };
                    btn.setAttribute('data-gp-focus','1');
                    document.body.appendChild(btn);
                    // Initialize uiNav guard state for the Play Again button so holding A won't immediately activate it
                    try {
                        game.uiNav = game.uiNav || {};
                        game.uiNav.container = btn;
                        game.uiNav.items = gatherFocusables(btn);
                        game.uiNav.index = 0;
                        const now = (performance && performance.now) ? performance.now() : Date.now();
                        game.uiNav.lastFire = !!(game.input && game.input.gpFire);
                        game.uiNav.lastFireAt = now;
                        applyGpFocus();
                    } catch(_) {}
                }
            }
        };
        container.appendChild(card);
    });

    overlay.appendChild(container);
    document.body.appendChild(overlay);
    // Initialize gamepad focus for this overlay so controllers can navigate immediately
    try {
        game.uiNav = game.uiNav || {};
        game.uiNav.container = overlay;
        game.uiNav.items = gatherFocusables(overlay);
        // prefer the first data-gp-focus item when present
        let idx = 0;
        for (let i=0;i<game.uiNav.items.length;i++) {
            const el = game.uiNav.items[i];
            if (el && el.getAttribute && el.getAttribute('data-gp-focus') === '1') { idx = i; break; }
        }
        game.uiNav.index = idx;
        applyGpFocus();
        // If the player is holding the fire button when this overlay appears, require them to release
        // and press again. Also record a timestamp to avoid immediate accidental confirms.
        try {
            const now = (performance && performance.now) ? performance.now() : Date.now();
            game.uiNav.lastFire = !!(game.input && game.input.gpFire);
            game.uiNav.lastFireAt = now;
        } catch(_) {}
    } catch(_) {}
    // Ensure flair intervals are cleared if overlay removed externally
    const obs = new MutationObserver(()=>{ if(!document.body.contains(overlay)) { flairIntervals.forEach(id=>clearInterval(id)); obs.disconnect(); }});
    obs.observe(document.body,{childList:true});
}

// Rainbow Chest: full ability picker (choose any ability; does not remove existing ones)
function showRainbowAbilityPicker(onSelect) {
    // Ensure persisted seen/unlocked abilities are loaded so secret abilities aren't offered prematurely
    try { if (typeof loadSeenAbilities === 'function') loadSeenAbilities(); } catch(_) {}
    // Prevent duplicates
    const existing = document.getElementById('rainbowAbilityOverlay');
    if (existing) { try { existing.remove(); } catch(_) {} }
    const wasPaused = !!game.paused; game.paused = true;
    const overlay = document.createElement('div');
    overlay.id = 'rainbowAbilityOverlay';
    overlay.style.cssText = 'position:fixed;inset:0;z-index:20000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);font-family:Courier New,monospace;';
    const panel = document.createElement('div');
    panel.style.cssText = 'width:min(1100px,94vw);max-height:min(86vh,940px);background:#121212;border:2px solid #666;border-radius:10px;padding:14px;display:flex;flex-direction:column;gap:10px;box-shadow:0 0 18px rgba(255,255,255,0.15), 0 0 60px rgba(180,120,255,0.25) inset;';
    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:12px;';
    header.innerHTML = '<div style="color:#fff;font-weight:800;letter-spacing:1px;text-shadow:0 0 10px #fff, 0 0 20px #f0f;">Rainbow Chest — Choose Any Ability</div>'+
        '<button id="rainbowCloseBtn" data-gp-focus="1" style="background:#222;color:#ddd;border:1px solid #666;padding:6px 10px;border-radius:6px;cursor:pointer">Close (Esc)</button>';
    const controls = document.createElement('div');
    controls.style.cssText = 'display:flex;gap:10px;align-items:center;flex-wrap:wrap;';
    const search = document.createElement('input');
    search.type = 'text'; search.placeholder = 'Search abilities...';
    search.style.cssText = 'flex:1;min-width:260px;padding:8px 10px;border:1px solid #555;border-radius:6px;background:#0b0b0b;color:#eee;outline:none';
    const onlyNewLabel = document.createElement('label');
    onlyNewLabel.style.cssText = 'display:flex;align-items:center;gap:6px;color:#bbb;font-size:12px;user-select:none;';
    const onlyNewChk = document.createElement('input');
    onlyNewChk.type = 'checkbox'; onlyNewChk.checked = true;
    onlyNewLabel.appendChild(onlyNewChk);
    onlyNewLabel.appendChild(document.createTextNode('Hide owned'));
    controls.appendChild(search); controls.appendChild(onlyNewLabel);
    const grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px;overflow:auto;flex:1;padding-right:4px;';
    function tierStyle(tier){ if (tier===3) return { border:'#c68b1a', bg:'#2a1d05', name:'#ffd37a' }; if (tier===2) return { border:'#3d7dd9', bg:'#0a1d33', name:'#aaccff' }; return { border:'#5aa84d', bg:'#0d2a0d', name:'#b9e8b2' }; }
    function buildItem(name, meta){
        const t = (meta && meta.tier) || 1; const st = tierStyle(t);
        const owned = Array.isArray(game?.player?.abilities) && game.player.abilities.includes(name);
        const d = document.createElement('div');
        d.style.cssText = 'border:2px solid '+st.border+';background:'+st.bg+';border-radius:8px;padding:10px;display:flex;flex-direction:column;gap:6px;box-shadow:inset 0 0 8px #000, 0 0 8px rgba(0,0,0,0.35)';
        // Hover/interactive affordances only if not owned
        if (!owned) {
            d.style.cursor = 'pointer';
            d.onmouseenter = ()=> d.style.transform = 'translateY(-2px)';
            d.onmouseleave = ()=> d.style.transform = 'none';
        } else {
            d.style.cursor = 'not-allowed';
            d.style.filter = 'grayscale(0.6) opacity(0.65)';
            d.setAttribute('aria-disabled','true');
            d.title = 'Already owned';
        }
        const title = document.createElement('div'); title.textContent = name; title.style.cssText = 'font-weight:700;color:'+st.name+';text-shadow:0 0 6px rgba(0,0,0,.6)';
        const desc = document.createElement('div'); desc.textContent = meta && meta.desc ? meta.desc : ''; desc.style.cssText = 'color:#ddd;font-size:12px;min-height:32px;line-height:1.25';
        d.appendChild(title);
        // Owned badge
        if (owned) {
            const badge = document.createElement('div');
            badge.textContent = 'OWNED';
            badge.style.cssText = 'align-self:flex-start;background:#2a2a2a;color:#bbb;border:1px solid #555;border-radius:4px;padding:2px 6px;font-size:11px;letter-spacing:0.5px;';
            d.appendChild(badge);
        }
        d.appendChild(desc);
        // Controller focus and click only when selectable
        if (!owned) {
            d.setAttribute('data-gp-focus','1');
            d.onclick = () => {
                try { document.body.removeChild(overlay); } catch(_) {}
                game.paused = wasPaused;
                if (typeof onSelect === 'function') onSelect(name);
            };
        }
        return d;
    }
    function filterAndRender(){
        const q = (search.value||'').trim().toLowerCase();
        grid.innerHTML='';
        let keys = Object.keys(ABILITIES);
        if (onlyNewChk.checked) keys = keys.filter(k => !game.player.abilities.includes(k));
        keys = keys.filter(k => {
            // Hide secret/unlocked-only abilities unless they have been discovered via their unlock path
            try {
                const secretList = ['Gooster Teeth','Wunder Doodle','Release the Quacken!'];
                if (secretList.indexOf(k) >= 0) {
                    if (!(game && game.player && game.player._seenAbilities && game.player._seenAbilities[k])) return false;
                }
            } catch(_) {}
            if (!q) return true; const meta = ABILITIES[k]; const d = (meta && meta.desc)||''; return k.toLowerCase().includes(q) || d.toLowerCase().includes(q);
        }).sort((a,b)=>{
            const ta=(ABILITIES[a].tier||1), tb=(ABILITIES[b].tier||1); if (ta!==tb) return ta-tb; return a.localeCompare(b);
        });
        if (keys.length===0){ const empty=document.createElement('div'); empty.textContent='No abilities match your filter.'; empty.style.cssText='color:#aaa;font-size:13px;padding:8px;grid-column:1/-1'; grid.appendChild(empty); }
        else { keys.forEach(k => grid.appendChild(buildItem(k, ABILITIES[k]))); }
    }
    panel.appendChild(header); panel.appendChild(controls); panel.appendChild(grid);
    overlay.appendChild(panel); document.body.appendChild(overlay);
    document.getElementById('rainbowCloseBtn').onclick = () => { try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; };
    search.oninput = filterAndRender; onlyNewChk.onchange = filterAndRender;
    const escHandler = (ev)=>{ if (ev.key==='Escape'){ ev.preventDefault(); try { document.body.removeChild(overlay); } catch(_) {} game.paused = wasPaused; window.removeEventListener('keydown', escHandler, true);} };
    window.addEventListener('keydown', escHandler, true);
    filterAndRender();
    // Default controller focus to the first selectable card (skip owned/disabled); fall back to Close
    try {
        setTimeout(() => {
            const cont = document.getElementById('rainbowAbilityOverlay');
            if (!cont) return;
            const items = gatherFocusables(cont);
            if (items && items.length) {
                game.uiNav = game.uiNav || {};
                game.uiNav.container = cont;
                game.uiNav.items = items;
                let idx = 0;
                // Prefer a grid card that is selectable (has data-gp-focus and lives in grid)
                for (let i=0;i<items.length;i++) {
                    const el = items[i];
                    if (el.getAttribute && el.getAttribute('data-gp-focus')==='1' && grid.contains(el)) { idx = i; break; }
                }
                game.uiNav.index = idx;
                applyGpFocus();
            }
        }, 0);
    } catch(_) {}
}

function offerPermanentAbilityChoice() {
    if (!game || !game.player) return;
    let pool = game.player.abilities.filter(a => !game.player.permanentAbilities.includes(a));
    // If fewer than 3 unique non-permanent, fallback to include permanent ones (still avoid duplicates in display)
    if (pool.length < 3) {
        const extras = game.player.abilities.filter(a => !pool.includes(a));
        pool = pool.concat(extras);
    }
    // Still not enough? Show whatever exists (1–3). If none, show informational overlay.
    if (pool.length === 0) {
        console.info('[Permanent Ability Choice] No abilities available to offer.');
        const msg = document.createElement('div');
        msg.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:18px 26px;color:#fff;font:14px Courier New;border:2px solid #555;z-index:35000;';
        msg.textContent = 'No abilities to make permanent. Press Play Again to restart.';
        document.body.appendChild(msg);
        return;
    }
    const shuffled = [...pool].sort(() => Math.random() - 0.5);
    const options = shuffled.slice(0, Math.min(3, shuffled.length));
    console.info('[Permanent Ability Choice] Offering options:', options);
    showAbilityChoiceUI(options);
}

        const ABILITIES = {
            /*
             * Synergy Notes (pattern stacking system):
             *  - Projectile motion patterns (sineWave, wackyZigzag, ekgWave, spiralPattern, teleporting, orbital, growing, homing/weakHoming, bouncing/ricochet, omni/radial, crossPattern, boomerang) now coexist. (Split Shot removed)
             *  - updateProjectiles aggregates lateral deltas from sine + wacky + ekg instead of making them mutually exclusive.
             *  - Dampening rules: when multiple patterns active, each pattern's amplitude is slightly reduced to prevent runaway speed inflation.
             *  - Spiral still applies its own loop motion; if also sine/wacky/ekg, their offsets add on top.
             *  - Orbitals inherit pattern flags on spawn and animate with radial/tangential modulation.
             *  - Split projectiles propagate pattern flags so child fragments maintain complex motion.
             *  - Teleport Shot synergy: additional portal particle styles appear based on which pattern flags the projectile has (spiral / sine / wacky / ekg).
             *  - Speed capping & normalization keeps composite velocity within ~1.85x original forward speed.
             *  - Resonance Combos: 2+ core motion patterns (sine, wacky, ekg, spiral) grant escalating damage multiplier (8%/15%/22%) and at 3+ patterns periodic resonance pulses (AoE % base damage) emanate; all 4 patterns trigger occasional hypersurge speed burst.
             *  - Elemental Amplifiers: Fire+Wind (burn tick +15%, burn duration +40f), Ice+Lightning (12% shatter proc for bonus burst), Poison+Void (poison tick +25%, duration +90f), Fire+Poison (magma combustion: +10% burn tick, +12% poison tick), Ice+Wind (slow duration +60f).
             *  - Beam Pattern Blending: Laser/Particle beams inherit pattern flags for visual modulation (oscillation, jitter, spikes, mini-spiral); movement unaffected for fairness; particles tint by dominant pattern.
             *  - DOT Scaling: Elemental amplifiers modify per-tick burn/poison damage dynamically based on active ability sets.
             *  - Elemental Infusions: Temporary stacked overlays (up to 3 via Elemental Conduit) add bonus partial damage + status effects; strongest infusion selects primary damageType if projectile neutral; diminishing returns on multi stack.
             */
            // Shooting Abilities
            'Fire Shot': { desc: 'Fire damage + burning DoT', effect: { damageBonus: 8, damageType: 'fire' }, tier: 1 },
            'Ice Shot': { desc: 'Slows enemies by 60%', effect: { damageType: 'ice' }, tier: 1 },
            'Lightning Shot': { desc: 'Chains to 3 enemies', effect: { damageType: 'lightning' }, tier: 1 },
            'Poison Shot': { desc: 'Poison damage over time', effect: { damageType: 'poison' }, tier: 1 },
            'Explosive Shot': { desc: 'Bullet go boom', effect: { explosive: true }, tier: 2 },
            'Double Shot': { desc: 'Fire 2 projectiles', effect: { projectileCount: 2 }, tier: 1 },
            'Triple Shot': { desc: 'Fire 3 projectiles', effect: { projectileCount: 3 }, tier: 2 },
            'Quad Shot': { desc: 'Fire 4 projectiles', effect: { projectileCount: 4 }, tier: 2 }, // Rebalanced: was tier 3
            'Machine Gun': { desc: 'Fire rate +100%', effect: { attackSpeedMultiplier: 2.0 }, tier: 2 },
            'Laser Cannon': { desc: 'Fire rate +200%', effect: { attackSpeedMultiplier: 3.0 }, tier: 2 }, // Rebalanced: was tier 3
            'Pierce Shot': { desc: 'Pierce through 3 enemies', effect: { piercing: true, pierceCount: 3 }, tier: 2 },
            'Multi-Pierce': { desc: 'Pierce unlimited enemies', effect: { piercing: true, pierceCount: 999 }, tier: 3 },
            'Homing Shot': { desc: 'Auto-target nearest enemy', effect: { homing: true }, tier: 1 }, // Rebalanced: was tier 2
            'Bouncing Shot': { desc: 'Bounce off walls 3 times', effect: { bouncing: true }, tier: 1 }, // Rebalanced: was tier 2
            // Special/Secret: Spinning golden teeth that ricochet and explode into gold dust on final bounce
            'Gooster Teeth': { desc: 'Ever seen a goose with teeth? Nightmare Fuel', effect: { goldTooth: true, bouncing: true, bounces: 3 }, tier: 3 },
            // Secret: Wunder Doodle — messy scribble laser unlocked by defeating Wunderswan (discoverable via chest)
            'Wunder Doodle': { desc: 'Auto-tracking laser that leaves a lingering doodle DoT on all it touches', effect: { energyType: 'laser', continuous: true, scribble: true, homing: true, damageType: 'fire', damageBonus: 10, wunderDoodle: true }, tier: 3 },
            // Secret: Release the Quacken! — defeat The Quacken to add inky tentacles to chest rewards
            'Release the Quacken!': { desc: 'Reach out and touch someone', effect: { damageType: 'void', knockback: true, knockbackDistance: 28 }, tier: 3 },
            'Growing Shot': { desc: 'Size increases over time', effect: { growing: true }, tier: 1 },
            'Shotgun Blast': { desc: '5 wide spread shots', effect: { shotgunBlast: true }, tier: 2 },
            'Sniper Shot': { desc: '3x larger, faster shots', effect: { projectileSize: 3, projectileSpeed: 2 }, tier: 2 },
            // Advanced Projectile Abilities
            'Plasma Cannon': { desc: 'Super heated plasma bolts for extra damage', effect: { damageBonus: 15, damageType: 'plasma' }, tier: 2 },
            'Acid Shot': { desc: 'Melts armor, leaving a puddle of acid', effect: { damageType: 'acid', armorPiercing: true }, tier: 2 },
            'Shadow Bolt': { desc: 'Dark energy projectiles that deal bonus shadow damage', effect: { damageBonus: 12, damageType: 'shadow' }, tier: 2 },
            'Solar Flare': { desc: 'Blinding solar energy', effect: { damageType: 'solar', blinds: true }, tier: 2 },
            'Frost Shard': { desc: 'Freezing ice projectiles', effect: { damageType: 'frost', freezes: true }, tier: 2 },
            'Wind Blade': { desc: 'Razor sharp air currents — massively pushes enemies back', effect: { damageBonus: 10, damageType: 'wind', knockback: true, knockbackDistance: 120 }, tier: 1 }, // Added strong knockback
            // Newly re-added base Earth element so Earth combos (e.g., Magma) have a source ability when combo card not yet offered.
            'Earth Spike': { desc: 'Stone spikes with impact shock (minor stun & knockback)', effect: { damageType: 'earth', knockback: true, knockbackDistance: 48 }, tier: 1 },
            'Void Shot': { desc: 'Reality-tearing projectiles', effect: { damageBonus: 25, damageType: 'void' }, tier: 3 },
            'Crystal Shot': { desc: 'Prismatic energy bolts that spawn crystal shards on enemy death', effect: { damageBonus: 18, damageType: 'crystal' }, tier: 2 },
            // Multi-Shot Abilities
            'Penta Shot': { desc: 'Fire 5 projectiles', effect: { projectileCount: 5 }, tier: 2 }, // Rebalanced: was tier 3
            'Hexa Shot': { desc: 'Fire 6 projectiles', effect: { projectileCount: 6 }, tier: 3 },
            'Octa Shot': { desc: 'Fire 8 projectiles', effect: { projectileCount: 8 }, tier: 3 },
            'Deca Shot': { desc: 'Fire 10 projectiles', effect: { projectileCount: 10 }, tier: 3 },
            'Storm Barrage': { desc: 'Fire 15 random projectiles', effect: { projectileCount: 15, randomSpread: true }, tier: 3 },
            'Bullet Hell': { desc: 'Fire 20 chaotic shots', effect: { projectileCount: 20, randomSpread: true }, tier: 3 },
            'Omni Shot': { desc: 'Fire in all 8 directions', effect: { omniDirectional: true }, tier: 3 },
            'Radial Burst': { desc: 'Fire 16 shots in circle', effect: { radialBurst: true }, tier: 3 },
            'Spiral Shot': { desc: 'Spinning projectile pattern — shots curve in local swirling loops for a tight spiral motion', effect: { spiralPattern: true }, tier: 2 },
            'Uzumaki': { desc: 'The art of the spiral...', effect: { uzumaki: true }, tier: 2 },
            'Sine Wave': { desc: 'Shots follow a sine wave pattern', effect: { sineWave: true }, tier: 2 },
            'Wacky Shot': { desc: 'Bullets zigzag unpredictably with rapid direction changes', effect: { wackyZigzag: true }, tier: 2 },
            'EKG': { desc: 'Shots follow an erratic cardiogram spike pattern (flatline pulses then sharp vertical spikes)', effect: { ekgWave: true }, tier: 2 },
            'Cross Shot': { desc: 'Fire in + pattern', effect: { crossPattern: true }, tier: 2 },
            // Rate of Fire Abilities
            'Rapid Fire': { desc: 'Fire rate +50%', effect: { attackSpeedMultiplier: 1.5 }, tier: 1 },
            'Burst Fire': { desc: 'Fire rate +75%', effect: { attackSpeedMultiplier: 1.75 }, tier: 2 },
            'Auto Cannon': { desc: 'Fire rate +150%', effect: { attackSpeedMultiplier: 2.5 }, tier: 2 },
            'Gatling Gun': { desc: 'Fire rate +250%', effect: { attackSpeedMultiplier: 3.5 }, tier: 3 },
            'Chain Gun': { desc: 'Fire rate +300%', effect: { attackSpeedMultiplier: 4.0 }, tier: 3 },
            'Minigun': { desc: 'Fire rate +400%', effect: { attackSpeedMultiplier: 5.0 }, tier: 3 },
            'Vulcan Cannon': { desc: 'Fire rate +500%', effect: { attackSpeedMultiplier: 6.0 }, tier: 3 },
            // Damage Boost Abilities
            'Power Shot': { desc: 'Damage +10', effect: { damageBonus: 10 }, tier: 1 },
            'Heavy Shot': { desc: 'Damage +15', effect: { damageBonus: 15 }, tier: 1 },
            'Mega Damage': { desc: 'Damage +20', effect: { damageBonus: 20 }, tier: 2 },
            'Ultra Damage': { desc: 'Damage +40', effect: { damageBonus: 40 }, tier: 2 }, // Rebalanced: was tier 3
            'Supreme Damage': { desc: 'Damage +60', effect: { damageBonus: 60 }, tier: 3 },
            'Divine Power': { desc: 'Damage +80', effect: { damageBonus: 80 }, tier: 3 },
            'Apocalypse': { desc: 'Damage +100', effect: { damageBonus: 100 }, tier: 3 },
            // Projectile Behavior Abilities
            'Seeking Shot': { desc: 'Weak homing behavior', effect: { weakHoming: true }, tier: 1 },
            'Smart Bomb': { desc: 'Explodes near enemies', effect: { smartExplosive: true }, tier: 2 },
            'Ricochet': { desc: 'Bounce between enemies', effect: { ricochet: true }, tier: 2 },
            'Boomerang': { desc: 'Returns to player', effect: { boomerang: true }, tier: 1 }, // Rebalanced: was tier 2
            'Orbital': { desc: 'Orbits around player', effect: { orbital: true }, tier: 2 },
            'Drill Shot': { desc: 'Spins while moving', effect: { drilling: true }, tier: 1 }, // Rebalanced: was tier 2
            'Phasing Shot': { desc: 'Passes through walls', effect: { phasing: true }, tier: 2 },
            'Teleport Shot': { desc: 'Each fired projectile instantly teleports to a random nearby location around you (within ~140px) before flying forward', effect: { teleporting: true }, tier: 2 }, // Rebalanced: was tier 3
            // Area Effect Abilities
            'Nova Blast': { desc: 'Explosion on impact', effect: { novaBlast: true }, tier: 2 },
            'Chain Explosion': { desc: 'Explosions spread', effect: { chainExplosion: true }, tier: 2 }, // Rebalanced: was tier 3
            'Shockwave': { desc: 'Ground-traveling wave', effect: { shockwave: true }, tier: 2 },
            'Meteor': { desc: 'Falls from sky', effect: { meteor: true }, tier: 3 },
            'Black Hole': { desc: 'Pulls enemies inward', effect: { blackHole: true }, tier: 3 },
            'Vortex': { desc: 'Creates a lingering void spiral that pulls enemies inward, deals periodic damage, and ignites them', effect: { vortex: true }, tier: 3 },
            'Time Bomb': { desc: 'Delayed massive explosion', effect: { timeBomb: true }, tier: 3 },
            // Status Effect Abilities
            'Stun Shot': { desc: 'Paralyzes enemies briefly', effect: { damageType: 'stun' }, tier: 2 },
            // Removed status shots (blind, silence, curse, weakness, doom) per design trim
            'Fear Shot': { desc: 'Makes enemies flee', effect: { damageType: 'fear' }, tier: 2 },
            'Charm Shot': { desc: 'Turns enemies friendly', effect: { damageType: 'charm' }, tier: 3 },
            // Elemental Combinations
            'Steam Shot': { desc: 'Fire + Ice combo damage', effect: { damageType: 'steam', damageBonus: 20 }, tier: 2 },
            'Magma Shot': { desc: 'Fire + Earth combo', effect: { damageType: 'magma', damageBonus: 25 }, tier: 2 }, // Rebalanced: was tier 3
            'Storm Shot': { desc: 'Lightning + Wind combo', effect: { damageType: 'storm', damageBonus: 22 }, tier: 2 },
            'Toxic Cloud': { desc: 'Poison gas area', effect: { damageType: 'toxic', areaEffect: true }, tier: 2 }, // Rebalanced: was tier 3
            'Blizzard': { desc: 'Ice + Wind storm', effect: { damageType: 'blizzard', areaEffect: true }, tier: 3 },
            'Inferno': { desc: 'Spreading fire damage', effect: { damageType: 'inferno', spreading: true }, tier: 3 },
            // New multi-stage special
            'SIGMA': { desc: 'Its Greek to me', effect: { sigma: true }, tier: 3 },
            // Weapon Types
            'Sword Throw': { desc: 'Throw a sword that flies blade-first', effect: { weaponType: 'sword' }, tier: 1 }, // Rebalanced: was tier 2
            'Axe Hurl': { desc: 'Heavy axe projectile — slow, large axe that deals high impact damage and knocks enemies back on hit', effect: { weaponType: 'axe', damageBonus: 30 }, tier: 2 },
            'Spear Thrust': { desc: 'Long-range piercing — fast spear that pierces multiple enemies for extended reach', effect: { weaponType: 'spear', piercing: true }, tier: 2 },
            'Hammer Slam': { desc: 'Crushing blunt damage — heavy hammer shot that stuns or briefly incapacitates enemies on impact', effect: { weaponType: 'hammer', crushDamage: true }, tier: 2 },
            'Dagger Rain': { desc: 'Multiple small blades', effect: { weaponType: 'dagger', projectileCount: 8 }, tier: 3 },
            // Culinary Weapon
            'Crusty Bread': { desc: 'Feed the ducks...with a vengeance', effect: { weaponType: 'bread', damageBonus: 20 }, tier: 2 },
            // Energy Weapons
            'Laser Beam': { desc: 'Continuous energy beam (adds persistent beam ticks while you fire; does NOT block normal shots)', effect: { energyType: 'laser', continuous: true }, tier: 3 },
            'Particle Beam': { desc: 'High-energy particles — thick beam segments with AoE ticks; hold to deal sustained area damage along the beam', effect: { energyType: 'particle', damageBonus: 35 }, tier: 3 },
            'Ion Cannon': { desc: 'Charged ion blast — hold to charge and release a massive piercing blast; charge increases size and damage', effect: { energyType: 'ion', chargeShot: true }, tier: 3 },
            'Pulse Rifle': { desc: 'Energy pulse bursts — fires short 3-round bursts (micro-projectiles) for rapid close damage', effect: { energyType: 'pulse', burstFire: true }, tier: 2 },
            'Photon Torpedo': { desc: 'Light-speed projectile — instantly strikes the nearest enemy when fired (instant-travel strike)', effect: { energyType: 'photon', instantTravel: true }, tier: 3 },
            // Exotic Abilities
            'Quantum Shot': { desc: 'Bullets strike twice', effect: { quantum: true, hitMultipleTimes: true }, tier: 3 },
            'Dimensional Rift': { desc: 'Tears through space — creates a rift field that manipulates projectiles and can teleport or refract shots; ignores armor', effect: { dimensional: true, ignoresArmor: true }, tier: 3 },
            'Time Warp': { desc: 'Slows time around impact', effect: { timeWarp: true }, tier: 3 },
            'Reality Break': { desc: 'Breaks physics rules — spawns an unstable field that disrupts projectile paths and weakens enemy resistances', effect: { realityBreak: true, ignoresEverything: true }, tier: 3 },
            'Antimatter': { desc: 'Pure destruction', effect: { antimatter: true, massiveExplosion: true }, tier: 3 },
            // Unique/Utility
            'Tumbleweed': { desc: 'You know you want to shoot it.', effect: { tumbleweed: true }, tier: 2 },
            'Kick the Can': { desc: 'You know what to do.', effect: { kickTheCan: true }, tier: 2 },
            // Core / Meta Abilities (previously system placeholders)
            'Auto-Aim': { desc: 'Automatically targets the nearest enemy when firing (no manual aim needed).', effect: { autoAim: true }, tier: 1 },
            'Treasure Hunter': { desc: 'Higher chance for rooms to spawn a chest (+30%) and health bread drops are 50% more likely.', effect: { chestChanceBonus: 0.3, breadDropBonus: 0.5 }, tier: 1 },
            'Rage Mode': { desc: 'Gain +3 damage for every enemy you have slain this run (scales endlessly).', effect: { rageScaling: true }, tier: 2 },
            'Berserker': { desc: 'Damage increases up to +50% as your health gets lower (scales with missing HP).', effect: { berserker: true }, tier: 2 },
            // Removed Death Touch per design trim
            'Terrifying Aura': { desc: 'Every 25 kills create a purple aura; enemies touching it are Feared for 3s and flee.', effect: { terrifyingAura: true }, tier: 2 },
            'Diarrhea': { desc: 'Oh God!', effect: { diarrhea: true }, tier: 2 },
            'Carb it up!': { desc: 'Bread drops magnetize and glide to you for instant pickup.', effect: { breadMagnet: true }, tier: 1 },
            'Beartrap': { desc: 'Every 5s drop a beartrap; first enemy to step on it takes heavy damage and is immobilized for 5s.', effect: { beartrap: true }, tier: 2 },
            'Punji Pit': { desc: 'Every 5s leave a poison spike pit; enemies touching it take damage and are poisoned.', effect: { punjiPit: true }, tier: 2 },
            'Oppemheimer': { desc: 'Every 10s a massive nuke strikes a random area — huge blast radius dealing catastrophic damage.', effect: { nukeStrike: true }, tier: 3 },
            'Silent But Deadly': { desc: 'Cropdust your enemies!', effect: { poisonTrail: true }, tier: 2 },
            'Spontaneous Combustion': { desc: 'Enemies you kill erupt into an omni blast of burning shards', effect: { combustOnKill: true }, tier: 2 },
            // Infusion / Overlay Systems
            'Elemental Conduit': { desc: 'Periodically channels random elemental infusions (can stack up to 3 simultaneous; each adds partial damage + status to shots).', effect: { elementalConduit: true }, tier: 3 },
            
            // --- New Bullet Pattern / Behavior Abilities ---
            'Lissajous Shot': { desc: 'Figure-8 oscillation path (compound wave)', effect: { lissajousPattern: true }, tier: 2 },
            'Helix Pair': { desc: 'Fires twin helix-winding partners', effect: { helixPair: true }, tier: 2 },
            'Bloom Ring': { desc: 'Periodically emits expanding pellet ring', effect: { bloomRing: true }, tier: 3 },
            'Cascade Burst': { desc: 'Pulsing forward micro-bursts', effect: { cascadeBurst: true }, tier: 2 },
            'Pendulum Shot': { desc: 'Swinging arc that settles', effect: { pendulumPattern: true }, tier: 1 },
            'Sawtooth Wave': { desc: 'Jagged saw lateral motion', effect: { sawWave: true }, tier: 2 },
            'Phase Echo': { desc: 'Afterimage echoes re-impact', effect: { phaseEcho: true }, tier: 3 },
            'Resonant Pulse Core': { desc: 'Periodic buff pulse for nearby shots', effect: { resonantPulseCore: true }, tier: 3 },
            'Vector Pivot': { desc: 'Quarter-turn pivot arcs', effect: { pivotPattern: true }, tier: 2 },
            'Converging Twins': { desc: 'Diverge then fuse for burst', effect: { convergePair: true }, tier: 2 },
            'Fragment Wake': { desc: 'Leaves a lingering trail of flickering sparks that rapidly ping nearby enemies (stacking contact DPS).', effect: { fragmentWake: true }, tier: 1 },
            'Spiral Bloom': { desc: 'Oooh, Pretty', effect: { spiralBloom: true }, tier: 3 },
            'Harmonic Split': { desc: 'Splits twice at set life points', effect: { harmonicSplit: true }, tier: 3 },
            
            'Temporal Drift': { desc: 'Cycles slow stretch & surge', effect: { temporalDrift: true }, tier: 3 },
            'Veering Fan': { desc: 'Fans into arc mid-flight', effect: { veeringFan: true }, tier: 2 },
            'Echo Bloom': { desc: 'Echo catches up & bursts', effect: { echoBloom: true }, tier: 2 },
            'Toenail Clibbins': { desc: 'Thats a biggin', effect: { toenailClibbins: true }, tier: 2 },
            'Popcorn': { desc: 'Fires a kernel that pops into several flying puffs', effect: { popcornKernel: true }, tier: 1 },
            'Umbrella Shot': { desc: 'Primary shot splits forward into two arcing halves that curve overhead then return past you', effect: { umbrellaShot: true }, tier: 2 },
            'Duck Dynasty': { desc: 'Summon your ancestors', effect: { duckDynasty: true }, tier: 2 },
            // Crowd Control / Utility
            'Rizz': { desc: 'Every 5s magnetically gathers enemies near you then Fears them for 3s', effect: { rizzAbility: true }, tier: 3 },
            'SHOOTING INTENSIFIES': { desc: 'Amplifies ALL projectile motion patterns (waves, spirals, zigzags, helix, etc.) for +40% pattern amplitude & special speed; stacks after normal dampening.', effect: { patternAmplify: true }, tier: 3 },
            // Environmental havoc
            'Tanks Alot': { desc: 'A runaway truck barrels down the street. If it hits a dumpster, it explodes and ignites the street for 5s.', effect: { tanksAlot: true }, tier: 3 },
        };
        // (Removed placeholder system ability injection; all core meta abilities now have proper entries.)

    // Enemy type definitions (restored after recent update)
        const ENEMY_TYPES = {
            'Thug':      { health: 60,  speed: 1.2, damage: 10, color: '#FF8888', size: 24, xp: 10,  ranged: false, armor: 0 },
            'Street Dog':{ health: 40,  speed: 1.1, damage: 8,  color: '#AA6644', size: 20, xp: 8,   ranged: false, armor: 0 },
            'Punk':      { health: 55,  speed: 1.05, damage: 12, color: '#FF44FF', size: 22, xp: 12,  ranged: false, armor: 1 },
            'Gangster':  { health: 90,  speed: 0.9, damage: 18, color: '#8888FF', size: 30, xp: 20,  ranged: true, rangedCooldown: 2500, armor: 2 },
            'Dealer':    { health: 70,  speed: 1.0, damage: 14, color: '#FFFF00', size: 26, xp: 15,  ranged: true, armor: 1 },
            'Enforcer':  { health: 130, speed: 0.7, damage: 25, color: '#FF4444', size: 34, xp: 35,  ranged: false, armor: 3 },
            'Boss Thug': { health: 350, speed: 0.6, damage: 40, color: '#FFD700', size: 52, xp: 200, ranged: false, armor: 5 },
            'Boss Gangster': { health: 520, speed: 0.65, damage: 50, color: '#4444FF', size: 56, xp: 260, ranged: true, rangedCooldown: 2000, armor: 6 },
            'The Big Quack': { health: 10000, speed: 0.55, damage: 50, color: '#111111', size: 104, xp: 4000, ranged: true, rangedCooldown: 1600, armor: 10, bossFinal: true }
        };

    // Act II exclusive enemy: Eggscobar (non-ranged)
    ENEMY_TYPES['Eggscobar'] = { health: 85, speed: 0.92, damage: 16, color: '#EEDD88', size: 28, xp: 26, ranged: false, armor: 0, act: 'II' };

    // Act II boss: Big Bill (non-ranged) - stats mirror Boss Thug size and role
    ENEMY_TYPES['Big Bill'] = { health: 350, speed: 0.6, damage: 40, color: '#D4AA55', size: 52, xp: 200, ranged: false, armor: 5, act: 'II', boss: true };

    // Act II ranged enemy: Goose Willis
    ENEMY_TYPES['Goose Willis'] = { health: 95, speed: 1.0, damage: 18, color: '#DDCCFF', size: 30, xp: 30, ranged: true, rangedCooldown: 1800, armor: 0, act: 'II' };

    // Act II melee grunt: Goosey Smalls (non-ranged)
    ENEMY_TYPES['Goosey Smalls'] = { health: 88, speed: 0.98, damage: 17, color: '#CCEECC', size: 30, xp: 28, ranged: false, armor: 0, act: 'II' };

    // Act II ranged grunt: Lil Goosey (small ranged goose)
    ENEMY_TYPES['Lil Goosey'] = { health: 60, speed: 1.08, damage: 12, color: '#DDEEFF', size: 24, xp: 15, ranged: true, rangedCooldown: 1600, armor: 0, act: 'II' };

    // Act II melee grunt: Goosey Elliot (non-ranged)
    ENEMY_TYPES['Goosey Elliot'] = { health: 82, speed: 1.0, damage: 16, color: '#DCEECC', size: 28, xp: 24, ranged: false, armor: 0, act: 'II' };
    ENEMY_TYPES['Fowl Pacino'] = { health: 96, speed: 0.95, damage: 18, color: '#E0D4B8', size: 32, xp: 36, ranged: false, armor: 0, act: 'II' };
    // Rare melee enemy: The Quacken (spawns via special 1% override in any street)
    ENEMY_TYPES['The Quacken'] = { health: 1000, speed: 0.82, damage: 24, color: '#2F6B68', size: 42, xp: 160, ranged: false, armor: 2, act: 'II' };
    // Act II ranged grunt: Geese Robbins
    ENEMY_TYPES['Geese Robbins'] = { health: 90, speed: 1.02, damage: 14, color: '#DDE8FF', size: 30, xp: 32, ranged: true, rangedCooldown: 700, armor: 0, act: 'II' };

    // Act II ranged special: 2Honk Shakur
    ENEMY_TYPES['2Honk Shakur'] = { health: 110, speed: 0.98, damage: 18, color: '#E2D8FF', size: 34, xp: 48, ranged: true, rangedCooldown: 2000, armor: 1, act: 'II' };

    // Act III ranged enemy: Cardi Beak (exclusive to Act III)
    // Uses assets/swans/spritesheets/cardibeak-sheet.png. Spritesheet with 8 columns, 4 rows, 32 frames, using all frames. Default side faces right; left is mirrored.
    // Stats chosen as a mid-tier Act III ranged grunt. Assumptions: health/speed/size tuned relative to other ranged grunts.
    ENEMY_TYPES['Cardi Beak'] = { health: 180, speed: 0.78, damage: 22, color: '#FF77AA', size: 42, xp: 220, ranged: true, rangedCooldown: 1400, armor: 2, act: 'III' };

    // Act III ranged enemy: Feather Krueger (exclusive to Act III)
    // Uses assets/swans/spritesheets/featherkrueger-sheet-6-31.png (animated spritesheet, frames 6-31, left/right facing only, mirrors for left).
    ENEMY_TYPES['Feather Krueger'] = { health: 220, speed: 0.66, damage: 28, color: '#88CCFF', size: 48, xp: 320, ranged: true, rangedCooldown: 1200, armor: 4, act: 'III' };

    // Act III ranged enemy: Honkutus of Cygnus (exclusive to Act III)
    // Uses assets/swans/honkutusofcygnus.png. Default side faces right; left is mirrored.
    ENEMY_TYPES['Honkutus of Cygnus'] = { health: 200, speed: 0.72, damage: 26, color: '#C8B3FF', size: 46, xp: 300, ranged: true, rangedCooldown: 1300, armor: 3, act: 'III' };

    // Act III ranged enemy: Mr Gosling (exclusive to Act III)
    // Uses assets/swans/mrgosling.png. Default side faces right; left is mirrored.
    ENEMY_TYPES['Mr Gosling'] = { health: 240, speed: 0.68, damage: 30, color: '#B3D1FF', size: 52, xp: 360, ranged: true, rangedCooldown: 1400, armor: 5, act: 'III' };

    // Act III boss: Cygnus Prime (street 5)
    // Uses assets/swans/spritesheets/cygnusprime-sheet-20-31.png. Spritesheet with 8 columns, 4 rows, 32 frames, using 20-31. Default side faces right; left is mirrored.
    ENEMY_TYPES['Cygnus Prime'] = { health: 1800, speed: 0.36, damage: 72, color: '#C0C8FF', size: 160, xp: 8000, ranged: true, rangedCooldown: 1100, armor: 12, act: 'III', boss: true, spawnStreet: 5 };
    // Act III ranged enemy: The Honkinator (exclusive to Act III)
    // Uses assets/swans/spritesheets/honkinator-sheet-0-24.png. Spritesheet with 8 columns, 4 rows, 32 frames, using 0-24. Default side faces right; left is mirrored.
    ENEMY_TYPES['The Honkinator'] = { health: 160, speed: 0.72, damage: 20, color: '#FFCC88', size: 48, xp: 420, ranged: true, rangedCooldown: 1200, armor: 2, act: 'III' };

    // Secret boss: Wunderswan (spawned conditionally in generateRoom)
    ENEMY_TYPES['Wunderswan'] = { health: 100000, speed: 0.38, damage: 80, color: '#FF4444', size: 180, xp: 12000, ranged: true, rangedCooldown: 1200, armor: 18, bossSecret: true };
    // Secret boss: Golden Goose (unlocks Act II when defeated)
    ENEMY_TYPES['Golden Goose'] = { health: 100000, speed: 0.36, damage: 90, color: '#FFD24D', size: 180, xp: 14000, ranged: true, rangedCooldown: 3000, armor: 16, bossSecret: true };

    // Act III melee enemy: Swanomaly (non-ranged, Act III exclusive)
    ENEMY_TYPES['Swanomaly'] = { health: 220, speed: 0.52, damage: 18, color: '#E6F4FF', size: 56, xp: 420, ranged: false, armor: 3, act: 'III' };
    // Act III ranged enemy: Swan Wick (exclusive to Act III)
    // Uses assets/swans/spritesheets/swanwick-sheet-3-29.png (animated spritesheet, frames 3-29, left/right facing only, mirrors for left).
    // Uses assets/swans/swanwick.png. Default side faces right; left is mirrored.
    ENEMY_TYPES['Swan Wick'] = { health: 200, speed: 0.70, damage: 20, color: '#DDEEFF', size: 44, xp: 360, ranged: true, rangedCooldown: 1300, armor: 2, act: 'III' };

    // Act III melee enemy: Swandroid 18 (non-ranged, Act III exclusive)
    // Uses assets/swans/swandroid18.jpeg. Front/Rear/Side frames provided; side faces RIGHT by default.
    ENEMY_TYPES['Swandroid 18'] = { health: 260, speed: 0.70, damage: 26, color: '#9FB3FF', size: 52, xp: 380, ranged: false, armor: 4, act: 'III' };

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

                    // Floating damage numbers storage
                        game.damageNumbers = []; // Initialize damage numbers array

                        // Initialize reality break distortion state for rendering
                        game.realityBreakDistort = { time: 0, intensity: 0.15 };

            // World pickups (health bread, etc.)
            game.pickups = [];
            // Beartraps (ability-based deployables)
            game.traps = [];
            game._lastTrapDrop = 0;
            // Punji pits (poison spike fields)
            game.pits = [];
            game._lastPitDrop = 0;
            // Nuke strike markers (Oppemheimer ability)
            game.nukes = [];
            game._lastNuke = 0;
            // Poison cloud trail (Silent But Deadly ability)
            game.poisonClouds = [];
            // Fragment Wake sparks (lingering damaging embers)
            game.fragmentSparks = [];
            // EKG damaging trail segments (lingering hazardous line pieces)
            game.ekgTrailSegments = [];
            game._lastPoisonCloud = 0;
            // Photon strike visual records
            game.photonStrikes = [];
            // Traveling shockwaves (Shockwave ability)
            game.shockwaves = [];

            // Tanks Alot state
            game.trucks = [];
            game.truckFires = [];
            game._lastTruckSpawn = 0;

            // Small util: darken/lighten hex color (amount negative to darken)
            window.shadeColor = function(col, amt) {
                try {
                    if (!col || col[0] !== '#') return col;
                    let num = parseInt(col.slice(1), 16);
                    let r = (num >> 16) & 255;
                    let g = (num >> 8) & 255;
                    let b = num & 255;
                    r = Math.min(255, Math.max(0, r + amt));
                    g = Math.min(255, Math.max(0, g + amt));
                    b = Math.min(255, Math.max(0, b + amt));
                    return '#' + (r.toString(16).padStart(2,'0')) + (g.toString(16).padStart(2,'0')) + (b.toString(16).padStart(2,'0'));
                } catch(e) { return col; }
            };

            // Background music now created in title screen start() to ensure autoplay eligibility.
            // (Previously created here, causing some browsers to require a second click to play.)
            if (!game.bgMusic) {
                // placeholder reference; real Audio object assigned on start
                game.bgMusic = null;
            }

            // Prevent spacebar from scrolling the page
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    // Prevent page scroll AND suppress normal firing when ending overlay is active
                    e.preventDefault();
                    if (game && game._bigQuackDefeated && !game._finalAbilityOffered) {
                        const overlay = document.getElementById('endingOverlay');
                        if (overlay) overlay.remove();
                        offerPermanentAbilityChoice();
                        game._finalAbilityOffered = true;
                        return; // stop propagation to any firing logic
                    }
                }
                // Dev: toggle sprite bounds with F3
                if (e.code === 'F3') {
                    game._debugSpriteBounds = !game._debugSpriteBounds;
                    console.info('[Debug] Sprite bounds:', game._debugSpriteBounds ? 'ON' : 'OFF');
                }
                if (e.code === 'F1') {
                    console.info('[Sprite Debug]', {
                        meta: game.player && game.player.spriteMeta,
                        scale: game.player && game.player.spriteScale,
                        loaded: game.player && game.player.spriteLoaded,
                        directionalFrames: game.player && game.player.directionalFrames,
                        facing: game.player && game.player.facing
                    });
                }
                if (e.code === 'F2') {
                    game.perfHud = !game.perfHud;
                    console.info('[Perf HUD]', game.perfHud ? 'ON' : 'OFF');
                }
                if (e.code === 'F4') {
                    console.info('[ThugSprite Debug]', game.enemySprites && game.enemySprites.thug);
                }
                if (e.code === 'F5') {
                    console.info('[StreetDogSprite Debug]', game.enemySprites && game.enemySprites.streetDog);
                }
                if (e.code === 'F6') {
                    console.info('[PunkSprite Debug]', game.enemySprites && game.enemySprites.punk);
                }
                if (e.code === 'F7') {
                    console.info('[DealerSprite Debug]', game.enemySprites && game.enemySprites.dealer);
                }
                if (e.code === 'F8') {
                    console.info('[EnforcerSprite Debug]', game.enemySprites && game.enemySprites.enforcer);
                }
                if (e.code === 'F9') {
                    console.info('[BossThugSprite Debug]', game.enemySprites && game.enemySprites.bossThug);
                }
                if (e.code === 'F10') {
                    console.info('[BossGangsterSprite Debug]', game.enemySprites && game.enemySprites.bossGangster);
                }
                if (e.code === 'F11') {
                    console.info('[BigQuackSprite Debug]', game.enemySprites && game.enemySprites.bigQuack);
                }
                if (e.code === 'F12') {
                    console.info('[GangsterSprite Debug]', game.enemySprites && game.enemySprites.gangster);
                }
            });
            // Also allow mouse primary click on ending overlay to proceed (mobile / desktop convenience)
            window.addEventListener('mousedown', (e) => {
                if (game && game._bigQuackDefeated && !game._finalAbilityOffered) {
                    const overlay = document.getElementById('endingOverlay');
                    if (overlay) {
                        overlay.remove();
                        offerPermanentAbilityChoice();
                        game._finalAbilityOffered = true;
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            // Removed pointer fallback to match original spec (FIRE key only)

            // --- Permanent Ability Integration ---
            try { ensureSeenAbilitiesLoaded(); } catch(_) {}
            loadPermanentAbilities();
            grantPermanentAbilities();
            // Cleanup removed abilities post-reset
            if (game.player && Array.isArray(game.player.abilities)) {
                game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
            }
            if (game.player && Array.isArray(game.player.permanentAbilities)) {
                game.player.permanentAbilities = game.player.permanentAbilities.filter(a => ABILITIES[a]);
            }
            // Clean up any abilities that were removed from the design set
            if (game.player && Array.isArray(game.player.abilities)) {
                game.player.abilities = game.player.abilities.filter(a => ABILITIES[a]);
            }
            if (game.player && Array.isArray(game.player.permanentAbilities)) {
                game.player.permanentAbilities = game.player.permanentAbilities.filter(a => ABILITIES[a]);
            }

            const PLAYER_IDLE_BOUNDS = { x: 25, y: 42, w: 505, h: 756 };
            const PLAYER_WALK_BOUNDS = [
                { x: 45, y: 13, w: 183, h: 253 },
                { x: 301, y: 13, w: 183, h: 236 },
                { x: 557, y: 10, w: 184, h: 239 },
                { x: 813, y: 9, w: 183, h: 240 },
                { x: 1069, y: 10, w: 183, h: 239 },
                { x: 1325, y: 13, w: 184, h: 236 },
                { x: 1581, y: 13, w: 183, h: 236 },
                { x: 1837, y: 12, w: 184, h: 237 },
                { x: 45, y: 266, w: 183, h: 239 }
            ];
            const PLAYER_WALK_SHEET = {
                cols: 8,
                rows: 2,
                frameWidth: 256,
                frameHeight: 266,
                frames: [
                    { row: 0, col: 0 },
                    { row: 0, col: 1 },
                    { row: 0, col: 2 },
                    { row: 0, col: 3 },
                    { row: 0, col: 4 },
                    { row: 0, col: 5 },
                    { row: 0, col: 6 },
                    { row: 0, col: 7 },
                    { row: 1, col: 0 }
                ]
            };
            const PLAYER_TARGET_HEIGHT = 54;
            game.player = game.player || {};
            game.player.facing = game.player.facing || 'down';
            game.player.animFrame = 0;
            game.player.animTimer = 0;
            game.player.animSpeed = 7;
            game.player.moving = false;
            game.player.walkFrames = game.player.walkFrames || null;
            game.player.spriteTargetHeight = game.player.spriteTargetHeight || PLAYER_TARGET_HEIGHT;
            game.player.spriteMeta = {
                rows: PLAYER_WALK_SHEET.rows,
                cols: PLAYER_WALK_SHEET.cols,
                frameWidth: PLAYER_WALK_SHEET.frameWidth,
                frameHeight: PLAYER_WALK_SHEET.frameHeight,
                totalFrames: PLAYER_WALK_SHEET.frames.length,
                order: ['right']
            };

            function applyPlayerScaleFromHeight(height) {
                if (!height || height <= 0) return;
                const scale = PLAYER_TARGET_HEIGHT / height;
                if (isFinite(scale) && scale > 0) {
                    game.player.spriteScale = scale;
                }
            }

            function buildDirectionalFramesFromBounds(image, bounds) {
                if (!image || !bounds) return null;
                const frame = {
                    image,
                    x: bounds.x,
                    y: bounds.y,
                    w: bounds.w,
                    h: bounds.h,
                    visibleHeight: bounds.visibleHeight || bounds.h,
                    visibleWidth: bounds.visibleWidth || bounds.w
                };
                return {
                    down: { ...frame },
                    up: { ...frame },
                    right: { ...frame }
                };
            }

            function applyWalkFrames(image) {
                if (!image) return;
                game.player.spriteSheet = image;
                const uniformWidth = PLAYER_WALK_BOUNDS.reduce((m, b) => Math.max(m, b.w), 0);
                const uniformHeight = PLAYER_WALK_BOUNDS.reduce((m, b) => Math.max(m, b.h), 0);
                game.player.walkFrames = PLAYER_WALK_BOUNDS.map(raw => {
                    const bottom = raw.y + raw.h;
                    let cropY = Math.round(bottom - uniformHeight);
                    if (cropY < 0) cropY = 0;
                    if (cropY + uniformHeight > image.height) cropY = Math.max(0, image.height - uniformHeight);
                    const centerX = raw.x + raw.w / 2;
                    let cropX = Math.round(centerX - uniformWidth / 2);
                    if (cropX < 0) cropX = 0;
                    if (cropX + uniformWidth > image.width) cropX = Math.max(0, image.width - uniformWidth);
                    return {
                        image,
                        x: cropX,
                        y: cropY,
                        w: uniformWidth,
                        h: uniformHeight,
                        visibleHeight: raw.h,
                        visibleWidth: raw.w
                    };
                });
                if (game.player.spriteMeta) {
                    game.player.spriteMeta.rows = PLAYER_WALK_SHEET.rows;
                    game.player.spriteMeta.cols = PLAYER_WALK_SHEET.cols;
                    game.player.spriteMeta.frameWidth = PLAYER_WALK_SHEET.frameWidth;
                    game.player.spriteMeta.frameHeight = PLAYER_WALK_SHEET.frameHeight;
                    game.player.spriteMeta.totalFrames = PLAYER_WALK_SHEET.frames.length;
                    game.player.spriteMeta.order = ['right'];
                }
                game.player.walkBaseHeight = uniformHeight;
                game.player.spriteTargetHeight = game.player.spriteTargetHeight || PLAYER_TARGET_HEIGHT;
                const first = game.player.walkFrames[0];
                if (first) {
                    if (!game.player.directionalFrames) {
                        game.player.directionalFrames = buildDirectionalFramesFromBounds(image, {
                            x: first.x,
                            y: first.y,
                            w: first.w,
                            h: first.h,
                            visibleHeight: first.visibleHeight,
                            visibleWidth: first.visibleWidth
                        });
                    }
                    applyPlayerScaleFromHeight(first.visibleHeight || first.h);
                }
                game.player.spriteLoaded = true;
            }

            function applyIdleFrame(image) {
                if (!image) return;
                const frames = buildDirectionalFramesFromBounds(image, {
                    ...PLAYER_IDLE_BOUNDS,
                    visibleHeight: PLAYER_IDLE_BOUNDS.h,
                    visibleWidth: PLAYER_IDLE_BOUNDS.w
                });
                if (frames) {
                    game.player.directionalFrames = frames;
                    game.player.spriteTargetHeight = game.player.spriteTargetHeight || PLAYER_TARGET_HEIGHT;
                    applyPlayerScaleFromHeight(PLAYER_IDLE_BOUNDS.h);
                }
            }

            if (!game.player.walkSheet) game.player.walkSheet = new Image();
            game.player.walkSheet.onload = () => applyWalkFrames(game.player.walkSheet);
            game.player.walkSheet.onerror = (err) => { console.warn('[PlayerSprite] walk sheet failed to load', err); };
            game.player.walkSheet.src = 'assets/playerwalk-sheet.png';

            if (!game.player.idleImage) game.player.idleImage = new Image();
            game.player.idleImage.onload = () => applyIdleFrame(game.player.idleImage);
            game.player.idleImage.onerror = (err) => { console.warn('[PlayerSprite] idle sprite failed to load', err); };
            game.player.idleImage.src = 'assets/player-side.png';

            // Legacy sprite flags kept for fallback detection
            game.sprites = game.sprites || {};
            game.spritesLoaded = { front:false, rear:false, side:false };

            // Game Over assets & state
            game.gameOverImage = new Image();
            game.gameOverImage.src = 'assets/gameover.png';
            game.gameOver = false;
            game._gameOverSound = null;
            game.player.spriteLoaded = !!(game.player.walkSheet && game.player.walkSheet.complete);

            // Helper: rebuild player directional frames if lost or on reset
            function rebuildPlayerSprite() {
                try {
                    if (!game || !game.player) return;
                    if (game.player.walkSheet && game.player.walkSheet.complete) {
                        applyWalkFrames(game.player.walkSheet);
                    }
                    if (game.player.idleImage && game.player.idleImage.complete) {
                        applyIdleFrame(game.player.idleImage);
                    }
                    if (!game.player.spriteLoaded && game.player.walkSheet && game.player.walkSheet.complete) {
                        game.player.spriteLoaded = true;
                    }
                    // Reset blink/visibility timers when rebuilding explicitly
                    game.player.blinkTimer = 0;
                    game.player.wasHitTimer = 0;
                    // Ensure visibility and loaded flags so render path draws immediately
                    game.player.spriteLoaded = true;
                    if (!game.player.forceVisibleFrames || game.player.forceVisibleFrames < 30) {
                        game.player.forceVisibleFrames = 45; // extend a bit after rebuild
                    }
                } catch(e) { console.warn('rebuildPlayerSprite failed', e); }
            }
            // Expose globally in case resetGame fires in a scope where local function not yet hoisted
            if (typeof window !== 'undefined') window.rebuildPlayerSprite = rebuildPlayerSprite;

            // === Thug enemy sprite sheet ===
            game.enemySprites = game.enemySprites || {};
            if (!game.enemySprites.thug) {
                const thugImg = new Image();
                thugImg.src = 'assets/knifeduck1-sheet.png';
                game.enemySprites.thug = { image: thugImg, loaded: false };
                thugImg.onload = () => {
                    game.enemySprites.thug.loaded = true;
                    const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                    const frames = [];
                    for (let i = 0; i <= 31; i++) {
                        frames.push(atlas.frames[i.toString()]);
                    }
                    const container = game.enemySprites.thug;
                    container.frames = frames;
                    const makeSequence = (id, seqFrames, options)=> ({
                        frames: seqFrames,
                        frameStep: options.frameStep || 5,
                        mirrorX: options.mirrorX || false,
                        source: options.source || null,
                        id: id
                    });
                    const rightSequence = makeSequence('right', frames, { frameStep: 5 });
                    const leftSequence = makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' });
                    container.animations = { right: rightSequence, left: leftSequence };
                    container.defaultAnimation = rightSequence;
                    container.anim = { sequence: frames, frameStep: 5 };
                    container.animFrameStep = 5;
                    const refH = 256;
                    container.referenceHeight = refH;
                    container.referenceWidth = 256;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                        const w = 256 * scale; const h = 256 * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    container.image = thugImg;
                    console.info('[ThugSprite] Loaded knifeduck1-sheet.png', { frames: frames.length });
                };
                thugImg.onerror = (ev)=> { try { console.warn('[ThugSprite] failed to load assets/knifeduck1-sheet.png', ev); } catch(_){} };
            }

            // === Eggscobar (Act II exclusive) sprite ===
            if (!game.enemySprites.eggscobar) {
                const egImg = new Image();
                egImg.src = 'assets/geese/spritesheets/eggscobar-sheet-12-31.png';
                game.enemySprites.eggscobar = { image: egImg, loaded: false };
                egImg.onload = function(ev) {
                    const img = (ev && ev.target) ? ev.target : this;
                    try {
                        game.enemySprites.eggscobar.loaded = true;
                        // Spritesheet atlas frames 11-30 (frames 12-31 in 1-based, 20 total frames)
                        game.enemySprites.eggscobar.frames = [
                            {x:1024,y:256,w:256,h:256}, {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256},
                            {x:0,y:512,w:256,h:256}, {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256},
                            {x:1024,y:512,w:256,h:256}, {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256},
                            {x:0,y:768,w:256,h:256}, {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256},
                            {x:1024,y:768,w:256,h:256}, {x:1280,y:768,w:256,h:256}, {x:1536,y:768,w:256,h:256}, {x:1792,y:768,w:256,h:256}
                        ];
                        const refH = 256;
                        game.enemySprites.eggscobar.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                        game.enemySprites.eggscobar.computeHitbox = (enemy)=> {
                            const size = enemy.size; const scale = game.enemySprites.eggscobar.baseScaleForSize(size);
                            const f = game.enemySprites.eggscobar.frames[0];
                            const w = f.w * scale; const h = f.h * scale;
                            const hitW = w * 0.5;
                            const hitH = h * 0.6;
                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                        };
                        try { console.info('[EggscobarSprite] Loaded eggscobar-sheet-12-31.png', game.enemySprites.eggscobar.frames.length, 'frames'); } catch(_){}
                    } catch(e) { console.warn('[EggscobarSprite] onload error', e); }
                };
                egImg.onerror = function(ev){ try { console.warn('[EggscobarSprite] failed to load', ev, egImg && egImg.src); } catch(_){} };
                try { const resolved = (new URL('assets/geese/spritesheets/eggscobar-sheet-12-31.png', document.baseURI)).href; egImg.src = resolved; } catch(_) { /* keep assigned src */ }
            }
            // === Enforcer enemy sprite sheet ===
            if (!game.enemySprites.enforcer) {
                const enfImg = new Image();
                enfImg.src = 'assets/enforcer-sheet.png';
                game.enemySprites.enforcer = { image: enfImg, loaded: false };
                enfImg.onload = () => {
                    game.enemySprites.enforcer.loaded = true;
                    const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                    const frames = [];
                    // Use all frames 0-31
                    for (let i = 0; i <= 31; i++) {
                        frames.push(atlas.frames[i.toString()]);
                    }
                    const container = game.enemySprites.enforcer;
                    container.frames = frames;
                    const makeSequence = (id, seqFrames, options)=> ({
                        frames: seqFrames,
                        frameStep: options.frameStep || 5,
                        mirrorX: options.mirrorX || false,
                        source: options.source || null,
                        id: id
                    });
                    const rightSequence = makeSequence('right', frames, { frameStep: 5 });
                    const leftSequence = makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' });
                    container.animations = { right: rightSequence, left: leftSequence };
                    container.defaultAnimation = rightSequence;
                    container.anim = { sequence: frames, frameStep: 5 };
                    container.animFrameStep = 5;
                    const refH = 256;
                    container.referenceHeight = refH;
                    container.referenceWidth = 256;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                        const w = 256 * scale; const h = 256 * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    container.image = enfImg;
                    console.info('[EnforcerSprite] Loaded enforcer-sheet.png', { frames: frames.length });
                };
                enfImg.onerror = (ev)=> { try { console.warn('[EnforcerSprite] failed to load assets/enforcer-sheet.png', ev); } catch(_){} };
                try { const resolved = (new URL('assets/enforcer-sheet.png', document.baseURI)).href; enfImg.src = resolved; } catch(_) { /* keep assigned src */ }
            }

            // === Swanomaly (Act III exclusive) animated sprite loader ===
            if (!game.enemySprites.swanomaly) {
                try {
                    const soImg = new Image();
                    try { soImg.src = (new URL('assets/swans/spritesheets/swanomaly-sheet-0-27.png', document.baseURI)).href; } catch(_) { soImg.src = 'assets/swans/spritesheets/swanomaly-sheet-0-27.png'; }
                    game.enemySprites.swanomaly = { image: soImg, loaded: false, _forcedBitmap: null };
                    const atlasFrames = [
                        {"x":0,"y":0,"w":256,"h":256,"duration":1},
                        {"x":256,"y":0,"w":256,"h":256,"duration":1},
                        {"x":512,"y":0,"w":256,"h":256,"duration":1},
                        {"x":768,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                        {"x":0,"y":256,"w":256,"h":256,"duration":1},
                        {"x":256,"y":256,"w":256,"h":256,"duration":1},
                        {"x":512,"y":256,"w":256,"h":256,"duration":1},
                        {"x":768,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                        {"x":0,"y":512,"w":256,"h":256,"duration":1},
                        {"x":256,"y":512,"w":256,"h":256,"duration":1},
                        {"x":512,"y":512,"w":256,"h":256,"duration":1},
                        {"x":768,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                        {"x":0,"y":768,"w":256,"h":256,"duration":1},
                        {"x":256,"y":768,"w":256,"h":256,"duration":1},
                        {"x":512,"y":768,"w":256,"h":256,"duration":1},
                        {"x":768,"y":768,"w":256,"h":256,"duration":1}
                    ];
                    soImg.onload = function(ev){
                        try {
                            const img = (ev && ev.target) ? ev.target : this;
                            const cont = game.enemySprites.swanomaly;
                            // If a createImageBitmap fallback was previously used, prefer the real Image now.
                            try {
                                if (cont && cont._forcedBitmap) {
                                    try { if (cont._forcedBitmap.close) cont._forcedBitmap.close(); } catch(_){}
                                    cont._forcedBitmap = null;
                                    try { console.info('[SwanomalySprite] Image loaded; cleared forced bitmap fallback'); } catch(_){}
                                }
                            } catch(_){}
                            cont.loaded = true;
                            cont.frames = { seq: atlasFrames };
                            cont.anim = { frameStep: 8 };
                            const refH = 256;
                            cont.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            cont.computeHitbox = (enemy)=>{
                                try {
                                    const size = enemy.size || 56; const scale = cont.baseScaleForSize(size);
                                    const w = 256 * scale; const h = 256 * scale;
                                    const hitW = w * 0.62; const hitH = h * 0.66;
                                    return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                } catch(_) { return { w: enemy.size||56, h: enemy.size||56, ox: -(enemy.size||56)/2, oy: -(enemy.size||56)/2 }; }
                            };
                            try { console.info('[SwanomalySprite] Loaded swanomaly spritesheet', cont.frames); } catch(_){}
                        } catch(e) { console.warn('[SwanomalySprite] onload error', e); }
                    };
                    soImg.onerror = function(ev){
                        try {
                            const cont = game.enemySprites.swanomaly;
                            try { console.warn('[SwanomalySprite] image onerror, attempting cache-bust then fetch fallback', soImg && soImg.src); } catch(_){}
                            if (!soImg._triedBust) { soImg._triedBust = true; try { soImg.src = soImg.src + (soImg.src.indexOf('?')===-1 ? '?v=1' : '&v=1'); } catch(_){}; return; }
                            const href = soImg.src || '';
                            if (href.indexOf('file:') === 0) { cont._broken = true; try { console.warn('[SwanomalySprite] running from file:// - skipping fetch fallback'); } catch(_){}; return; }
                            try {
                                if (typeof fetch === 'function' && typeof createImageBitmap === 'function') {
                                    try { console.info('[SwanomalySprite] starting fetch/createImageBitmap fallback for', href); } catch(_){}
                                    const ac = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                                    const signal = ac ? ac.signal : null;
                                    const t = setTimeout(()=>{ try{ if (ac) ac.abort(); }catch(_){} }, 900);
                                    fetch(href, { signal }).then(r=>r.blob()).then(b=>createImageBitmap(b)).then(bmp=>{
                                        clearTimeout(t);
                                        cont._forcedBitmap = bmp; cont.loaded = true;
                                        try { console.info('[SwanomalySprite] createImageBitmap fallback succeeded'); } catch(_){}
                                    }).catch(e=>{ clearTimeout(t); try { console.warn('[SwanomalySprite] fetch/createImageBitmap fallback failed', e); } catch(_){} });
                                }
                            } catch(e) { try { console.warn('[SwanomalySprite] fallback error', e); } catch(_){} }
                        } catch(_){}
                    };
                    try { game.enemySprites['Swanomaly'] = game.enemySprites.swanomaly; } catch(_){}
                    try { game.enemySprites['swanomaly'] = game.enemySprites.swanomaly; } catch(_){}
                } catch(e) { console.warn('[SwanomalySprite] install failed', e); }
            }

                    // === Swan Wick (Act III ranged enemy) sprite ===
                    if (!game.enemySprites.swanwick) {
                        try {
                            const swImg = new Image();
                            try { swImg.src = (new URL('assets/swans/spritesheets/swanwick-sheet-3-29.png', document.baseURI)).href; } catch(_) { swImg.src = 'assets/swans/spritesheets/swanwick-sheet-3-29.png'; }
                            game.enemySprites.swanwick = { image: swImg, loaded: false, _forcedBitmap: null };
                            swImg.onload = function(ev){
                                try {
                                    const img = (ev && ev.target) ? ev.target : this;
                                    const cont = game.enemySprites.swanwick;
                                    // If a createImageBitmap fallback was used earlier, clear it so the real Image is preferred
                                    try { if (cont && cont._forcedBitmap) { try { if (cont._forcedBitmap.close) cont._forcedBitmap.close(); } catch(_){} cont._forcedBitmap = null; try { console.info('[SwanWickSprite] Image loaded; cleared forced bitmap fallback'); } catch(_){} } } catch(_){}
                                    cont.loaded = true;
                                    // Spritesheet: 8 columns, 4 rows, 32 frames, use frames 3-29 (27 frames)
                                    const atlasFrames = [
                                        {x:768,y:0,w:256,h:256,duration:1}, // frame 3
                                        {x:1024,y:0,w:256,h:256,duration:1}, // 4
                                        {x:1280,y:0,w:256,h:256,duration:1}, // 5
                                        {x:1536,y:0,w:256,h:256,duration:1}, // 6
                                        {x:1792,y:0,w:256,h:256,duration:1}, // 7
                                        {x:0,y:256,w:256,h:256,duration:1}, // 8
                                        {x:256,y:256,w:256,h:256,duration:1}, // 9
                                        {x:512,y:256,w:256,h:256,duration:1}, // 10
                                        {x:768,y:256,w:256,h:256,duration:1}, // 11
                                        {x:1024,y:256,w:256,h:256,duration:1}, // 12
                                        {x:1280,y:256,w:256,h:256,duration:1}, // 13
                                        {x:1536,y:256,w:256,h:256,duration:1}, // 14
                                        {x:1792,y:256,w:256,h:256,duration:1}, // 15
                                        {x:0,y:512,w:256,h:256,duration:1}, // 16
                                        {x:256,y:512,w:256,h:256,duration:1}, // 17
                                        {x:512,y:512,w:256,h:256,duration:1}, // 18
                                        {x:768,y:512,w:256,h:256,duration:1}, // 19
                                        {x:1024,y:512,w:256,h:256,duration:1}, // 20
                                        {x:1280,y:512,w:256,h:256,duration:1}, // 21
                                        {x:1536,y:512,w:256,h:256,duration:1}, // 22
                                        {x:1792,y:512,w:256,h:256,duration:1}, // 23
                                        {x:0,y:768,w:256,h:256,duration:1}, // 24
                                        {x:256,y:768,w:256,h:256,duration:1}, // 25
                                        {x:512,y:768,w:256,h:256,duration:1}, // 26
                                        {x:768,y:768,w:256,h:256,duration:1}, // 27
                                        {x:1024,y:768,w:256,h:256,duration:1}, // 28
                                        {x:1280,y:768,w:256,h:256,duration:1}  // 29
                                    ];
                                    cont.frames = {
                                        seq: atlasFrames,
                                        right: atlasFrames[0],
                                        down: atlasFrames[0],
                                        up: atlasFrames[0],
                                        front: atlasFrames[0],
                                        rear: atlasFrames[0]
                                    };
                                    cont.anim = { frameStep: 8 };
                                    // For left, create mirrored canvases if needed, but since animating, handle in draw
                                    // Precreate right canvas for first frame
                                    try {
                                        const rf = cont.frames.right;
                                        if (rf && img && img.naturalWidth && img.naturalHeight && typeof document !== 'undefined') {
                                            const rightC = document.createElement('canvas'); rightC.width = rf.w; rightC.height = rf.h;
                                            const rc = rightC.getContext('2d'); rc.imageSmoothingEnabled = true;
                                            rc.drawImage(img, rf.x, rf.y, rf.w, rf.h, 0, 0, rf.w, rf.h);

                                            const leftC = document.createElement('canvas'); leftC.width = rf.w; leftC.height = rf.h;
                                            const lc = leftC.getContext('2d'); lc.imageSmoothingEnabled = true;
                                            lc.translate(leftC.width, 0); lc.scale(-1, 1);
                                            lc.drawImage(rightC, 0, 0);

                                            try { cont._rightCanvas = rightC; } catch(_){ }
                                            try { cont._leftCanvas = leftC; } catch(_){ }
                                            try { cont.frames.right = { x:0,y:0,w:rightC.width,h:rightC.height }; } catch(_){ }
                                            try { cont.frames.left = { x:0,y:0,w:leftC.width,h:leftC.height }; } catch(_){ }
                                        }
                                    } catch(_){ }

                                    const refH = cont.frames.down.h || 256;
                                    cont.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                    cont.computeHitbox = (enemy)=>{
                                        try {
                                            const size = enemy.size || 44; const scale = cont.baseScaleForSize(size);
                                            const f = cont.frames.down || { w: size*2, h: size*2 };
                                            const w = f.w * scale; const h = f.h * scale;
                                            const hitW = w * 0.64; const hitH = h * 0.68;
                                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                        } catch(_) { return { w: enemy.size||44, h: enemy.size||44, ox: -(enemy.size||44)/2, oy: -(enemy.size||44)/2 }; }
                                    };
                                    try { console.info('[SwanWickSprite] Loaded swanwick-sheet-3-29.png', cont.frames); } catch(_){}
                                } catch(e) { console.warn('[SwanWickSprite] onload error', e); }
                            };
                            swImg.onerror = function(ev){
                                try {
                                    const cont = game.enemySprites.swanwick;
                                    try { console.warn('[SwanWickSprite] image onerror, attempting cache-bust then fetch fallback', swImg && swImg.src); } catch(_){ }
                                    if (!swImg._triedBust) { swImg._triedBust = true; try { swImg.src = swImg.src + (swImg.src.indexOf('?')===-1 ? '?v=1' : '&v=1'); } catch(_){}; return; }
                                    const href = swImg.src || '';
                                    if (href.indexOf('file:') === 0) { cont._broken = true; try { console.warn('[SwanWickSprite] running from file:// - skipping fetch fallback'); } catch(_){}; return; }
                                    try {
                                        if (typeof fetch === 'function' && typeof createImageBitmap === 'function') {
                                            try { console.info('[SwanWickSprite] starting fetch/createImageBitmap fallback for', href); } catch(_){ }
                                            const ac = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                                            const signal = ac ? ac.signal : null;
                                            const t = setTimeout(()=>{ try{ if (ac) ac.abort(); }catch(_){} }, 900);
                                            fetch(href, { signal }).then(r=>{ clearTimeout(t); if (!r.ok) throw new Error('status '+r.status); return r.blob(); }).then(b=>createImageBitmap(b)).then(bmp=>{
                                                clearTimeout(t);
                                                cont._forcedBitmap = bmp; cont.loaded = true;
                                                // Set up animation frames for fallback
                                                const atlasFrames = [
                                                    {x:768,y:0,w:256,h:256,duration:1}, // frame 3
                                                    {x:1024,y:0,w:256,h:256,duration:1}, // 4
                                                    {x:1280,y:0,w:256,h:256,duration:1}, // 5
                                                    {x:1536,y:0,w:256,h:256,duration:1}, // 6
                                                    {x:1792,y:0,w:256,h:256,duration:1}, // 7
                                                    {x:0,y:256,w:256,h:256,duration:1}, // 8
                                                    {x:256,y:256,w:256,h:256,duration:1}, // 9
                                                    {x:512,y:256,w:256,h:256,duration:1}, // 10
                                                    {x:768,y:256,w:256,h:256,duration:1}, // 11
                                                    {x:1024,y:256,w:256,h:256,duration:1}, // 12
                                                    {x:1280,y:256,w:256,h:256,duration:1}, // 13
                                                    {x:1536,y:256,w:256,h:256,duration:1}, // 14
                                                    {x:1792,y:256,w:256,h:256,duration:1}, // 15
                                                    {x:0,y:512,w:256,h:256,duration:1}, // 16
                                                    {x:256,y:512,w:256,h:256,duration:1}, // 17
                                                    {x:512,y:512,w:256,h:256,duration:1}, // 18
                                                    {x:768,y:512,w:256,h:256,duration:1}, // 19
                                                    {x:1024,y:512,w:256,h:256,duration:1}, // 20
                                                    {x:1280,y:512,w:256,h:256,duration:1}, // 21
                                                    {x:1536,y:512,w:256,h:256,duration:1}, // 22
                                                    {x:1792,y:512,w:256,h:256,duration:1}, // 23
                                                    {x:0,y:768,w:256,h:256,duration:1}, // 24
                                                    {x:256,y:768,w:256,h:256,duration:1}, // 25
                                                    {x:512,y:768,w:256,h:256,duration:1}, // 26
                                                    {x:768,y:768,w:256,h:256,duration:1}, // 27
                                                    {x:1024,y:768,w:256,h:256,duration:1}, // 28
                                                    {x:1280,y:768,w:256,h:256,duration:1}  // 29
                                                ];
                                                cont.frames = {
                                                    seq: atlasFrames,
                                                    right: atlasFrames[0],
                                                    down: atlasFrames[0],
                                                    up: atlasFrames[0],
                                                    front: atlasFrames[0],
                                                    rear: atlasFrames[0]
                                                };
                                                cont.anim = { frameStep: 8 };
                                                const refH = cont.frames.down.h || 256;
                                                cont.baseScaleForSize = cont.baseScaleForSize || ((enemySize)=> ((enemySize*2)/refH));
                                                cont.computeHitbox = cont.computeHitbox || (enemy=>{
                                                    const size = enemy.size || 44; const scale = cont.baseScaleForSize(size);
                                                    const f = cont.frames.down || { w: size*2, h: size*2 };
                                                    const w = f.w * scale; const h = f.h * scale;
                                                    const hitW = w * 0.64; const hitH = h * 0.68;
                                                    return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                                });
                                                try { console.info('[SwanWickSprite] createImageBitmap fallback succeeded'); } catch(_){ }
                                            }).catch(e=>{ clearTimeout(t); try { console.warn('[SwanWickSprite] fetch/createImageBitmap fallback failed', e); } catch(_){} });
                                        }
                                    } catch(e) { try { console.warn('[SwanWickSprite] fallback error', e); } catch(_){} }
                                } catch(_){}
                            };
                            try { if (!game.enemySprites.swanwick) game.enemySprites.swanwick = game.enemySprites.swanwick; } catch(_){ }
                            try { if (!game.enemySprites['Swan Wick']) game.enemySprites['Swan Wick'] = game.enemySprites.swanwick; } catch(_){ }
                        } catch(e) { console.warn('[SwanWickSprite] install failed', e); }
                    }

                    // === Cygnus Prime (Act III boss) sprite loader ===
                    if (!game.enemySprites.cygnusPrime) {
                        try {
                            const cpImg = new Image();
                            try { cpImg.src = (new URL('assets/swans/spritesheets/cygnusprime-sheet-20-31.png', document.baseURI)).href; } catch(_) { cpImg.src = 'assets/swans/spritesheets/cygnusprime-sheet-20-31.png'; }
                            game.enemySprites.cygnusPrime = { image: cpImg, loaded: false, _forcedBitmap: null };
                            const atlasFrames = [
                                {"x":0,"y":0,"w":256,"h":256,"duration":1},
                                {"x":256,"y":0,"w":256,"h":256,"duration":1},
                                {"x":512,"y":0,"w":256,"h":256,"duration":1},
                                {"x":768,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                                {"x":0,"y":256,"w":256,"h":256,"duration":1},
                                {"x":256,"y":256,"w":256,"h":256,"duration":1},
                                {"x":512,"y":256,"w":256,"h":256,"duration":1},
                                {"x":768,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                                {"x":0,"y":512,"w":256,"h":256,"duration":1},
                                {"x":256,"y":512,"w":256,"h":256,"duration":1},
                                {"x":512,"y":512,"w":256,"h":256,"duration":1},
                                {"x":768,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                                {"x":0,"y":768,"w":256,"h":256,"duration":1},
                                {"x":256,"y":768,"w":256,"h":256,"duration":1},
                                {"x":512,"y":768,"w":256,"h":256,"duration":1},
                                {"x":768,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":768,"w":256,"h":256,"duration":1}
                            ];
                            function cpBox(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                            cpImg.onload = function(ev){
                                try {
                                    const img = (ev && ev.target) ? ev.target : this;
                                    const cont = game.enemySprites.cygnusPrime;
                                    try { if (cont && cont._forcedBitmap) { try { if (cont._forcedBitmap.close) cont._forcedBitmap.close(); } catch(_){} cont._forcedBitmap = null; try { console.info('[CygnusPrimeSprite] Image loaded; cleared forced bitmap fallback'); } catch(_){}} } catch(_){ }
                                    cont.loaded = true;
                                    cont.frames = { seq: atlasFrames.slice(20,32) };
                                    cont.anim = { frameStep: 8 };
                                    const refH = 256;
                                    cont.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                    cont.computeHitbox = (enemy)=>{
                                        try {
                                            const size = enemy.size || 160; const scale = cont.baseScaleForSize(size);
                                            const w = 256 * scale; const h = 256 * scale;
                                            const hitW = w * 0.70; const hitH = h * 0.72;
                                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                        } catch(_) { return { w: enemy.size||160, h: enemy.size||160, ox: -(enemy.size||160)/2, oy: -(enemy.size||160)/2 }; }
                                    };
                                    try { console.info('[CygnusPrimeSprite] Loaded cygnusprime spritesheet', cont.frames); } catch(_){ }
                                } catch(e) { console.warn('[CygnusPrimeSprite] onload error', e); }
                            };
                            cpImg.onerror = function(ev){
                                try {
                                    const cont = game.enemySprites.cygnusPrime;
                                    try { console.warn('[CygnusPrimeSprite] image onerror, attempting cache-bust then fetch fallback', cpImg && cpImg.src); } catch(_){ }
                                    if (!cpImg._triedBust) { cpImg._triedBust = true; try { cpImg.src = cpImg.src + (cpImg.src.indexOf('?')===-1 ? '?v=1' : '&v=1'); } catch(_){}; return; }
                                    const href = cpImg.src || '';
                                    if (href.indexOf('file:') === 0) { cont._broken = true; try { console.warn('[CygnusPrimeSprite] running from file:// - skipping fetch fallback'); } catch(_){}; return; }
                                    try {
                                        if (typeof fetch === 'function' && typeof createImageBitmap === 'function') {
                                            try { console.info('[CygnusPrimeSprite] starting fetch/createImageBitmap fallback for', href); } catch(_){ }
                                            const ac = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                                            const signal = ac ? ac.signal : null;
                                            const t = setTimeout(()=>{ try{ if (ac) ac.abort(); }catch(_){} }, 900);
                                            fetch(href, { signal }).then(r=>{ clearTimeout(t); if (!r.ok) throw new Error('status '+r.status); return r.blob(); }).then(b=>createImageBitmap(b)).then(bmp=>{
                                                clearTimeout(t);
                                                cont._forcedBitmap = bmp; cont.loaded = true;
                                                cont.frames = { seq: atlasFrames.slice(20,32) };
                                                cont.anim = { frameStep: 8 };
                                                try { console.info('[CygnusPrimeSprite] createImageBitmap fallback succeeded'); } catch(_){ }
                                            }).catch(e=>{ clearTimeout(t); try { console.warn('[CygnusPrimeSprite] fetch/createImageBitmap fallback failed', e); } catch(_){} });
                                        }
                                    } catch(e) { try { console.warn('[CygnusPrimeSprite] fallback error', e); } catch(_){} }
                                } catch(_){ }
                            };
                            try { if (!game.enemySprites.cygnusPrime) game.enemySprites.cygnusPrime = game.enemySprites.cygnusPrime; } catch(_){ }
                            try { if (!game.enemySprites['Cygnus Prime']) game.enemySprites['Cygnus Prime'] = game.enemySprites.cygnusPrime; } catch(_){ }
                        } catch(e) { console.warn('[CygnusPrimeSprite] install failed', e); }
                    }

                    // === The Honkinator (Act III ranged) sprite loader ===
                    if (!game.enemySprites.honkinator) {
                        try {
                            const hImg = new Image();
                            try { hImg.src = (new URL('assets/swans/spritesheets/honkinator-sheet-0-24.png', document.baseURI)).href; } catch(_) { hImg.src = 'assets/swans/spritesheets/honkinator-sheet-0-24.png'; }
                            game.enemySprites.honkinator = { image: hImg, loaded: false, _forcedBitmap: null };
                            const atlasFrames = [
                                {"x":0,"y":0,"w":256,"h":256,"duration":1},
                                {"x":256,"y":0,"w":256,"h":256,"duration":1},
                                {"x":512,"y":0,"w":256,"h":256,"duration":1},
                                {"x":768,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                                {"x":0,"y":256,"w":256,"h":256,"duration":1},
                                {"x":256,"y":256,"w":256,"h":256,"duration":1},
                                {"x":512,"y":256,"w":256,"h":256,"duration":1},
                                {"x":768,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                                {"x":0,"y":512,"w":256,"h":256,"duration":1},
                                {"x":256,"y":512,"w":256,"h":256,"duration":1},
                                {"x":512,"y":512,"w":256,"h":256,"duration":1},
                                {"x":768,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                                {"x":0,"y":768,"w":256,"h":256,"duration":1}
                            ];
                            function hBox(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                            hImg.onload = function(ev){
                                try {
                                    const img = (ev && ev.target) ? ev.target : this;
                                    const cont = game.enemySprites.honkinator;
                                    try { if (cont && cont._forcedBitmap) { try { if (cont._forcedBitmap.close) cont._forcedBitmap.close(); } catch(_){} cont._forcedBitmap = null; try { console.info('[HonkinatorSprite] Image loaded; cleared forced bitmap fallback'); } catch(_){}} } catch(_){ }
                                    cont.loaded = true;
                                    const atlasFrames = [
                                        {"x":0,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":256,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":512,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":768,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                                        {"x":0,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":256,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":512,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":768,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                                        {"x":0,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":256,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":512,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":768,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                                        {"x":0,"y":768,"w":256,"h":256,"duration":1}
                                    ];
                                    cont.frames = { seq: atlasFrames };
                                    cont.anim = { frameStep: 8 };
                                    const refH = 256;
                                    cont.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                    cont.computeHitbox = (enemy)=>{
                                        try {
                                            const size = enemy.size || 48; const scale = cont.baseScaleForSize(size);
                                            const w = 256 * scale; const h = 256 * scale;
                                            const hitW = w * 0.64; const hitH = h * 0.68;
                                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                        } catch(_) { return { w: enemy.size||48, h: enemy.size||48, ox: -(enemy.size||48)/2, oy: -(enemy.size||48)/2 }; }
                                    };
                                    try { console.info('[HonkinatorSprite] Loaded honkinator spritesheet', cont.frames); } catch(_){ }
                                } catch(e) { console.warn('[HonkinatorSprite] onload error', e); }
                            };
                            hImg.onerror = function(ev){
                                try {
                                    const cont = game.enemySprites.honkinator;
                                    try { console.warn('[HonkinatorSprite] image onerror, attempting cache-bust then fetch fallback', hImg && hImg.src); } catch(_){ }
                                    if (!hImg._triedBust) { hImg._triedBust = true; try { hImg.src = hImg.src + (hImg.src.indexOf('?')===-1 ? '?v=1' : '&v=1'); } catch(_){}; return; }
                                    const href = hImg.src || '';
                                    if (href.indexOf('file:') === 0) { cont._broken = true; try { console.warn('[HonkinatorSprite] running from file:// - skipping fetch fallback'); } catch(_){}; return; }
                                    try {
                                        if (typeof fetch === 'function' && typeof createImageBitmap === 'function') {
                                            try { console.info('[HonkinatorSprite] starting fetch/createImageBitmap fallback for', href); } catch(_){ }
                                            const ac = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                                            const signal = ac ? ac.signal : null;
                                            const t = setTimeout(()=>{ try{ if (ac) ac.abort(); }catch(_){} }, 900);
                                            fetch(href, { signal }).then(r=>{ clearTimeout(t); if (!r.ok) throw new Error('status '+r.status); return r.blob(); }).then(b=>createImageBitmap(b)).then(bmp=>{
                                                clearTimeout(t);
                                                cont._forcedBitmap = bmp; cont.loaded = true;
                                                cont.frames = { seq: atlasFrames };
                                                cont.anim = { frameStep: 8 };
                                                try { console.info('[HonkinatorSprite] createImageBitmap fallback succeeded'); } catch(_){ }
                                            }).catch(e=>{ clearTimeout(t); try { console.warn('[HonkinatorSprite] fetch/createImageBitmap fallback failed', e); } catch(_){} });
                                        }
                                    } catch(e) { try { console.warn('[HonkinatorSprite] fallback error', e); } catch(_){} }
                                } catch(_){ }
                            };
                            try { if (!game.enemySprites.honkinator) game.enemySprites.honkinator = game.enemySprites.honkinator; } catch(_){ }
                            try { if (!game.enemySprites['The Honkinator']) game.enemySprites['The Honkinator'] = game.enemySprites.honkinator; } catch(_){ }
                        } catch(e) { console.warn('[HonkinatorSprite] install failed', e); }
                    }

                    // === Swandroid 18 (Act III melee, non-ranged) animated sprite loader ===
                    if (!game.enemySprites.swandroid18) {
                        try {
                            const saImg = new Image();
                            try { saImg.src = (new URL('assets/swans/spritesheets/swandroid18-sheet.png', document.baseURI)).href; } catch(_) { saImg.src = 'assets/swans/spritesheets/swandroid18-sheet.png'; }
                            game.enemySprites.swandroid18 = { image: saImg, loaded: false, _forcedBitmap: null };
                            const atlasFrames = [
                                {"x":0,"y":0,"w":256,"h":256,"duration":1},
                                {"x":256,"y":0,"w":256,"h":256,"duration":1},
                                {"x":512,"y":0,"w":256,"h":256,"duration":1},
                                {"x":768,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                                {"x":0,"y":256,"w":256,"h":256,"duration":1},
                                {"x":256,"y":256,"w":256,"h":256,"duration":1},
                                {"x":512,"y":256,"w":256,"h":256,"duration":1},
                                {"x":768,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                                {"x":0,"y":512,"w":256,"h":256,"duration":1},
                                {"x":256,"y":512,"w":256,"h":256,"duration":1},
                                {"x":512,"y":512,"w":256,"h":256,"duration":1},
                                {"x":768,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                                {"x":0,"y":768,"w":256,"h":256,"duration":1},
                                {"x":256,"y":768,"w":256,"h":256,"duration":1},
                                {"x":512,"y":768,"w":256,"h":256,"duration":1},
                                {"x":768,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1024,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1280,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1536,"y":768,"w":256,"h":256,"duration":1},
                                {"x":1792,"y":768,"w":256,"h":256,"duration":1}
                            ];
                            saImg.onload = function(ev){
                                try {
                                    const img = (ev && ev.target) ? ev.target : this;
                                    const cont = game.enemySprites.swandroid18;
                                    // If a createImageBitmap fallback was previously used, prefer the real Image now.
                                    try {
                                        if (cont && cont._forcedBitmap) {
                                            try { if (cont._forcedBitmap.close) cont._forcedBitmap.close(); } catch(_){}
                                            cont._forcedBitmap = null;
                                            try { console.info('[Swandroid18Sprite] Image loaded; cleared forced bitmap fallback'); } catch(_){}
                                        }
                                    } catch(_){}
                                    cont.loaded = true;
                                    cont.frames = { seq: atlasFrames };
                                    cont.anim = { frameStep: 8 };
                                    const refH = 256;
                                    cont.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                    cont.computeHitbox = (enemy)=>{
                                        try {
                                            const size = enemy.size || 52; const scale = cont.baseScaleForSize(size);
                                            const w = 256 * scale; const h = 256 * scale;
                                            const hitW = w * 0.64; const hitH = h * 0.68;
                                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                        } catch(_) { return { w: enemy.size||52, h: enemy.size||52, ox: -(enemy.size||52)/2, oy: -(enemy.size||52)/2 }; }
                                    };
                                    try { console.info('[Swandroid18Sprite] Loaded swandroid18 spritesheet', cont.frames); } catch(_){}
                                } catch(e) { console.warn('[Swandroid18Sprite] onload error', e); }
                            };
                            saImg.onerror = function(ev){
                                try {
                                    const cont = game.enemySprites.swandroid18;
                                    try { console.warn('[Swandroid18Sprite] image onerror, attempting cache-bust then fetch fallback', saImg && saImg.src); } catch(_){ }
                                    if (!saImg._triedBust) { saImg._triedBust = true; try { saImg.src = saImg.src + (saImg.src.indexOf('?')===-1 ? '?v=1' : '&v=1'); } catch(_){}; return; }
                                    const href = saImg.src || '';
                                    if (href.indexOf('file:') === 0) { cont._broken = true; try { console.warn('[Swandroid18Sprite] running from file:// - skipping fetch fallback'); } catch(_){}; return; }
                                    try {
                                        if (typeof fetch === 'function' && typeof createImageBitmap === 'function') {
                                            try { console.info('[Swandroid18Sprite] starting fetch/createImageBitmap fallback for', href); } catch(_){ }
                                            const ac = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                                            const signal = ac ? ac.signal : null;
                                            const t = setTimeout(()=>{ try{ if (ac) ac.abort(); }catch(_){} }, 900);
                                            fetch(href, { signal }).then(r=>{ clearTimeout(t); if (!r.ok) throw new Error('status '+r.status); return r.blob(); }).then(b=>createImageBitmap(b)).then(bmp=>{
                                                clearTimeout(t);
                                                cont._forcedBitmap = bmp; cont.loaded = true;
                                                try { console.info('[Swandroid18Sprite] createImageBitmap fallback succeeded'); } catch(_){ }
                                            }).catch(e=>{ clearTimeout(t); try { console.warn('[Swandroid18Sprite] fetch/createImageBitmap fallback failed', e); } catch(_){} });
                                        }
                                    } catch(e) { try { console.warn('[Swandroid18Sprite] fallback error', e); } catch(_){} }
                                } catch(_){ }
                            };
                            try { if (!game.enemySprites.swandroid18) game.enemySprites.swandroid18 = game.enemySprites.swandroid18; } catch(_){ }
                            try { if (!game.enemySprites['Swandroid 18']) game.enemySprites['Swandroid 18'] = game.enemySprites.swandroid18; } catch(_){ }
                        } catch(e) { console.warn('[Swandroid18Sprite] install failed', e); }
                    }

            // === Street Dog enemy sprite sheet ===
            if (!game.enemySprites.streetDog) {
                const dogImg = new Image();
                dogImg.src = 'assets/knifeduck2-sheet-2-21.png';
                game.enemySprites.streetDog = { image: dogImg, loaded: false };
                dogImg.onload = () => {
                    game.enemySprites.streetDog.loaded = true;
                    const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                    const frames = [];
                    for (let i = 2; i <= 21; i++) {
                        frames.push(atlas.frames[i.toString()]);
                    }
                    const container = game.enemySprites.streetDog;
                    container.frames = frames;
                    const makeSequence = (id, seqFrames, options)=> ({
                        frames: seqFrames,
                        frameStep: options.frameStep || 5,
                        mirrorX: options.mirrorX || false,
                        source: options.source || null,
                        id: id
                    });
                    const rightSequence = makeSequence('right', frames, { frameStep: 5 });
                    const leftSequence = makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' });
                    container.animations = { right: rightSequence, left: leftSequence };
                    container.defaultAnimation = rightSequence;
                    container.anim = { sequence: frames, frameStep: 5 };
                    container.animFrameStep = 5;
                    const refH = 256;
                    container.referenceHeight = refH;
                    container.referenceWidth = 256;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                        const w = 256 * scale; const h = 256 * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    container.image = dogImg;
                    console.info('[StreetDogSprite] Loaded knifeduck2-sheet-2-21.png', { frames: frames.length });
                };
            }

            // === Punk enemy sprite sheet ===
            if (!game.enemySprites.punk) {
                const punkImg = new Image();
                punkImg.src = 'assets/knifeduck2-sheet.png';
                game.enemySprites.punk = { image: punkImg, loaded: false };
                punkImg.onload = () => {
                    game.enemySprites.punk.loaded = true;
                    const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                    const frames = [];
                    for (let i = 0; i <= 31; i++) {
                        frames.push(atlas.frames[i.toString()]);
                    }
                    const container = game.enemySprites.punk;
                    container.frames = frames;
                    const makeSequence = (id, seqFrames, options)=> ({
                        frames: seqFrames,
                        frameStep: options.frameStep || 5,
                        mirrorX: options.mirrorX || false,
                        source: options.source || null,
                        id: id
                    });
                    const rightSequence = makeSequence('right', frames, { frameStep: 5 });
                    const leftSequence = makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' });
                    container.animations = { right: rightSequence, left: leftSequence };
                    container.defaultAnimation = rightSequence;
                    container.anim = { sequence: frames, frameStep: 5 };
                    container.animFrameStep = 5;
                    const refH = 256;
                    container.referenceHeight = refH;
                    container.referenceWidth = 256;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                        const w = 256 * scale; const h = 256 * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    container.image = punkImg;
                    console.info('[PunkSprite] Loaded knifeduck2-sheet.png', { frames: frames.length });
                };
                punkImg.onerror = (ev)=> { try { console.warn('[PunkSprite] failed to load assets/knifeduck2-sheet.png', ev); } catch(_){} };
            }

            // === Gangster enemy sprite sheet ===
            if (!game.enemySprites.gangster) {
                const gangsterImg = new Image();
                gangsterImg.src = 'assets/gunduck1-sheet.png';
                game.enemySprites.gangster = { image: gangsterImg, loaded: false };
                gangsterImg.onload = () => {
                    const container = game.enemySprites.gangster;
                    container.loaded = true;
                    try {
                        const sheetW = gangsterImg.naturalWidth || gangsterImg.width || 0;
                        const sheetH = gangsterImg.naturalHeight || gangsterImg.height || 0;
                        if (!sheetW || !sheetH) {
                            console.warn('[GangsterSprite] sprite sheet size unavailable', sheetW, sheetH);
                            return;
                        }
                        const cols = 8;
                        const rows = 1;
                        const cellW = Math.floor(sheetW / cols);
                        const cellH = Math.floor(sheetH / rows);
                        const trimPadding = 2;
                        const rawFrames = [];
                        for (let row = 0; row < rows; row++) {
                            for (let col = 0; col < cols; col++) {
                                rawFrames.push({
                                    index: rawFrames.length,
                                    row,
                                    col,
                                    x: col * cellW,
                                    y: row * cellH,
                                    w: cellW,
                                    h: cellH
                                });
                            }
                        }
                        if (!rawFrames.length) {
                            console.warn('[GangsterSprite] sprite sheet produced no frames');
                            return;
                        }
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = cellW;
                        tempCanvas.height = cellH;
                        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                        if (!tempCtx) {
                            console.warn('[GangsterSprite] failed to create temp 2d context');
                            return;
                        }
                        tempCtx.imageSmoothingEnabled = false;
                        const canSamplePixels = (() => {
                            try {
                                if (typeof window === 'undefined') return false;
                                if (window.location && window.location.protocol === 'file:') return false;
                                return true;
                            } catch (_) {
                                return false;
                            }
                        })();
                        let taintedWarningLogged = false;
                        const clamp01 = (value) => Math.max(0, Math.min(1, value));
                        const processed = rawFrames.map(frame => {
                            tempCtx.clearRect(0, 0, cellW, cellH);
                            tempCtx.drawImage(gangsterImg, frame.x, frame.y, frame.w, frame.h, 0, 0, cellW, cellH);
                            let minX = cellW;
                            let minY = cellH;
                            let maxX = -1;
                            let maxY = -1;
                            if (canSamplePixels) {
                                try {
                                    const imageData = tempCtx.getImageData(0, 0, cellW, cellH);
                                    const data = imageData.data;
                                    for (let y = 0; y < cellH; y++) {
                                        for (let x = 0; x < cellW; x++) {
                                            const alpha = data[(y * cellW + x) * 4 + 3];
                                            if (alpha > 10) {
                                                if (x < minX) minX = x;
                                                if (x > maxX) maxX = x;
                                                if (y < minY) minY = y;
                                                if (y > maxY) maxY = y;
                                            }
                                        }
                                    }
                                } catch (sampleErr) {
                                    if (!taintedWarningLogged) {
                                        console.warn('[GangsterSprite] pixel trim disabled (tainted canvas)', sampleErr);
                                        taintedWarningLogged = true;
                                    }
                                }
                            }
                            if (maxX < minX || maxY < minY) {
                                minX = 0;
                                minY = 0;
                                maxX = cellW - 1;
                                maxY = cellH - 1;
                            } else {
                                minX = Math.max(0, minX - trimPadding);
                                minY = Math.max(0, minY - trimPadding);
                                maxX = Math.min(cellW - 1, maxX + trimPadding);
                                maxY = Math.min(cellH - 1, maxY + trimPadding);
                            }
                            const trimmedWidth = (maxX - minX) + 1;
                            const trimmedHeight = (maxY - minY) + 1;
                            return Object.assign({}, frame, {
                                offsetX: minX,
                                offsetY: minY,
                                w: trimmedWidth,
                                h: trimmedHeight,
                                sourceX: frame.x + minX,
                                sourceY: frame.y + minY
                            });
                        });
                        const minOffsetX = processed.reduce((min, f) => Math.min(min, f.offsetX), Infinity);
                        const minOffsetY = processed.reduce((min, f) => Math.min(min, f.offsetY), Infinity);
                        const maxRight = processed.reduce((max, f) => Math.max(max, f.offsetX + f.w), 0);
                        const maxBottom = processed.reduce((max, f) => Math.max(max, f.offsetY + f.h), 0);
                        const leftPad = Math.max(0, -minOffsetX);
                        const topPad = Math.max(0, -minOffsetY);
                        const baselineRef = maxBottom;
                        const preparedWidth = Math.max(1, Math.ceil(Math.max(maxRight + leftPad, cellW + leftPad)));
                        const preparedHeight = Math.max(1, Math.ceil(Math.max(baselineRef + topPad, cellH + topPad)));
                        const refVisibleH = processed.reduce((max, f) => Math.max(max, f.h), 1);
                        const refVisibleW = processed.reduce((max, f) => Math.max(max, f.w), 1);
                        const frames = processed.map(frame => {
                            const baselineGap = Math.max(0, baselineRef - (frame.offsetY + frame.h));
                            const drawX = frame.offsetX + leftPad;
                            const drawY = frame.offsetY + baselineGap + topPad;
                            const baselinePx = drawY + frame.h;
                            const centerPx = drawY + (frame.h * 0.5);
                            const anchorX = clamp01((drawX + frame.w * 0.5) / preparedWidth);
                            const anchorY = clamp01(centerPx / preparedHeight);
                            const baselineRatio = clamp01(baselinePx / preparedHeight);
                            const canvas = document.createElement('canvas');
                            canvas.width = preparedWidth;
                            canvas.height = preparedHeight;
                            const ctx = canvas.getContext('2d', { alpha: true });
                            if (ctx) {
                                ctx.clearRect(0, 0, preparedWidth, preparedHeight);
                                ctx.drawImage(gangsterImg, frame.sourceX, frame.sourceY, frame.w, frame.h, drawX, drawY, frame.w, frame.h);
                            }
                            let mirroredCanvas = null;
                            if (canvas) {
                                mirroredCanvas = document.createElement('canvas');
                                mirroredCanvas.width = preparedWidth;
                                mirroredCanvas.height = preparedHeight;
                                const mctx = mirroredCanvas.getContext('2d', { alpha: true });
                                if (mctx) {
                                    mctx.clearRect(0, 0, preparedWidth, preparedHeight);
                                    mctx.translate(preparedWidth, 0);
                                    mctx.scale(-1, 1);
                                    mctx.drawImage(canvas, 0, 0, preparedWidth, preparedHeight);
                                } else {
                                    mirroredCanvas = null;
                                }
                            }
                            return Object.assign({}, frame, {
                                canvas,
                                mirroredCanvas,
                                preparedWidth,
                                preparedHeight,
                                anchorRatioX: anchorX,
                                mirrorAnchorRatioX: clamp01(1 - anchorX),
                                anchorRatioY: anchorY,
                                baselineRatio,
                                baselinePx,
                                centerPx,
                                atlasOffsetX: drawX,
                                atlasOffsetY: drawY,
                                visibleWidth: frame.w,
                                visibleHeight: frame.h
                            });
                        });
                        const makeSequence = (id, seqFrames, options)=> ({
                            id,
                            frames: Array.isArray(seqFrames) ? seqFrames : [],
                            frameStep: (options && options.frameStep) ? options.frameStep : 5,
                            mirrorX: !!(options && options.mirrorX),
                            source: options && options.source ? options.source : null
                        });
                        const runSequence = makeSequence('run', frames, { frameStep: 5 });
                        const idleFrame = frames[0] || null;
                        const sequences = {
                            right: makeSequence('right', frames, { frameStep: 5 }),
                            left: makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' }),
                            down: makeSequence('down', frames, { frameStep: 5 }),
                            up: makeSequence('up', frames, { frameStep: 5 }),
                            idle: idleFrame ? makeSequence('idle', [idleFrame], { frameStep: 12 }) : null
                        };
                        Object.keys(sequences).forEach((key)=> {
                            if (!sequences[key] || !Array.isArray(sequences[key].frames) || !sequences[key].frames.length) {
                                delete sequences[key];
                            }
                        });
                        container.animations = sequences;
                        container.defaultAnimation = runSequence;
                        container.anim = { sequence: frames, frameStep: 5 };
                        container.animFrameStep = 5;
                        container.frames = {
                            down: frames[0] || null,
                            up: frames[0] || null,
                            right: frames[0] || null,
                            left: frames[0] || null
                        };
                        container.preparedWidth = preparedWidth;
                        container.preparedHeight = preparedHeight;
                        container.referenceHeight = refVisibleH;
                        container.referenceWidth = refVisibleW;
                        container.maxVisibleWidth = refVisibleW;
                        container.maxVisibleHeight = refVisibleH;
                        container.anchorRatioX = frames[0] ? frames[0].anchorRatioX : 0.5;
                        container.anchorRatioY = frames[0] ? frames[0].anchorRatioY : 0.5;
                        container.baselineRatio = frames[0] ? frames[0].baselineRatio : 1;
                        container.baseScaleForSize = (enemySize)=> ((enemySize*2)/(refVisibleH || 1));
                        container.computeHitbox = (enemy)=> {
                            const size = enemy.size;
                            const scale = container.baseScaleForSize(size);
                            const visibleW = container.maxVisibleWidth || container.referenceWidth || container.preparedWidth || 1;
                            const visibleH = container.maxVisibleHeight || container.referenceHeight || container.preparedHeight || 1;
                            const scaledH = visibleH * scale;
                            const baselineRatio = (typeof container.baselineRatio === 'number') ? container.baselineRatio : 1;
                            const hitW = (visibleW * scale) * 0.56;
                            const hitH = (visibleH * scale) * 0.62;
                            // Position hitbox using same baseline offset as sprite rendering
                            const baselineOffset = -scaledH * baselineRatio;
                            const hitboxCenterY = baselineOffset + scaledH * 0.5;
                            return { w: hitW, h: hitH, ox: -hitW/2, oy: hitboxCenterY - hitH/2 };
                        };
                        container.image = gangsterImg;
                        console.info('[GangsterSprite] Loaded gunduck1-sheet.png', { frames: frames.length, preparedWidth, preparedHeight, refVisibleH, refVisibleW });
                    } catch (err) {
                        console.warn('[GangsterSprite] processing failed', err);
                    }
                };
                gangsterImg.onerror = (ev)=> { try { console.warn('[GangsterSprite] failed to load assets/gunduck1-sheet.png', ev); } catch(_){} };
                try { const resolved = (new URL('assets/gunduck1-sheet.png', document.baseURI)).href; gangsterImg.src = resolved; } catch(_) { /* keep assigned src */ }
            }

            // === Dealer enemy sprite sheet ===
            if (!game.enemySprites.dealer) {
                const dealerImg = new Image();
                dealerImg.src = 'assets/dealer-sheet.png';
                game.enemySprites.dealer = { image: dealerImg, loaded: false };
                dealerImg.onload = () => {
                    game.enemySprites.dealer.loaded = true;
                    const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                    const frames = [];
                    // Use frames 1-30 (skip frame 0 and 31 which are blank)
                    for (let i = 1; i <= 30; i++) {
                        frames.push(atlas.frames[i.toString()]);
                    }
                    const container = game.enemySprites.dealer;
                    container.frames = frames;
                    const makeSequence = (id, seqFrames, options)=> ({
                        frames: seqFrames,
                        frameStep: options.frameStep || 5,
                        mirrorX: options.mirrorX || false,
                        source: options.source || null,
                        id: id
                    });
                    const rightSequence = makeSequence('right', frames, { frameStep: 5 });
                    const leftSequence = makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' });
                    container.animations = { right: rightSequence, left: leftSequence };
                    container.defaultAnimation = rightSequence;
                    container.anim = { sequence: frames, frameStep: 5 };
                    container.animFrameStep = 5;
                    const refH = 256;
                    container.referenceHeight = refH;
                    container.referenceWidth = 256;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                        const w = 256 * scale; const h = 256 * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    container.image = dealerImg;
                    console.info('[DealerSprite] Loaded assets/dealer-sheet.png', { frames: frames.length });
                };
                dealerImg.onerror = (ev)=> { try { console.warn('[DealerSprite] failed to load assets/dealer-sheet.png', ev); } catch(_){} };
                try { const resolved = (new URL('assets/dealer-sheet.png', document.baseURI)).href; dealerImg.src = resolved; } catch(_) { /* keep assigned src */ }
            }

            // === Boss Thug enemy sprite sheet ===
            if (!game.enemySprites.bossThug) {
                const bossImg = new Image();
                bossImg.src = 'assets/knifeboss-sheet.png';
                game.enemySprites.bossThug = { image: bossImg, loaded: false };
                bossImg.onload = () => {
                    game.enemySprites.bossThug.loaded = true;
                    const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                    const frames = [];
                    for (let i = 0; i <= 31; i++) {
                        frames.push(atlas.frames[i.toString()]);
                    }
                    const container = game.enemySprites.bossThug;
                    container.frames = frames;
                    const makeSequence = (id, seqFrames, options)=> ({
                        frames: seqFrames,
                        frameStep: options.frameStep || 5,
                        mirrorX: options.mirrorX || false,
                        source: options.source || null,
                        id: id
                    });
                    const rightSequence = makeSequence('right', frames, { frameStep: 5 });
                    const leftSequence = makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' });
                    container.animations = { right: rightSequence, left: leftSequence };
                    container.defaultAnimation = rightSequence;
                    container.anim = { sequence: frames, frameStep: 5 };
                    container.animFrameStep = 5;
                    const refH = 256;
                    container.referenceHeight = refH;
                    container.referenceWidth = 256;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                        const w = 256 * scale; const h = 256 * scale;
                        const hitW = w * 0.72;
                        const hitH = h * 0.76;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    container.image = bossImg;
                    console.info('[BossThugSprite] Loaded knifeboss-sheet.png', { frames: frames.length });
                };
                bossImg.onerror = (ev)=> { try { console.warn('[BossThugSprite] failed to load assets/knifeboss-sheet.png', ev); } catch(_){} };
            }

                // === Big Bill (Act II boss) sprite sheet ===
                if (!game.enemySprites.bigBill) {
                    const bbImg = new Image();
                    bbImg.src = 'assets/geese/spritesheets/bigbill-sheet.png';
                    game.enemySprites.bigBill = { image: bbImg, loaded: false };
                    bbImg.onload = () => {
                        game.enemySprites.bigBill.loaded = true;
                        // Spritesheet atlas frames 0-31 (32 total frames)
                        game.enemySprites.bigBill.frames = [
                            {x:0,y:0,w:256,h:256}, {x:256,y:0,w:256,h:256}, {x:512,y:0,w:256,h:256}, {x:768,y:0,w:256,h:256},
                            {x:1024,y:0,w:256,h:256}, {x:1280,y:0,w:256,h:256}, {x:1536,y:0,w:256,h:256}, {x:1792,y:0,w:256,h:256},
                            {x:0,y:256,w:256,h:256}, {x:256,y:256,w:256,h:256}, {x:512,y:256,w:256,h:256}, {x:768,y:256,w:256,h:256},
                            {x:1024,y:256,w:256,h:256}, {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256},
                            {x:0,y:512,w:256,h:256}, {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256},
                            {x:1024,y:512,w:256,h:256}, {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256},
                            {x:0,y:768,w:256,h:256}, {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256},
                            {x:1024,y:768,w:256,h:256}, {x:1280,y:768,w:256,h:256}, {x:1536,y:768,w:256,h:256}, {x:1792,y:768,w:256,h:256}
                        ];
                        const refH = 256;
                        game.enemySprites.bigBill.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                        game.enemySprites.bigBill.computeHitbox = (enemy)=> {
                            const size = enemy.size; const scale = game.enemySprites.bigBill.baseScaleForSize(size);
                            const f = game.enemySprites.bigBill.frames[0];
                            const w = f.w * scale; const h = f.h * scale;
                            const hitW = w * 0.5;
                            const hitH = h * 0.6;
                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                        };
                        console.info('[BigBillSprite] Loaded bigbill-sheet.png', game.enemySprites.bigBill.frames.length, 'frames');
                    };
                    bbImg.onerror = (ev)=> { try { console.warn('[BigBillSprite] failed to load', ev, bbImg && bbImg.src); } catch(_){} };
                    try { const resolved = (new URL('assets/geese/spritesheets/bigbill-sheet.png', document.baseURI)).href; bbImg.src = resolved; } catch(_) { /* keep assigned src */ }
                }

                // === Goose Willis (Act II ranged grunt) sprite ===
                if (!game.enemySprites.gooseWillis) {
                    const gwImg = new Image();
                    gwImg.src = 'assets/geese/spritesheets/goosewillis-sheet-2-8.png';
                    game.enemySprites.gooseWillis = { image: gwImg, loaded: false };
                    gwImg.onload = function(ev) {
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            game.enemySprites.gooseWillis.loaded = true;
                            // Spritesheet atlas frames 1-7 (frames 2-8 in 1-based, 7 total frames)
                            game.enemySprites.gooseWillis.frames = [
                                {x:256,y:0,w:256,h:256}, {x:512,y:0,w:256,h:256}, {x:768,y:0,w:256,h:256}, {x:1024,y:0,w:256,h:256},
                                {x:1280,y:0,w:256,h:256}, {x:1536,y:0,w:256,h:256}, {x:1792,y:0,w:256,h:256}
                            ];
                            const refH = 256;
                            game.enemySprites.gooseWillis.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites.gooseWillis.computeHitbox = (enemy)=> {
                                const size = enemy.size; const scale = game.enemySprites.gooseWillis.baseScaleForSize(size);
                                const f = game.enemySprites.gooseWillis.frames[0];
                                const w = f.w * scale; const h = f.h * scale;
                                const hitW = w * 0.5;
                                const hitH = h * 0.6;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                            };
                            console.info('[GooseWillisSprite] Loaded goosewillis-sheet-2-8.png', game.enemySprites.gooseWillis.frames.length, 'frames');
                        } catch(e) { console.warn('[GooseWillisSprite] onload error', e); }
                    };
                    gwImg.onerror = function(ev){ try { console.warn('[GooseWillisSprite] failed to load', ev, gwImg && gwImg.src); } catch(_){} };
                    try { const resolved = (new URL('assets/geese/spritesheets/goosewillis-sheet-2-8.png', document.baseURI)).href; gwImg.src = resolved; } catch(_) { /* keep assigned src */ }
                }

                // === Lil Goosey (Act II small ranged grunt) sprite ===
                if (!game.enemySprites.lilGoosey) {
                    const lgImg = new Image();
                    lgImg.src = 'assets/geese/spritesheets/lilgoosey-sheet-1-31.png';
                    game.enemySprites.lilGoosey = { image: lgImg, loaded: false };
                    lgImg.onload = function(ev) {
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            game.enemySprites.lilGoosey.loaded = true;
                            // Spritesheet atlas frames 0-30 (31 total frames, excluding 31)
                            game.enemySprites.lilGoosey.frames = [
                                {x:0,y:0,w:256,h:256}, {x:256,y:0,w:256,h:256}, {x:512,y:0,w:256,h:256}, {x:768,y:0,w:256,h:256},
                                {x:1024,y:0,w:256,h:256}, {x:1280,y:0,w:256,h:256}, {x:1536,y:0,w:256,h:256}, {x:1792,y:0,w:256,h:256},
                                {x:0,y:256,w:256,h:256}, {x:256,y:256,w:256,h:256}, {x:512,y:256,w:256,h:256}, {x:768,y:256,w:256,h:256},
                                {x:1024,y:256,w:256,h:256}, {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256},
                                {x:0,y:512,w:256,h:256}, {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256},
                                {x:1024,y:512,w:256,h:256}, {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256},
                                {x:0,y:768,w:256,h:256}, {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256},
                                {x:1024,y:768,w:256,h:256}, {x:1280,y:768,w:256,h:256}, {x:1536,y:768,w:256,h:256}
                            ];
                            const refH = 256;
                            game.enemySprites.lilGoosey.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites.lilGoosey.computeHitbox = (enemy)=> {
                                const size = enemy.size; const scale = game.enemySprites.lilGoosey.baseScaleForSize(size);
                                const f = game.enemySprites.lilGoosey.frames[0];
                                const w = f.w * scale; const h = f.h * scale;
                                const hitW = w * 0.5;
                                const hitH = h * 0.6;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                            };
                            console.info('[LilGooseySprite] Loaded lilgoosey-sheet-1-31.png', game.enemySprites.lilGoosey.frames.length, 'frames');
                        } catch(e) { console.warn('[LilGooseySprite] onload error', e); }
                    };
                    lgImg.onerror = function(ev){ try { console.warn('[LilGooseySprite] failed to load', ev, lgImg && lgImg.src); } catch(_){} };
                    try { const resolved = (new URL('assets/geese/spritesheets/lilgoosey-sheet-1-31.png', document.baseURI)).href; lgImg.src = resolved; } catch(_) { /* keep assigned src */ }
                }

                // === Goosey Elliot (Act II melee grunt) sprite ===
                if (!game.enemySprites.gooseyElliot) {
                    const geImg = new Image();
                    geImg.src = 'assets/geese/spritesheets/gooseyelliot-sheet-12-31.png';
                    game.enemySprites.gooseyElliot = { image: geImg, loaded: false };
                    geImg.onload = function(ev) {
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            game.enemySprites.gooseyElliot.loaded = true;
                            // Spritesheet atlas frames 11-30 (frames 12-31 in 1-based, 20 total frames)
                            game.enemySprites.gooseyElliot.frames = [
                                {x:1024,y:256,w:256,h:256}, {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256},
                                {x:0,y:512,w:256,h:256}, {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256},
                                {x:1024,y:512,w:256,h:256}, {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256},
                                {x:0,y:768,w:256,h:256}, {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256},
                                {x:1024,y:768,w:256,h:256}, {x:1280,y:768,w:256,h:256}, {x:1536,y:768,w:256,h:256}, {x:1792,y:768,w:256,h:256}
                            ];
                            const refH = 256;
                            game.enemySprites.gooseyElliot.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites.gooseyElliot.computeHitbox = (enemy)=> {
                                const size = enemy.size; const scale = game.enemySprites.gooseyElliot.baseScaleForSize(size);
                                const f = game.enemySprites.gooseyElliot.frames[0];
                                const w = f.w * scale; const h = f.h * scale;
                                const hitW = w * 0.5;
                                const hitH = h * 0.6;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                            };
                            console.info('[GooseyElliotSprite] Loaded gooseyelliot-sheet-12-31.png', game.enemySprites.gooseyElliot.frames.length, 'frames');
                        } catch(e) { console.warn('[GooseyElliotSprite] onload error', e); }
                    };
                    geImg.onerror = function(ev){ try { console.warn('[GooseyElliotSprite] failed to load', ev, geImg && geImg.src); } catch(_){} };
                    try { const resolved = (new URL('assets/geese/spritesheets/gooseyelliot-sheet-12-31.png', document.baseURI)).href; geImg.src = resolved; } catch(_) { /* keep assigned src */ }
                }

                // === Goosey Smalls (Act II melee grunt) sprite ===
                if (!game.enemySprites.gooseySmalls) {
                    const gsImg = new Image();
                    gsImg.src = 'assets/geese/spritesheets/gooseysmalls-sheet-2-31.png';
                    game.enemySprites.gooseySmalls = { image: gsImg, loaded: false };
                    gsImg.onload = function(ev) {
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            game.enemySprites.gooseySmalls.loaded = true;
                            // Spritesheet atlas frames 1-30 (frames 2-31 in 1-based, 30 total frames)
                            game.enemySprites.gooseySmalls.frames = [
                                {x:256,y:0,w:256,h:256}, {x:512,y:0,w:256,h:256}, {x:768,y:0,w:256,h:256}, {x:1024,y:0,w:256,h:256},
                                {x:1280,y:0,w:256,h:256}, {x:1536,y:0,w:256,h:256}, {x:1792,y:0,w:256,h:256}, {x:0,y:256,w:256,h:256},
                                {x:256,y:256,w:256,h:256}, {x:512,y:256,w:256,h:256}, {x:768,y:256,w:256,h:256}, {x:1024,y:256,w:256,h:256},
                                {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256}, {x:0,y:512,w:256,h:256},
                                {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256}, {x:1024,y:512,w:256,h:256},
                                {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256}, {x:0,y:768,w:256,h:256},
                                {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256}, {x:1024,y:768,w:256,h:256},
                                {x:1280,y:768,w:256,h:256}, {x:1536,y:768,w:256,h:256}
                            ];
                            const refH = 256;
                            game.enemySprites.gooseySmalls.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites.gooseySmalls.computeHitbox = (enemy)=> {
                                const size = enemy.size; const scale = game.enemySprites.gooseySmalls.baseScaleForSize(size);
                                const f = game.enemySprites.gooseySmalls.frames[0];
                                const w = f.w * scale; const h = f.h * scale;
                                const hitW = w * 0.5;
                                const hitH = h * 0.6;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                            };
                            console.info('[GooseySmallsSprite] Loaded gooseysmalls-sheet-2-31.png', game.enemySprites.gooseySmalls.frames.length, 'frames');
                        } catch(e) { console.warn('[GooseySmallsSprite] onload error', e); }
                    };
                    gsImg.onerror = function(ev){ try { console.warn('[GooseySmallsSprite] failed to load', ev, gsImg && gsImg.src); } catch(_){} };
                    try { const resolved = (new URL('assets/geese/spritesheets/gooseysmalls-sheet-2-31.png', document.baseURI)).href; gsImg.src = resolved; } catch(_) { /* keep assigned src */ }
                }

                    // === Fowl Pacino (Act II melee grunt) sprite ===
                    if (!game.enemySprites.fowlPacino) {
                        const fpImg = new Image();
                        fpImg.src = 'assets/geese/spritesheets/fowlpacino-sheet-0-29.png';
                        game.enemySprites.fowlPacino = { image: fpImg, loaded: false };
                        fpImg.onload = function(ev) {
                            const img = (ev && ev.target) ? ev.target : this;
                            try {
                                game.enemySprites.fowlPacino.loaded = true;
                                // Spritesheet atlas frames 0-29 (30 total frames)
                                game.enemySprites.fowlPacino.frames = [
                                    {x:0,y:0,w:256,h:256}, {x:256,y:0,w:256,h:256}, {x:512,y:0,w:256,h:256}, {x:768,y:0,w:256,h:256},
                                    {x:1024,y:0,w:256,h:256}, {x:1280,y:0,w:256,h:256}, {x:1536,y:0,w:256,h:256}, {x:1792,y:0,w:256,h:256},
                                    {x:0,y:256,w:256,h:256}, {x:256,y:256,w:256,h:256}, {x:512,y:256,w:256,h:256}, {x:768,y:256,w:256,h:256},
                                    {x:1024,y:256,w:256,h:256}, {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256},
                                    {x:0,y:512,w:256,h:256}, {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256},
                                    {x:1024,y:512,w:256,h:256}, {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256},
                                    {x:0,y:768,w:256,h:256}, {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256},
                                    {x:1024,y:768,w:256,h:256}, {x:1280,y:768,w:256,h:256}
                                ];
                                const refH = 256;
                                game.enemySprites.fowlPacino.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                game.enemySprites.fowlPacino.computeHitbox = (enemy)=> {
                                    const size = enemy.size; const scale = game.enemySprites.fowlPacino.baseScaleForSize(size);
                                    const f = game.enemySprites.fowlPacino.frames[0];
                                    const w = f.w * scale; const h = f.h * scale;
                                    const hitW = w * 0.5;
                                    const hitH = h * 0.6;
                                    return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                                };
                                console.info('[FowlPacinoSprite] Loaded fowlpacino-sheet-0-29.png', game.enemySprites.fowlPacino.frames.length, 'frames');
                            } catch(e) { console.warn('[FowlPacinoSprite] onload error', e); }
                        };
                        fpImg.onerror = function(ev){ try { console.warn('[FowlPacinoSprite] failed to load', ev, fpImg && fpImg.src); } catch(_){} };
                        try { const resolved = (new URL('assets/geese/spritesheets/fowlpacino-sheet-0-29.png', document.baseURI)).href; fpImg.src = resolved; } catch(_) { /* keep assigned src */ }
                    }

                    // === Geese Robbins (Act II ranged grunt) sprite ===
                    if (!game.enemySprites.geeseRobbins) {
                        const grImg = new Image();
                        grImg.src = 'assets/geese/spritesheets/geeserobbins-sheet-1-31.png';
                        game.enemySprites.geeseRobbins = { image: grImg, loaded: false };
                        grImg.onload = function(ev) {
                            const img = (ev && ev.target) ? ev.target : this;
                            try {
                                game.enemySprites.geeseRobbins.loaded = true;
                                // Spritesheet atlas frames 0-30 (frames 1-31 in 1-based, 31 total frames)
                                game.enemySprites.geeseRobbins.frames = [
                                    {x:0,y:0,w:256,h:256}, {x:256,y:0,w:256,h:256}, {x:512,y:0,w:256,h:256}, {x:768,y:0,w:256,h:256},
                                    {x:1024,y:0,w:256,h:256}, {x:1280,y:0,w:256,h:256}, {x:1536,y:0,w:256,h:256}, {x:1792,y:0,w:256,h:256},
                                    {x:0,y:256,w:256,h:256}, {x:256,y:256,w:256,h:256}, {x:512,y:256,w:256,h:256}, {x:768,y:256,w:256,h:256},
                                    {x:1024,y:256,w:256,h:256}, {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256},
                                    {x:0,y:512,w:256,h:256}, {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256},
                                    {x:1024,y:512,w:256,h:256}, {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256},
                                    {x:0,y:768,w:256,h:256}, {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256},
                                    {x:1024,y:768,w:256,h:256}, {x:1280,y:768,w:256,h:256}, {x:1536,y:768,w:256,h:256}
                                ];
                                const refH = 256;
                                game.enemySprites.geeseRobbins.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                game.enemySprites.geeseRobbins.computeHitbox = (enemy)=> {
                                    const size = enemy.size; const scale = game.enemySprites.geeseRobbins.baseScaleForSize(size);
                                    const f = game.enemySprites.geeseRobbins.frames[0];
                                    const w = f.w * scale; const h = f.h * scale;
                                    const hitW = w * 0.5;
                                    const hitH = h * 0.6;
                                    return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                                };
                                console.info('[GeeseRobbinsSprite] Loaded geeserobbins-sheet-1-31.png', game.enemySprites.geeseRobbins.frames.length, 'frames');
                            } catch(e) { console.warn('[GeeseRobbinsSprite] onload error', e); }
                        };
                        grImg.onerror = function(ev){ try { console.warn('[GeeseRobbinsSprite] failed to load', ev, grImg && grImg.src); } catch(_){} };
                        try { const resolved = (new URL('assets/geese/spritesheets/geeserobbins-sheet-1-31.png', document.baseURI)).href; grImg.src = resolved; } catch(_) { /* keep assigned src */ }
                    }

                    // === 2Honk Shakur (Act II special ranged) sprite ===
                    if (!game.enemySprites['2honkShakur']) {
                        const hsImg = new Image();
                        hsImg.src = 'assets/geese/spritesheets/2honkshakur-sheet.png';
                        game.enemySprites['2honkShakur'] = { image: hsImg, loaded: false };
                        hsImg.onload = () => {
                            game.enemySprites['2honkShakur'].loaded = true;
                            // Spritesheet atlas frames 0-31 (32 total frames)
                            game.enemySprites['2honkShakur'].frames = [
                                {x:0,y:0,w:256,h:256}, {x:256,y:0,w:256,h:256}, {x:512,y:0,w:256,h:256}, {x:768,y:0,w:256,h:256},
                                {x:1024,y:0,w:256,h:256}, {x:1280,y:0,w:256,h:256}, {x:1536,y:0,w:256,h:256}, {x:1792,y:0,w:256,h:256},
                                {x:0,y:256,w:256,h:256}, {x:256,y:256,w:256,h:256}, {x:512,y:256,w:256,h:256}, {x:768,y:256,w:256,h:256},
                                {x:1024,y:256,w:256,h:256}, {x:1280,y:256,w:256,h:256}, {x:1536,y:256,w:256,h:256}, {x:1792,y:256,w:256,h:256},
                                {x:0,y:512,w:256,h:256}, {x:256,y:512,w:256,h:256}, {x:512,y:512,w:256,h:256}, {x:768,y:512,w:256,h:256},
                                {x:1024,y:512,w:256,h:256}, {x:1280,y:512,w:256,h:256}, {x:1536,y:512,w:256,h:256}, {x:1792,y:512,w:256,h:256},
                                {x:0,y:768,w:256,h:256}, {x:256,y:768,w:256,h:256}, {x:512,y:768,w:256,h:256}, {x:768,y:768,w:256,h:256},
                                {x:1024,y:768,w:256,h:256}, {x:1280,y:768,w:256,h:256}, {x:1536,y:768,w:256,h:256}, {x:1792,y:768,w:256,h:256}
                            ];
                            const refH = 256;
                            game.enemySprites['2honkShakur'].baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites['2honkShakur'].computeHitbox = (enemy)=> {
                                const size = enemy.size; const scale = game.enemySprites['2honkShakur'].baseScaleForSize(size);
                                const f = game.enemySprites['2honkShakur'].frames[0];
                                const w = f.w * scale; const h = f.h * scale;
                                const hitW = w * 0.5;
                                const hitH = h * 0.6;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.1 };
                            };
                            console.info('[2HonkShakurSprite] Loaded 2honkshakur-sheet.png', game.enemySprites['2honkShakur'].frames.length, 'frames');
                        };
                        hsImg.onerror = (ev)=> { try { console.warn('[2HonkShakurSprite] failed to load', ev, hsImg && hsImg.src); } catch(_){} };
                        try { const resolved = (new URL('assets/geese/spritesheets/2honkshakur-sheet.png', document.baseURI)).href; hsImg.src = resolved; } catch(_) { /* keep assigned src */ }
                    }

            // === Boss Gangster enemy sprite sheet ===
            if (!game.enemySprites.bossGangster) {
                const bossGImg = new Image();
                bossGImg.src = 'assets/gunboss-sheet-1-22.png';
                game.enemySprites.bossGangster = { image: bossGImg, loaded: false };
                bossGImg.onload = () => {
                    game.enemySprites.bossGangster.loaded = true;
                    const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                    const frames = [];
                    // Use only frames 1-22
                    for (let i = 1; i <= 22; i++) {
                        frames.push(atlas.frames[i.toString()]);
                    }
                    const container = game.enemySprites.bossGangster;
                    container.frames = frames;
                    const makeSequence = (id, seqFrames, options)=> ({
                        frames: seqFrames,
                        frameStep: options.frameStep || 5,
                        mirrorX: options.mirrorX || false,
                        source: options.source || null,
                        id: id
                    });
                    const rightSequence = makeSequence('right', frames, { frameStep: 5 });
                    const leftSequence = makeSequence('left', frames, { frameStep: 5, mirrorX: true, source: 'right' });
                    container.animations = { right: rightSequence, left: leftSequence };
                    container.defaultAnimation = rightSequence;
                    container.anim = { sequence: frames, frameStep: 5 };
                    container.animFrameStep = 5;
                    const refH = 256;
                    container.referenceHeight = refH;
                    container.referenceWidth = 256;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                        const w = 256 * scale; const h = 256 * scale;
                        const hitW = w * 0.70;
                        const hitH = h * 0.74;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.05 };
                    };
                    container.image = bossGImg;
                    console.info('[BossGangsterSprite] Loaded gunboss-sheet-1-22.png', { frames: frames.length });
                };
                bossGImg.onerror = (ev)=> { try { console.warn('[BossGangsterSprite] failed to load assets/gunboss-sheet-1-22.png', ev); } catch(_){} };
                try { const resolved = (new URL('assets/gunboss-sheet-1-22.png', document.baseURI)).href; bossGImg.src = resolved; } catch(_) { /* keep assigned src */ }
            }

            // === The Big Quack final boss sprite sheet ===
            if (!game.enemySprites.bigQuack) {
                const bqImg = new Image();
                bqImg.src = 'assets/bigquack-sheet.png';
                game.enemySprites.bigQuack = { image: bqImg, loaded: false };
                bqImg.onload = () => {
                    const container = game.enemySprites.bigQuack;
                    container.loaded = true;
                    function box(x1,y1,w,h){ return { x:x1, y:y1, w, h }; }
                    // Bounds generated via tools/compute_bigquack_bounds.ps1 (frame indices 0-7)
                    const rawFrames = [
                        box(35,7,186,248),
                        box(289,5,187,250),
                        box(533,4,210,251),
                        box(788,10,213,244),
                        box(1057,1,187,254),
                        box(1311,8,191,247),
                        box(1569,1,188,254),
                        box(1827,7,186,248)
                    ];
                    const refH = rawFrames.reduce((max,f)=> Math.max(max, f.h), rawFrames[0] ? rawFrames[0].h : 1);
                    const refW = rawFrames.reduce((max,f)=> Math.max(max, f.w), rawFrames[0] ? rawFrames[0].w : 1);
                    const frames = rawFrames.map((f)=> Object.assign({ renderScale: refH / (f.h || refH), visibleHeight: f.h }, f));
                    container.frames = {
                        down: frames[0],
                        up: frames[0],
                        right: frames[0]
                    };
                    container.anim = {
                        frames,
                        frameStep: 6
                    };
                    container.referenceHeight = refH;
                    container.referenceWidth = refW;
                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/(refH || 1));
                    container.computeHitbox = (enemy)=> {
                        const size = enemy.size;
                        const scale = container.baseScaleForSize(size);
                        const hitW = (refW * scale) * 0.76;
                        const hitH = (refH * scale) * 0.80;
                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + (refH * scale) * 0.04 };
                    };
                    try { container.image = bqImg; } catch(_) {}
                    console.info('[BigQuackSprite] Loaded bigquack-sheet.png', { frames: container.anim.frames, refH, refW });
                };
                bqImg.onerror = (ev)=> {
                    try { console.warn('[BigQuackSprite] failed to load assets/bigquack-sheet.png', ev); } catch(_) {}
                };
                try { const resolved = (new URL('assets/bigquack-sheet.png', document.baseURI)).href; bqImg.src = resolved; } catch(_) { /* keep assigned src */ }
            }

                // === Wunderswan secret boss sprite & audio preloads ===
                if (!game.enemySprites.wunderswan) {
                    const wsImg = new Image();
                    // Small helper to describe a frame rectangle
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    // Early placeholder so other code can reference the structure immediately
                    game.enemySprites.wunderswan = { image: wsImg, loaded: false };

                    // Strict single-path load: load exactly assets/wunderswan-sheet-1-30.png
                    wsImg.onload = function(ev) {
                        // Use the actual Image instance that fired the event (this / ev.target)
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            game.enemySprites.wunderswan.loaded = true;
                            const atlas = {"frames":{"0":{"x":0,"y":0,"w":256,"h":256,"duration":1},"1":{"x":256,"y":0,"w":256,"h":256,"duration":1},"2":{"x":512,"y":0,"w":256,"h":256,"duration":1},"3":{"x":768,"y":0,"w":256,"h":256,"duration":1},"4":{"x":1024,"y":0,"w":256,"h":256,"duration":1},"5":{"x":1280,"y":0,"w":256,"h":256,"duration":1},"6":{"x":1536,"y":0,"w":256,"h":256,"duration":1},"7":{"x":1792,"y":0,"w":256,"h":256,"duration":1},"8":{"x":0,"y":256,"w":256,"h":256,"duration":1},"9":{"x":256,"y":256,"w":256,"h":256,"duration":1},"10":{"x":512,"y":256,"w":256,"h":256,"duration":1},"11":{"x":768,"y":256,"w":256,"h":256,"duration":1},"12":{"x":1024,"y":256,"w":256,"h":256,"duration":1},"13":{"x":1280,"y":256,"w":256,"h":256,"duration":1},"14":{"x":1536,"y":256,"w":256,"h":256,"duration":1},"15":{"x":1792,"y":256,"w":256,"h":256,"duration":1},"16":{"x":0,"y":512,"w":256,"h":256,"duration":1},"17":{"x":256,"y":512,"w":256,"h":256,"duration":1},"18":{"x":512,"y":512,"w":256,"h":256,"duration":1},"19":{"x":768,"y":512,"w":256,"h":256,"duration":1},"20":{"x":1024,"y":512,"w":256,"h":256,"duration":1},"21":{"x":1280,"y":512,"w":256,"h":256,"duration":1},"22":{"x":1536,"y":512,"w":256,"h":256,"duration":1},"23":{"x":1792,"y":512,"w":256,"h":256,"duration":1},"24":{"x":0,"y":768,"w":256,"h":256,"duration":1},"25":{"x":256,"y":768,"w":256,"h":256,"duration":1},"26":{"x":512,"y":768,"w":256,"h":256,"duration":1},"27":{"x":768,"y":768,"w":256,"h":256,"duration":1},"28":{"x":1024,"y":768,"w":256,"h":256,"duration":1},"29":{"x":1280,"y":768,"w":256,"h":256,"duration":1},"30":{"x":1536,"y":768,"w":256,"h":256,"duration":1},"31":{"x":1792,"y":768,"w":256,"h":256,"duration":1}},"meta":{"size":{"w":2048,"h":1024},"frame_size":{"w":256,"h":256},"background_mode":"spriteclean"}};
                            const seq = [];
                            for(let i=1; i<=30; i++){
                                const frame = atlas.frames[i.toString()];
                                if(frame) seq.push({x:frame.x, y:frame.y, w:frame.w, h:frame.h});
                            }
                            game.enemySprites.wunderswan.frames = { seq };
                            game.enemySprites.wunderswan.anim = { frameStep: 8 };
                            const refH = 256;
                            game.enemySprites.wunderswan.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites.wunderswan.computeHitbox = (enemy)=> {
                                const size = enemy.size; const scale = game.enemySprites.wunderswan.baseScaleForSize(size);
                                const ww = 256 * scale; const hh = 256 * scale;
                                const hitW = ww * 0.72; const hitH = hh * 0.78;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + hh*0.06 };
                            };
                            // Ensure the stored image reference matches the loaded instance
                            try { game.enemySprites.wunderswan.image = img; } catch(_){}
                            // Extra diagnostics: log resolved src and document.baseURI to diagnose encoding issues
                            try {
                                console.info('[WunderswanSprite] Loaded wunderswan image', { frames: game.enemySprites.wunderswan.frames, complete: !!img.complete, nw: img.naturalWidth, nh: img.naturalHeight, src: img.src, baseURI: document.baseURI });
                            } catch(e) { console.info('[WunderswanSprite] Loaded wunderswan image (partial)', { nw: img.naturalWidth, nh: img.naturalHeight }); }

                            // Defensive: some environments report onload but naturalWidth/Height == 0
                            // Try an alternate URL variant (decode/re-encode or swap %20/space) once to recover
                            try {
                                const nw2 = img.naturalWidth || img.width || 0;
                                const nh2 = img.naturalHeight || img.height || 0;
                                if ((nw2 === 0 || nh2 === 0) && !game._wunderswan_altRetry) {
                                    game._wunderswan_altRetry = true;
                                    try {
                                        const alt = tryAlternateWunderswanUrl(img.src);
                                        if (alt && alt !== img.src) {
                                            console.info('[WunderswanSprite] natural size zero — retrying alt URL', { alt });
                                            // Mark loaded false so draw branch won't treat as ready
                                            game.enemySprites.wunderswan.loaded = false;
                                            // Reset image to a fresh Image() to ensure proper retry on some browsers
                                            const fresh = new Image();
                                            fresh.onload = wsImg.onload;
                                            fresh.onerror = wsImg.onerror;
                                            game.enemySprites.wunderswan.image = fresh;
                                            fresh.src = alt;
                                            return; // exit handler; fresh onload will pick up
                                        }
                                    } catch(_) {}
                                }
                            } catch(_) {}
                        } catch (e) { console.warn('[WunderswanSprite] onload handler error', e); }
                    };

                    // Visible DOM thumbnail for debugging: shows the loaded image in the page so you can confirm
                    // the asset actually loaded independently of the canvas renderer. Created/updated on image load.
                    function _ensureWundThumbnail(img) {
                                        // Disabled: suppress creating a persistent DOM thumbnail for Wunderswan debug overlays.
                                        // Leaving this function as a no-op avoids injecting a fixed-position image into the page.
                                        return;
                    }

                    // wsImg load thumbnail handler disabled to avoid DOM debug overlay
                    // wsImg.addEventListener('load', function(ev){ try { const i = (ev && ev.target) ? ev.target : this; _ensureWundThumbnail(i); } catch(_){} });

                    wsImg.onerror = function(ev) {
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            console.warn('[WunderswanSprite] failed to load assets/wunderswan-sheet-1-30.png', ev, img && img.src);
                            // Try a single cache-busting retry in case a bad cached response or server glitch prevented a proper load
                            if (!game._wunderswan_retry) {
                                game._wunderswan_retry = true;
                                try {
                                    const cb = 'assets/wunderswan-sheet-1-30.png?v=' + Date.now();
                                    console.info('[WunderswanSprite] retrying with cache-bust:', cb);
                                    // If this handler was attached to a fresh image, prefer assigning the cached-bust to the shared loader image
                                    try { if (game.enemySprites && game.enemySprites.wunderswan && game.enemySprites.wunderswan.image) game.enemySprites.wunderswan.image.src = cb; else img.src = cb; } catch(_) { img.src = cb; }
                                    return;
                                } catch(_) {}
                            }
                        } catch (_) { try { console.warn('[WunderswanSprite] onerror handler threw'); } catch(_){} }
                    };

                    // Kick off the load (single required path) using a resolved absolute URL and defensive retries
                    try {
                        // Prefer constructing with the document base so resolution matches page context
                        let resolvedUrl;
                        try { resolvedUrl = new URL('assets/wunderswan-sheet-1-30.png', document.baseURI).href; } catch(_) { resolvedUrl = 'assets/wunderswan-sheet-1-30.png'; }
                        console.info('[WunderswanSprite] requesting', resolvedUrl);
                        wsImg.src = resolvedUrl;
                        // Try to detect accidental reassignment of the shared image reference by installing a watcher
                        try {
                            if (game && game.enemySprites && game.enemySprites.wunderswan) {
                                const container = game.enemySprites.wunderswan;
                                if (!container._hasWatcher) {
                                    const hiddenKey = '_wund_img_ref';
                                    container[hiddenKey] = container.image;
                                    Object.defineProperty(container, 'image', {
                                        configurable: true,
                                        enumerable: true,
                                        get: function(){ return this[hiddenKey]; },
                                        set: function(v){ try { console.info('[WunderswanSprite][WATCH] image reference changed', { old: this[hiddenKey] && this[hiddenKey].src, new: v && v.src }); } catch(_){} this[hiddenKey] = v; }
                                    });
                                    container._hasWatcher = true;
                                }
                            }
                        } catch(_) {}
                        // If the normal image load doesn't complete within a short window, try fetching the file
                        // and using a blob URL as a robust fallback (helps with file:// encoding edge-cases).
                        try {
                            setTimeout(() => {
                                try {
                                    if (game.enemySprites && game.enemySprites.wunderswan && !game.enemySprites.wunderswan.loaded) {
                                        // Attempt fetch->blob with a short timeout
                                        try {
                                            const ac = new AbortController();
                                            const timer = setTimeout(() => ac.abort(), 3000);
                                            fetch(resolvedUrl, { signal: ac.signal }).then(resp => {
                                                clearTimeout(timer);
                                                if (!resp.ok) throw new Error('fetch status ' + resp.status);
                                                return resp.blob();
                                            }).then(b => {
                                                try {
                                                    const blobUrl = URL.createObjectURL(b);
                                                    console.info('[WunderswanSprite] fetch->blob fallback created', blobUrl);
                                                    // Replace src only if still not successfully loaded
                                                    if (game.enemySprites && game.enemySprites.wunderswan && !game.enemySprites.wunderswan.loaded) {
                                                        // Use a fresh Image instance to ensure onload handler runs
                                                        const fresh = new Image();
                                                        fresh.onload = wsImg.onload;
                                                        fresh.onerror = wsImg.onerror;
                                                        game.enemySprites.wunderswan.image = fresh;
                                                        fresh.src = blobUrl;
                                                    } else {
                                                        console.info('[WunderswanSprite] fetch fallback skipped; already loaded');
                                                    }
                                                } catch(e){ console.warn('[WunderswanSprite] blob handling failed', e); }
                                            }).catch(e => { console.warn('[WunderswanSprite] fetch fallback failed', e); });
                                        } catch(e) { console.warn('[WunderswanSprite] fetch fallback setup failed', e); }
                                    }
                                } catch(_) {}
                            }, 600);
                        } catch(_) {}
                    } catch(_){ }
                }
                
                // === Cardi Beak (Act III ranged enemy) sprite ===
                if (!game.enemySprites.cardiBeak) {
                    const cbImg = new Image();
                    // Use provided asset path
                    cbImg.src = 'assets/swans/spritesheets/cardibeak-sheet.png';
                    game.enemySprites.cardiBeak = { image: cbImg, loaded: false };
                    const atlasFrames = [
                        {"x":0,"y":0,"w":256,"h":256,"duration":1},
                        {"x":256,"y":0,"w":256,"h":256,"duration":1},
                        {"x":512,"y":0,"w":256,"h":256,"duration":1},
                        {"x":768,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                        {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                        {"x":0,"y":256,"w":256,"h":256,"duration":1},
                        {"x":256,"y":256,"w":256,"h":256,"duration":1},
                        {"x":512,"y":256,"w":256,"h":256,"duration":1},
                        {"x":768,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                        {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                        {"x":0,"y":512,"w":256,"h":256,"duration":1},
                        {"x":256,"y":512,"w":256,"h":256,"duration":1},
                        {"x":512,"y":512,"w":256,"h":256,"duration":1},
                        {"x":768,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                        {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                        {"x":0,"y":768,"w":256,"h":256,"duration":1},
                        {"x":256,"y":768,"w":256,"h":256,"duration":1},
                        {"x":512,"y":768,"w":256,"h":256,"duration":1},
                        {"x":768,"y":768,"w":256,"h":256,"duration":1},
                        {"x":1024,"y":768,"w":256,"h":256,"duration":1},
                        {"x":1280,"y":768,"w":256,"h":256,"duration":1},
                        {"x":1536,"y":768,"w":256,"h":256,"duration":1},
                        {"x":1792,"y":768,"w":256,"h":256,"duration":1}
                    ];
                    function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                    cbImg.onload = function(ev) {
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            game.enemySprites.cardiBeak.loaded = true;
                            game.enemySprites.cardiBeak.frames = { seq: atlasFrames };
                            game.enemySprites.cardiBeak.anim = { frameStep: 8 };
                            const refH = 256;
                            game.enemySprites.cardiBeak.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites.cardiBeak.computeHitbox = (enemy)=> {
                                const size = enemy.size; const scale = game.enemySprites.cardiBeak.baseScaleForSize(size);
                                const w = 256 * scale; const h = 256 * scale;
                                const hitW = w * 0.64;
                                const hitH = h * 0.68;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                            };
                            console.info('[CardiBeakSprite] Loaded cardibeak spritesheet', game.enemySprites.cardiBeak.frames);
                        } catch(e) { console.warn('[CardiBeakSprite] onload error', e); }
                    };
                    cbImg.onerror = function(ev){ try { console.warn('[CardiBeakSprite] failed to load', ev, cbImg && cbImg.src); } catch(_){} };
                    try { const resolved = (new URL('assets/swans/spritesheets/cardibeak-sheet.png', document.baseURI)).href; cbImg.src = resolved;
                        // Defensive fetch->ImageBitmap fallback: some contexts (file://, odd CORS, or decoding glitches)
                        // can leave Image incomplete. Try a fetch->blob->createImageBitmap path after a short delay
                        setTimeout(function(){
                            try {
                                if (!game || !game.enemySprites || !game.enemySprites.cardiBeak || game.enemySprites.cardiBeak.loaded) return;
                                const ac = new AbortController();
                                const t = setTimeout(()=>{ try{ ac.abort(); }catch(_){} }, 3000);
                                fetch(resolved, { signal: ac.signal }).then(resp => { clearTimeout(t); if (!resp.ok) throw new Error('status '+resp.status); return resp.blob(); }).then(blob => {
                                    try {
                                        if (typeof createImageBitmap === 'function') {
                                            return createImageBitmap(blob).then(bitmap => {
                                                try {
                                                    if (game && game.enemySprites && game.enemySprites.cardiBeak) {
                                                        const cb = game.enemySprites.cardiBeak;
                                                        cb._forcedBitmap = bitmap;
                                                        cb.frames = { seq: atlasFrames };
                                                        cb.anim = { frameStep: 8 };
                                                        // Maintain front/rear/side aliases for consistency with primary loader
                                                        try { cb.frames.front = cb.frames.front || cb.frames.down; } catch(_){}
                                                        try { cb.frames.rear = cb.frames.rear || cb.frames.up; } catch(_){}
                                                        try { cb.frames.side = cb.frames.side || cb.frames.right; } catch(_){}
                                                        // Provide baseScale and computeHitbox so renderer can size and align
                                                        const refH = 256;
                                                        cb.baseScaleForSize = cb.baseScaleForSize || ((enemySize)=> ((enemySize*2)/refH));
                                                        cb.computeHitbox = cb.computeHitbox || (enemy=>{
                                                            const size = enemy.size; const scale = cb.baseScaleForSize(size);
                                                            const w = 256 * scale; const h = 256 * scale;
                                                            const hitW = w * 0.64;
                                                            const hitH = h * 0.68;
                                                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                                        });
                                                        cb.loaded = true;
                                                        console.info('[CardiBeakSprite][PRELOAD] ImageBitmap created via fetch and frames assigned', { bitmapWidth: bitmap.width, bitmapHeight: bitmap.height });
                                                    }
                                                } catch(_){ }
                                            });
                                        } else {
                                            // Older env: convert blob to data URL and assign to image.src as a last resort
                                            const reader = new FileReader();
                                            reader.onload = function(ev2){ try { if (game && game.enemySprites && game.enemySprites.cardiBeak && !game.enemySprites.cardiBeak.loaded) { game.enemySprites.cardiBeak.image.src = ev2.target.result; } } catch(_){} };
                                            reader.readAsDataURL(blob);
                                        }
                                    } catch(e){ try { console.warn('[CardiBeakSprite][PRELOAD] bitmap creation failed', e); } catch(_){} }
                                }).catch(e => { try { console.warn('[CardiBeakSprite][PRELOAD] fetch fallback failed', e); } catch(_){} });
                            } catch(_){}
                        }, 600);
                    } catch(_) { /* keep assigned src */ }
                }
                // Provide renderer-friendly aliases so lookups that lowercase/remove-spaces will find the loader
                try { if (!game.enemySprites.cardibeak) game.enemySprites.cardibeak = game.enemySprites.cardiBeak; } catch(_) {}
                try { if (!game.enemySprites['Cardi Beak']) game.enemySprites['Cardi Beak'] = game.enemySprites.cardiBeak; } catch(_) {}
                // === Feather Krueger (Act III ranged enemy) sprite ===
                if (!game.enemySprites.featherKrueger) {
                    const fkImg = new Image();
                    fkImg.src = 'assets/swans/spritesheets/featherkrueger-sheet-6-31.png';
                    game.enemySprites.featherKrueger = { image: fkImg, loaded: false };
                    fkImg.onload = function(ev){
                        const img = (ev && ev.target) ? ev.target : this;
                        try {
                            game.enemySprites.featherKrueger.loaded = true;
                            // Spritesheet: 8 columns, 4 rows, 32 frames, use frames 6-31 (26 frames)
                            const atlasFrames = [
                                {x:1536,y:0,w:256,h:256,duration:1}, // frame 6
                                {x:1792,y:0,w:256,h:256,duration:1}, // 7
                                {x:0,y:256,w:256,h:256,duration:1}, // 8
                                {x:256,y:256,w:256,h:256,duration:1}, // 9
                                {x:512,y:256,w:256,h:256,duration:1}, // 10
                                {x:768,y:256,w:256,h:256,duration:1}, // 11
                                {x:1024,y:256,w:256,h:256,duration:1}, // 12
                                {x:1280,y:256,w:256,h:256,duration:1}, // 13
                                {x:1536,y:256,w:256,h:256,duration:1}, // 14
                                {x:1792,y:256,w:256,h:256,duration:1}, // 15
                                {x:0,y:512,w:256,h:256,duration:1}, // 16
                                {x:256,y:512,w:256,h:256,duration:1}, // 17
                                {x:512,y:512,w:256,h:256,duration:1}, // 18
                                {x:768,y:512,w:256,h:256,duration:1}, // 19
                                {x:1024,y:512,w:256,h:256,duration:1}, // 20
                                {x:1280,y:512,w:256,h:256,duration:1}, // 21
                                {x:1536,y:512,w:256,h:256,duration:1}, // 22
                                {x:1792,y:512,w:256,h:256,duration:1}, // 23
                                {x:0,y:768,w:256,h:256,duration:1}, // 24
                                {x:256,y:768,w:256,h:256,duration:1}, // 25
                                {x:512,y:768,w:256,h:256,duration:1}, // 26
                                {x:768,y:768,w:256,h:256,duration:1}, // 27
                                {x:1024,y:768,w:256,h:256,duration:1}, // 28
                                {x:1280,y:768,w:256,h:256,duration:1}, // 29
                                {x:1536,y:768,w:256,h:256,duration:1}, // 30
                                {x:1792,y:768,w:256,h:256,duration:1}  // 31
                            ];
                            game.enemySprites.featherKrueger.frames = {
                                seq: atlasFrames,
                                right: atlasFrames[0], // first frame for static
                                down: atlasFrames[0], // use first frame for down
                                up: atlasFrames[0], // use first frame for up
                                front: atlasFrames[0],
                                rear: atlasFrames[0]
                            };
                            game.enemySprites.featherKrueger.anim = { frameStep: 8 };
                            // For left, create mirrored canvases if needed, but since animating, handle in draw
                            // Precreate right canvas for first frame
                            try {
                                const rf = game.enemySprites.featherKrueger.frames.right;
                                if (rf && img && img.naturalWidth && img.naturalHeight && typeof document !== 'undefined') {
                                    const rightC = document.createElement('canvas'); rightC.width = rf.w; rightC.height = rf.h;
                                    const rc = rightC.getContext('2d'); rc.imageSmoothingEnabled = true;
                                    rc.drawImage(img, rf.x, rf.y, rf.w, rf.h, 0, 0, rf.w, rf.h);

                                    const leftC = document.createElement('canvas'); leftC.width = rf.w; leftC.height = rf.h;
                                    const lc = leftC.getContext('2d'); lc.imageSmoothingEnabled = true;
                                    lc.translate(leftC.width, 0); lc.scale(-1, 1);
                                    lc.drawImage(rightC, 0, 0);

                                    try { game.enemySprites.featherKrueger._rightCanvas = rightC; } catch(_){ }
                                    try { game.enemySprites.featherKrueger._leftCanvas = leftC; } catch(_){ }
                                    try { game.enemySprites.featherKrueger.frames.right = { x:0,y:0,w:rightC.width,h:rightC.height }; } catch(_){ }
                                    try { game.enemySprites.featherKrueger.frames.left = { x:0,y:0,w:leftC.width,h:leftC.height }; } catch(_){ }
                                }
                            } catch(_){ }
                            const refH = game.enemySprites.featherKrueger.frames.down.h || 256;
                            game.enemySprites.featherKrueger.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                            game.enemySprites.featherKrueger.computeHitbox = (enemy)=>{
                                const size = enemy.size; const scale = game.enemySprites.featherKrueger.baseScaleForSize(size);
                                const f = (game.enemySprites.featherKrueger.frames.front || game.enemySprites.featherKrueger.frames.down);
                                const w = f.w * scale; const h = f.h * scale;
                                const hitW = w * 0.64; const hitH = h * 0.68;
                                return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                            };
                            console.info('[FeatherKruegerSprite] Loaded featherkrueger-sheet-6-31.png', game.enemySprites.featherKrueger.frames);
                        } catch(e){ console.warn('[FeatherKruegerSprite] onload error', e); }
                    };
                    // Provide renderer-friendly aliases so lookups that lowercase/remove-spaces will find the loader
                    try { if (!game.enemySprites.featherkrueger) game.enemySprites.featherkrueger = game.enemySprites.featherKrueger || game.enemySprites.featherKrueger; } catch(_) {}
                    try { if (!game.enemySprites['Feather Krueger']) game.enemySprites['Feather Krueger'] = game.enemySprites.featherKrueger || game.enemySprites.featherKrueger; } catch(_) {}

                    // === Honkutus of Cygnus (Act III ranged enemy) animated sprite loader ===
                    if (!game.enemySprites.honkutusOfCygnus) {
                        const hkImg = new Image();
                        try { hkImg.src = (new URL('assets/swans/spritesheets/honkutusofcygnus-sheet.png', document.baseURI)).href; } catch(_) { hkImg.src = 'assets/swans/spritesheets/honkutusofcygnus-sheet.png'; }
                        game.enemySprites.honkutusOfCygnus = { image: hkImg, loaded: false, _forcedBitmap: null };
                        const atlasFrames = [
                            {"x":0,"y":0,"w":256,"h":256,"duration":1},
                            {"x":256,"y":0,"w":256,"h":256,"duration":1},
                            {"x":512,"y":0,"w":256,"h":256,"duration":1},
                            {"x":768,"y":0,"w":256,"h":256,"duration":1},
                            {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                            {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                            {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                            {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                            {"x":0,"y":256,"w":256,"h":256,"duration":1},
                            {"x":256,"y":256,"w":256,"h":256,"duration":1},
                            {"x":512,"y":256,"w":256,"h":256,"duration":1},
                            {"x":768,"y":256,"w":256,"h":256,"duration":1},
                            {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                            {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                            {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                            {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                            {"x":0,"y":512,"w":256,"h":256,"duration":1},
                            {"x":256,"y":512,"w":256,"h":256,"duration":1},
                            {"x":512,"y":512,"w":256,"h":256,"duration":1},
                            {"x":768,"y":512,"w":256,"h":256,"duration":1},
                            {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                            {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                            {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                            {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                            {"x":0,"y":768,"w":256,"h":256,"duration":1},
                            {"x":256,"y":768,"w":256,"h":256,"duration":1},
                            {"x":512,"y":768,"w":256,"h":256,"duration":1},
                            {"x":768,"y":768,"w":256,"h":256,"duration":1},
                            {"x":1024,"y":768,"w":256,"h":256,"duration":1},
                            {"x":1280,"y":768,"w":256,"h":256,"duration":1},
                            {"x":1536,"y":768,"w":256,"h":256,"duration":1},
                            {"x":1792,"y":768,"w":256,"h":256,"duration":1}
                        ];
                        hkImg.onload = function(ev){
                            const img = (ev && ev.target) ? ev.target : this;
                            try {
                                game.enemySprites.honkutusOfCygnus.loaded = true;
                                game.enemySprites.honkutusOfCygnus.frames = { seq: atlasFrames };
                                game.enemySprites.honkutusOfCygnus.anim = { frameStep: 8 };
                                const refH = 256;
                                game.enemySprites.honkutusOfCygnus.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                game.enemySprites.honkutusOfCygnus.computeHitbox = (enemy)=>{
                                    const size = enemy.size; const scale = game.enemySprites.honkutusOfCygnus.baseScaleForSize(size);
                                    const f = game.enemySprites.honkutusOfCygnus.frames.down || { w: 256, h: 256 };
                                    const w = Math.round((f.w || 32) * scale); const h = Math.round((f.h || 32) * scale);
                                    return { x: Math.round(enemy.x - w/2), y: Math.round(enemy.y - h/2), w, h };
                                };
                                console.info('[HonkutusSprite] Loaded honkutusofcygnus spritesheet', game.enemySprites.honkutusOfCygnus.frames);
                            } catch(e) { console.warn('[HonkutusSprite] onload error', e); }
                        };
                        hkImg.onerror = function(ev){ try { console.warn('[HonkutusSprite] failed to load', ev, hkImg && hkImg.src); } catch(_){} };
                        // Fetch->ImageBitmap preload & fallback canvas creation
                        try {
                            (async function(){
                                const resolved = (new URL('assets/swans/spritesheets/honkutusofcygnus-sheet.png', document.baseURI)).href;
                                const resp = await fetch(resolved);
                                const blob = await resp.blob();
                                const bitmap = await createImageBitmap(blob);
                                const cb = game.enemySprites.honkutusOfCygnus;
                                cb._forcedBitmap = bitmap;
                                cb.loaded = true;
                                console.info('[HonkutusSprite][PRELOAD] ImageBitmap created via fetch');
                            })().catch(e => { try { console.warn('[HonkutusSprite][PRELOAD] fetch fallback failed', e); } catch(_){} });
                        } catch(_) {}
                        try { if (!game.enemySprites.honkutusofcygnus) game.enemySprites.honkutusofcygnus = game.enemySprites.honkutusOfCygnus; } catch(_) {}
                        try { if (!game.enemySprites['Honkutus of Cygnus']) game.enemySprites['Honkutus of Cygnus'] = game.enemySprites.honkutusOfCygnus; } catch(_) {}

                            // === Mr Gosling (Act III ranged enemy) animated sprite loader ===
                            if (!game.enemySprites.mrGosling) {
                                const mgImg = new Image();
                                try { mgImg.src = (new URL('assets/swans/spritesheets/mrgosling-sheet.png', document.baseURI)).href; } catch(_) { mgImg.src = 'assets/swans/spritesheets/mrgosling-sheet.png'; }
                                game.enemySprites.mrGosling = { image: mgImg, loaded: false, _forcedBitmap: null };
                                const atlasFrames = [
                                    {"x":0,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":256,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":512,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":768,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":1024,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":1280,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":1536,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":1792,"y":0,"w":256,"h":256,"duration":1},
                                    {"x":0,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":256,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":512,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":768,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":1024,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":1280,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":1536,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":1792,"y":256,"w":256,"h":256,"duration":1},
                                    {"x":0,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":256,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":512,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":768,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":1024,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":1280,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":1536,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":1792,"y":512,"w":256,"h":256,"duration":1},
                                    {"x":0,"y":768,"w":256,"h":256,"duration":1},
                                    {"x":256,"y":768,"w":256,"h":256,"duration":1},
                                    {"x":512,"y":768,"w":256,"h":256,"duration":1},
                                    {"x":768,"y":768,"w":256,"h":256,"duration":1},
                                    {"x":1024,"y":768,"w":256,"h":256,"duration":1},
                                    {"x":1280,"y":768,"w":256,"h":256,"duration":1},
                                    {"x":1536,"y":768,"w":256,"h":256,"duration":1},
                                    {"x":1792,"y":768,"w":256,"h":256,"duration":1}
                                ];
                                mgImg.onload = function(ev){
                                    const img = (ev && ev.target) ? ev.target : this;
                                    try {
                                        game.enemySprites.mrGosling.loaded = true;
                                        game.enemySprites.mrGosling.frames = { seq: atlasFrames };
                                        game.enemySprites.mrGosling.anim = { frameStep: 8 };
                                        const refH = 256;
                                        game.enemySprites.mrGosling.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                        game.enemySprites.mrGosling.computeHitbox = (enemy)=>{
                                            const size = enemy.size; const scale = game.enemySprites.mrGosling.baseScaleForSize(size);
                                            const f = game.enemySprites.mrGosling.frames.down || { w: 256, h: 256 };
                                            const w = Math.round((f.w || 32) * scale); const h = Math.round((f.h || 32) * scale);
                                            return { x: Math.round(enemy.x - w/2), y: Math.round(enemy.y - h/2), w, h };
                                        };
                                        console.info('[MrGoslingSprite] Loaded mrgosling spritesheet', game.enemySprites.mrGosling.frames);
                                    } catch(e) { console.warn('[MrGoslingSprite] onload error', e); }
                                };
                                mgImg.onerror = function(ev){ try { console.warn('[MrGoslingSprite] failed to load', ev, mgImg && mgImg.src); } catch(_){} };
                                // Fetch->ImageBitmap preload & fallback canvas creation
                                try {
                                    (async function(){
                                        const resolved = (new URL('assets/swans/spritesheets/mrgosling-sheet.png', document.baseURI)).href;
                                        const resp = await fetch(resolved);
                                        const blob = await resp.blob();
                                        const bitmap = await createImageBitmap(blob);
                                        const cb = game.enemySprites.mrGosling;
                                        cb._forcedBitmap = bitmap;
                                        cb.loaded = true;
                                        console.info('[MrGoslingSprite][PRELOAD] ImageBitmap created via fetch');
                                    })().catch(e => { try { console.warn('[MrGoslingSprite][PRELOAD] fetch fallback failed', e); } catch(_){} });
                                } catch(_) {}
                            }
                    }
                    fkImg.onerror = function(ev){ try { console.warn('[FeatherKruegerSprite] failed to load', ev, fkImg && fkImg.src); } catch(_){ } };
                    try { const resolved = (new URL('assets/swans/spritesheets/featherkrueger-sheet-6-31.png', document.baseURI)).href; fkImg.src = resolved;
                        setTimeout(function(){
                            try {
                                if (!game || !game.enemySprites || !game.enemySprites.featherKrueger || game.enemySprites.featherKrueger.loaded) return;
                                const ac = new AbortController(); const t = setTimeout(()=>{ try{ ac.abort(); }catch(_){} }, 3000);
                                fetch(resolved, { signal: ac.signal }).then(resp => { clearTimeout(t); if (!resp.ok) throw new Error('status '+resp.status); return resp.blob(); }).then(blob => {
                                    try {
                                        if (typeof createImageBitmap === 'function') {
                                            return createImageBitmap(blob).then(bitmap => {
                                                try {
                                                    if (game && game.enemySprites && game.enemySprites.featherKrueger) {
                                                        const cb = game.enemySprites.featherKrueger;
                                                        cb._forcedBitmap = bitmap;
                                                        // Set up animation frames for new spritesheet
                                                        const atlasFrames = [
                                                            {x:1536,y:0,w:256,h:256,duration:1}, // frame 6
                                                            {x:1792,y:0,w:256,h:256,duration:1}, // 7
                                                            {x:0,y:256,w:256,h:256,duration:1}, // 8
                                                            {x:256,y:256,w:256,h:256,duration:1}, // 9
                                                            {x:512,y:256,w:256,h:256,duration:1}, // 10
                                                            {x:768,y:256,w:256,h:256,duration:1}, // 11
                                                            {x:1024,y:256,w:256,h:256,duration:1}, // 12
                                                            {x:1280,y:256,w:256,h:256,duration:1}, // 13
                                                            {x:1536,y:256,w:256,h:256,duration:1}, // 14
                                                            {x:1792,y:256,w:256,h:256,duration:1}, // 15
                                                            {x:0,y:512,w:256,h:256,duration:1}, // 16
                                                            {x:256,y:512,w:256,h:256,duration:1}, // 17
                                                            {x:512,y:512,w:256,h:256,duration:1}, // 18
                                                            {x:768,y:512,w:256,h:256,duration:1}, // 19
                                                            {x:1024,y:512,w:256,h:256,duration:1}, // 20
                                                            {x:1280,y:512,w:256,h:256,duration:1}, // 21
                                                            {x:1536,y:512,w:256,h:256,duration:1}, // 22
                                                            {x:1792,y:512,w:256,h:256,duration:1}, // 23
                                                            {x:0,y:768,w:256,h:256,duration:1}, // 24
                                                            {x:256,y:768,w:256,h:256,duration:1}, // 25
                                                            {x:512,y:768,w:256,h:256,duration:1}, // 26
                                                            {x:768,y:768,w:256,h:256,duration:1}, // 27
                                                            {x:1024,y:768,w:256,h:256,duration:1}, // 28
                                                            {x:1280,y:768,w:256,h:256,duration:1}, // 29
                                                            {x:1536,y:768,w:256,h:256,duration:1}, // 30
                                                            {x:1792,y:768,w:256,h:256,duration:1}  // 31
                                                        ];
                                                        cb.frames = {
                                                            seq: atlasFrames,
                                                            right: atlasFrames[0],
                                                            down: atlasFrames[0],
                                                            up: atlasFrames[0],
                                                            front: atlasFrames[0],
                                                            rear: atlasFrames[0]
                                                        };
                                                        cb.anim = { frameStep: 8 };
                                                        const refH = cb.frames.down.h || 256;
                                                        cb.baseScaleForSize = cb.baseScaleForSize || ((enemySize)=> ((enemySize*2)/refH));
                                                        cb.computeHitbox = cb.computeHitbox || (enemy=>{
                                                            const size = enemy.size; const scale = cb.baseScaleForSize(size);
                                                            const f = cb.frames.down;
                                                            const w = f.w * scale; const h = f.h * scale;
                                                            const hitW = w * 0.64; const hitH = h * 0.68;
                                                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + h*0.06 };
                                                        });
                                                        // Also, create preflipped canvases from the ImageBitmap fallback so renderer can use them
                                                        try {
                                                            const rf = cb.frames.right;
                                                            if (rf && typeof document !== 'undefined') {
                                                                try {
                                                                    const rightC = document.createElement('canvas'); rightC.width = rf.w; rightC.height = rf.h;
                                                                    const rc = rightC.getContext('2d'); rc.imageSmoothingEnabled = true;
                                                                    rc.drawImage(bitmap, rf.x, rf.y, rf.w, rf.h, 0, 0, rf.w, rf.h);

                                                                    const leftC = document.createElement('canvas'); leftC.width = rf.w; leftC.height = rf.h;
                                                                    const lc = leftC.getContext('2d'); lc.imageSmoothingEnabled = true;
                                                                    lc.translate(leftC.width, 0); lc.scale(-1, 1);
                                                                    lc.drawImage(rightC, 0, 0);

                                                                    try { cb._rightCanvas = rightC; } catch(_){ }
                                                                    try { cb._leftCanvas = leftC; } catch(_){ }
                                                                    try { cb.frames.right = { x:0,y:0,w:rightC.width,h:rightC.height }; } catch(_){ }
                                                                    try { cb.frames.left = { x:0,y:0,w:leftC.width,h:leftC.height }; } catch(_){ }
                                                                } catch(e) { console.warn('[FeatherKruegerSprite][PRELOAD][canvas] failed', e); }
                                                            }
                                                        } catch(_){}
                                                        cb.loaded = true;
                                                        console.info('[FeatherKruegerSprite][PRELOAD] ImageBitmap created via fetch and frames assigned', { bitmapWidth: bitmap.width, bitmapHeight: bitmap.height });
                                                    }
                                                } catch(_){ }
                                            });
                                        } else {
                                            const reader = new FileReader();
                                            reader.onload = function(ev2){ try { if (game && game.enemySprites && game.enemySprites.featherKrueger && !game.enemySprites.featherKrueger.loaded) { game.enemySprites.featherKrueger.image.src = ev2.target.result; } } catch(_){} };
                                            reader.readAsDataURL(blob);
                                        }
                                    } catch(e){ try { console.warn('[FeatherKruegerSprite][PRELOAD] bitmap creation failed', e); } catch(_){} }
                                }).catch(e => { try { console.warn('[FeatherKruegerSprite][PRELOAD] fetch fallback failed', e); } catch(_){} });
                            } catch(_){ }
                        }, 600);
                    } catch(_) { }
                }
                try { if (!game.enemySprites.featherkrueger) game.enemySprites.featherkrueger = game.enemySprites.featherKrueger || game.enemySprites.featherKrueger; } catch(_) {}
                try { if (!game.enemySprites['Feather Krueger']) game.enemySprites['Feather Krueger'] = game.enemySprites.featherKrueger || game.enemySprites.featherKrueger; } catch(_) {}
                    // Prepare audio list for Wunderswan (queue will be managed on game._wunderswanAudioQueue)
                    try {
                        const list = [
                            'assets/audio/wunderswan/quack1.wav','assets/audio/wunderswan/quack2.wav','assets/audio/wunderswan/quack3.wav',
                            'assets/audio/wunderswan/quack4.wav','assets/audio/wunderswan/quack6.wav',
                            'assets/audio/wunderswan/quack7.wav','assets/audio/wunderswan/quack8.wav','assets/audio/wunderswan/quack9.wav',
                            'assets/audio/wunderswan/quack10.wav','assets/audio/wunderswan/futile1.wav','assets/audio/wunderswan/futile2.wav','assets/audio/wunderswan/futile3.wav'
                        ];
                        game._wunderswanAudioList = list.map(src => { const a = new Audio(src); a.preload = 'auto'; try { a.onended = ()=>{ if (game && game._wunderswanAudioPlaying === a) game._wunderswanAudioPlaying = null; } } catch(_){} return a; });
                        game._wunderswanAudioIndex = 0;
                        game._wunderswanAudioPlaying = null; // current Audio object
                        // Add a one-time user-gesture priming: many browsers block programmatic plays until a user gesture
                        // This handler will attempt to play then immediately pause each audio on first user interaction,
                        // which typically marks them as allowed for subsequent programmatic play().
                        try {
                            if (!game._wunderswanAudioPrimed) {
                                const prime = () => {
                                    try {
                                        if (game._wunderswanAudioList && game._wunderswanAudioList.length) {
                                            game._wunderswanAudioList.forEach(a => {
                                                try {
                                                    // Play silently to prime without audible blip: temporarily mute during the priming play
                                                    const prevMuted = a.muted;
                                                    try { a.muted = true; } catch(_){}
                                                    try { a.currentTime = 0; } catch(_){}
                                                    const p = a.play();
                                                    if (p && typeof p.then === 'function') {
                                                        p.then(()=>{ try { a.pause(); a.currentTime = 0; } catch(_){} }).catch(()=>{ try { a.pause(); a.currentTime = 0; } catch(_){} }).finally(()=>{ try { a.muted = prevMuted; } catch(_){} });
                                                    } else {
                                                        try { a.pause(); a.currentTime = 0; } catch(_){ }
                                                        try { a.muted = prevMuted; } catch(_){}
                                                    }
                                                } catch(_){ }
                                            });
                                        }
                                    } catch(_){ }
                                    try { window.removeEventListener('pointerdown', prime); window.removeEventListener('keydown', prime); } catch(_){ }
                                    game._wunderswanAudioPrimed = true;
                                    try { console.info('[Wunderswan][AUDIO] primed by user gesture (silent)'); } catch(_){ }
                                };
                                window.addEventListener('pointerdown', prime, { once: true });
                                window.addEventListener('keydown', prime, { once: true });
                            }
                        } catch(_) {}
                        // Minimal, safe autoplay scheduler for Wunderswan SFX (HTMLAudio-based).
                        // This schedules a random clip ~10s after load and repeats with jitter.
                        try {
                            // Helper: return true if a Wunderswan enemy is currently present and appears alive
                            game._isWunderswanActive = function(){
                                try {
                                    if (!game || !Array.isArray(game.enemies)) return false;
                                    for (let i = 0; i < game.enemies.length; i++) {
                                        const en = game.enemies[i];
                                        if (!en) continue;
                                        const t = (en.type || en.name || '').toString().toLowerCase();
                                        if (t.indexOf('wunderswan') !== -1) {
                                            // Consider alive if no explicit dead flag and health/hp undefined or > 0
                                            if (en.isDead || en.dead) continue;
                                            if (typeof en.hp === 'number' && en.hp <= 0) continue;
                                            if (typeof en.health === 'number' && en.health <= 0) continue;
                                            return true;
                                        }
                                    }
                                } catch(_) {}
                                return false;
                            };

                            // Schedule helper (creates/clears a single timer) - only schedules when the boss is present
                            game._scheduleWunderswanAutoPlay = function(){
                                try {
                                    // Clear any existing timer before scheduling a fresh one
                                    if (game._wunderswanAudioTimer) { try { clearTimeout(game._wunderswanAudioTimer); } catch(_){} game._wunderswanAudioTimer = null; }
                                    if (game._wunderswanAudioStopped) return;
                                    // Only schedule autoplay when a Wunderswan enemy is active
                                    if (!game._isWunderswanActive()) return;
                                    const delay = 10000 + Math.floor(Math.random() * 6000); // 10-16s
                                    try { console.debug && console.debug('[Wunderswan][AUDIO] schedule next in', delay); } catch(_){}
                                    game._wunderswanAudioTimer = setTimeout(function(){
                                        try {
                                            if (typeof game._playRandomWunderswan === 'function') game._playRandomWunderswan();
                                        } catch(e) {
                                            try { console.warn('[Wunderswan][AUDIO] scheduled play threw', e); } catch(_){}
                                        }
                                    }, delay);
                                } catch(e) { try { console.warn('[Wunderswan][AUDIO] schedule failed', e); } catch(_){} }
                            };

                            // Play a random clip; respects priming and avoids overlapping plays. Only plays when Wunderswan is active.
                            game._playRandomWunderswan = function(){
                                try {
                                    if (game._wunderswanAudioStopped) return;
                                    if (!game._isWunderswanActive()) return; // only play when boss present
                                    if (!game._wunderswanAudioList || !game._wunderswanAudioList.length) return;
                                    // If not primed yet, postpone scheduling
                                    if (!game._wunderswanAudioPrimed) { try { game._scheduleWunderswanAutoPlay(); } catch(_){}; return; }
                                    // Avoid starting if already playing — but ensure schedule exists
                                    if (game._wunderswanAudioPlaying) { try { game._scheduleWunderswanAutoPlay(); } catch(_){}; return; }
                                    const idx = Math.floor(Math.random() * game._wunderswanAudioList.length);
                                    const src = (game._wunderswanAudioList[idx] && game._wunderswanAudioList[idx].src) ? game._wunderswanAudioList[idx].src : null;
                                    if (!src) { try { game._scheduleWunderswanAutoPlay(); } catch(_){}; return; }
                                    // Create a fresh Audio instance for this play to avoid reuse issues
                                    let playEl = null;
                                    try {
                                        playEl = new Audio(src);
                                        try { playEl.preload = 'auto'; } catch(_){ }
                                        try { playEl.currentTime = 0; } catch(_){ }
                                    } catch(e) {
                                        try { console.warn('[Wunderswan][AUDIO] failed to construct Audio', e); } catch(_){}
                                        try { game._scheduleWunderswanAutoPlay(); } catch(_){};
                                        return;
                                    }
                                    // Track current playing instance (set early so other code knows a play is attempted)
                                    try { game._wunderswanAudioPlaying = playEl; } catch(_){}
                                    const clearPlaying = function(){ try { if (game && game._wunderswanAudioPlaying === playEl) game._wunderswanAudioPlaying = null; } catch(_){} };
                                    // Attach handlers
                                    try { playEl.onended = function(){ clearPlaying(); try { if (typeof playEl.remove === 'function') playEl.remove(); } catch(_){} }; } catch(_){}
                                    try { playEl.onerror = function(e){ clearPlaying(); try { console.warn('[Wunderswan][AUDIO] element error', e); } catch(_){} }; } catch(_){}
                                    // Attempt play and handle promise rejection
                                    try {
                                        const p = playEl.play();
                                        if (p && typeof p.then === 'function') {
                                            p.then(()=>{ try { game._wunderswanAudioPlaying = playEl; try { console.debug && console.debug('[Wunderswan][AUDIO] play resolved'); } catch(_){} } catch(_){} }).catch((err)=>{ try { clearPlaying(); console.warn('[Wunderswan][AUDIO] play rejected', err); } catch(_){} });
                                        } else {
                                            try { game._wunderswanAudioPlaying = playEl; } catch(_){}
                                        }
                                    } catch(err) {
                                        try { clearPlaying(); console.warn('[Wunderswan][AUDIO] play threw', err); } catch(_){}
                                    }
                                    // Always schedule next attempt defensively
                                    try { game._scheduleWunderswanAutoPlay(); } catch(_){}
                                } catch(e){ try { console.warn('[Wunderswan][AUDIO] _playRandomWunderswan error', e); } catch(_){} }
                            };

                            // Kick off an initial schedule (the play function itself will wait until primed)
                            try { game._scheduleWunderswanAutoPlay(); } catch(_){ }
                            // Defensive watcher: if a Wunderswan spawns later (after initial schedule), re-arm scheduling.
                            try {
                                if (!game._wunderswanSchedulerWatcher) {
                                    game._wunderswanSchedulerWatcher = setInterval(function(){
                                        try {
                                            // If stopped, clear watcher
                                            if (game._wunderswanAudioStopped) { try { clearInterval(game._wunderswanSchedulerWatcher); } catch(_){} game._wunderswanSchedulerWatcher = null; return; }
                                            // If a boss is active but no timer exists, re-arm
                                            if (game._isWunderswanActive() && !game._wunderswanAudioTimer) {
                                                try { console.debug && console.debug('[Wunderswan][AUDIO] watcher re-arming scheduler'); } catch(_){}
                                                try { game._scheduleWunderswanAutoPlay(); } catch(_){}
                                            }
                                        } catch(_){}
                                    }, 1500);
                                }
                            } catch(_){}
                        } catch(_) {}
                    } catch(e) { console.warn('Wunderswan audio preload failed', e); }

                    // === Golden Goose secret boss sprite preloads ===
                    if (!game.enemySprites.goldengoose) {
                        const ggImg = new Image();
                        // Small helper to describe a frame rectangle
                        function box(x1,y1,x2,y2){ return { x:x1, y:y1, w:(x2 - x1), h:(y2 - y1) }; }
                        // Early placeholder so other code can reference the structure immediately
                        game.enemySprites.goldengoose = { image: ggImg, loaded: false };
                        const _ggLayout = { columns: 8, rows: 4 };
                        function applyGoldenGooseFrames(container, img) {
                            try {
                                if (!container) return;
                                const totalW = img && (img.naturalWidth || img.width) || 0;
                                const totalH = img && (img.naturalHeight || img.height) || 0;
                                container.sheetLayout = _ggLayout;
                                if (!(totalW > 0 && totalH > 0)) {
                                    container.frames = container.frames || { down: box(0,0, totalW || 256, totalH || 256) };
                                    if (!container.mouthRatios) {
                                        container.mouthRatios = { x: 0.82, y: 0.35 };
                                    }
                                    if (typeof container.mouthForwardPx !== 'number') {
                                        container.mouthForwardPx = 0;
                                    }
                                    if (typeof container.mouthForwardFactor !== 'number') {
                                        container.mouthForwardFactor = 0;
                                    }
                                    container.mouthForward = 0;
                                    return;
                                }
                                const stepX = totalW / _ggLayout.columns;
                                const stepY = totalH / _ggLayout.rows;
                                const sequence = [];
                                for (let row = 0; row < _ggLayout.rows; row++) {
                                    for (let col = 0; col < _ggLayout.columns; col++) {
                                        const x1 = Math.round(col * stepX);
                                        const y1 = Math.round(row * stepY);
                                        const x2 = Math.round((col + 1) * stepX);
                                        const y2 = Math.round((row + 1) * stepY);
                                        const frame = box(x1, y1, x2, y2);
                                        sequence.push(frame);
                                    }
                                }
                                const referenceFrame = sequence[0] || { x: 0, y: 0, w: Math.round(stepX) || totalW, h: Math.round(stepY) || totalH };
                                if (!container.frames) container.frames = {};
                                container.frames.down = referenceFrame;
                                container.frames.idle = referenceFrame;
                                container.frames.seq = sequence;
                                container.frames.byIndex = sequence;
                                container.frames.columns = _ggLayout.columns;
                                container.frames.rows = _ggLayout.rows;
                                container.frames.frameWidth = referenceFrame.w;
                                container.frames.frameHeight = referenceFrame.h;
                                if (!container.anim) container.anim = {};
                                container.anim.frames = sequence;
                                container.anim.frameStep = container.anim.frameStep || 5;
                                container.anim.loop = true;
                                container.anim.columns = _ggLayout.columns;
                                container.anim.rows = _ggLayout.rows;
                                container.anim.frameCount = sequence.length;
                                const refH = referenceFrame.h || (totalH / Math.max(1, _ggLayout.rows)) || 256;
                                container.baseScaleForSize = (enemySize) => ((enemySize * 2) / (refH || 1));
                                container.computeHitbox = (enemy) => {
                                    const scale = container.baseScaleForSize ? container.baseScaleForSize(enemy.size) : ((enemy.size * 2) / (refH || 1));
                                    const drawW = (referenceFrame.w || 64) * scale;
                                    const drawH = (referenceFrame.h || 64) * scale;
                                    const hitW = drawW * 0.92;
                                    const hitH = drawH * 0.86;
                                    return { w: hitW, h: hitH, ox: -hitW / 2, oy: -hitH / 2 + drawH * 0.06 };
                                };
                                if (!container.mouthRatios) {
                                    container.mouthRatios = { x: 0.82, y: 0.35 };
                                }
                                if (typeof container.mouthForwardPx !== 'number') {
                                    container.mouthForwardPx = 0;
                                }
                                if (typeof container.mouthForwardFactor !== 'number') {
                                    container.mouthForwardFactor = 0;
                                }
                                container.mouthForward = 0;
                            } catch (err) {
                                console.warn('[GoldenGooseSprite][LAYOUT] failed to assign frames', err);
                            }
                        }
                        game.enemySprites.goldengoose._applyFrameLayout = function(img) {
                            return applyGoldenGooseFrames(game.enemySprites.goldengoose, img);
                        };
                        applyGoldenGooseFrames(game.enemySprites.goldengoose, ggImg);
                        // Also alias the human-readable key so renderer and spawn handlers both see the same object
                        try { game.enemySprites['Golden Goose'] = game.enemySprites.goldengoose; } catch(_){}

                        // Strict single-path load: load exactly assets/geese/goldengoose-sheet.png
                        ggImg.onload = function(ev) {
                            const img = (ev && ev.target) ? ev.target : this;
                            try {
                                game.enemySprites.goldengoose.loaded = true;
                                // Provide a canonical ready-image reference used by the renderer
                                try { game.enemySprites.goldengoose._gg_img_ref = img; } catch(_){}
                                // Ensure alias is present after successful load
                                try { game.enemySprites['Golden Goose'] = game.enemySprites.goldengoose; } catch(_){}
                                const container = game.enemySprites.goldengoose;
                                try {
                                    if (container && typeof container._applyFrameLayout === 'function') {
                                        container._applyFrameLayout(img);
                                    } else {
                                        const w = img.naturalWidth || img.width || 256;
                                        const h = img.naturalHeight || img.height || 256;
                                        container.frames = { down: box(0,0, w, h) };
                                        const refH = container.frames.down.h || 256;
                                        container.baseScaleForSize = (enemySize)=> ((enemySize*2)/refH);
                                        container.computeHitbox = (enemy)=> {
                                            const size = enemy.size; const scale = container.baseScaleForSize(size);
                                            const f = container.frames.down;
                                            const drawW = (f.w || 64) * scale; const drawH = (f.h || 64) * scale;
                                            const hitW = drawW * 0.92; const hitH = drawH * 0.86;
                                            return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + drawH*0.06 };
                                        };
                                    }
                                } catch(layoutErr) {
                                    console.warn('[GoldenGooseSprite][LAYOUT] apply onload failed', layoutErr);
                                }
                                const refFrame = (container && container.frames && (container.frames.down || container.frames.seq && container.frames.seq[0])) || null;
                                const refH = refFrame ? (refFrame.h || 256) : 256;
                                if (!container.baseScaleForSize) {
                                    container.baseScaleForSize = (enemySize)=> ((enemySize*2)/(refH || 1));
                                }
                                if (!container.computeHitbox) {
                                    container.computeHitbox = (enemy)=> {
                                        const size = enemy.size; const scale = container.baseScaleForSize(size);
                                        const f = refFrame || { w: 64, h: 64 };
                                        const drawW = (f.w || 64) * scale; const drawH = (f.h || 64) * scale;
                                        const hitW = drawW * 0.92; const hitH = drawH * 0.86;
                                        return { w: hitW, h: hitH, ox: -hitW/2, oy: -hitH/2 + drawH*0.06 };
                                    };
                                }
                                if (!container.mouthRatios) {
                                    container.mouthRatios = { x: 0.82, y: 0.35 };
                                }
                                if (typeof container.mouthForwardPx !== 'number') {
                                    container.mouthForwardPx = 0;
                                }
                                if (typeof container.mouthForwardFactor !== 'number') {
                                    container.mouthForwardFactor = 0;
                                }
                                container.mouthForward = 0;
                                try { game.enemySprites.goldengoose.image = img; } catch(_){ }
                                try {
                                    console.info('[GoldenGooseSprite] Loaded goldengoose image', { frames: game.enemySprites.goldengoose.frames, complete: !!img.complete, nw: img.naturalWidth, nh: img.naturalHeight, src: img.src, baseURI: document.baseURI });
                                } catch(_) { console.info('[GoldenGooseSprite] Loaded goldengoose (partial)', { nw: img.naturalWidth, nh: img.naturalHeight }); }

                                // Proactively create an ImageBitmap from the loaded Image so the renderer can draw it
                                try {
                                    if (typeof createImageBitmap === 'function' && img && img.complete && (img.naturalWidth || img.width) > 0) {
                                        createImageBitmap(img).then(bitmap => {
                                            try {
                                                if (game && game.enemySprites && game.enemySprites.goldengoose) {
                                                    game.enemySprites.goldengoose._forcedBitmap = bitmap;
                                                    console.info('[GoldenGooseSprite][PRELOAD] ImageBitmap created', { w: bitmap.width, h: bitmap.height, src: img.src });
                                                }
                                            } catch(e) { console.warn('[GoldenGooseSprite][PRELOAD][STORE-ERR]', e); }
                                        }).catch(e => {
                                            console.warn('[GoldenGooseSprite][PRELOAD][BITMAP-ERR]', e);
                                        });
                                    }
                                } catch(e) { console.warn('[GoldenGooseSprite][PRELOAD][BITMAP-THROWN]', e); }

                                // Defensive: if natural size is zero, attempt a single alternate URL retry (guarded)
                                try {
                                    const nw2 = img.naturalWidth || img.width || 0;
                                    const nh2 = img.naturalHeight || img.height || 0;
                                    if ((nw2 === 0 || nh2 === 0) && !game._goldengoose_altRetry) {
                                        game._goldengoose_altRetry = true;
                                        try {
                                            const alt = (typeof tryAlternateWunderswanUrl === 'function') ? tryAlternateWunderswanUrl(img.src) : null;
                                            if (alt && alt !== img.src) {
                                                console.info('[GoldenGooseSprite] natural size zero — retrying alt URL', { alt });
                                                game.enemySprites.goldengoose.loaded = false;
                                                const fresh = new Image();
                                                fresh.onload = ggImg.onload;
                                                fresh.onerror = ggImg.onerror;
                                                game.enemySprites.goldengoose.image = fresh;
                                                fresh.src = alt;
                                                return;
                                            }
                                        } catch(_){}
                                    }
                                } catch(_){}
                            } catch (e) { console.warn('[GoldenGooseSprite] onload handler error', e); }
                        };

                        // Disabled DOM thumbnail (avoid injecting persistent debug overlay)
                        function _ensureGooseThumbnail(img) { return; }

                        ggImg.onerror = function(ev) {
                            const img = (ev && ev.target) ? ev.target : this;
                            try {
                                console.warn('[GoldenGooseSprite] failed to load assets/geese/goldengoose-sheet.png', ev, img && img.src);
                                if (!game._goldengoose_retry) {
                                    game._goldengoose_retry = true;
                                    try {
                                        const cb = 'assets/geese/goldengoose-sheet.png?v=' + Date.now();
                                        console.info('[GoldenGooseSprite] retrying with cache-bust:', cb);
                                        try { if (game.enemySprites && game.enemySprites.goldengoose && game.enemySprites.goldengoose.image) game.enemySprites.goldengoose.image.src = cb; else img.src = cb; } catch(_) { img.src = cb; }
                                        return;
                                    } catch(_){}
                                }
                            } catch(_) { try { console.warn('[GoldenGooseSprite] onerror handler threw'); } catch(_){} }
                        };

                        try {
                            let resolvedUrl;
                            try { resolvedUrl = new URL('assets/geese/goldengoose-sheet.png', document.baseURI).href; } catch(_) { resolvedUrl = 'assets/geese/goldengoose-sheet.png'; }
                            console.info('[GoldenGooseSprite] requesting', resolvedUrl);
                            ggImg.src = resolvedUrl;

                            // Install watcher to detect accidental image reference reassignment
                            try {
                                if (game && game.enemySprites && game.enemySprites.goldengoose) {
                                    const container = game.enemySprites.goldengoose;
                                    if (!container._hasWatcher) {
                                        const hiddenKey = '_gg_img_ref';
                                        container[hiddenKey] = container.image;
                                        Object.defineProperty(container, 'image', {
                                            configurable: true,
                                            enumerable: true,
                                            get: function(){ return this[hiddenKey]; },
                                            set: function(v){
                                                try {
                                                    const oldSrc = this[hiddenKey] && this[hiddenKey].src;
                                                    const newSrc = v && v.src;
                                                    try { console.warn('[GoldenGooseSprite][WATCH] image reference changed', { old: oldSrc, new: newSrc, time: Date.now() }); } catch(_){}
                                                    try { throw new Error('GoldenGoose image change stack'); } catch(e) { try { console.info(e.stack || e); } catch(_){} }

                                                    // If the old and new src are the same (for example both point to the
                                                    // canonical assets/geese/goldengoose-sheet.png), replacing the Image object
                                                    // can transiently remove frames/loaded state and cause the renderer to
                                                    // draw the fallback. Prefer keeping the existing image object when the
                                                    // src is identical to avoid that race.
                                                            try {
                                                                // Record assignment attempts so we can inspect them later from the console.
                                                                try { window._gg_assignments = window._gg_assignments || []; } catch(_){}
                                                                try { window._gg_assignments.push({ old: oldSrc || null, new: newSrc || null, time: Date.now(), stack: (new Error()).stack }); } catch(_){}
                                                            } catch(_){}
                                                    if (oldSrc && newSrc && oldSrc === newSrc) {
                                                        try { console.info('[GoldenGooseSprite][WATCH] identical-src assignment ignored to avoid transient fallback'); } catch(_){}
                                                        return; // skip replacing the image object
                                                    }
                                                } catch(_){}
                                                this[hiddenKey] = v;
                                            }
                                        });
                                        container._hasWatcher = true;
                                    }
                                }
                            } catch(_){}

                            // Fetch->blob fallback in case normal image load doesn't complete (helps file:// edge-cases)
                            try {
                                setTimeout(() => {
                                    try {
                                        if (game.enemySprites && game.enemySprites.goldengoose && !game.enemySprites.goldengoose.loaded) {
                                            try {
                                                const ac = new AbortController();
                                                const timer = setTimeout(() => ac.abort(), 3000);
                                                fetch(resolvedUrl, { signal: ac.signal }).then(resp => {
                                                    clearTimeout(timer);
                                                    if (!resp.ok) throw new Error('fetch status ' + resp.status);
                                                    return resp.blob();
                                                }).then(b => {
                                                    try {
                                                        const blobUrl = URL.createObjectURL(b);
                                                        console.info('[GoldenGooseSprite] fetch->blob fallback created', blobUrl);
                                                        if (game.enemySprites && game.enemySprites.goldengoose && !game.enemySprites.goldengoose.loaded) {
                                                            const fresh = new Image();
                                                            fresh.onload = ggImg.onload;
                                                            fresh.onerror = ggImg.onerror;
                                                            game.enemySprites.goldengoose.image = fresh;
                                                            fresh.src = blobUrl;
                                                            // Also create an ImageBitmap from the blob so we can draw immediately from bitmap cache
                                                            try {
                                                                if (typeof createImageBitmap === 'function') {
                                                                    createImageBitmap(b).then(bitmap => {
                                                                        try {
                                                                            if (game && game.enemySprites && game.enemySprites.goldengoose) {
                                                                                game.enemySprites.goldengoose._forcedBitmap = bitmap;
                                                                                console.info('[GoldenGooseSprite][PRELOAD-FETCH] ImageBitmap created from blob', { w: bitmap.width, h: bitmap.height });
                                                                            }
                                                                        } catch(e) { console.warn('[GoldenGooseSprite][PRELOAD-FETCH][STORE-ERR]', e); }
                                                                    }).catch(e => { console.warn('[GoldenGooseSprite][PRELOAD-FETCH][BITMAP-ERR]', e); });
                                                                }
                                                            } catch(e) { console.warn('[GoldenGooseSprite][PRELOAD-FETCH][BITMAP-THROW]', e); }
                                                        } else {
                                                            console.info('[GoldenGooseSprite] fetch fallback skipped; already loaded');
                                                        }
                                                    } catch(e){ console.warn('[GoldenGooseSprite] blob handling failed', e); }
                                                }).catch(e => { console.warn('[GoldenGooseSprite] fetch fallback failed', e); });
                                            } catch(e) { console.warn('[GoldenGooseSprite] fetch fallback setup failed', e); }
                                        }
                                    } catch(_){}
                                }, 600);
                            } catch(_){}
                        } catch(e) { console.warn('[GoldenGooseSprite] init error', e); }
                    }

            // (Rolled back) Removed procedural enemy & wall sprite generation.

            // Try to decode a first background early; non-blocking to avoid parse/runtime issues
            try {
                const b = window._streetBackgrounds;
                if (b && Array.isArray(b.list) && b.list.length) {
                    const initialSrc = b.list[(Math.random() * b.list.length) | 0];
                    if (window.preloadStreetBackgrounds) { try { window.preloadStreetBackgrounds(); } catch(_) {} }
                    if (typeof loadBgToCache === 'function') {
                        loadBgToCache(initialSrc).then(entry => {
                            if (entry) {
                                b.currentSrc = initialSrc;
                                b.img = entry.bitmap || entry.img;
                                b.ready = true;
                                b.alpha = 1.0; // draw immediately at full opacity
                            }
                        }).catch(()=>{});
                    }
                }
            } catch (e) { console.warn('[BG] Initial preload kick failed', e); }

            generateRoom();
            setupControls();
            updateUI();
            gameLoop();
            // Add particle effects
            setInterval(addAmbientParticles, 2000);
            // Track guaranteed chest logic per district cycle (rooms 1-5)
            game.chestsThisCycle = 0;

            // Initialize audio buttons & listeners
            updateAudioButtons();
            const bs = document.getElementById('btnToggleSfx');
            const bm = document.getElementById('btnToggleMusic');
            if (bs) bs.addEventListener('click', toggleSfx);
            if (bm) bm.addEventListener('click', toggleMusic);
            // Apply initial music mute state if bgMusic already created
            if (game.bgMusic) {
                game.bgMusic.muted = !game.musicEnabled;
                if (game.musicEnabled) { try { game.bgMusic.play().catch(()=>{}); } catch(e) {} }
            }
        }

        // ================= Elemental Infusion System =================
        // Supports multiple concurrent temporary elemental overlays that augment outgoing projectiles.
        // Each infusion tracked as { type, remaining, potency }. potency: scalar applied to bonus damage (% of base) and status strength.
        function ensureInfusionState() {
            if (!game.player) return;
            if (!game.player.infusions) {
                game.player.infusions = []; // array of active infusions
                game.player.maxInfusions = 3;
            }
        }

        // Add (or refresh/stack) an infusion. duration in frames. If same type exists, refresh to max of existing/added and slightly increase potency (capped).
        function addElementalInfusion(type, duration = 600, potency = 0.25) {
            ensureInfusionState();
            if (!game.player) return;
            const existing = game.player.infusions.find(i => i.type === type);
            if (existing) {
                existing.remaining = Math.max(existing.remaining, duration);
                existing.potency = Math.min(0.6, existing.potency + potency * 0.5); // soft cap
            } else {
                if (game.player.infusions.length >= game.player.maxInfusions) {
                    // Replace the one with least remaining time to keep system from silently failing
                    let worstIndex = 0; let worst = Infinity;
                    game.player.infusions.forEach((i, idx) => { if (i.remaining < worst) { worst = i.remaining; worstIndex = idx; } });
                    game.player.infusions.splice(worstIndex, 1);
                }
                game.player.infusions.push({ type, remaining: duration, potency });
            }
            // Visual: infusion gain pulse (perf-aware)
            try {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx) {
                    const colorMap = { fire:'#FFAA55', ice:'#AAE6FF', lightning:'#FFF277', poison:'#88FFAA', void:'#CC88FF', wind:'#AEEFFF' };
                    const col = colorMap[type] || '#FFE6AA';
                    if (!reduceRings) addParticle(game.player.x, game.player.y, col, 'ring');
                    for (let s=0;s<3;s++) addParticle(game.player.x + (Math.random()-0.5)*14, game.player.y + (Math.random()-0.5)*14, col, 'spark');
                }
            } catch(_) {}
        }

        // Randomly roll an element not already active (or refresh one if all taken)
        function rollRandomInfusion() {
            ensureInfusionState();
            if (!game.player) return;
            const pool = ['fire','ice','lightning','poison','void','wind'];
            const inactive = pool.filter(t => !game.player.infusions.some(i => i.type === t));
            const pick = inactive.length ? inactive[Math.floor(Math.random()*inactive.length)] : pool[Math.floor(Math.random()*pool.length)];
            addElementalInfusion(pick, 600, 0.25);
        }

        // Update infusion timers; remove expired.
        function updateInfusions() {
            if (!game.player || !game.player.infusions) return;
            for (let i = game.player.infusions.length - 1; i >= 0; i--) {
                const inf = game.player.infusions[i];
                inf.remaining--;
                if (inf.remaining <= 0) game.player.infusions.splice(i,1);
            }
        }

        // Visual helper: blend colors for infusion overlay (simple average)
        function getInfusionColorBlend() {
            if (!game.player || !game.player.infusions || game.player.infusions.length === 0) return null;
            const colors = { fire:'#ff6a00', ice:'#55ccff', lightning:'#ffee55', poison:'#55ff55', void:'#aa55ff', wind:'#aaffdd' };
            let r=0,g=0,b=0,n=0;
            game.player.infusions.forEach(i => { const c = colors[i.type]; if (!c) return; const v=parseInt(c.slice(1),16); r+=(v>>16)&255; g+=(v>>8)&255; b+=v&255; n++; });
            if (!n) return '#ffffff';
            r=Math.min(255,Math.round(r/n)); g=Math.min(255,Math.round(g/n)); b=Math.min(255,Math.round(b/n));
            return '#'+r.toString(16).padStart(2,'0')+g.toString(16).padStart(2,'0')+b.toString(16).padStart(2,'0');
        }
        // =================================================================

        // Add a floating damage number at world position (x,y). Options can include
        // {crit:true, type:'fire'|'ice'|..., armor:true, heal:true, color:'#rrggbb', big:true, scale:number}
        function addDamageNumber(amount, x, y, opts={}) {
            if (amount == null) return;
            // Avoid flooding: cap active numbers
            if (game.damageNumbers.length > 120) game.damageNumbers.splice(0, game.damageNumbers.length - 120);
            const typeColors = {
                fire:'#ff7933', ice:'#66ccff', lightning:'#ffee55', poison:'#66ff55', void:'#aa66ff',
                shadow:'#8855ff', earth:'#c2934b', wind:'#aaffdd', plasma:'#ff4455', crystal:'#88e6ff',
                solar:'#ffd966', // bright golden hue for Solar Flare
                storm:'#d7f542', magma:'#ff5522', blizzard:'#d0f0ff', inferno:'#ff2200', toxic:'#99ff66',
                bleed:'#ff3355', doom:'#ffffff', weakness:'#cccccc', stun:'#ffee88'
            };
            let color = '#ffffff';
            if (opts.heal) color = '#66ff88';
            else if (opts.crit) color = '#ffdd55';
            else if (opts.type && typeColors[opts.type]) color = typeColors[opts.type];
            if (opts.armor) color = '#888888';
            // Allow explicit color override
            if (opts.color) color = opts.color;
            const floatAngle = (Math.random()*0.8) - 0.4;
            let scale = 1.0;
            if (opts.scale && typeof opts.scale === 'number') scale = opts.scale;
            else if (opts.big) scale = 1.3;
            else if (opts.crit) scale = 1.4;
            game.damageNumbers.push({
                value: amount,
                x, y,
                vx: Math.sin(floatAngle) * 0.4,
                vy: -1.4 - Math.random()*0.4,
                life: 60, // frames
                color,
                scale,
                crit: !!opts.crit,
                heal: !!opts.heal
            });
        }

        function generateRoom() {
            game.walls = [];
            game.enemies = [];
            game.chests = [];
            game.projectiles = [];
            game.particles = [];
            game.pickups = [];
            game.traps = [];
            game.pits = [];
            game.nukes = [];
            game.poisonClouds = [];
            game.shockwaves = [];
            // Active vortex fields (persistent spinning damage zones)
            game.vortexFields = [];
            // Active transient lightning arcs for visual chain effects
            game.lightningArcs = [];
            // Mark the start time of the room for gating early ranged attacks
            game.roomStartTime = Date.now();
            game.roomCleared = false;
            // Prefetch Wunderswan sprite one room early (when player is in room 4) so it's likely cached
            // if the next room (room 5) may spawn the secret Wunderswan boss.
            try {
                if (game.room === 4 && !game._wunderswanPrefetched) {
                    game._wunderswanPrefetched = true;
                    try {
                        const p = new Image();
                        p.onload = function(){ console.info('[WunderswanSprite][prefetch] loaded', { src: p.src, nw: p.naturalWidth, nh: p.naturalHeight }); };
                        p.onerror = function(ev){ console.warn('[WunderswanSprite][prefetch] failed', ev, p.src); };
                        try { p.src = new URL('assets/wunderswan.png', document.baseURI).href; } catch(_) { p.src = 'assets/wunderswan.png'; }
                        game._wunderswanPrefetch = p; // keep reference so GC won't cancel load
                        console.info('[WunderswanSprite][prefetch] requested', p.src);
                    } catch(e){ console.warn('[WunderswanSprite][prefetch] error', e); }
                }
            } catch(_) {}
            
            // Select / update theme for this room
            game.currentTheme = pickTheme(game.dungeon, game.room);

            // Pick a background image for this room
            if (typeof window.pickRandomBackground === 'function') {
                window.pickRandomBackground();
            }

            // Create perimeter walls
            // Build perimeter walls spanning full logical canvas area
            for (let x = 0; x < ROOM_WIDTH; x++) {
                game.walls.push({ x: x * TILE_SIZE, y: 0, type: 'building' }); // top
                game.walls.push({ x: x * TILE_SIZE, y: (ROOM_HEIGHT - 1) * TILE_SIZE, type: 'building' }); // bottom
            }
            for (let y = 1; y < ROOM_HEIGHT - 1; y++) {
                game.walls.push({ x: 0, y: y * TILE_SIZE, type: 'building' }); // left
                game.walls.push({ x: (ROOM_WIDTH - 1) * TILE_SIZE, y: y * TILE_SIZE, type: 'building' }); // right
            }
            
            // Add varied obstacles (streetlight removed per design request)
            const baseObstacleTypes = ['car', 'dumpster', 'barrier'];
            // Expand obstacle list according to theme weights (simple duplication weighting)
            let obstacleTypes = [];
            const ow = game.currentTheme.obstacleWeights || {};
            baseObstacleTypes.forEach(t => {
                const weight = Math.max(0.1, ow[t] || 1);
                const copies = Math.round(weight * 5); // scale factor for variety; 1 => 5 copies
                for (let c=0;c<copies;c++) obstacleTypes.push(t);
            });
            if (!obstacleTypes.length) obstacleTypes = baseObstacleTypes.slice();
            const obstacleCount = 5 + Math.floor(game.dungeon / 2);
            const OBSTACLE_MIN_GAP = TILE_SIZE * 1.25; // minimum pixel gap between obstacle bounding boxes (excluding perimeter walls)
            
            for (let i = 0; i < obstacleCount; i++) {
                let x, y, attempts = 0;
                do {
                    x = (2 + Math.floor(Math.random() * (ROOM_WIDTH - 4))) * TILE_SIZE;
                    y = (2 + Math.floor(Math.random() * (ROOM_HEIGHT - 4))) * TILE_SIZE;
                    attempts++;
                } while ((Math.abs(x - (LOGICAL_W/2)) < 100 && Math.abs(y - (LOGICAL_H/2)) < 100) && attempts < 50);
                
                if (attempts < 50) {
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    if (type === 'car') {
                        // Larger car footprint: treat horizontal as wider, vertical as taller.
                        const orientation = Math.random() < 0.55 ? 'horizontal' : 'vertical';
                        // Base tile to pixel conversions
                        const tile = TILE_SIZE;
                        let widthPx, heightPx;
                        if (orientation === 'horizontal') {
                            widthPx = tile * 3; // spans 3 tiles wide
                            heightPx = tile * 2; // 2 tiles tall
                        } else {
                            widthPx = tile * 2; // 2 tiles wide
                            heightPx = tile * 3; // 3 tiles tall
                        }
                        // Re-center placement so original (x,y) acts as top-left snapped to tile grid
                        // Ensure it doesn't overlap perimeter (simple clamp)
                        if (x + widthPx > (ROOM_WIDTH-1)*tile) x = Math.max(tile, (ROOM_WIDTH-1)*tile - widthPx - tile);
                        if (y + heightPx > (ROOM_HEIGHT-1)*tile) y = Math.max(tile, (ROOM_HEIGHT-1)*tile - heightPx - tile);
                        // Check overlap with existing walls to avoid stacking
                        const overlaps = game.walls.some(w => {
                            const wW = w.width || tile; const wH = w.height || tile;
                            // Expand tested car bounds by negative margin (gap) so we enforce distance.
                            const ax1 = x - OBSTACLE_MIN_GAP, ay1 = y - OBSTACLE_MIN_GAP;
                            const ax2 = x + widthPx + OBSTACLE_MIN_GAP, ay2 = y + heightPx + OBSTACLE_MIN_GAP;
                            const bx1 = w.x, by1 = w.y, bx2 = w.x + wW, by2 = w.y + wH;
                            return !(ax2 <= bx1 || ax1 >= bx2 || ay2 <= by1 || ay1 >= by2);
                        });
                        if (overlaps) {
                            // Skip placing this car; continue loop without decrementing obstacleCount
                            continue;
                        }
                        // Car theme tint adjustment range overrides random per-car variance if theme supplies range
                        const carRange = game.currentTheme.carTintRange;
                        let tint = null;
                        if (carRange && carRange.length === 2) {
                            tint = carRange[0] + Math.random()*(carRange[1]-carRange[0]);
                        }
                        // Precompute visual adjustments to improve readability and variety
                        // Mild brightness/saturation boost plus a small hue shift per car instance
                        // Brightness boost only (no color variation), fixed for consistency
                        let brightness = 1.45; // fixed brightness multiplier
                        game.walls.push({ x, y, type, orientation, width: widthPx, height: heightPx, tint, brightness });
                        // Placing a large object counts as two obstacles to keep density reasonable
                        if (i < obstacleCount - 1) i++;
                    } else {
                        // Enforce spacing for non-car obstacles too; dumpsters are up-scaled to a larger footprint
                        const tile = TILE_SIZE;
                        let widthPx = tile, heightPx = tile;
                        if (type === 'dumpster') {
                            // At least 5x bigger in both dimensions
                            const SCALE = 5;
                            widthPx = tile * SCALE;
                            heightPx = tile * SCALE;
                            // Clamp within room bounds leaving one tile perimeter similar to cars
                            if (x < tile) x = tile;
                            if (y < tile) y = tile;
                            if (x + widthPx > (ROOM_WIDTH-1)*tile) x = Math.max(tile, (ROOM_WIDTH-1)*tile - widthPx - tile);
                            if (y + heightPx > (ROOM_HEIGHT-1)*tile) y = Math.max(tile, (ROOM_HEIGHT-1)*tile - heightPx - tile);
                            // Avoid player start zone: exclude a rectangle around the logical center
                            const startZoneW = 260; // width of exclusion zone
                            const startZoneH = 220; // height of exclusion zone
                            const sx1 = (LOGICAL_W/2) - startZoneW/2;
                            const sy1 = (LOGICAL_H/2) - startZoneH/2;
                            const sx2 = sx1 + startZoneW;
                            const sy2 = sy1 + startZoneH;
                            const ax1 = x, ay1 = y, ax2 = x + widthPx, ay2 = y + heightPx;
                            const overlapsStart = !(ax2 <= sx1 || ax1 >= sx2 || ay2 <= sy1 || ay1 >= sy2);
                            if (overlapsStart) {
                                // Skip placing this dumpster and try another position by continuing outer loop
                                continue;
                            }
                        } else if (type === 'barrier') {
                            // Enlarge barrier: spans multiple tiles wide, modest height
                            const W_TILES = 3; // width in tiles
                            const H_TILES = 2; // height in tiles
                            widthPx = tile * W_TILES;
                            heightPx = tile * H_TILES;
                            // Clamp within room bounds leaving one tile perimeter margin
                            if (x < tile) x = tile;
                            if (y < tile) y = tile;
                            if (x + widthPx > (ROOM_WIDTH-1)*tile) x = Math.max(tile, (ROOM_WIDTH-1)*tile - widthPx - tile);
                            if (y + heightPx > (ROOM_HEIGHT-1)*tile) y = Math.max(tile, (ROOM_HEIGHT-1)*tile - heightPx - tile);
                        }
                        const overlaps = game.walls.some(w => {
                            const wW = w.width || tile; const wH = w.height || tile;
                            const ax1 = x - OBSTACLE_MIN_GAP, ay1 = y - OBSTACLE_MIN_GAP;
                            const ax2 = x + widthPx + OBSTACLE_MIN_GAP, ay2 = y + heightPx + OBSTACLE_MIN_GAP;
                            const bx1 = w.x, by1 = w.y, bx2 = w.x + wW, by2 = w.y + wH;
                            return !(ax2 <= bx1 || ax1 >= bx2 || ay2 <= by1 || ay1 >= by2);
                        });
                        if (overlaps) continue;
                        if (type === 'dumpster') {
                            game.walls.push({ x, y, type, width: widthPx, height: heightPx });
                            // Large dumpster counts as two obstacles to keep density reasonable
                            if (i < obstacleCount - 1) i++;
                        } else if (type === 'barrier') {
                            game.walls.push({ x, y, type, width: widthPx, height: heightPx });
                            // Larger barrier also counts as two obstacles for density control
                            if (i < obstacleCount - 1) i++;
                        } else {
                            game.walls.push({ x, y, type });
                        }
                    }
                }
            }
            
            // Spawn enemies with scaling difficulty
            const baseEnemyCount = 4;
            const enemyCount = baseEnemyCount + Math.floor(game.dungeon / 2) + Math.floor(game.room / 2);
            console.info('[RoomGen] Begin', { dungeon: game.dungeon, room: game.room, enemyCount });
            // Build theme-weighted enemy pool (fallback to legacy logic if needed)
            const enemyTypesAll = Object.keys(ENEMY_TYPES);
            const themeEnemyWeights = (game.currentTheme && game.currentTheme.enemyWeights) || {};
            let themeWeightedPool = [];
            enemyTypesAll.forEach(t => {
                const w = Math.max(0.05, themeEnemyWeights[t] || 1);
                const copies = Math.round(w * 10);
                for (let c=0;c<copies;c++) themeWeightedPool.push(t);
            });
            themeWeightedPool = themeWeightedPool.filter(name => name !== 'The Quacken');
            // Act III additions: Cardi Beak is an Act III ranged enemy; ensure it's present only when Act III selected
            try {
                if (String(game._selectedAct) === 'III') {
                    // moderate presence: push multiple copies to emulate a weight
                    for (let c=0;c<8;c++) themeWeightedPool.push('Cardi Beak');
                    // Also add Feather Krueger to Act III pool
                    for (let c=0;c<6;c++) themeWeightedPool.push('Feather Krueger');
                    // Also add Honkutus of Cygnus to Act III pool
                    for (let c=0;c<6;c++) themeWeightedPool.push('Honkutus of Cygnus');
                    // Also add Mr Gosling to Act III pool
                    for (let c=0;c<6;c++) themeWeightedPool.push('Mr Gosling');
                }
            } catch(_) {}

            // Enforce Act-scoped spawning: when Act III is selected, filter out enemies
            // that are explicitly marked as Act I or Act II to prevent them appearing in Act III.
            try {
                if (String(game._selectedAct) === 'III') {
                    // STRICT: require an explicit act === 'III'. Treat missing `act` as Act I/II and exclude.
                    themeWeightedPool = themeWeightedPool.filter(function(t) {
                        try {
                            const meta = ENEMY_TYPES[t];
                            if (!meta) return false;
                            // Only allow entries explicitly marked for Act III
                            if (!meta.hasOwnProperty('act')) return false;
                            return String(meta.act) === 'III';
                        } catch(_) { return false; }
                    });
                    // Fallback: if filtering removed everything, restore Cardi Beak so Act III still has spawns
                    if (!themeWeightedPool.length) {
                        for (let c=0;c<12;c++) themeWeightedPool.push('Cardi Beak');
                    }
                }
            } catch(_) {}
            if (!themeWeightedPool.length) themeWeightedPool = enemyTypesAll.slice();
            
            // Add boss enemy every 5th room. Final boss only appears in district 10 room 5.
            const hasBoss = game.room === 5;
            
            for (let i = 0; i < enemyCount; i++) {
                let x, y, attempts = 0;
                do {
                    x = 60 + Math.random() * (LOGICAL_W - 120);
                    y = 60 + Math.random() * (LOGICAL_H - 120);
                    attempts++;
                } while ((Math.abs(x - (LOGICAL_W/2)) < 120 || Math.abs(y - (LOGICAL_H/2)) < 120 || isWall(x, y)) && attempts < 50);
                
                if (attempts < 50) {
                    let typeName;
                    if (hasBoss && i === 0) {
                        // Boss slot (room 5): allow specialized boss spawns. Prefer Cygnus Prime when
                        // present and the spawnStreet matches the current room. Otherwise fall back to
                        // the legacy Wunderswan/Big Bill/etc logic.
                        if (String(game._selectedAct) === 'III') {
                            try {
                                const cpMeta = ENEMY_TYPES['Cygnus Prime'];
                                if (cpMeta && cpMeta.spawnStreet && Number(cpMeta.spawnStreet) === Number(game.room)) {
                                    typeName = 'Cygnus Prime';
                                    console.info('[RoomGen] Act III boss forced to Cygnus Prime (room ' + game.room + ')');
                                } else if (!game._wunderswanSpawned) {
                                    typeName = 'Wunderswan';
                                    game._wunderswanSpawned = true;
                                    console.info('[RoomGen] Act III final boss forced to Wunderswan');
                                }
                            } catch(_) {
                                // Fallback to original behavior if anything throws
                                if (!game._wunderswanSpawned) { typeName = 'Wunderswan'; game._wunderswanSpawned = true; }
                            }
                        } else if (game._selectedAct === 'II' && !game._wunderswanSpawned && Math.random() < 0.05) {
                            typeName = 'Wunderswan';
                            game._wunderswanSpawned = true;
                            console.info('[RoomGen] Secret Wunderswan spawned (one-time)');
                            // Immediately request the sprite to ensure load attempt is visible in console/network
                            try {
                                if (!game.enemySprites) game.enemySprites = {};
                                if (!game.enemySprites.wunderswan || !game.enemySprites.wunderswan.image) {
                                    const preKick = new Image();
                                    preKick.onload = function(){ 
                                        console.info('[WunderswanSprite][pre-kick] loaded', { nw: preKick.naturalWidth, nh: preKick.naturalHeight });
                                        // If loaded but has zero size, attempt a re-request with decoded/encoded variants
                                        if ((preKick.naturalWidth || 0) === 0 || (preKick.naturalHeight || 0) === 0) {
                                            try {
                                                const alt = tryAlternateWunderswanUrl(preKick.src);
                                                if (alt && alt !== preKick.src) { console.info('[WunderswanSprite][pre-kick] retrying alt URL', alt); preKick.src = alt; }
                                            } catch(_){}
                                        }
                                    };
                                    preKick.onerror = function(ev){ console.warn('[WunderswanSprite][pre-kick] failed', ev); };
                                    try { preKick.src = new URL('assets/wunderswan.png', document.baseURI).href; console.info('[WunderswanSprite][pre-kick] requesting', preKick.src); } catch(e){ preKick.src = 'assets/wunderswan.png'; }
                                    // keep reference
                                    game._wunderswan_preKick = preKick;
                                } else {
                                    try { const ws = game.enemySprites.wunderswan; if (ws && ws.image && (!ws.image.src || !ws.image.src.includes('wunderswan.png'))) { ws.image.src = 'assets/wunderswan.png'; console.info('[WunderswanSprite][pre-kick] set existing image.src'); } } catch(_){}
                                }
                            } catch(e) { console.warn('[WunderswanSprite][pre-kick] error', e); }
                        } else if (game._selectedAct === 'II') {
                            // Act II main boss slot: in most districts use the Act-II boss 'Big Bill'.
                            // However, for District 10 room 5 we want Golden Goose to be the final boss
                            // (replacing The Big Quack). Prefer Golden Goose for dungeon 10 boss slot in Act II.
                            if (game.dungeon === 10) {
                                typeName = 'Golden Goose';
                                try { game._goldenGooseSpawned = true; } catch(_){ }
                                try { console.info('[RoomGen] Golden Goose chosen as Act II final boss (dungeon 10)'); } catch(_){ }
                            } else {
                                typeName = 'Big Bill';
                            }
                        } else if (game.dungeon === 10) {
                            typeName = 'The Big Quack';
                        // Golden Goose secret (Districts 5-9). High chance for testing: 95%.
                        } else if (game.dungeon >= 5 && game.dungeon <= 9 && !game._goldenGooseSpawned && Math.random() < 0.95 && String(game._selectedAct) !== 'III') {
                            typeName = 'Golden Goose';
                            game._goldenGooseSpawned = true;
                            console.info('[RoomGen] Secret Golden Goose spawned (one-time)');
                            try {
                                if (!game.enemySprites) game.enemySprites = {};
                                if (!game.enemySprites.goldengoose || !game.enemySprites.goldengoose.image) {
                                    const preKick = new Image();
                                    preKick.onload = function(){ try { console.info('[GoldenGooseSprite][pre-kick] loaded', { nw: preKick.naturalWidth, nh: preKick.naturalHeight }); } catch(_){} };
                                    preKick.onerror = function(ev){ console.warn('[GoldenGooseSprite][pre-kick] failed', ev); };
                                    try { preKick.src = new URL('assets/geese/goldengoose-sheet.png', document.baseURI).href; } catch(e){ preKick.src = 'assets/geese/goldengoose-sheet.png'; }
                                    game._goldengoose_preKick = preKick;
                                } else {
                                    try { const gg = game.enemySprites.goldengoose; if (gg && gg.image && (!gg.image.src || !gg.image.src.includes('goldengoose-sheet.png'))) { gg.image.src = 'assets/geese/goldengoose-sheet.png'; } } catch(_){ }
                                }
                            } catch(e) { console.warn('[GoldenGooseSprite][pre-kick] error', e); }
                            // NOTE: do NOT break here; allow the main spawn/push code below to create the Golden Goose
                        } else if (game.dungeon >= 5) {
                            typeName = 'Boss Gangster';
                        } else {
                            typeName = 'Boss Thug';
                        }
                    } else {
                        const quackenMeta = ENEMY_TYPES['The Quacken'];
                        if (quackenMeta && Math.random() < 0.01) {
                            typeName = 'The Quacken';
                        } else {
                            // Use theme weighted pool then modulate by dungeon progression similarly to legacy weighting (soft gating)
                            // Filter pool for enemies whose legacy weight would be >0 to avoid early access to late-game types.
                            // Legacy weights modulated by act selection: Act II has its own pool and should not include Act I-only grunts
                            const legacyWeights = {
                                'Thug': (game._selectedAct === 'II') ? 0 : Math.max(1, 4 - game.dungeon),
                                'Street Dog': (game._selectedAct === 'II') ? 0 : Math.max(1, 4 - game.dungeon),
                                'Punk': (game._selectedAct === 'II') ? 0 : Math.max(1, 3 - game.dungeon + 2),
                                // Exclude heavier Act I types from Act II as well
                                'Gangster': (game._selectedAct === 'II') ? 0 : Math.max(0, game.dungeon - 1),
                                'Dealer': (game._selectedAct === 'II') ? 0 : Math.max(0, game.dungeon - 3),
                                'Enforcer': (game._selectedAct === 'II') ? 0 : Math.max(0, game.dungeon - 6)
                            };
                            // Ensure Act II exclusive enemies are available in the pool when in Act II
                            if (game._selectedAct === 'II') {
                                // Provide a legacy weight entry for Eggscobar to allow inclusion in filtered pool
                                legacyWeights['Eggscobar'] = Math.max(1, 2); // moderate availability
                                // Add Goose Willis to Act II pool
                                legacyWeights['Goose Willis'] = Math.max(1, 2);
                                // Add Goosey Smalls to Act II pool
                                legacyWeights['Goosey Smalls'] = Math.max(1, 2);
                                // Add Geese Robbins to Act II pool
                                legacyWeights['Geese Robbins'] = Math.max(1, 2);
                                // Add Fowl Pacino to Act II pool
                                legacyWeights['Fowl Pacino'] = Math.max(1, 2);
                                // Add 2Honk Shakur to Act II pool
                                legacyWeights['2Honk Shakur'] = Math.max(1, 1);
                                // Add Lil Goosey to Act II pool
                                legacyWeights['Lil Goosey'] = Math.max(1, 2);
                                // Add Goosey Elliot to Act II pool
                                legacyWeights['Goosey Elliot'] = Math.max(1, 2);
                                // Add Lil Goosey to Act II pool
                                legacyWeights['Lil Goosey'] = Math.max(1, 2);
                            }
                            const filtered = themeWeightedPool.filter(t => (legacyWeights[t] || 0) > 0);
                            let pool = filtered.length ? filtered : themeWeightedPool;
                            // Exclude explicit boss-only types from non-boss spawn pool so bosses
                            // (like 'Cygnus Prime') only appear in the boss slot (room 5).
                            try {
                                const nonBossPool = pool.filter(t => { try { const m = ENEMY_TYPES[t]; return !(m && m.boss); } catch(_) { return true; } });
                                if (nonBossPool && nonBossPool.length) pool = nonBossPool;
                            } catch(_) {}
                            typeName = pool[Math.floor(Math.random() * pool.length)];
                        }
                    }
                    const baseType = ENEMY_TYPES[typeName];
                    // Compounding 35% health increase per completed district: multiplier = 1.35^(dungeon-1)
                    const healthMult = Math.pow(1.35, (game.dungeon - 1));
                    // Elite determination (skip for final boss)
                    const themeMult = (game.currentTheme && game.currentTheme.eliteMult) || 1;
                    const baseEliteChance = 0.05 + game.dungeon * 0.004 + game.room * 0.002;
                    // District-specific bump: D9 and D10 get noticeably higher elite rates
                    let eliteChance = baseEliteChance;
                    if (game.dungeon === 9) eliteChance *= 1.75;
                    else if (game.dungeon === 10) eliteChance *= 2.25;
                    eliteChance *= themeMult;
                    eliteChance = Math.min(0.65, eliteChance); // cap to avoid overwhelming all spawns
                    const isElite = (!hasBoss || i > 0) && Math.random() < eliteChance;
                    const enemyObj = {
                        x, y, type: typeName,
                        health: Math.floor(baseType.health * healthMult),
                        maxHealth: Math.floor(baseType.health * healthMult),
                        speed: baseType.speed,
                        baseSpeed: baseType.speed, // store unmodified original for later recovery
                        // Damage no longer scales per district; only health scales to avoid late-game one-shots.
                        damage: baseType.damage,
                        color: baseType.color,
                        size: baseType.size,
                        xp: baseType.xp,
                        ranged: baseType.ranged || false,
                        lastAttack: 0,
                        poisoned: false, poisonTime: 0,
                        slowed: false, slowTime: 0,
                        burning: false, burnTime: 0,
                        wunderScribble: false, wunderScribbleTime: 0,
                        wunderScribbleInterval: 0, wunderScribbleTickDamage: 0,
                        _wunderScribbleTick: 0,
                        quackenSnared: false, quackenSnareTime: 0,
                        _quackenStack: 0, _quackenTick: 0,
                        _quackenBaseDamage: 0, _quackenDotScale: 0,
                        _quackenRingCd: 0,
                        elite: isElite
                    };
                    if (isElite) {
                        // Elite stat scaling updated: 5x health, modest speed & damage buffs
                        enemyObj.health = Math.floor(enemyObj.health * 5.0);
                        enemyObj.maxHealth = enemyObj.health;
                        enemyObj.speed *= 1.10;
                        enemyObj.damage = Math.ceil(enemyObj.damage * 1.4);
                        enemyObj.eliteGlow = 1.0; // visual state tracker
                    }
                    if (typeName === 'The Big Quack') {
                        enemyObj.finalBoss = true;
                        // Music swap to boss theme
                        try {
                            if (!game._bossMusicPlaying) {
                                if (game.bgMusic) { game._prevMusicSrc = game.bgMusic.src; try { game.bgMusic.pause(); } catch(e) {} }
                                game.bgMusic = new Audio('assets/audio/PixelShowdown.mp3');
                                game.bgMusic.loop = true;
                                applyMusicPreference();
                                updateAudioButtons();
                                game._bossMusicPlaying = true;
                            }
                        } catch(e) {}
                    }
                    // If Golden Goose is being spawned as an Act II final boss, mark it so we can suppress UI noise
                    try {
                        if (typeName === 'Golden Goose' && String(game._selectedAct) === 'II') {
                            try { enemyObj.finalBoss = true; } catch(_){}
                            try { console.info('[RoomGen] Golden Goose spawned as Act II final boss — marking finalBoss'); } catch(_){}
                        }
                    } catch(_){}
                    game.enemies.push(enemyObj);
                    if (typeName === 'Wunderswan') {
                        try { console.info('[RoomGen][SPAWN] Wunderswan enemy pushed', enemyObj); } catch(_){}
                    }
                    // If we selected the secret Wunderswan, ensure it spawns alone and attempt to kick the sprite loader
                    if (typeName === 'Wunderswan') {
                        try {
                            console.info('[RoomGen] Wunderswan chosen - forcing single spawn and ensuring sprite load');
                            // Try to nudge the sprite loader in case it was not initialized earlier
                            if (!game.enemySprites) game.enemySprites = {};
                            if (!game.enemySprites.wunderswan) {
                                try {
                                    const kick = new Image();
                                    kick.onload = function(){ 
                                        console.info('[WunderswanSprite][spawn-kick] loaded on spawn', { nw: kick.naturalWidth, nh: kick.naturalHeight });
                                        try {
                                            if (!game.enemySprites.wunderswan) game.enemySprites.wunderswan = {};
                                            game.enemySprites.wunderswan.image = kick;
                                            game.enemySprites.wunderswan.loaded = true;
                                            game.enemySprites.wunderswan.frames = { down: { x:0, y:0, w: kick.naturalWidth || kick.width, h: kick.naturalHeight || kick.height } };
                                        } catch(_){ }
                                        // Defensive: if natural size zero, try alternate URL
                                        if ((kick.naturalWidth || 0) === 0 || (kick.naturalHeight || 0) === 0) {
                                            try { const alt = tryAlternateWunderswanUrl(kick.src); if (alt && alt !== kick.src) { console.info('[WunderswanSprite][spawn-kick] retrying alt', alt); kick.src = alt; } } catch(_){}
                                        }
                                    };
                                    kick.onerror = function(ev){ console.warn('[WunderswanSprite][spawn-kick] failed to load', ev); };
                                    try { kick.src = new URL('assets/wunderswan.png', document.baseURI).href; console.info('[WunderswanSprite][spawn-kick] requesting', kick.src); } catch(e){ kick.src = 'assets/wunderswan.png'; }
                                    // keep reference so GC doesn't drop it before onload
                                    game._wunderswan_spawnKick = kick;
                                } catch(e){ console.warn('[WunderswanSprite][spawn-kick] error', e); }
                            } else {
                                // If loader exists but not yet requested or not loaded, try to set src explicitly
                                try {
                                    const ws = game.enemySprites.wunderswan;
                                    if (ws && ws.image && (!ws.image.src || !ws.image.src.includes('wunderswan.png'))) {
                                        try { ws.image.src = 'assets/wunderswan.png'; console.info('[WunderswanSprite][spawn] set existing image.src to assets/wunderswan.png'); } catch(_){}
                                    }
                                } catch(_){}
                            }
                        } catch(e) { console.warn('[RoomGen] Wunderswan spawn handler error', e); }
                        // Ensure no further enemies spawn for this room so Wunderswan appears alone
                        break;
                    }
                    // If we selected the secret Golden Goose, ensure it spawns alone and attempt to kick the sprite loader
                    if (typeName === 'Golden Goose') {
                        try {
                            console.info('[RoomGen] Golden Goose chosen - forcing single spawn and ensuring sprite load');
                            try {
                                console.info('[GoldenGooseSprite][dbg] spawn handler entry', {
                                    enemySpritesExists: !!game.enemySprites,
                                    ggExists: !!(game.enemySprites && game.enemySprites.goldengoose),
                                    ggImageSrc: (game.enemySprites && game.enemySprites.goldengoose && game.enemySprites.goldengoose.image && game.enemySprites.goldengoose.image.src) || null,
                                    ggLoaded: !!(game.enemySprites && game.enemySprites.goldengoose && game.enemySprites.goldengoose.loaded),
                                    preKick: !!game._goldengoose_preKick,
                                    preKickSrc: (game._goldengoose_preKick && game._goldengoose_preKick.src) || null,
                                    spawnKickRef: !!game._goldengoose_spawnKick,
                                    spawnKickSrc: (game._goldengoose_spawnKick && game._goldengoose_spawnKick.src) || null,
                                    baseURI: document.baseURI
                                });
                            } catch(_){ }
                                if (!game.enemySprites) game.enemySprites = {};
                                if (!game.enemySprites.goldengoose) {
                                try {
                                    const kick = new Image();
                                    kick.onload = function(){
                                        try {
                                            console.info('[GoldenGooseSprite][spawn-kick] loaded on spawn', { nw: kick.naturalWidth, nh: kick.naturalHeight });
                                            if (!game.enemySprites) game.enemySprites = {};
                                            if (!game.enemySprites.goldengoose) game.enemySprites.goldengoose = {};
                                            // Maintain alias used by renderer
                                            try { game.enemySprites['Golden Goose'] = game.enemySprites.goldengoose; } catch(_){}
                                            try {
                                                const gg = game.enemySprites.goldengoose;
                                                const existingImg = gg.image;
                                                const existingReady = !!(gg.loaded || (existingImg && (existingImg.complete || (existingImg.naturalWidth && existingImg.naturalHeight))));
                                                const newReady = !!(kick.complete || (kick.naturalWidth && kick.naturalHeight));
                                                // Only replace an existing ready image if the new image is actually ready.
                                                if (!existingReady || newReady) {
                                                    gg.image = kick;
                                                    gg._gg_img_ref = kick;
                                                    // Ensure the public alias references the same container
                                                    try { game.enemySprites['Golden Goose'] = game.enemySprites.goldengoose; } catch(_){}
                                                    gg.loaded = true;
                                                    if (typeof gg._applyFrameLayout === 'function') {
                                                        try { gg._applyFrameLayout(kick); } catch(err) { console.warn('[GoldenGooseSprite][spawn-kick] frame layout apply failed', err); }
                                                    } else {
                                                        gg.frames = { down: { x:0, y:0, w: kick.naturalWidth || kick.width, h: kick.naturalHeight || kick.height } };
                                                    }
                                                } else {
                                                    try { console.info('[GoldenGooseSprite][spawn-kick] preserved existing loaded image; deferred replacing with spawn-kick'); } catch(_){ }
                                                }
                                            } catch(_){ }
                                        } catch(_){ }
                                        // Defensive: if natural size zero, try alternate URL (reuse alternate helper if available)
                                        if ((kick.naturalWidth || 0) === 0 || (kick.naturalHeight || 0) === 0) {
                                            try { const alt = (typeof tryAlternateWunderswanUrl === 'function') ? tryAlternateWunderswanUrl(kick.src) : null; if (alt && alt !== kick.src) { console.info('[GoldenGooseSprite][spawn-kick] retrying alt', alt); kick.src = alt; } } catch(_){ }
                                        }
                                    };
                                    kick.onerror = function(ev){ console.warn('[GoldenGooseSprite][spawn-kick] failed to load', ev); };
                                    try {
                                        const resolvedUrl = (function(){ try { return new URL('assets/geese/goldengoose-sheet.png', document.baseURI).href; } catch(_) { return 'assets/geese/goldengoose-sheet.png'; } })();
                                        kick.src = resolvedUrl; console.info('[GoldenGooseSprite][spawn-kick] requesting', resolvedUrl);
                                    } catch(e){ kick.src = 'assets/geese/goldengoose-sheet.png'; console.warn('[GoldenGooseSprite][spawn-kick] requesting failed', e); }
                                    game._goldengoose_spawnKick = kick;
                                } catch(e){ console.warn('[GoldenGooseSprite][spawn-kick] error', e); }
                            } else {
                                try {
                                    const gg = game.enemySprites.goldengoose;
                                    if (gg && gg.image && (!gg.image.src || !gg.image.src.includes('goldengoose-sheet.png'))) {
                                        try { gg.image.src = 'assets/geese/goldengoose-sheet.png'; console.info('[GoldenGooseSprite][spawn] set existing image.src to assets/geese/goldengoose-sheet.png'); } catch(_){ }
                                    }
                                } catch(_){}
                            }
                        } catch(e) { console.warn('[RoomGen] Golden Goose spawn handler error', e); }
                        // Ensure no further enemies spawn for this room so Golden Goose appears alone
                        break;
                    }
                    if (typeof game._roomSpawnedEnemies === 'number') game._roomSpawnedEnemies++;
                    if (i === 0) console.info('[RoomGen] First enemy', { type: typeName, x: +enemyObj.x.toFixed(1), y: +enemyObj.y.toFixed(1) });
                }
            }
            if (game.enemies.length === 0) {
                console.warn('[RoomGen] No enemies spawned; injecting fallback.');
                const fallback = { x: (LOGICAL_W/2)+(Math.random()*160-80), y: (LOGICAL_H/2)+(Math.random()*160-80), type:'Thug', health:40, maxHealth:40, speed:1.1, baseSpeed:1.1, damage:5, color:'#884400', size:20, xp:5, ranged:false, lastAttack:0, poisoned:false, slowed:false, burning:false, wunderScribble:false, wunderScribbleTime:0, wunderScribbleInterval:0, wunderScribbleTickDamage:0, _wunderScribbleTick:0 };
                game.enemies.push(fallback);
                if (typeof game._roomSpawnedEnemies === 'number') game._roomSpawnedEnemies++;
            }
            // Clamp any enemies that may have landed outside logical bounds due to future logic changes.
            for (const en of game.enemies) {
                if (!en) continue;
                const margin = 40;
                if (en.x < margin) en.x = margin + Math.random()*30;
                if (en.y < margin) en.y = margin + Math.random()*30;
                if (en.x > LOGICAL_W - margin) en.x = LOGICAL_W - margin - Math.random()*30;
                if (en.y > LOGICAL_H - margin) en.y = LOGICAL_H - margin - Math.random()*30;
            }
            console.info('[RoomGen] Done', { spawned: game.enemies.length, counter: game._roomSpawnedEnemies });
            // Debug: if projectile pool is nearly full immediately after room generation, dump diagnostics
            try {
                if (game.projectilePool && typeof game.projectilePool.active === 'function') {
                    const ac = game.projectilePool.active();
                    const max = game.projectilePool.max || 6000;
                    if (ac > Math.max(3000, Math.floor(max * 0.85))) {
                        console.warn('[RoomGen][DEBUG] High projectile active count after room gen', { active: ac, max });
                        try {
                            if (game._debug && game._debug.spawnStacks && game._debug.spawnStacks.size) {
                                // Sort stack keys by count desc and print top 6
                                const arr = Array.from(game._debug.spawnStacks.entries());
                                arr.sort((a,b)=>b[1]-a[1]);
                                console.warn('[RoomGen][DEBUG] Top spawn stack samples (count, stack snippet):', arr.slice(0,6));
                            }
                            if (game._debug && game._debug.spawnExample && game._debug.spawnExample.length) {
                                console.warn('[RoomGen][DEBUG] Example spawn indices captured', game._debug.spawnExample.slice(0,8));
                            }
                        } catch(e) { console.warn('[RoomGen][DEBUG] spawn dump error', e); }
                    }
                }
            } catch(_) {}
            
            // Spawn chests
            let chestSpawnChance = 0.5;
            if (game.player.abilities.includes('Treasure Hunter')) chestSpawnChance = 0.8;
            // Guaranteed minimum chest logic: ensure at least 2 chests every district (rooms 1-5)
            // Strategy: If still below quota and nearing end of cycle, force spawn.
            const roomsPerDistrict = 5;
            const minChestsPerDistrict = 2;
            const roomIndexInCycle = game.room; // 1..5
            let forceChest = false;
            if (typeof game.chestsThisCycle !== 'number') game.chestsThisCycle = 0;
            const remainingRooms = roomsPerDistrict - roomIndexInCycle + 1;
            const needed = minChestsPerDistrict - game.chestsThisCycle;
            if (needed > 0) {
                // If number of remaining rooms equals needed, we must force spawn now.
                if (needed >= remainingRooms) {
                    forceChest = true;
                } else {
                    // Soft pity: slightly boost chance proportional to deficit
                    chestSpawnChance += 0.15 * needed; // each missing chest adds 15% chance
                }
            }
            if (forceChest || Math.random() < chestSpawnChance) {
                let x, y, attempts = 0;
                const startX = LOGICAL_W/2, startY = LOGICAL_H/2; // player spawn center (dynamic)
                const startExclusionR = 90; // radius within which chests may not spawn
                const startExclusionR2 = startExclusionR * startExclusionR;
                do {
                    x = 60 + Math.random() * (LOGICAL_W - 120);
                    y = 60 + Math.random() * (LOGICAL_H - 120);
                    attempts++;
                    const dxs = x - startX; const dys = y - startY;
                    var tooCloseToStart = (dxs*dxs + dys*dys) < startExclusionR2;
                } while ((tooCloseToStart || game.enemies.some(e => Math.abs(e.x - x) < 60) || isWall(x, y)) && attempts < 50);
                
                if (attempts < 50) {
                    // Rare rainbow chest: 2% baseline chance per spawn (before Treasure Hunter etc.)
                    const isRainbow = Math.random() < 0.02;
                    // Preselect an ability for this chest now so variant can reflect rarity.
                    // Choose from abilities the player does NOT yet have.
                    const pool = Object.keys(ABILITIES).filter(a => !game.player.abilities.includes(a));
                    let chosenAbility = null;
                    if (pool.length > 0) {
                        // Weight by inverse tier (common more likely) but with slight bias for variety.
                        const weighted = [];
                        pool.forEach(a => {
                            const tier = ABILITIES[a].tier || 1;
                            const base = Math.max(1, 4 - tier); // 3 for T1,2 for T2,1 for T3
                            for (let i=0;i<base;i++) weighted.push(a);
                        });
                        chosenAbility = weighted[Math.floor(Math.random()*weighted.length)];
                    }
                    // Map tier to can variant: tier1 -> platinum (common / white), tier2 -> gold (rare / blue), tier3 -> irradiated (epic / purple)
                    // Rainbow overrides these and ignores preselected ability (player will pick from all)
                    let variant = 'gold';
                    if (chosenAbility) {
                        const tier = ABILITIES[chosenAbility].tier || 1;
                        if (tier === 1) variant = 'platinum';
                        else if (tier === 2) variant = 'gold';
                        else if (tier >= 3) variant = 'irradiated';
                    } else {
                        // No ability available (player owns everything) keep neutral gold appearance
                        variant = 'gold';
                    }
                    if (isRainbow) {
                        variant = 'rainbow';
                    }
                    game.chests.push({ x, y, opened: false, variant, jigglePhase: 0, ability: isRainbow ? null : chosenAbility, rainbow: !!isRainbow });
                    game.chestsThisCycle = (game.chestsThisCycle || 0) + 1;
                }
            }
            
            // Center player based on dynamic logical size
            game.player.x = LOGICAL_W / 2;
            game.player.y = LOGICAL_H / 2;
            // Spawn room-unique Tumbleweed / Kick the Can if player has the abilities
            try {
                const hasTw = game.player && Array.isArray(game.player.abilities) && game.player.abilities.includes('Tumbleweed');
                const hasCan = game.player && Array.isArray(game.player.abilities) && game.player.abilities.includes('Kick the Can');
                if (hasTw || hasCan) {
                    // Pick a spot away from center/start and not inside walls/obstacles
                    const startX = LOGICAL_W/2, startY = LOGICAL_H/2;
                    const exclusionR = 120; const exclusionR2 = exclusionR*exclusionR;
                    // Plan spawn order to reduce overlap: try placing Tumbleweed first, then Can with separation from TW.
                    let twPos = null;
                    let canPos = null;
                    if (hasTw) {
                        let tx, ty, attempts = 0;
                        do {
                            tx = 60 + Math.random() * (LOGICAL_W - 120);
                            ty = 60 + Math.random() * (LOGICAL_H - 120);
                            attempts++;
                            const dxs = tx - startX, dys = ty - startY;
                            var tooClose = (dxs*dxs + dys*dys) < exclusionR2;
                        } while ((tooClose || isWall(tx, ty, 18)) && attempts < 80);
                        if (attempts < 80) twPos = { x: tx, y: ty };
                    }
                    if (hasCan) {
                        const sep = 80; const sep2 = sep*sep;
                        let cx, cy, attempts = 0;
                        do {
                            cx = 60 + Math.random() * (LOGICAL_W - 120);
                            cy = 60 + Math.random() * (LOGICAL_H - 120);
                            attempts++;
                            const dxs = cx - startX, dys = cy - startY;
                            var tooClose = (dxs*dxs + dys*dys) < exclusionR2;
                            var tooNearTw = false;
                            if (twPos) { const dxt = cx - twPos.x, dyt = cy - twPos.y; tooNearTw = (dxt*dxt + dyt*dyt) < sep2; }
                        } while ((tooClose || tooNearTw || isWall(cx, cy, 18)) && attempts < 100);
                        if (attempts < 100) canPos = { x: cx, y: cy };
                        // If we didn't place TW earlier but will place Can, and later we place TW, ensure separation too
                        if (!twPos && hasTw) {
                            let tx, ty, tries = 0; const sep3 = 80*80;
                            do {
                                tx = 60 + Math.random() * (LOGICAL_W - 120);
                                ty = 60 + Math.random() * (LOGICAL_H - 120);
                                tries++;
                                const dxs = tx - startX, dys = ty - startY;
                                var tooClose = (dxs*dxs + dys*dys) < exclusionR2;
                                var tooNearCan = false;
                                if (canPos) { const dxc = tx - canPos.x, dyc = ty - canPos.y; tooNearCan = (dxc*dxc + dyc*dyc) < sep3; }
                            } while ((tooClose || tooNearCan || isWall(tx, ty, 18)) && tries < 100);
                            if (tries < 100) twPos = { x: tx, y: ty };
                        }
                    }
                    // Now spawn whichever positions are valid
                    if (twPos && hasTw) {
                        const baseDmg = Math.max(6, Math.floor((typeof calculateDamage === 'function' ? calculateDamage() : 22) * 0.70));
                        const idx = game.spawnProjectile({
                            x: twPos.x, y: twPos.y,
                            vx: (Math.random()*2-1) * 0.25,
                            vy: (Math.random()*2-1) * 0.25,
                            life: 60000,
                            radius: 14,
                            damage: baseDmg,
                            bouncing: true
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        if (idx >= 0) {
                            game._projMeta.set(idx, { tumbleweed: true, bouncing: true, piercing: true, pierceCount: 999, pierceHits: 0, indestructible: true, baseDamage: baseDmg, _rollAngle: 0 });
                            game._tumbleweedIndex = idx;
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:twPos.x, y:twPos.y, color:'#EED7AA', radius: 18, life: 90 });
                        }
                    } else {
                        game._tumbleweedIndex = -1;
                    }
                    if (canPos && hasCan) {
                        const baseDmg = Math.max(6, Math.floor((typeof calculateDamage === 'function' ? calculateDamage() : 22) * 0.70));
                        const idx = game.spawnProjectile({
                            x: canPos.x, y: canPos.y,
                            vx: (Math.random()*2-1) * 0.25,
                            vy: (Math.random()*2-1) * 0.25,
                            life: 60000,
                            radius: 14,
                            damage: baseDmg,
                            bouncing: true
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        if (idx >= 0) {
                            game._projMeta.set(idx, { kickTheCan: true, bouncing: true, piercing: true, pierceCount: 999, pierceHits: 0, indestructible: true, baseDamage: baseDmg, _rollAngle: 0 });
                            game._kickCanIndex = idx;
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:canPos.x, y:canPos.y, color:'#EED7AA', radius: 18, life: 90 });
                        }
                    } else {
                        game._kickCanIndex = -1;
                    }
                } else {
                    game._tumbleweedIndex = -1;
                    game._kickCanIndex = -1;
                }
            } catch(_) {}
        }

        function isWall(x, y, size = 25) {
            // Supports variable-sized walls (cars, dumpsters, barriers) and aligns hitboxes with their sprite draw rects
            return game.walls.some(wall => {
                let wx = wall.x, wy = wall.y, w = wall.width || TILE_SIZE, h = wall.height || TILE_SIZE;
                if (wall.type === 'dumpster' && typeof window.getDumpsterSpriteRect === 'function') {
                    const rect = window.getDumpsterSpriteRect(wall);
                    if (rect && rect.w && rect.h) { wx = rect.x; wy = rect.y; w = rect.w; h = rect.h; }
                } else if (wall.type === 'barrier') {
                    // Map opaque image bounds to on-canvas footprint for tighter collisions
                    const img = window._barrierImage;
                    const opaque = window._barrierOpaqueRect;
                    if (img && opaque && opaque.w && opaque.h) {
                        const iw = img.naturalWidth || img.width;
                        const ih = img.naturalHeight || img.height;
                        const sx = wall.x, sy = wall.y; // destination top-left
                        const sw = w, sh = h;           // destination size
                        // Scale opaque rect from image space to dest space
                        const scaleX = sw / iw;
                        const scaleY = sh / ih;
                        wx = sx + opaque.x * scaleX;
                        wy = sy + opaque.y * scaleY;
                        w = Math.max(1, opaque.w * scaleX);
                        h = Math.max(1, opaque.h * scaleY);
                    }
                }
                return (x > wx - size && x < wx + w + size && y > wy - size && y < wy + h + size);
            });
        }

        // Move an enemy along a vector in small steps, stopping before hitting walls.
        // dx,dy is the normalized direction vector; distance is how far to attempt to push.
        function pushEnemy(enemy, dx, dy, distance, step = 4) {
            const steps = Math.max(1, Math.ceil(distance / step));
            let moved = 0;
            for (let i = 0; i < steps; i++) {
                const nx = enemy.x + dx * step;
                const ny = enemy.y + dy * step;
                // If the next step would be inside a wall, stop early
                if (isWall(nx, ny, enemy.size/2)) break;
                enemy.x = nx;
                enemy.y = ny;
                moved += step;
            }
            // Failsafe clamp so enemies never leave playable bounds
            const margin = 40;
            enemy.x = Math.max(margin, Math.min(enemy.x, canvas.width - margin));
            enemy.y = Math.max(margin, Math.min(enemy.y, canvas.height - margin));
            return moved;
        }

        // Unified knockback impulse application (velocity-based) replacing instantaneous pushEnemy usage for knockback effects.
        // forceDist approximates desired travel distance; direction provided via normalized (dx,dy) or computed from sx,sy vector.
        function applyKnockback(enemy, forceDist, sx, sy) {
            if (!enemy) return;
            // Derive direction from sx,sy
            const mag = Math.hypot(sx, sy) || 1;
            const dx = sx / mag; const dy = sy / mag;
            // Parameters: decay & initial velocity mapping (reuse smooth knockback math but allow independent tuning)
            const decay = 0.9; // slightly higher decay (slower) vs applySmoothKnockback for layered pushes
            const v0 = Math.min(30, forceDist * (1 - decay));
            enemy._kbDecay = decay;
            enemy.kbVX = (enemy.kbVX || 0) + dx * v0;
            enemy.kbVY = (enemy.kbVY || 0) + dy * v0;
            // Extend kbFrames proportionally; layering multiple impulses increases duration modestly
            const addFrames = Math.min(40, Math.floor(forceDist * 0.4));
            enemy.kbFrames = Math.max(enemy.kbFrames || 0, addFrames);
            enemy._knockbacking = true;
        }

        // Smooth knockback: apply an initial velocity and let updateEnemies integrate it over several frames.
        // distance roughly correlates with the total displacement we want. We translate that into an initial
        // speed and decay factor. This avoids the "teleport" look of large instantaneous pushes (e.g., Wind Blade 120px).
        function applySmoothKnockback(enemy, dx, dy, distance) {
            // Normalize direction (defensive)
            const mag = Math.hypot(dx, dy) || 1;
            const ndx = dx / mag; const ndy = dy / mag;
            // If enemy already has knockback velocity, blend (add) the new impulse.
            const decay = 0.88; // stored for reference if we later want per-enemy tuning
            enemy._kbDecay = decay;
            // Convert desired travel distance into initial speed; geometric series sum S = v0 / (1-decay)
            // => v0 ≈ distance * (1 - decay). We clamp to avoid absurd speeds on gigantic values.
            const baseV0 = distance * (1 - decay); // e.g. distance 120, decay .88 -> ~14.4
            const v0 = Math.min(28, baseV0);
            enemy.kbVX = (enemy.kbVX || 0) + ndx * v0;
            enemy.kbVY = (enemy.kbVY || 0) + ndy * v0;
            // Duration in frames: allow enough frames for displacement. Use log threshold: v * decay^n < 0.25 => n ≈ log(0.25/v)/log(decay)
            // Approximate with linear scale for simplicity.
            enemy.kbFrames = Math.max(enemy.kbFrames || 0, Math.min(50, Math.floor(distance * 0.5))); // 120 -> 60 (capped 50)
            // Flag so other movement AI can skip while sliding.
            enemy._knockbacking = true;
        }

        // Returns true if any ability selection modal/overlay is currently visible
        function isAnyAbilityModalOpen() {
            const ids = ['startAbilityOverlay', 'rainbowAbilityOverlay', 'abilityChoiceOverlay', 'confirmOverlay'];
            for (let i = 0; i < ids.length; i++) {
                const el = document.getElementById(ids[i]);
                if (!el) continue;
                const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
                const visible = cs ? (cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0') : (el.style.display !== 'none');
                if (visible) return true;
            }
            return false;
        }

        // --- Gamepad helpers (controller fixes 2025-10-10) ---
        function _applyDeadzone(ax, ay, deadzone) {
            const mag = Math.hypot(ax, ay);
            if (mag < deadzone) return { x: 0, y: 0 };
            const n = (mag - deadzone) / (1 - deadzone);
            const scale = n / (mag || 1);
            return { x: ax * scale, y: ay * scale };
        }

        function updateGamepadInput() {
            const inp = game.input;
            if (!inp || !inp.gamepadEnabled) return;
            const get = (navigator.getGamepads && navigator.getGamepads()) || [];
            let pad = null;
            if (inp.gpIndex != null && get[inp.gpIndex]) {
                pad = get[inp.gpIndex];
            }
            if (!pad) {
                // pick first connected standard-mapped pad
                for (let i=0;i<get.length;i++) { if (get[i] && get[i].connected) { pad = get[i]; inp.gpIndex = i; break; } }
            }
            if (!pad) return;
            // Axes: standard mapping: 0=LX,1=LY, 2=RX,3=RY
            const ax0 = pad.axes[0] || 0, ay0 = pad.axes[1] || 0;
            const ax1 = pad.axes[2] || 0, ay1 = pad.axes[3] || 0;
            const dz = Math.min(0.6, Math.max(0.05, inp.gpDeadzone||0.25));
            const mv = _applyDeadzone(ax0, ay0, dz);
            const av = _applyDeadzone(ax1, ay1, dz);
            // Clamp to [-1,1] to avoid rare >1 magnitudes from browser quirks
            function clamp1(v){ return v>1?1:(v<-1?-1:v); }
            mv.x = clamp1(mv.x); mv.y = clamp1(mv.y);
            av.x = clamp1(av.x); av.y = clamp1(av.y);
            // Some pads (e.g., MOGA XP5-A Plus) report right-stick Y as -1 at rest; treat this as invalid aim so movement can control facing
            if (Math.abs(av.x) < 0.2 && (Math.abs(av.y + 1) < 0.12 || Math.abs(av.y) > 0.98)) {
                // If aim appears pegged vertically with near-zero X, ignore it
                av.x = 0; av.y = 0;
            }
            inp.gpMove.x = mv.x; inp.gpMove.y = mv.y;
            inp.gpAim.x = av.x; inp.gpAim.y = av.y;
            // Buttons: 0=A, 1=B, 2=X, 3=Y, 4=LB, 5=RB, 6=LT, 7=RT, 8=Back, 9=Start, 10=LS, 11=RS
            const btn = (i)=>{ const b = pad.buttons[i]; return !!(b && (b.pressed || (b.value!=null && b.value>0.5))); };
            // Manual mapping support
            const map = (game.input && game.input.gpMap) || null;
            // Resolve D-Pad state either via mapping or fallbacks
            let dpx = 0, dpy = 0;
            if (map && (map.dpadUp || map.dpadDown || map.dpadLeft || map.dpadRight)) {
                const up = __gp_mappingPressed(pad, map.dpadUp);
                const down = __gp_mappingPressed(pad, map.dpadDown);
                const left = __gp_mappingPressed(pad, map.dpadLeft);
                const right = __gp_mappingPressed(pad, map.dpadRight);
                dpx = (right?1:0) - (left?1:0);
                dpy = (down?1:0) - (up?1:0);
            } else {
                // D-Pad digital movement (12=Up, 13=Down, 14=Left, 15=Right)
                const dUp = btn(12), dDown = btn(13), dLeft = btn(14), dRight = btn(15);
                dpx = (dRight?1:0) - (dLeft?1:0);
                dpy = (dDown?1:0) - (dUp?1:0);
            }
            // Fallback: D-Pad via POV "hat" (axis 9)
            if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length > 9) {
                const hat = pad.axes[9];
                const vec = __gp_hatToVec(hat);
                if (vec) { dpx = vec.x; dpy = vec.y; }
            }
            // Fallback 2: older/alt mappings use separate axes 6 (horizontal) and 7 (vertical) for the D-Pad
            if (!map && dpx === 0 && dpy === 0 && Array.isArray(pad.axes) && pad.axes.length >= 8) {
                const dax = pad.axes[6] || 0, day = pad.axes[7] || 0;
                if (Math.abs(dax) > 0.5) dpx = dax > 0 ? 1 : -1;
                if (Math.abs(day) > 0.5) dpy = day > 0 ? 1 : -1; // +1 down, -1 up (matches standard)
            }
            if (dpx !== 0 || dpy !== 0) {
                // Override analog move when D-Pad is pressed for crisp digital control (no deadzone)
                inp.gpMove.x = dpx;
                inp.gpMove.y = dpy;
            }
            // Clamp tiny drift post-deadzone
            if (Math.abs(inp.gpMove.x) < 0.001) inp.gpMove.x = 0;
            if (Math.abs(inp.gpMove.y) < 0.001) inp.gpMove.y = 0;
            if (Math.abs(inp.gpAim.x) < 0.001) inp.gpAim.x = 0;
            if (Math.abs(inp.gpAim.y) < 0.001) inp.gpAim.y = 0;
            // Fire: manual mapping takes precedence; else A (0) only
            let fireNow = false;
            if (map && map.fire) fireNow = __gp_mappingPressed(pad, map.fire);
            else fireNow = btn(0);
            inp.gpFire = !!fireNow;
            // Start toggles pause on rising edge; ignore if a modal is open.
            // Also guard against triggers mistakenly toggling by checking their raw values and mapping.
            const trigBtnL = btn(6), trigBtnR = btn(7);
            const trigValL = (pad.buttons[6] && typeof pad.buttons[6].value === 'number') ? pad.buttons[6].value : 0;
            const trigValR = (pad.buttons[7] && typeof pad.buttons[7].value === 'number') ? pad.buttons[7].value : 0;
            const startNow = (map && map.pause) ? __gp_mappingPressed(pad, map.pause) : btn(9);
            const last = inp._lastButtons || {};
            if (startNow && !last.start && trigValL < 0.1 && trigValR < 0.1 && !trigBtnL && !trigBtnR) {
                const now = performance.now ? performance.now() : Date.now();
                if (!inp._lastStartAt || now - inp._lastStartAt > 250) {
                    if (!(typeof isAnyAbilityModalOpen === 'function' && isAnyAbilityModalOpen())) {
                        if (typeof togglePause === 'function') togglePause();
                    }
                    inp._lastStartAt = now;
                }
            }
            // Snapshot for edge detection; explicitly track LS/RS to filter accidental actions
            inp._lastButtons = {
                start: startNow,
                ls: btn(10),
                rs: btn(11),
                lt: trigBtnL,
                rt: trigBtnR
            };
        }

        function setupControls() {
            document.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                game.keys[key] = true;
                // Toggle gamepad debug overlay with F6 (diagnostics)
                if (e.key === 'F6') {
                    const dbg = document.getElementById('gpDebug');
                    if (dbg) dbg.style.display = (dbg.style.display === 'none' || !dbg.style.display) ? 'block' : 'none';
                }
                
                // Handle pause
                if (key === 'p') {
                    // If typing in an input/textarea/contentEditable or an ability modal is open,
                    // do NOT toggle pause so 'p' can be used in search fields.
                    const ae = document.activeElement;
                    const tag = ae && ae.tagName ? String(ae.tagName).toUpperCase() : '';
                    const isTypingField = (tag === 'INPUT' || tag === 'TEXTAREA') || (ae && ae.isContentEditable === true);
                    if (isTypingField || isAnyAbilityModalOpen()) {
                        return; // let default typing behavior occur
                    }
                    togglePause();
                    e.preventDefault();
                }
                if (key === 'f') {
                    game.showFps = !game.showFps;
                }
            });
            
            document.addEventListener('keyup', e => {
                game.keys[e.key.toLowerCase()] = false;
            });
        }

        function gameLoop() {
            if (!game._loopStarted) game._loopStarted = true; // mark loop engaged once
            // Cache a single timestamp per frame to avoid many calls to performance.now() per-projectile
            try { game._frameNow = (performance && performance.now) ? performance.now() : Date.now(); } catch(_) { game._frameNow = Date.now(); }
            // Defensive: if multiple RAF chains somehow created, abort duplicates
            if (game._cancelExtraLoop) return;
            // Always poll gamepad so Start can unpause and inputs are fresh even when paused (controller fixes 2025-10-10)
            try { updateGamepadInput(); } catch(_) {}
            // Allow menu navigation with D-Pad/left stick and confirm with A when overlays are open
            try { handleGamepadMenuNavigation(); } catch(_) {}
            // Update debug overlay if visible
            try { updateGpDebug(); } catch(_) {}
            const returningToTitle = !!(game && game._returningToTitle);
            if (!returningToTitle && !game.paused && !game.gameOver) {
                update();
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            game.paused = !game.paused;
            const overlay = document.getElementById('pauseOverlay');
            
            if (game.paused) {
                overlay.style.display = 'flex';
                initPauseTabs();
                switchPauseTab('abilities');
                updatePauseMenu();
            } else {
                overlay.style.display = 'none';
            }
        }

        // Update pause menu to show ability descriptions
        function updatePauseMenu() {
            const pauseAbilities = document.getElementById('pauseAbilities');
            if (game.player.abilities.length === 0) {
                pauseAbilities.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #666; font-style: italic;">No abilities acquired yet</div>';
                return;
            }
            let html = '';
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                const tier = abilityData ? abilityData.tier || 1 : 1;
                const isPermanent = game.player.permanentAbilities.includes(ability);
                let cardClass = `ability-card tier${tier}` + (isPermanent ? ' permanent' : '');
                let color = '#ffffff';
                if (tier === 2) color = '#4488ff';
                else if (tier >= 3) color = '#c855ff';
                const permaBadge = isPermanent ? `<span style="display:inline-block;margin-left:8px;padding:1px 6px;border:1px solid #ffd700;border-radius:10px;color:#ffd700;font-size:10px;letter-spacing:0.5px;vertical-align:middle;">PERMANENT</span>` : '';
                html += `<div class="${cardClass}" style="margin-bottom:8px; position:relative;">
                    <div class="ability-card-name" style="color:${isPermanent ? '#ffd700' : color}">${ability}${permaBadge}</div>
                    <div class="ability-card-desc">${abilityData ? abilityData.desc : 'Unknown ability'}</div>
                </div>`;
            });
            pauseAbilities.innerHTML = html;
        }

        function quitToTitleFromPause() {
            try { game._returningToTitle = true; game._titleMusicSuppressed = true; } catch(_){ }
            try {
                // Close pause overlay if still visible
                if (game && game.paused && typeof togglePause === 'function') {
                    togglePause();
                } else {
                    const pauseOverlay = document.getElementById('pauseOverlay');
                    if (pauseOverlay) pauseOverlay.style.display = 'none';
                    try { game.paused = false; } catch(_){ }
                }
            } catch(_){ }

            // Remove any lingering run-specific overlays
            try {
                const removable = [
                    'confirmOverlay','rainbowAbilityOverlay','abilityChoiceOverlay','startAbilityOverlay',
                    'actTransitionOverlay','discoveredAbilitiesOverlay','endingOverlay','abilityDraftOverlay',
                    'gpMapOverlay'
                ];
                removable.forEach(id => {
                    const el = document.getElementById(id);
                    if (el && el.parentElement) el.parentElement.removeChild(el);
                });
            } catch(_){ }

            try {
                if (game) {
                    game.gameOver = false;
                    game._restartArm = false;
                    game._restartGpPrev = false;
                    if (game._gameOverSound) {
                        try { game._gameOverSound.pause(); } catch(_){ }
                        game._gameOverSound = null;
                    }
                }
            } catch(_){ }

            try { resetGame({ suppressMusic: true, skipRoomInit: true }); } catch(_){ }

            try {
                if (game) {
                    game.paused = true;
                    game.keys = {};
                    if (game.input) {
                        game.input.gpFire = false;
                        if (game.input.gpMove) { game.input.gpMove.x = 0; game.input.gpMove.y = 0; }
                        if (game.input.gpAim) { game.input.gpAim.x = 0; game.input.gpAim.y = 0; }
                    }
                    game._started = false;
                    game.uiNav = null;
                }
            } catch(_){ }

            try { showTitleScreen(); } catch(err) { console.warn('[QuitToTitle] showTitleScreen failed', err); }
        }

        // --- Minimal gamepad debug overlay ---
        (function ensureGpDebug(){
            if (document.getElementById('gpDebug')) return;
            const el = document.createElement('div');
            el.id = 'gpDebug';
            el.style.cssText = 'position:fixed;left:6px;top:6px;z-index:20000;background:rgba(0,0,0,0.6);color:#0f0;padding:6px 8px;border:1px solid #0a4;border-radius:6px;font:11px Courier New,monospace;white-space:pre;display:none;max-width:50vw;';
            el.textContent = 'GP Debug';
            document.body.appendChild(el);
        })();
        function updateGpDebug(){
            const box = document.getElementById('gpDebug'); if (!box || box.style.display==='none') return;
            const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
            const idx = game && game.input ? game.input.gpIndex : null;
            const p = (idx!=null && pads[idx]) ? pads[idx] : pads.find(x=>x && x.connected);
            const m = p ? (p.mapping||'') : '';
            const bStates = [];
            if (p && p.buttons) {
                for (let i=0;i<Math.min(16,p.buttons.length);i++) {
                    const b = p.buttons[i]; bStates.push((b && (b.pressed||((b.value||0)>0.5)))?1:0);
                }
            }
            const mv = game.input ? game.input.gpMove : {x:0,y:0};
            const av = game.input ? game.input.gpAim : {x:0,y:0};
            const facing = game.player ? game.player.facing : '?';
            const axesLen = p && p.axes ? p.axes.length : 0;
            const a6 = p && p.axes && p.axes.length>6 ? p.axes[6] : 0;
            const a7 = p && p.axes && p.axes.length>7 ? p.axes[7] : 0;
            const a9 = p && p.axes && p.axes.length>9 ? p.axes[9] : 0;
            // Mapped state preview
            let mappedLine = '';
            try {
                const mp = game.input && game.input.gpMap;
                if (mp) {
                    const pressed = (ent)=>__gp_mappingPressed(p, ent) ? '1':'0';
                    const up = mp.dpadUp?pressed(mp.dpadUp):'-';
                    const dn = mp.dpadDown?pressed(mp.dpadDown):'-';
                    const lf = mp.dpadLeft?pressed(mp.dpadLeft):'-';
                    const rt = mp.dpadRight?pressed(mp.dpadRight):'-';
                    const fire = mp.fire?pressed(mp.fire):'-';
                    const pause = mp.pause?pressed(mp.pause):'-';
                    mappedLine = `\nmapped: U${up} D${dn} L${lf} R${rt} F${fire} P${pause}`;
                }
            } catch(_) {}
            box.textContent = `map:${m}\nbtn[0..15]: ${bStates.join('')}\nmove: ${mv.x.toFixed(2)}, ${mv.y.toFixed(2)}  aim: ${av.x.toFixed(2)}, ${av.y.toFixed(2)}\naxes(len=${axesLen}): a6=${(+a6).toFixed(2)} a7=${(+a7).toFixed(2)} a9=${(+a9).toFixed(2)}${mappedLine}\nfacing: ${facing}`;
        }

        // Expose mapping overlay at top-level scope
        function startManualGamepadMapping() {
            const existing = document.getElementById('gpMapOverlay'); if (existing) try { existing.remove(); } catch(_) {}
            const ov = document.createElement('div'); ov.id='gpMapOverlay';
            ov.style.cssText = 'position:fixed;inset:0;z-index:30000;background:rgba(0,0,0,0.86);display:flex;align-items:center;justify-content:center;font-family:Courier New,monospace;';
            const panel = document.createElement('div');
            panel.style.cssText = 'width:min(720px,92vw);background:#141414;border:2px solid #666;border-radius:10px;padding:16px;color:#eee;display:flex;flex-direction:column;gap:10px;';
            const title = document.createElement('div'); title.style.cssText='font-weight:800;letter-spacing:1px;color:#fff'; title.textContent='Controller Mapping';
            const info = document.createElement('div'); info.style.cssText='color:#bbb;font-size:12px'; info.textContent='Follow the prompts. Press the requested button/direction. Press Esc to cancel.';
            const prompt = document.createElement('div'); prompt.id='gpMapPrompt'; prompt.style.cssText='background:#0c0c0c;border:1px solid #555;border-radius:8px;padding:10px;color:#aaffaa;min-height:46px;display:flex;align-items:center;';
            const actions = document.createElement('div'); actions.style.cssText='display:flex;gap:8px;justify-content:flex-end;';
            const btnCancel = document.createElement('button'); btnCancel.textContent='Cancel'; btnCancel.style.cssText='padding:6px 10px;background:#222;border:1px solid #777;color:#ddd;border-radius:6px;cursor:pointer;'; btnCancel.setAttribute('data-gp-focus','1');
            const btnClear = document.createElement('button'); btnClear.textContent='Clear Mapping'; btnClear.style.cssText='padding:6px 10px;background:#222;border:1px solid #777;color:#ddd;border-radius:6px;cursor:pointer;'; btnClear.setAttribute('data-gp-focus','1');
            panel.appendChild(title); panel.appendChild(info); panel.appendChild(prompt); actions.appendChild(btnClear); actions.appendChild(btnCancel); panel.appendChild(actions); ov.appendChild(panel); document.body.appendChild(ov);

            let steps = [
                { key:'pause', label:'Press the PAUSE button (Start)' },
                { key:'fire', label:'Press the FIRE button (A)' },
                { key:'dpadUp', label:'Press D-Pad UP' },
                { key:'dpadDown', label:'Press D-Pad DOWN' },
                { key:'dpadLeft', label:'Press D-Pad LEFT' },
                { key:'dpadRight', label:'Press D-Pad RIGHT' }
            ];
            const result = {};
            let idx = 0;
            let lastSnapshot = null;
            let paused = false;
            try { paused = !!game.paused; game.paused = true; } catch(_) {}

            function setPrompt(text, color='#aaffaa') { prompt.textContent = text; prompt.style.color = color; }
            function snapshotPad(p) {
                if (!p) return null;
                const s = { buttons:[], axes:[] };
                for (let i=0;i<Math.min(24, (p.buttons?p.buttons.length:0)); i++) {
                    const b = p.buttons[i]; s.buttons[i] = { pressed: !!(b && (b.pressed || ((b.value||0)>0.5))), value: (b && typeof b.value==='number') ? b.value : 0 };
                }
                for (let i=0;i<Math.min(16, (p.axes?p.axes.length:0)); i++) {
                    s.axes[i] = typeof p.axes[i] === 'number' ? p.axes[i] : 0;
                }
                return s;
            }
            function diffPad(prev, curr) {
                if (!prev || !curr) return null;
                // Buttons first
                for (let i=0;i<Math.min(prev.buttons.length, curr.buttons.length); i++) {
                    if (!prev.buttons[i].pressed && curr.buttons[i].pressed) {
                        return { type:'button', index:i };
                    }
                }
                // Axes: detect hat axis changes and strong digital pushes
                for (let i=0;i<Math.min(prev.axes.length, curr.axes.length); i++) {
                    const a0 = prev.axes[i], a1 = curr.axes[i];
                    if (i === 9) {
                        const v = __gp_hatToVec(a1);
                        const v0 = __gp_hatToVec(a0);
                        if (v && (!v0 || v.x !== v0.x || v.y !== v0.y)) {
                            return { type:'axis', index:9, dir:'hat' };
                        }
                    } else {
                        const thr = 0.6;
                        // Rising over threshold in either direction
                        if (Math.abs(a1) >= thr && Math.abs(a0) < thr) {
                            return { type:'axis', index:i, threshold:thr, sign: (a1>0)?1:-1 };
                        }
                    }
                }
                return null;
            }
            function saveAndClose(ok=true) {
                try { if (!paused) game.paused = false; else game.paused = paused; } catch(_) {}
                window.removeEventListener('keydown', escHandler, true);
                try { document.body.removeChild(ov); } catch(_) {}
                if (ok) { saveInputPreferences(); reflectOptionStates(); }
            }
            function escHandler(e){ if (e.key==='Escape'){ e.preventDefault(); saveAndClose(false);} }
            window.addEventListener('keydown', escHandler, true);
            btnCancel.onclick = () => saveAndClose(false);
            btnClear.onclick = () => { try { delete game.input.gpMap; localStorage.removeItem('pref_gp_map'); } catch(_) {} setPrompt('Mapping cleared. Close this overlay.', '#ffcc88'); };

            function nextStep() {
                if (idx >= steps.length) {
                    game.input.gpMap = result;
                    try { saveInputPreferences(); } catch(_) {}
                    try { console.info('[Gamepad Mapping] Saved:', result); } catch(_) {}
                    setPrompt('Saved mapping. You can close this overlay.', '#aaccff');
                    return;
                }
                setPrompt(steps[idx].label + ' …');
                // capture initial snapshot for edge detection
                const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
                const p = pads.find(x=>x && x.connected);
                lastSnapshot = snapshotPad(p);
            }

            const interval = setInterval(()=>{
                if (!document.body.contains(ov)) { clearInterval(interval); return; }
                const pads = (navigator.getGamepads && navigator.getGamepads()) || [];
                const p = pads.find(x=>x && x.connected);
                if (!p) return;
                const curr = snapshotPad(p);
                if (!lastSnapshot) { lastSnapshot = curr; return; }
                const change = diffPad(lastSnapshot, curr);
                if (change) {
                    const key = steps[idx].key;
                    if (key === 'dpadUp') {
                        result.dpadUp = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'up' } : change;
                    } else if (key === 'dpadDown') {
                        result.dpadDown = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'down' } : change;
                    } else if (key === 'dpadLeft') {
                        result.dpadLeft = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'left' } : change;
                    } else if (key === 'dpadRight') {
                        result.dpadRight = (change.dir==='hat') ? { type:'axis', index:9, dir:'hat', want:'right' } : change;
                    } else if (key === 'pause') {
                        result.pause = change;
                    } else if (key === 'fire') {
                        result.fire = change;
                    }
                    idx++;
                    lastSnapshot = curr;
                    nextStep();
                }
            }, 60);

            // Kick it off
            nextStep();
        }
        try { window.startManualGamepadMapping = startManualGamepadMapping; } catch(_) {}

        function initPauseTabs() {
            const btnA = document.getElementById('tabAbilities');
            const btnH = document.getElementById('tabAchievements');
            const btnO = document.getElementById('tabOptions');
            if (!btnA || !btnO) return;
            try { btnA.setAttribute('data-gp-focus','1'); btnO.setAttribute('data-gp-focus','1'); } catch(_) {}
            btnA.onclick = () => { switchPauseTab('abilities'); };
            if (btnH) { try { btnH.setAttribute('data-gp-focus','1'); } catch(_) {} btnH.onclick = () => { switchPauseTab('achievements'); renderAchievementsPanel(); }; }
            btnO.onclick = () => { switchPauseTab('options'); };
            // Option buttons
            const sfxBtn = document.getElementById('optToggleSfx');
            const musicBtn = document.getElementById('optToggleMusic');
            const cosBtn = document.getElementById('optToggleCosmetic');
            const resetBtn = document.getElementById('optResetProgress');
            const quitBtn = document.getElementById('optQuitToTitle');
            // Inject gamepad controls into options panel if not present
            const pauseOptions = document.getElementById('pauseOptions');
            if (pauseOptions && !document.getElementById('optToggleGamepad')) {
                const gpToggle = document.createElement('button');
                gpToggle.id = 'optToggleGamepad';
                gpToggle.textContent = 'Gamepad: ON';
                gpToggle.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #555;color:#0f0;font-family:\'Courier New\', monospace;cursor:pointer;';
                gpToggle.setAttribute('data-gp-focus','1');
                const gpDead = document.createElement('div');
                gpDead.id = 'optGpDeadzoneRow';
                gpDead.style.cssText = 'display:flex;align-items:center;gap:8px;color:#ccc;font-family:Courier New,monospace;';
                const gpDeadLbl = document.createElement('span'); gpDeadLbl.id='optGpDeadzoneLabel'; gpDeadLbl.textContent = 'Deadzone: 25%';
                const gpDec = document.createElement('button'); gpDec.id='optGpDeadDec'; gpDec.textContent='-'; gpDec.style.cssText='padding:4px 8px;background:#222;border:2px solid #555;color:#0f0;cursor:pointer;';
                gpDec.setAttribute('data-gp-focus','1');
                const gpInc = document.createElement('button'); gpInc.id='optGpDeadInc'; gpInc.textContent='+'; gpInc.style.cssText='padding:4px 8px;background:#222;border:2px solid #555;color:#0f0;cursor:pointer;';
                gpInc.setAttribute('data-gp-focus','1');
                gpDead.appendChild(gpDeadLbl); gpDead.appendChild(gpDec); gpDead.appendChild(gpInc);
                // Manual mapping button
                const gpMapBtn = document.createElement('button');
                gpMapBtn.id = 'optGpManualMap';
                gpMapBtn.textContent = 'Controller Mapping…';
                gpMapBtn.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #888;color:#fff;font-family:\'Courier New\', monospace;cursor:pointer;';
                gpMapBtn.setAttribute('data-gp-focus','1');
                const gpMapNote = document.createElement('div');
                gpMapNote.id = 'optGpMapNote';
                gpMapNote.style.cssText = 'color:#aaa;font:11px Courier New,monospace;margin-top:6px;';
                gpMapNote.textContent = 'Configure A/Start/D-Pad if auto-detect fails.';
                // Insert into panel
                const container = pauseOptions.querySelector('div');
                if (container) { container.appendChild(gpToggle); container.appendChild(gpDead); container.appendChild(gpMapBtn); container.appendChild(gpMapNote); }
            }
            if (sfxBtn) sfxBtn.onclick = () => { toggleSfx(); reflectOptionStates(); };
            if (musicBtn) musicBtn.onclick = () => { toggleMusic(); reflectOptionStates(); };
            if (cosBtn) cosBtn.onclick = () => {
                game.potatoMode = !game.potatoMode;
                applyPotatoFxClamps(game.potatoMode);
                saveAudioPreferences();
                reflectOptionStates();
                updatePotatoBadge();
            };
            if (resetBtn) resetBtn.onclick = () => {
                // Custom overlay with three choices
                const old = document.getElementById('confirmOverlay');
                if (old) { try { old.remove(); } catch(_) {} }
                const overlay = document.createElement('div');
                overlay.id = 'confirmOverlay';
                overlay.style.cssText = 'position:fixed;inset:0;z-index:25000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.82);font-family:Courier New,monospace;';
                const panel = document.createElement('div');
                panel.style.cssText = 'min-width:380px;max-width:680px;background:#141414;border:2px solid #666;border-radius:10px;padding:16px;display:flex;flex-direction:column;gap:12px;box-shadow:0 10px 24px rgba(0,0,0,0.6)';
                const title = document.createElement('div');
                title.textContent = 'Reset options';
                title.style.cssText = 'color:#fff;font-weight:700;letter-spacing:0.5px;';
                const desc = document.createElement('div');
                desc.textContent = 'Choose what to reset:';
                desc.style.cssText = 'color:#ccc;font-size:13px;margin-top:-6px;';
                const list = document.createElement('div');
                list.style.cssText = 'display:flex;flex-direction:column;gap:8px;';
                const btnAch = document.createElement('button');
                btnAch.textContent = 'Reset Achievements Only';
                btnAch.style.cssText = 'padding:8px 12px;background:#1b1b1b;border:2px solid #557;color:#cfe8ff;border-radius:6px;cursor:pointer;text-align:left;';
                btnAch.setAttribute('data-gp-focus','1');
                const noteAch = document.createElement('div'); noteAch.textContent = 'Clears unlocked achievements and counters.'; noteAch.style.cssText='color:#9bb; font-size:11px; margin-top:3px;'; btnAch.appendChild(noteAch);
                const btnProg = document.createElement('button');
                btnProg.textContent = 'Reset Progress Only';
                btnProg.style.cssText = 'padding:8px 12px;background:#1b1b1b;border:2px solid #755;color:#ffd7d7;border-radius:6px;cursor:pointer;text-align:left;';
                btnProg.setAttribute('data-gp-focus','1');
                const noteProg = document.createElement('div'); noteProg.textContent = 'Clears permanent abilities and progression.'; noteProg.style.cssText='color:#b99; font-size:11px; margin-top:3px;'; btnProg.appendChild(noteProg);
                const btnBoth = document.createElement('button');
                btnBoth.textContent = 'Reset Both';
                btnBoth.style.cssText = 'padding:8px 12px;background:#1b1b1b;border:2px solid #577;color:#cff;border-radius:6px;cursor:pointer;text-align:left;';
                btnBoth.setAttribute('data-gp-focus','1');
                const noteBoth = document.createElement('div'); noteBoth.textContent = 'Clears achievements and progress in one go.'; noteBoth.style.cssText='color:#9bd; font-size:11px; margin-top:3px;'; btnBoth.appendChild(noteBoth);
                const actions = document.createElement('div');
                actions.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;margin-top:6px;';
                const btnCancel = document.createElement('button'); btnCancel.textContent='Cancel'; btnCancel.style.cssText='padding:8px 12px;background:#222;border:2px solid #777;color:#ddd;border-radius:6px;cursor:pointer;'; btnCancel.setAttribute('data-gp-focus','1');
                actions.appendChild(btnCancel);
                list.appendChild(btnAch); list.appendChild(btnProg); list.appendChild(btnBoth);
                panel.appendChild(title); panel.appendChild(desc); panel.appendChild(list); panel.appendChild(actions);
                overlay.appendChild(panel);
                document.body.appendChild(overlay);
                const close = ()=>{ try{ overlay.remove(); }catch(_){} };
                btnAch.onclick = ()=>{ try { localStorage.removeItem('achievements_v1'); } catch(_) {} close(); location.reload(); };
                btnProg.onclick = ()=>{ try { localStorage.removeItem('permanentAbilities'); localStorage.removeItem('seenAbilities_v1'); } catch(_) {} try { if (game) { game._actIIUnlocked = false; game._actIIIUnlocked = false; } } catch(_){} try { if (localStorage && localStorage.removeItem) { localStorage.removeItem('actIIUnlocked'); localStorage.removeItem('actIIIUnlocked'); } } catch(_){} close(); location.reload(); };
                btnBoth.onclick = ()=>{ try { localStorage.removeItem('achievements_v1'); localStorage.removeItem('permanentAbilities'); localStorage.removeItem('seenAbilities_v1'); } catch(_) {} try { if (game) { game._actIIUnlocked = false; game._actIIIUnlocked = false; } } catch(_){} try { if (localStorage && localStorage.removeItem) { localStorage.removeItem('actIIUnlocked'); localStorage.removeItem('actIIIUnlocked'); } } catch(_){} close(); location.reload(); };
                btnCancel.onclick = ()=> close();
                const esc = (e)=>{ if (e.key==='Escape') { e.preventDefault(); btnCancel.click(); window.removeEventListener('keydown', esc, true);} };
                window.addEventListener('keydown', esc, true);
                try {
                    game.uiNav = game.uiNav || {};
                    game.uiNav.container = overlay;
                    // Set initial focus to "Reset Progress Only" as a safe middle option
                    game.uiNav.items = [btnCancel, btnAch, btnProg, btnBoth];
                    game.uiNav.index = 2;
                    applyGpFocus();
                } catch(_) {}
            };
                if (quitBtn) {
                    try { quitBtn.setAttribute('data-gp-focus','1'); } catch(_){ }
                    quitBtn.onclick = () => {
                        const message = 'Quit to the title screen? Current run progress will be lost.';
                        try {
                            showConfirmOverlay(message, () => {
                                try { quitToTitleFromPause(); } catch(err) { console.warn('[QuitToTitle] failed', err); }
                            });
                        } catch(_) {
                            try { quitToTitleFromPause(); } catch(err) { console.warn('[QuitToTitle] fallback failed', err); }
                        }
                    };
                }
            // Gamepad handlers
            const gpBtn = document.getElementById('optToggleGamepad');
            const gpDec = document.getElementById('optGpDeadDec');
            const gpInc = document.getElementById('optGpDeadInc');
            if (gpBtn) gpBtn.onclick = () => { game.input.gamepadEnabled = !game.input.gamepadEnabled; saveInputPreferences(); reflectOptionStates(); };
            if (gpDec) gpDec.onclick = () => { game.input.gpDeadzone = Math.max(0.05, (game.input.gpDeadzone||0.25) - 0.05); saveInputPreferences(); reflectOptionStates(); };
            if (gpInc) gpInc.onclick = () => { game.input.gpDeadzone = Math.min(0.6, (game.input.gpDeadzone||0.25) + 0.05); saveInputPreferences(); reflectOptionStates(); };
            // Ensure mapping button exists even if gamepad toggle section was already inserted previously
            (function ensureGpMapButton(){
                const pauseOptions = document.getElementById('pauseOptions');
                if (!pauseOptions) return;
                let gpMapBtn = document.getElementById('optGpManualMap');
                if (!gpMapBtn) {
                    const container = pauseOptions.querySelector('div');
                    if (container) {
                        gpMapBtn = document.createElement('button');
                        gpMapBtn.id = 'optGpManualMap';
                        gpMapBtn.textContent = 'Controller Mapping…';
                        gpMapBtn.style.cssText = 'padding:8px 12px;background:#222;border:2px solid #888;color:#fff;font-family:\'Courier New\', monospace;cursor:pointer;';
                        const note = document.createElement('div');
                        note.id = 'optGpMapNote';
                        note.style.cssText = 'color:#aaa;font:11px Courier New,monospace;margin-top:6px;';
                        note.textContent = 'Configure A/Start/D-Pad if auto-detect fails.';
                        container.appendChild(gpMapBtn); container.appendChild(note);
                    }
                }
                gpMapBtn = document.getElementById('optGpManualMap');
                if (gpMapBtn) gpMapBtn.onclick = () => { try { startManualGamepadMapping(); } catch(e) { console.warn('Mapping overlay failed', e); } };
            })();
            reflectOptionStates();
        }

        function reflectOptionStates() {
            const sfxBtn = document.getElementById('optToggleSfx');
            const musicBtn = document.getElementById('optToggleMusic');
            const cosBtn = document.getElementById('optToggleCosmetic');
            if (sfxBtn) sfxBtn.textContent = 'SFX: ' + (game.sfxEnabled ? 'ON' : 'OFF');
            if (musicBtn) musicBtn.textContent = 'Music: ' + (game.musicEnabled ? 'ON' : 'OFF');
            if (cosBtn) cosBtn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF');
            const gpBtn = document.getElementById('optToggleGamepad');
            const gpLbl = document.getElementById('optGpDeadzoneLabel');
            if (gpBtn) gpBtn.textContent = 'Gamepad: ' + (game.input && game.input.gamepadEnabled ? 'ON' : 'OFF');
            if (gpLbl) {
                const pct = Math.round( ( (game.input && game.input.gpDeadzone) || 0.25) * 100 );
                gpLbl.textContent = 'Deadzone: ' + pct + '%';
            }
        }

        // === In-game confirmation modal (controller-friendly) ===
        function showConfirmOverlay(message, onYes, onCancel) {
            // Prevent duplicates
            const old = document.getElementById('confirmOverlay');
            if (old) { try { old.remove(); } catch(_) {} }
            const overlay = document.createElement('div');
            overlay.id = 'confirmOverlay';
            overlay.style.cssText = 'position:fixed;inset:0;z-index:25000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.82);font-family:Courier New,monospace;';
            const panel = document.createElement('div');
            panel.style.cssText = 'min-width:300px;max-width:520px;background:#141414;border:2px solid #666;border-radius:10px;padding:16px;display:flex;flex-direction:column;gap:12px;box-shadow:0 10px 24px rgba(0,0,0,0.6)';
            const text = document.createElement('div');
            text.textContent = message || 'Are you sure?';
            text.style.cssText = 'color:#eee;font-size:14px;line-height:1.4;';
            const actions = document.createElement('div');
            actions.style.cssText = 'display:flex;gap:10px;justify-content:flex-end;';
            const btnYes = document.createElement('button');
            btnYes.textContent = 'Yes';
            btnYes.style.cssText = 'padding:8px 14px;background:#222;border:2px solid #5a5;color:#bfb;color:#bfb;border-radius:6px;cursor:pointer;';
            btnYes.setAttribute('data-gp-focus','1');
            const btnNo = document.createElement('button');
            btnNo.textContent = 'Cancel';
            btnNo.style.cssText = 'padding:8px 14px;background:#222;border:2px solid #777;color:#ddd;border-radius:6px;cursor:pointer;';
            btnNo.setAttribute('data-gp-focus','1');
            actions.appendChild(btnNo); actions.appendChild(btnYes);
            panel.appendChild(text); panel.appendChild(actions);
            overlay.appendChild(panel);
            document.body.appendChild(overlay);

            const close = () => { try { overlay.remove(); } catch(_) {} };
            btnYes.onclick = () => { try { onYes && onYes(); } catch(_) {} close(); };
            btnNo.onclick = () => { try { onCancel && onCancel(); } catch(_) {} close(); };
            // ESC to cancel
            const esc = (e)=>{ if (e.key==='Escape') { e.preventDefault(); btnNo.click(); window.removeEventListener('keydown', esc, true);} };
            window.addEventListener('keydown', esc, true);

            // Ensure gamepad nav targets the confirm overlay immediately
            try {
                game.uiNav = game.uiNav || {};
                game.uiNav.container = overlay;
                game.uiNav.items = [btnNo, btnYes];
                game.uiNav.index = 1; // default to Yes
                applyGpFocus();
            } catch(_) {}

            return overlay;
        }

        function switchPauseTab(which) {
            const tabA = document.getElementById('tabAbilities');
            const tabH = document.getElementById('tabAchievements');
            const tabO = document.getElementById('tabOptions');
            const contentA = document.getElementById('pauseAbilities');
            const contentH = document.getElementById('pauseAchievements');
            const contentO = document.getElementById('pauseOptions');
            if (!tabA || !tabO || !contentA || !contentO) return;
            const activeStyles = { borderColor:'#00ff88', color:'#00ff88' };
            const idleStyles = { borderColor:'#444', color:'#aaa' };
            function applyStyles(btn, styles) { Object.assign(btn.style, styles); }
            if (which === 'abilities') {
                contentA.style.display = 'grid';
                if (contentH) contentH.style.display = 'none';
                contentO.style.display = 'none';
                applyStyles(tabA, activeStyles); applyStyles(tabO, idleStyles);
                if (tabH) applyStyles(tabH, idleStyles);
            } else if (which === 'achievements') {
                contentA.style.display = 'none';
                if (contentH) contentH.style.display = 'block';
                contentO.style.display = 'none';
                if (tabH) applyStyles(tabH, activeStyles);
                applyStyles(tabO, idleStyles); applyStyles(tabA, idleStyles);
            } else {
                contentA.style.display = 'none';
                if (contentH) contentH.style.display = 'none';
                contentO.style.display = 'block';
                applyStyles(tabO, activeStyles); applyStyles(tabA, idleStyles);
                if (tabH) applyStyles(tabH, idleStyles);
            }
        }

        function renderAchievementsPanel(){
            try {
                const holder = document.getElementById('pauseAchievements');
                if (!holder) return;
                const ach = (function(){
                    // mirror registry keys and meta from achievements module
                    const keys = [
                        ['madPooper','Mad Pooper!','Splatter 500 enemies with Diarrhea','diarrheaKills',500],
                        ['aimBot','Aim Bot','Kill 100 enemies with Auto-Aim','autoAimKills',100],
                        ['noKnock','No Knock List','Cause 5000 total trap damage (Beartrap/Punji Pit)','trapDamage',5000],
                        ['worthy','Worthy','Kill 500 enemies with Hammer Slam','hammerKills',500],
                        ['owMyEye','Ow! My Eye!','Hit 500 enemies with Toenail Clibbins','toenailHits',500],
                        ['downTheDrain','Down the Drain','Combine Uzumaki with Diarrhea',null,null],
                        ['vectorMan','Vector Man','Kill 250 enemies with Vector Pivot','vectorKills',250],
                        ['sonsIdea','This was my son\'s idea','Get Rizz',null,null],
                        ['projectileVomit','Projectile Vomit','Fire 56 projectiles in one attack',null,null],
                        ['giveItTheBeans','Give it the Beans!','Shoot the can of beans 50 times','beansShots',50],
                        ['diabeetus','Diabeetus','Consume 100 pieces of bread','breadEaten',100],
                        ['extraButter','Extra Butter','Hit 50 enemies with popcorn','popcornHits',50],
                        ['apothecary','Apothecary Diarrhea','Combine Diarrhea with Poison Shot',null,null],
                        ['gooseGoldenTeeth','The Goose that had the Golden Teeth','Find and defeat the Golden Goose',null,null],
                        ['oneFrame','I live my life one frame at a time','Drop the framerate to a single frame per second.',null,null]
                    ];
                    return keys;
                })();
                const unlocked = (game.achv && game.achv.unlocked) || {};
                const get = (k)=> (game.achv && game.achv[k]) || 0;
                let html = '';
                ach.forEach(([key,name,desc,counter,target])=>{
                    const isDone = !!unlocked[key];
                    const current = (counter? (get(counter)|0) : (isDone?1:0));
                    const max = (target||1);
                    const pct = Math.max(0, Math.min(100, Math.floor((current/max)*100)));
                    html += `
                        <div class="achvRow" data-key="${key}" style="padding:8px 10px;border:1px solid ${isDone?'#66ff88':'#444'};border-radius:8px;background:${isDone?'rgba(0,255,136,0.08)':'rgba(50,50,50,0.35)'};margin:6px 0;">
                            <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
                                <div style="font-weight:700;color:${isDone?'#66ff88':'#eee'};">${name}</div>
                                <div style="font-size:11px;color:${isDone?'#9fe6b8':'#ccc'};">${isDone?'Unlocked':'Locked'}</div>
                            </div>
                            <div style="color:#ccc;font-size:12px;margin-top:2px;">${desc}</div>
                            ${target?`
                            <div style="height:8px;background:#1b1b1b;border:1px solid #333;border-radius:6px;margin-top:6px;overflow:hidden;">
                                <div style="height:100%;width:${pct}%;background:linear-gradient(90deg,#00ff88,#00aa66);"></div>
                            </div>
                            <div style="color:#9bb;font-size:11px;margin-top:2px;">${current} / ${target}</div>
                            `:''}
                        </div>`;
                });
                holder.innerHTML = html;
            } catch (e) { console.warn('renderAchievementsPanel failed', e); }
        }

        // === Gamepad UI Navigation (menus/overlays) ===
        (function ensureGpFocusStyle(){
            if (document.getElementById('gpFocusStyle')) return;
            const st = document.createElement('style');
            st.id = 'gpFocusStyle';
            st.textContent = `
                .gpFocus {
                    outline: 2px solid #00ff88 !important;
                    outline-offset: 2px !important;
                    box-shadow: 0 0 0 2px rgba(0,255,136,0.3) !important;
                    border-color: #00ff88 !important;
                }
            `;
            document.head.appendChild(st);
        })();

        function isOverlayVisible(el){
            if (!el) return false;
            const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
            return cs ? (cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0') : (el.style.display !== 'none');
        }

        function getActiveUiContainer(){
            // Preference order: mapping overlay, ability picker, pause overlay
            const mapOv = document.getElementById('gpMapOverlay');
            if (mapOv && document.body.contains(mapOv)) return mapOv;
            const confirmOv = document.getElementById('confirmOverlay');
            if (confirmOv && document.body.contains(confirmOv)) return confirmOv;
            const abilOv = document.getElementById('startAbilityOverlay');
            if (abilOv && document.body.contains(abilOv)) return abilOv;
            // Permanent ability choice overlay
            const permOv = document.getElementById('abilityChoiceOverlay');
            if (permOv && document.body.contains(permOv)) return permOv;
            // Ending overlay (final image that appears when Big Quack defeated)
            const endOv = document.getElementById('endingOverlay');
            if (endOv && document.body.contains(endOv)) return endOv;
            // Rainbow ability picker overlay
            const rbOv = document.getElementById('rainbowAbilityOverlay');
            if (rbOv && document.body.contains(rbOv)) return rbOv;
            const pauseOv = document.getElementById('pauseOverlay');
            if (game.paused && pauseOv && isOverlayVisible(pauseOv)) return pauseOv;
            // Fallback: if a standalone Play Again button is visible (post-final), treat it as the active container
            const playAgainBtn = document.getElementById('postFinalPlayAgain');
            if (playAgainBtn && document.body.contains(playAgainBtn)) return playAgainBtn; // gatherFocusables will include container if button
            return null;
        }

        function gatherFocusables(container){
            if (!container) return [];
            const arr = [];
            // If the container itself is a button, include it
            if (container.tagName && container.tagName.toUpperCase() === 'BUTTON') {
                arr.push(container);
            }
            // Always include buttons
            container.querySelectorAll('button').forEach(b=>arr.push(b));
            // Include explicit gp-focus markers (used in grids)
            container.querySelectorAll('[data-gp-focus="1"]').forEach(el=>arr.push(el));
            // Include pause tab buttons explicitly if present
            const tabA = document.getElementById('tabAbilities');
            const tabO = document.getElementById('tabOptions');
            if (tabA && container.contains(tabA)) arr.unshift(tabA);
            if (tabO && container.contains(tabO)) arr.unshift(tabO);
            // Filter visible, unique
            const seen = new Set();
            const vis = arr.filter(el=>{
                if (!el || !container.contains(el)) return false;
                const key = el.tagName+"#"+(el.id||'')+"@"+(el.getAttribute('data-gp-focus')||'')+"@"+(el.textContent||'');
                if (seen.has(key)) return false; seen.add(key);
                const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
                if (cs && (cs.display==='none' || cs.visibility==='hidden')) return false;
                if (el.offsetParent === null && cs && cs.position !== 'fixed') return false;
                return true;
            });
            return vis;
        }

        function gpUiNavReset(){
            game.uiNav = game.uiNav || {};
            const cont = getActiveUiContainer();
            const items = gatherFocusables(cont);
            game.uiNav.container = cont;
            game.uiNav.items = items;
            game.uiNav.index = items.length ? 0 : -1;
            game.uiNav.lastDX = 0; game.uiNav.lastDY = 0; game.uiNav.lastMoveAt = 0; game.uiNav.lastFire = false; game.uiNav.lastFireAt = 0;
            applyGpFocus();
        }

        function applyGpFocus(){
            if (!game.uiNav) return;
            // Clear old
            document.querySelectorAll('.gpFocus').forEach(el=>el.classList.remove('gpFocus'));
            const items = game.uiNav.items || [];
            const i = game.uiNav.index|0;
            if (i >= 0 && i < items.length) {
                const el = items[i];
                el.classList.add('gpFocus');
            }
        }

        // Visual navigation helper: find the best candidate index in items when moving in a 2D direction.
        function findBestIndexForDirection(items, currentIndex, dx, dy) {
            if (!items || items.length === 0) return -1;
            const cur = items[currentIndex] || null;
            let cx = null, cy = null;
            try {
                if (cur && cur.getBoundingClientRect) {
                    const r = cur.getBoundingClientRect(); cx = r.left + r.width/2; cy = r.top + r.height/2;
                }
            } catch(_) {}
            // If we couldn't measure the current element, fall back to index arithmetic
            if (cx === null || cy === null) return -1;
            const candidates = [];
            for (let i = 0; i < items.length; i++) {
                if (i === currentIndex) continue;
                const it = items[i];
                try {
                    if (!it.getBoundingClientRect) continue;
                    const r = it.getBoundingClientRect();
                    const ix = r.left + r.width/2; const iy = r.top + r.height/2;
                    const vx = ix - cx; const vy = iy - cy;
                    // For vertical moves, prefer items that are strictly below/above, then minimize vertical distance and horizontal offset
                    if (dy !== 0) {
                        if ((dy > 0 && vy <= 2) || (dy < 0 && vy >= -2)) continue; // not in the requested direction
                        candidates.push({ i, primary: Math.abs(vy), secondary: Math.abs(vx) });
                    } else if (dx !== 0) {
                        if ((dx > 0 && vx <= 2) || (dx < 0 && vx >= -2)) continue;
                        candidates.push({ i, primary: Math.abs(vx), secondary: Math.abs(vy) });
                    }
                } catch(_) {}
            }
            if (!candidates.length) return -1;
            candidates.sort((a,b)=> (a.primary - b.primary) || (a.secondary - b.secondary));
            return candidates[0].i;
        }

        function moveGpFocus(delta){
            if (!game.uiNav || !game.uiNav.items || !game.uiNav.items.length) return;
            const n = game.uiNav.items.length;
            game.uiNav.index = ( (game.uiNav.index|0) + delta + n ) % n;
            applyGpFocus();
            // Scroll focused element into view only when focus changed via controller navigation
            try {
                const el = (game.uiNav.items || [])[game.uiNav.index|0];
                if (el && typeof el.scrollIntoView === 'function') el.scrollIntoView({block:'nearest', inline:'nearest'});
            } catch(_) {}
        }

        function handleGamepadMenuNavigation(){
            const cont = getActiveUiContainer();
            if (!cont) return; // no active UI
            // Skip if typing
            const ae = document.activeElement;
            const tag = ae && ae.tagName ? String(ae.tagName).toUpperCase() : '';
            if (tag === 'INPUT' || tag === 'TEXTAREA' || (ae && ae.isContentEditable === true)) return;
            // Ensure state container matches; only reset when container actually changes
            if (!game.uiNav || game.uiNav.container !== cont) gpUiNavReset();
            // Refresh items in case menu changed
            const items = gatherFocusables(cont);
            // Only update items list if it actually changed length or the container changed — avoid forcing focus each frame
            if (!game.uiNav._lastContainer || game.uiNav._lastContainer !== cont || (game.uiNav._lastItemsLen || 0) !== items.length) {
                game.uiNav.items = items;
                // store tracking values so we don't reapply focus/scroll on every frame
                game.uiNav._lastContainer = cont;
                game.uiNav._lastItemsLen = items.length;
                if (items.length && (game.uiNav.index == null || game.uiNav.index < 0 || game.uiNav.index >= items.length)) game.uiNav.index = 0;
                // apply focus once when the set changes
                applyGpFocus();
            }

            const inp = game.input;
            if (!inp || !inp.gamepadEnabled) return;
            // Digitalize nav from gpMove (supports dpad or stick)
            const dx = (inp.gpMove.x > 0.5) ? 1 : (inp.gpMove.x < -0.5) ? -1 : 0;
            const dy = (inp.gpMove.y > 0.5) ? 1 : (inp.gpMove.y < -0.5) ? -1 : 0; // down is +1 visually, but we use that as next
            const now = performance.now ? performance.now() : Date.now();
            const repeatDelay = 200; // ms between repeats

            // Special case: when pause overlay Abilities tab is active, use left stick to scroll the list
            // rather than moving focus vertically (so you can read long lists easily)
            const pauseMenuEl = document.getElementById('pauseMenu');
            const pauseAbilitiesEl = document.getElementById('pauseAbilities');
            const pauseAchievementsEl = document.getElementById('pauseAchievements');
            const inPauseAbilities = !!(game.paused && pauseMenuEl && pauseAbilitiesEl && pauseAbilitiesEl.style.display !== 'none' && cont && (cont.id === 'pauseOverlay'));
            const inPauseAchievements = !!(game.paused && pauseMenuEl && pauseAchievementsEl && pauseAchievementsEl.style.display !== 'none' && cont && (cont.id === 'pauseOverlay'));
            let consumedVertical = false;
            if (inPauseAbilities || inPauseAchievements) {
                // Analog scroll for smoothness; fallback to digital step with repeat
                const ay = inp.gpMove.y || 0;
                if (Math.abs(ay) > 0.28) {
                    // Scale speed with magnitude; smaller on low FX devices
                    const base = 16;
                    const speed = base + Math.min(1, Math.abs(ay)) * 24;
                    pauseMenuEl.scrollTop += ay * speed;
                    consumedVertical = true;
                } else if (dy !== 0) {
                    const canRepeat = (game.uiNav.lastDY === dy) ? (now - (game.uiNav.lastMoveAt||0) > repeatDelay) : true;
                    if (canRepeat) {
                        pauseMenuEl.scrollTop += dy * 64; // discrete step per repeat
                        game.uiNav.lastMoveAt = now;
                    }
                    game.uiNav.lastDY = dy;
                    consumedVertical = true;
                } else {
                    game.uiNav.lastDY = 0;
                }
            }

            // Vertical has priority for typical lists. If the visible items form a grid, move by a whole row (columns) instead of 1.
            if (!consumedVertical && dy !== 0) {
                // Prefer visual nearest element in the requested vertical direction
                const currentIndex = game.uiNav.index|0;
                const best = findBestIndexForDirection(items, currentIndex, 0, dy);
                const canRepeat = (game.uiNav.lastDY === dy) ? (now - (game.uiNav.lastMoveAt||0) > repeatDelay) : true;
                if (best >= 0 && canRepeat) {
                    const delta = best - currentIndex;
                    moveGpFocus(delta);
                    game.uiNav.lastMoveAt = now;
                    game.uiNav.lastDY = dy;
                } else {
                    // Fallback to row-step logic (columns heuristic) if visual selection didn't find a candidate
                    let cols = 1;
                    try {
                        if (items && items.length > 0) {
                            const firstTop = (items[0].getBoundingClientRect && items[0].getBoundingClientRect().top) || 0;
                            cols = 0;
                            for (let ii = 0; ii < items.length; ii++) {
                                const it = items[ii];
                                const t = (it.getBoundingClientRect && it.getBoundingClientRect().top) || 0;
                                if (Math.abs(t - firstTop) < 2) cols++; else break;
                            }
                            if (cols < 1) cols = 1;
                        }
                    } catch(_) { cols = 1; }
                    if (canRepeat) {
                        moveGpFocus(cols * dy);
                        game.uiNav.lastMoveAt = now;
                    }
                    game.uiNav.lastDY = dy;
                }
            } else if (!consumedVertical) {
                game.uiNav.lastDY = 0;
            }
            // Horizontal navigation for rows/grids
            if (dx !== 0 && dy === 0) {
                const canRepeat = (game.uiNav.lastDX === dx) ? (now - (game.uiNav.lastMoveAt||0) > repeatDelay) : true;
                if (canRepeat) {
                    moveGpFocus(dx);
                    game.uiNav.lastMoveAt = now;
                }
                game.uiNav.lastDX = dx;
            } else if (dx === 0) {
                game.uiNav.lastDX = 0;
            }

            // Confirm with A (gpFire) rising edge, but enforce a short guard and require release-first
            const GUARD_MS = 320; // minimum delay after overlay appears before allowing confirm
            const fireNow = !!inp.gpFire;
            const lastFireWas = !!(game.uiNav && game.uiNav.lastFire);
            const lastFireAt = (game.uiNav && game.uiNav.lastFireAt) || 0;
            const guardExpired = (now - lastFireAt) > GUARD_MS;
            // Only accept rising edge when previously not pressed AND the guard (if any) has expired
            if (fireNow && !lastFireWas && guardExpired) {
                const i = game.uiNav.index|0; const target = (items && items[i]) || null;
                if (target && typeof target.click === 'function') {
                    try { target.click(); } catch(_) {}
                }
                game.uiNav.lastFireAt = now;
            }
            game.uiNav.lastFire = fireNow;
        }

        // Keyboard navigation for overlays: map arrow keys and WASD to ui focus movement
        // This is separate from the global key listeners and only applies when an overlay that supports focus is present.
        window.addEventListener('keydown', function(ev){
            try {
                const tag = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toUpperCase() : '';
                if (tag === 'INPUT' || tag === 'TEXTAREA' || (document.activeElement && document.activeElement.isContentEditable === true)) return; // typing
                const cont = getActiveUiContainer();
                if (!cont) return;
                // Only handle navigation keys
                const key = ev.key;
                let handled = false;
                // vertical navigation: Up/Down or W/S
                if (key === 'ArrowUp' || key === 'Up' || key === 'w' || key === 'W' || key === 's' || key === 'S' || key === 'ArrowDown' || key === 'Down') {
                    // compute dy: up -> -1, down -> +1
                    let dy = 0;
                    if (key === 'ArrowUp' || key === 'Up' || key === 'w' || key === 'W') dy = -1;
                    if (key === 'ArrowDown' || key === 'Down' || key === 's' || key === 'S') dy = 1;
                    // If the active container has a scrollable child (grid/list), prefer scrolling it rather than moving focus.
                    try {
                        const scrollable = (function findScrollable(el){
                            if (!el) return null;
                            const nodes = el.querySelectorAll('*');
                            for (let n=0;n<nodes.length;n++) {
                                const c = nodes[n];
                                try {
                                    const cs = window.getComputedStyle(c);
                                    if (!cs) continue;
                                    const overflowY = cs.overflowY || cs.overflow || '';
                                    if (overflowY === 'auto' || overflowY === 'scroll' || c.scrollHeight > c.clientHeight + 4) return c;
                                } catch(_) {}
                            }
                            return null;
                        })(cont);
                        if (scrollable) {
                            const step = 64 * dy; // keyboard step
                            scrollable.scrollTop += step;
                            handled = true;
                        }
                    } catch(_) {}
                    if (handled) { ev.preventDefault(); ev.stopPropagation(); return; }
                    // determine columns count same as gp logic
                    let cols = 1;
                    const items = gatherFocusables(cont);
                    try {
                        if (items && items.length > 0) {
                            const firstTop = (items[0].getBoundingClientRect && items[0].getBoundingClientRect().top) || 0;
                            cols = 0;
                            for (let ii = 0; ii < items.length; ii++) {
                                const it = items[ii];
                                const t = (it.getBoundingClientRect && it.getBoundingClientRect().top) || 0;
                                if (Math.abs(t - firstTop) < 2) cols++; else break;
                            }
                            if (cols < 1) cols = 1;
                        }
                    } catch(_) { cols = 1; }
                    const step = cols * dy;
                    moveGpFocus(step);
                    handled = true;
                }
                // horizontal navigation: Left/Right or A/D
                if (!handled && (ev.key === 'ArrowLeft' || ev.key === 'Left' || ev.key === 'a' || ev.key === 'A' || ev.key === 'd' || ev.key === 'D' || ev.key === 'ArrowRight' || ev.key === 'Right')) {
                    let dx = 0;
                    if (ev.key === 'ArrowLeft' || ev.key === 'Left' || ev.key === 'a' || ev.key === 'A') dx = -1;
                    if (ev.key === 'ArrowRight' || ev.key === 'Right' || ev.key === 'd' || ev.key === 'D') dx = 1;
                    moveGpFocus(dx);
                    handled = true;
                }
                if (handled) {
                    ev.preventDefault(); ev.stopPropagation();
                }
            } catch(_) {}
        }, true);

        // Position the ability tooltip centered over the canvas and fully within the viewport
        function positionAbilityTooltip() {
            const tip = document.getElementById('abilityTooltip');
            const canvasEl = document.getElementById('gameCanvas');
            if (!tip || !canvasEl) return;
            const rect = canvasEl.getBoundingClientRect();
            // Force fixed positioning so we can clamp to viewport
            tip.style.position = 'fixed';
            tip.style.left = (rect.left + rect.width / 2) + 'px';
            tip.style.transform = 'translateX(-50%)';
            tip.style.right = 'auto';
            tip.style.bottom = 'auto';
            // Measure height after content is applied
            const tipH = tip.offsetHeight || 0;
            const margin = 56; // desired gap from canvas bottom
            let top = rect.bottom - margin - tipH;
            // Clamp within viewport
            const minTop = 8;
            const maxTop = Math.max(minTop, (window.innerHeight || document.documentElement.clientHeight) - tipH - 8);
            if (top > maxTop) top = maxTop;
            if (top < minTop) top = minTop;
            // Also avoid overlapping too far above the canvas
            const canvasTopClamp = rect.top + 8;
            if (top < canvasTopClamp) top = canvasTopClamp;
            tip.style.top = Math.round(top) + 'px';
        }

        function showAbilityTooltip(abilityName) {
            const tooltip = document.getElementById('abilityTooltip');
            const nameEl = document.getElementById('tooltipName');
            const descEl = document.getElementById('tooltipDesc');
            const abilityData = ABILITIES[abilityName];
            
            if (!abilityData) return;
            
            nameEl.textContent = abilityName;
            nameEl.style.fontWeight = '700';
            descEl.textContent = abilityData.desc;
            descEl.style.color = '#ffffff';
            
            // Apply tier coloring
            const tier = abilityData.tier || 1;
            switch (tier) {
                case 1:
                    nameEl.style.color = '#ffffff';
                    break;
                case 2:
                    nameEl.style.color = '#4488ff';
                    break;
                case 3:
                    nameEl.style.color = '#ff44ff';
                    break;
            }
            
            // If a prior hide timer exists, clear it so rapid acquisitions refresh visibility.
            if (tooltip._hideTimer) {
                clearTimeout(tooltip._hideTimer);
                tooltip._hideTimer = null;
            }

            // Render a "NEW" badge if this ability was marked new in-session (clears immediately so it only shows once)
            try {
                if (game && game.player && game.player._newAbilities && game.player._newAbilities[abilityName]) {
                    // clear any previous badge instance
                    const prev = nameEl.querySelector && nameEl.querySelector('.badge-new');
                    if (prev) prev.remove();
                    // Append badge
                    const badge = document.createElement('span');
                    badge.className = 'badge-new';
                    badge.textContent = 'NEW';
                    // Ensure nameEl keeps the plain text but allow appended badge
                    // (textContent already set above)
                    nameEl.appendChild(document.createTextNode(' '));
                    nameEl.appendChild(badge);
                    // Mark as seen permanently and remove the transient session marker
                    try { game.player._seenAbilities = game.player._seenAbilities || {}; game.player._seenAbilities[abilityName] = true; } catch(_) {}
                    try { delete game.player._newAbilities[abilityName]; } catch(_) { game.player._newAbilities[abilityName] = false; }
                    try { saveSeenAbilities(); } catch(_) {}
                } else {
                    // Remove any stray badge if present
                    try { const stray = nameEl.querySelector && nameEl.querySelector('.badge-new'); if (stray) stray.remove(); } catch(_) {}
                        }
                    } catch(_) {}
                    // Defensive inline background/border to guard against cascade overrides
                    try {
                        if (tooltip && tooltip.style) {
                            tooltip.style.background = 'rgba(6,6,6,0.94)';
                            tooltip.style.border = '1px solid rgba(255,255,255,0.06)';
                            tooltip.style.padding = tooltip.style.padding || '10px 12px';
                            tooltip.style.borderRadius = tooltip.style.borderRadius || '8px';
                        }
                    } catch(_) {}
                    // Ensure visible at the DOM level (inline display) then set show class for CSS hooks
                    try { tooltip.style.display = 'block'; } catch(_) {}
                    tooltip.classList.add('show');
            // Defer positioning to ensure correct measured height
            try {
                requestAnimationFrame(() => {
                    positionAbilityTooltip();
                });
            } catch(_) { positionAbilityTooltip(); }
            // Auto-hide after 3.5s unless retriggered; extend slightly from previous 3s for readability.
            tooltip._hideTimer = setTimeout(() => {
                try { tooltip.classList.remove('show'); } catch(_) {}
                try { tooltip.style.display = 'none'; } catch(_) {}
                tooltip._hideTimer = null;
            }, 3500);
        }

        // Maintain correct placement on viewport changes
        window.addEventListener('resize', () => { try { positionAbilityTooltip(); } catch(_) {} });

        // ================= Rizz Ability (Animated Pull) =================
        // Replaces previous teleport version: enemies are smoothly pulled into a ring.
        const RIZZ_INTERVAL_MS = 5000;       // Trigger cadence
        const RIZZ_PULL_DURATION = 900;      // ms for interpolation
        const RIZZ_RING_RADIUS = 90;         // Distance from player center
        const RIZZ_FEAR_FRAMES = 180;        // 3s fear after arrival

        function triggerRizzPull() {
            if (!game.player || !game.player.abilities || !game.player.abilities.includes('Rizz')) return;
            // Rizz should not pull boss-class enemies. Instead of skipping the whole effect when a boss
            // is present, filter them out so only regular enemies are pulled. This prevents bosses such as
            // 'Big Quack', 'Golden Goose' or 'Wunderswan' from being affected while allowing others to be pulled.
            function _rizzIsBossLike(en) {
                if (!en) return false;
                try {
                    const t = String(en.type || '');
                    if (en.isBoss || en.bossSecret) return true;
                    if (t === 'Wunderswan' || t === 'Big Quack' || t === 'Golden Goose') return true;
                } catch(_) {}
                return false;
            }
            const now = performance.now();
            if (!game._lastRizz) game._lastRizz = now;
            // Pre-telegraph window before pull triggers: emit faint rings near player
            const until = RIZZ_INTERVAL_MS - (now - game._lastRizz);
            if (until > 0 && until < 700) {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!reduceRings) {
                    if (!game._lastRizzTele || now - game._lastRizzTele > (lowFx? 260 : 160)) {
                        game._lastRizzTele = now;
                        const t = 1 - (until / 700);
                        const rad = 40 + t * 60;
                        const col = '#C89AFF';
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x: game.player.x, y: game.player.y, color: col, radius: rad, life: 180 });
                        } else {
                            addParticle(game.player.x, game.player.y, col, 'ring');
                        }
                    }
                }
            }
            if (now - game._lastRizz < RIZZ_INTERVAL_MS) return; // not time yet
            if (!Array.isArray(game.enemies) || game.enemies.length === 0) return;
            game._lastRizz = now;
            const px = game.player.x, py = game.player.y;
            // Build the list of pull targets excluding boss-like enemies
            const targets = (Array.isArray(game.enemies) ? game.enemies.slice() : []).filter(en => en && en.health > 0 && !_rizzIsBossLike(en));
            if (!targets || targets.length === 0) return;
            const angleStep = (Math.PI * 2) / Math.max(1, targets.length);
            let idx = 0;
            // Center pulse (perf-aware)
            const lowFx = !!(game.perf && game.perf.lowFx);
            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
            if (!hideSparks) {
                const burst = lowFx ? 12 : 28;
                for (let p=0;p<burst;p++) addParticle(px + (Math.random()-0.5)*30, py + (Math.random()-0.5)*30, '#B066FF', 'spark');
            }
            addScreenShake(3);
            targets.forEach(enemy => {
                // assign pull only to non-boss targets
                const ang = angleStep * idx + Math.random()*0.18;
                const tx = px + Math.cos(ang) * RIZZ_RING_RADIUS;
                const ty = py + Math.sin(ang) * RIZZ_RING_RADIUS;
                enemy._rizzPull = {
                    active: true,
                    startX: enemy.x,
                    startY: enemy.y,
                    targetX: tx,
                    targetY: ty,
                    startTime: now,
                    duration: RIZZ_PULL_DURATION,
                    appliedFear: false
                };
                if (!hideSparks) {
                    const prob = lowFx ? 0.45 : 0.9;
                    if (Math.random() < prob) addParticle(enemy.x, enemy.y - (enemy.size||20)/2, '#D080FF', 'spark');
                }
                idx++;
            });
        }

        function advanceRizzPull() {
            if (!game.enemies || game.enemies.length === 0) return;
            const now = performance.now();
            game.enemies.forEach(enemy => {
                const st = enemy && enemy._rizzPull;
                if (!st || !st.active) return;
                if (enemy.health <= 0) {
                    st.active = false;
                    try { if (enemy && /golden/i.test(String(enemy.type||''))) { try { safeUnlockActII('rizzPull'); } catch(_){} } } catch(_) {}
                    return;
                }
                const tRaw = (now - st.startTime) / st.duration;
                const t = Math.min(1, Math.max(0, tRaw));
                const ease = 1 - Math.pow(1 - t, 3); // cubic out
                enemy.x = st.startX + (st.targetX - st.startX) * ease;
                enemy.y = st.startY + (st.targetY - st.startY) * ease;
                {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                    if (!hideSparks) {
                        let prob = (0.25 * (1 - t) + 0.05);
                        if (lowFx) prob *= 0.5;
                        if (Math.random() < prob) addParticle(enemy.x, enemy.y - (enemy.size||20)/2, '#C070FF', 'spark');
                    }
                }
                if (t >= 1) {
                    st.active = false;
                    if (!st.appliedFear) {
                        enemy.fearTime = Math.max(enemy.fearTime || 0, RIZZ_FEAR_FRAMES);
                        enemy.feared = true;
                        st.appliedFear = true;
                        {
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!hideSparks) {
                                const prob = lowFx ? 0.45 : 0.85;
                                if (Math.random() < prob) addParticle(enemy.x, enemy.y, '#EEAAFF', 'spark');
                            }
                        }
                    }
                }
            });
            // Gentle separation to prevent enemies from stacking during pull
            // Small, cheap pass across actively pulled enemies
            const pulled = [];
            for (let i=0;i<game.enemies.length;i++) {
                const e = game.enemies[i];
                if (!e || !e._rizzPull || !e._rizzPull.active) continue;
                pulled.push(e);
            }
            const minBase = 20; // minimal spacing baseline
            for (let i=0;i<pulled.length;i++) {
                const a = pulled[i];
                let checks = 0;
                for (let j=i+1;j<pulled.length;j++) {
                    const b = pulled[j];
                    const dx = a.x - b.x; const dy = a.y - b.y;
                    const dist2 = dx*dx + dy*dy;
                    const minDist = Math.max(minBase, ((a.size||20) + (b.size||20)) * 0.45);
                    if (dist2 < minDist*minDist) {
                        const d = Math.sqrt(dist2) || 0.0001;
                        const push = (minDist - d) * 0.35; // gentle, avoids visible jitter
                        const nx = dx / d, ny = dy / d;
                        // distribute push equally
                        a.x += nx * (push*0.5);
                        a.y += ny * (push*0.5);
                        b.x -= nx * (push*0.5);
                        b.y -= ny * (push*0.5);
                        checks++;
                        if (checks > 10) break; // cap work per enemy
                    }
                }
            }
        }

        function updateRizz() {
            triggerRizzPull();
            advanceRizzPull();
        }

        // Safety: Rizz should never directly cause explosive kills. Add a lightweight guard.
        if (!game._rizzExplosionGuardInstalled) {
            game._rizzExplosionGuardInstalled = true;
            const originalExplode = explodeProjectile;
            window.explodeProjectile = function(proj, dmg){
                // If the only relevant source flag is a Rizz pull marker (no explosive / chain / nova / smartExplosive / meteor / timeBomb)
                // then skip explosion side effects.
                if (proj && proj._rizzPullSource && !proj.explosive && !proj.chainExplosion && !proj.novaBlast && !proj.smartExplosive && !proj.meteor && !proj.timeBomb) {
                    if (!game._rizzWarned) { console.warn('[Rizz] Prevented unintended explosion during Rizz pull.'); game._rizzWarned = true; }
                    return; // swallow
                }
                return originalExplode(proj, dmg);
            };
        }

        function update() {
            // Global frame counter (needed for timed mechanics like meteor detonation)
            if (typeof game.frame !== 'number') game.frame = 0;
            game.frame++;
            // Performance sampling (FPS + auto low FX)
            if (!game._lastFrameStamp) game._lastFrameStamp = performance.now();
            const nowPerf = performance.now();
            const dtFrame = nowPerf - game._lastFrameStamp; game._lastFrameStamp = nowPerf;
            if (game.perf) {
                const perf = game.perf;
                perf.frameTimes.push(dtFrame);
                if (perf.frameTimes.length > 90) perf.frameTimes.shift();
                if (nowPerf - perf.lastFpsSample >= 500) {
                    const avg = perf.frameTimes.reduce((a,b)=>a+b,0)/perf.frameTimes.length;
                    perf.fps = 1000/avg;
                    perf.lastFpsSample = nowPerf;
                    if (perf.fps > 0 && perf.fps <= 1.05) {
                        try {
                            ensureState();
                            if (!game.achv.unlocked || !game.achv.unlocked.oneFrame) {
                                if (typeof unlock === 'function') unlock('oneFrame');
                            }
                        } catch(_) {}
                    }
                    if (perf.autoLowFx) {
                        const before = !!perf.lowFx;
                        if (!perf.lowFx && perf.fps < 52) perf.lowFx = true;
                        else if (perf.lowFx && perf.fps > 58) perf.lowFx = false;
                        if (before !== !!perf.lowFx) updatePotatoBadge();
                    }
                    game.fxSuppression.particleSkip = perf.lowFx ? 0.55 : 0;
                }
            }
            updatePlayer();
            updateEnemies();
            // Rebuild enemy spatial hash (throttle if low enemy count)
            if (game.rebuildEnemyHash) {
                const enemyCnt = game.enemies ? game.enemies.length : 0;
                // Skip every other frame if very low enemy count to save a bit of CPU
                if (!(enemyCnt < 12 && (game.frame & 1))) {
                    game.rebuildEnemyHash();
                }
            }
            // Spawn/adjust orbitals BEFORE projectile update so they get a fresh position tick this frame
            if (typeof ensureOrbitals === 'function') ensureOrbitals();
            // NEW: SoA projectile update (dt approximation: assume 1 frame ~ 1 for legacy logic; adapt if real dt available)
            if (game.updateProjectilesSoA) game.updateProjectilesSoA(1);
            updateReleaseQuackenTentacles();
            // Legacy call kept temporarily if other subsystems still depend on side effects
            // updateProjectiles(); // commented out after SoA migration
            if (game.projectilePool) game._lastProjActive = game.projectilePool.active();
            if (typeof updateShockwaves === 'function') updateShockwaves();
            if (typeof updateVortexFields === 'function') updateVortexFields();
            if (typeof updateEchoBloomFields === 'function') updateEchoBloomFields();
            if (typeof updateBloomRings === 'function') updateBloomRings();
            if (typeof updateFrostAura === 'function') updateFrostAura();
            // Failsafe: re-anchor any orbitals to current player position in case other logic modified them after projectile update
            if (game.projectilesSoA && game._projMeta && game.player) {
                const so = game.projectilesSoA; const xArr=so.x, yArr=so.y, alive=so.alive, MAX=so.MAX;
                for (let i=0;i<MAX;i++) if (alive[i]) {
                    const meta = game._projMeta.get(i); if (!meta || !meta._orbital) continue;
                    if (meta._orbitRadius != null && meta._orbitAngle != null) {
                        const dx = xArr[i] - game.player.x;
                        const dy = yArr[i] - game.player.y;
                        const dist = Math.hypot(dx, dy);
                        if (Math.abs(dist - meta._orbitRadius) > 8) {
                            xArr[i] = game.player.x + Math.cos(meta._orbitAngle) * meta._orbitRadius;
                            yArr[i] = game.player.y + Math.sin(meta._orbitAngle) * meta._orbitRadius;
                        }
                    }
                }
            }
            // Dimensional rifts update
            if (typeof updateDimensionalRifts === 'function') updateDimensionalRifts();
            // Elemental infusion timers & periodic conduit proc
            if (typeof updateInfusions === 'function') updateInfusions();
            if (typeof updateTimeWarpFields === 'function') updateTimeWarpFields();
            if (typeof updateBlackHoles === 'function') updateBlackHoles();
            if (typeof updateRizz === 'function') updateRizz();
            // Touch fire now routed through standard spacebar key handling; no separate per-frame polling needed.
            // Terrifying Aura room-based expiration (in addition to level)
            if (game.player && game.player.auraActive) {
                if (game.player.auraExpireRoom && game.room >= game.player.auraExpireRoom) {
                    game.player.auraActive = false;
                }
            }
            if (game.player && game.player.abilities && game.player.abilities.includes('Elemental Conduit')) {
                const nowC = Date.now();
                if (!game._lastConduitRoll) game._lastConduitRoll = nowC;
                const conduitInterval = 4500; // ms between new infusions
                if (nowC - game._lastConduitRoll >= conduitInterval) {
                    rollRandomInfusion();
                    game._lastConduitRoll = nowC;
                    // Small visual pulse at player
                    for (let p=0;p<14;p++) addParticle(game.player.x + (Math.random()-0.5)*40, game.player.y + (Math.random()-0.5)*40, getInfusionColorBlend() || '#FFFFFF', 'spark');
                }
            }
            updateParticles();
            updateDamageNumbers();
            if (typeof updateEkgTrailSegments === 'function') updateEkgTrailSegments();
            if (typeof updateTraps === 'function') updateTraps();
            if (typeof updatePits === 'function') updatePits();
            if (typeof updateNukes === 'function') updateNukes();
            if (typeof updatePoisonClouds === 'function') updatePoisonClouds();
            if (typeof updateFragmentSparks === 'function') updateFragmentSparks();
            if (typeof updateAcidPools === 'function') updateAcidPools();
            if (typeof updateGoldDustPools === 'function') updateGoldDustPools();
            if (typeof updateTrucks === 'function') updateTrucks();
            if (typeof updateTruckFires === 'function') updateTruckFires();
            checkCollisions();
            checkRoomComplete();

            // Animate toenail crescents (rotate phase)
            if (game.projectilesSoA && game._projMeta) {
                const so = game.projectilesSoA; const alive=so.alive, MAX=so.MAX;
                for (let i=0;i<MAX;i++) if (alive[i]) {
                    const meta = game._projMeta.get(i); if (!meta) continue;
                    if (meta.toenail) meta._crescentPhase = (meta._crescentPhase||0) + 0.22 * (meta._crescentDir||1);
                    if (meta.popcornPuff) meta._puffSpin = (meta._puffSpin||0) + 0.18 * (meta._puffDir||1);
                    if (meta.isPopcornKernel) meta._kernelWobble = (meta._kernelWobble||0) + 0.4;
                }
            }

            // Pickup collection (bread health)
            if (game.pickups && game.pickups.length) {
                for (let i = game.pickups.length - 1; i >= 0; i--) {
                    const p = game.pickups[i];
                    if (p.collected) { game.pickups.splice(i,1); continue; }
                    let dx = p.x - game.player.x;
                    let dy = p.y - game.player.y;
                    // Bread magnetization (Carb it up!) – gently pull bread toward player
                    if (p.type === 'bread' && game.player.abilities.includes('Carb it up!')) {
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        // If outside auto-pick radius, move it closer
                        if (dist > 8) {
                            const speed = Math.min(6, 1.5 + dist * 0.05); // faster if farther, capped
                            const nx = p.x - (dx / dist) * speed;
                            const ny = p.y - (dy / dist) * speed;
                            p.x = nx;
                            p.y = ny;
                            // Recompute delta after movement for pickup radius test
                            dx = p.x - game.player.x;
                            dy = p.y - game.player.y;
                        }
                    }
                    if (dx*dx + dy*dy < 34*34) { // collection radius ~34px
                        // Handle bread (healing) as before
                        if (p.type === 'bread') {
                            // Only heal if not already full
                            if (game.player.health < game.player.maxHealth) {
                                const before = game.player.health;
                                game.player.health = Math.min(game.player.maxHealth, game.player.health + 25);
                                const healed = game.player.health - before;
                                if (healed > 0) {
                                    addDamageNumber(healed, game.player.x, game.player.y - 28, { heal:true });
                                    addParticle(game.player.x, game.player.y - 18, '#66FF88', 'heal');
                                    updateUI();
                                }
                            }
                            // SFX: crunch when picking up bread
                            try { if (typeof playBreadCrunchSfx === 'function') playBreadCrunchSfx(); } catch(_) {}
                            // Achievements: bread collected
                            try { if (window.achv_onBreadCollected) achv_onBreadCollected(); } catch(_) {}
                            p.collected = true;
                            game.pickups.splice(i,1);
                        }
                        // Irradiated trash can: grant a single (random) irradiated ability on pickup
                        else if (p.type === 'irradiatedCan') {
                            try {
                                // Build dynamic Tier-3 abilities pool (excluding ones player already has when possible)
                                const tier3Pool = Object.keys(ABILITIES).filter(a => (ABILITIES[a] && (ABILITIES[a].tier || 1) === 3));
                                let choice = null;
                                // Prefer an ability explicitly attached to this pickup (from boss drop)
                                if (p.abilityChoice && typeof p.abilityChoice === 'string') choice = p.abilityChoice;
                                // Otherwise pick a random Tier-3 ability not already owned (fall back to any tier3)
                                if (!choice) {
                                    let avail = tier3Pool.filter(a => !(game.player.abilities || []).includes(a));
                                    if (!avail || avail.length === 0) avail = tier3Pool;
                                    choice = avail[Math.floor(Math.random() * avail.length)];
                                }
                                game.player.abilities = game.player.abilities || [];
                                if (!game.player.abilities.includes(choice)) {
                                    game.player.abilities.push(choice);
                                    try { if (typeof window._onAbilityAdded === 'function') window._onAbilityAdded(choice); } catch(_){}
                                    // mark ability as new for this session so tooltip shows the NEW badge
                                    try { game.player._newAbilities = game.player._newAbilities || {}; game.player._seenAbilities = game.player._seenAbilities || {}; if (!game.player._seenAbilities[choice]) game.player._newAbilities[choice] = true; } catch(_) {}
                                    /* don't persist here; we'll mark as seen when the tooltip displays */
                                    // Visual / audio feedback
                                    try { addDamageNumber('+' + choice, game.player.x, game.player.y - 28, { color:'#FFD466' }); } catch(_) {}
                                    try { addParticle(game.player.x, game.player.y - 14, '#FFD466', 'spark'); } catch(_) {}
                                    try { if (typeof updateUI === 'function') updateUI(); } catch(_) {}
                                    try { if (typeof playPickupSfx === 'function') playPickupSfx(); } catch(_) {}
                                    // Show tooltip for the granted ability (if available)
                                    try { if (typeof showAbilityTooltip === 'function') showAbilityTooltip(choice); } catch(_) {}
                                    console.info('[Pickup] irradiatedCan granted ability', choice, 'attachedChoice:', p.abilityChoice || null);
                                } else {
                                    // Already have it: give small reward instead
                                    try {
                                        game.player.maxHealth = (game.player.maxHealth || 100) + 5;
                                        addDamageNumber('+5 HP', game.player.x, game.player.y - 28, { color:'#66FF88' });
                                        updateUI();
                                    } catch(_){ }
                                }
                            } catch (e) {
                                console.warn('[Pickup] irradiatedCan grant failed', e && e.message);
                            }
                            p.collected = true;
                            game.pickups.splice(i,1);
                        }
                        // Other pickup types fall back to generic collection (remove silently)
                        else {
                            p.collected = true;
                            game.pickups.splice(i,1);
                        }
                    }
                }
                                
            }
            
            if (game.screenShake > 0) {
                game.screenShake--;
            }
            // Enforce hard boundary for all enemies after every frame of motion/effects
            clampEnemiesToBounds();
            // Lightweight rescue: if any enemy somehow drifts far outside bounds ( > logical + 200 ), teleport near center.
            if (game.enemies && game.enemies.length) {
                for (const en of game.enemies) {
                    if (!en) continue;
                    if (en.x < -200 || en.y < -200 || en.x > LOGICAL_W + 200 || en.y > LOGICAL_H + 200) {
                        en.x = LOGICAL_W/2 + (Math.random()*240 - 120);
                        en.y = LOGICAL_H/2 + (Math.random()*240 - 120);
                    }
                }
            }
            // Terrifying Aura: removed level-based expiry; room-based handled elsewhere.
            // Beartrap periodic deployment
            if (game.player && game.player.abilities && game.player.abilities.includes('Beartrap')) {
                const now = Date.now();
                if (!game._lastTrapDrop) game._lastTrapDrop = now;
                const interval = 5000; // 5 seconds
                if (now - game._lastTrapDrop >= interval) {
                    dropBeartrap();
                    game._lastTrapDrop = now;
                }
            }
            // Punji Pit periodic deployment
            if (game.player && game.player.abilities && game.player.abilities.includes('Punji Pit')) {
                const now2 = Date.now();
                if (!game._lastPitDrop) game._lastPitDrop = now2;
                const interval2 = 5000;
                if (now2 - game._lastPitDrop >= interval2) {
                    dropPunjiPit();
                    game._lastPitDrop = now2;
                }
            }
            // Oppemheimer periodic nuke strike spawner
            if (game.player && game.player.abilities && game.player.abilities.includes('Oppemheimer')) {
                const nowN = Date.now();
                if (!game._lastNuke) game._lastNuke = nowN;
                const nukeInterval = 10000; // 10 seconds
                if (nowN - game._lastNuke >= nukeInterval) {
                    if (!Array.isArray(game.nukes)) game.nukes = [];
                    // Cap active pending nukes to prevent stacking abuse
                    const pending = game.nukes.filter(n => !n.exploded);
                    if (pending.length < 3) {
                        const margin = 80;
                        const nx = margin + Math.random() * (LOGICAL_W - margin*2);
                        const ny = margin + Math.random() * (LOGICAL_H - margin*2);
                        const radius = Math.min(LOGICAL_W, LOGICAL_H) / 4; // quarter logical playfield radius
                        game.nukes.push({
                            x: nx,
                            y: ny,
                            radius,
                            spawnAt: nowN,
                            impactAt: nowN + 1500, // warning duration 1.5s
                            exploded: false,
                            flashTime: 0
                        });
                        game._lastNuke = nowN;
                    } else {
                        // Delay slightly if too many pending so it retries soon
                        game._lastNuke = nowN - (nukeInterval - 1500);
                    }
                }
            }

            // Tanks Alot: periodic runaway truck spawner
            if (game.player && game.player.abilities && game.player.abilities.includes('Tanks Alot')) {
                const nowT = Date.now();
                if (!game._lastTruckSpawn) game._lastTruckSpawn = nowT;
                const interval = 3000; // every 3 seconds as requested
                if (nowT - game._lastTruckSpawn >= interval) {
                    spawnTruck();
                    game._lastTruckSpawn = nowT;
                }
            }

            // Silent But Deadly poison trail spawning
            if (game.player && game.player.abilities && game.player.abilities.includes('Silent But Deadly')) {
                const nowP = Date.now();
                if (!game._lastPoisonCloud) game._lastPoisonCloud = nowP;
                const interval = 120; // ms between trail puffs
                if (nowP - game._lastPoisonCloud >= interval) {
                    if (!Array.isArray(game.poisonClouds)) game.poisonClouds = [];
                    game.poisonClouds.push({
                        x: game.player.x + (Math.random()*14-7),
                        y: game.player.y + (Math.random()*14-7),
                        radius: 34 + Math.random()*10,
                        life: 180, // frames (~3s at 60fps)
                        maxLife: 180,
                        tickTimer: 0
                    });
                    // Trim excessive lingering (cap to ~120 clouds = 6s trail worst case)
                    if (game.poisonClouds.length > 120) game.poisonClouds.splice(0, game.poisonClouds.length - 120);
                    game._lastPoisonCloud = nowP;
                }
            }

            // Duck Dynasty: periodic flock swoop (every ~2s) -- redesigned to spawn from top and arc downward in a swoop
            if (game.player && game.player.abilities && game.player.abilities.includes('Duck Dynasty')) {
                if (!Array.isArray(game.duckFlocks)) game.duckFlocks = [];
                const frameNow = game.frame||0;
                const intervalFrames = 120; // 2 seconds at 60fps
                if (frameNow >= (game.nextDuckFlockFrame||0)) {
                    game.nextDuckFlockFrame = frameNow + intervalFrames;
                    // Spawn a flock entering slightly above the top edge, choosing a horizontal band entry span
                    const flockSize = 6 + Math.floor(Math.random()*4); // 6-9 ducks
                    const baseDamage = calculateDamage();
                    const entryY = -40 - Math.random()*60; // start above screen
                    const exitY = canvas.height + 80; // allow overshoot before cleanup
                    const bandLeft = 80 + Math.random()*120;
                    const bandRight = canvas.width - (80 + Math.random()*120);
                    const duration = 120 + Math.floor(Math.random()*40); // frames of flight
                    const midCurveY = canvas.height * (0.30 + Math.random()*0.15); // apex of downward curve
                    const lateralDrift = (Math.random()<0.5?-1:1) * (60 + Math.random()*90);
                    for (let i=0;i<flockSize;i++) {
                        const laneFrac = (i / Math.max(1, flockSize-1));
                        const startX = bandLeft + (bandRight - bandLeft) * laneFrac + (Math.random()-0.5)*30;
                        const sway = (Math.random()*0.4 + 0.6); // amplitude multiplier
                        game.duckFlocks.push({
                            mode:'swoop',
                            t:0, tMax: duration,
                            startX, startY: entryY,
                            midX: startX + lateralDrift*0.4 + (Math.random()-0.5)*40,
                            midY: midCurveY + (Math.random()-0.5)*30,
                            endX: startX + lateralDrift + (Math.random()-0.5)*60,
                            endY: exitY,
                            progress:0, // compatibility
                            speed:1,
                            damage: Math.max(2, Math.floor(baseDamage * 0.60)),
                            size: 18 + Math.random()*6,
                            hitIds: new Set(),
                            color: (Math.random()<0.5?'#FFD74A':'#FFECA0'),
                            wingPhase: Math.random()*Math.PI*2,
                            swayAmp: sway * (20 + Math.random()*14)
                        });
                    }
                    // Telegraph: falling feathers / sparks near top (perf-aware)
                    {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!hideSparks) {
                            const count = lowFx ? 8 : 18;
                            for (let p=0;p<count;p++) addParticle((bandLeft+bandRight)/2 + (Math.random()-0.5)*260, entryY + 20 + Math.random()*40, '#FFF2AA','spark');
                        }
                    }
                }
                // Update active ducks
                for (let i=game.duckFlocks.length-1;i>=0;i--) {
                    const d = game.duckFlocks[i];
                    if (d.mode === 'swoop') {
                        d.t++;
                        const u = d.t / d.tMax; // 0->1
                        if (u >= 1) { game.duckFlocks.splice(i,1); continue; }
                        // Ease curve progress (accelerate in, glide out)
                        const e = u<0.5 ? 2*u*u : -1 + (4 - 2*u)*u; // smooth-ish ease
                        // Quadratic Bezier for arc (start->mid->end)
                        const x1 = d.startX, y1 = d.startY;
                        const x2 = d.midX,   y2 = d.midY;
                        const x3 = d.endX,   y3 = d.endY;
                        d.x = (1-e)*(1-e)*x1 + 2*(1-e)*e*x2 + e*e*x3;
                        d.y = (1-e)*(1-e)*y1 + 2*(1-e)*e*y2 + e*e*y3;
                        // Add lateral sinusoidal sway for individual variation
                        d.wingPhase += 0.28 + Math.random()*0.02;
                        d.x += Math.sin(d.wingPhase*0.5 + d.startX*0.01) * (d.swayAmp*0.15);
                    } else {
                        // legacy arc mode (if any old objects remain)
                        d.progress += d.speed;
                        if (d.progress >= 1) { game.duckFlocks.splice(i,1); continue; }
                    }
                    // Collision with enemies (single hit per enemy per duck)
                    if (game.enemies && game.enemies.length) {
                        for (const en of game.enemies) {
                            if (en._dead) continue;
                            const dx = en.x - d.x; const dy = en.y - d.y;
                            const wingSpan = d.size * 1.6; // larger because wings out
                            const hitR = (wingSpan*0.5 + (en.size||20)*0.5);
                            if (dx*dx + dy*dy <= hitR*hitR && !d.hitIds.has(en._guid || en._hitMarker)) {
                                // assign a temp marker id if none
                                if (!en._guid) en._guid = 'e'+Math.random().toString(36).slice(2,9);
                                d.hitIds.add(en._guid);
                                en.health -= d.damage;
                                addDamageNumber(d.damage, en.x, en.y - en.size/2, { type:'wind'});
                                addParticle(en.x, en.y, '#FFECAA','impact');
                                if (en.health <= 0) en._dead = true;
                            }
                        }
                    }
                    // Occasional feather motes (perf-aware)
                    {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!hideSparks) {
                            const prob = lowFx ? 0.12 : 0.25;
                            if (Math.random()<prob) addParticle(d.x + (Math.random()-0.5)*10, d.y + (Math.random()-0.5)*10, '#FFF5CC','spark');
                        }
                    }
                }
                // Light flock separation to reduce overstacking among visible ducks
                if (game.duckFlocks.length > 1) {
                    const ducks = game.duckFlocks;
                    const minR = 18; // minimum comfortable separation
                    for (let i=0;i<ducks.length;i++) {
                        const a = ducks[i]; if (!a || a._gone) continue;
                        let pushes = 0;
                        for (let j=i+1;j<ducks.length;j++) {
                            const b = ducks[j]; if (!b || b._gone) continue;
                            const dx = a.x - b.x; const dy = a.y - b.y; const d2 = dx*dx + dy*dy;
                            const want = (Math.max(minR, (a.size||16)*0.9) + Math.max(minR, (b.size||16)*0.9)) * 0.5;
                            if (d2 < want*want) {
                                const d = Math.sqrt(d2) || 0.0001;
                                const nx = dx/d, ny = dy/d;
                                const push = (want - d) * 0.35; // gentle
                                a.x += nx * (push*0.5);
                                a.y += ny * (push*0.5);
                                b.x -= nx * (push*0.5);
                                b.y -= ny * (push*0.5);
                                pushes++;
                                if (pushes > 8) break;
                            }
                        }
                    }
                }
                // Cap flocks stored to avoid runaway if lag (should be small anyway)
                if (game.duckFlocks.length > 120) game.duckFlocks.splice(0, game.duckFlocks.length - 120);
            }

            // Process scheduled delayed combustion rings (Spontaneous Combustion synergies)
            if (game._pendingCombustionRings && game._pendingCombustionRings.length) {
                for (let i = game._pendingCombustionRings.length - 1; i >= 0; i--) {
                    const ring = game._pendingCombustionRings[i];
                    if (!ring) { game._pendingCombustionRings.splice(i,1); continue; }
                    if ((game.frame||0) >= ring.spawnFrame) {
                        const baseDmg = calculateDamage();
                        const count = ring.count || 10;
                        const speed = ring.speed || 6;
                        const dmgFrac = ring.dmgFrac != null ? ring.dmgFrac : 0.4;
                        for (let s=0; s<count; s++) {
                            const ang = (s / count) * Math.PI * 2; // even spread
                            game.spawnProjectile({
                                x: ring.x,
                                y: ring.y,
                                vx: Math.cos(ang) * speed,
                                vy: Math.sin(ang) * speed,
                                life: 64,
                                size: 5,
                                enemy: false,
                                baseDamage: Math.max(1, Math.floor(baseDmg * dmgFrac)),
                                damageType: 'fire',
                                burningShard: true,
                                piercing: false
                            });
                        }
                        // Visual feedback: modest particle ring & scaled screen shake
                        for (let p=0; p<Math.min(24, count*1.2); p++) {
                            const pang = Math.random()*Math.PI*2;
                            const pr = Math.random()*26;
                            addParticle(ring.x + Math.cos(pang)*pr, ring.y + Math.sin(pang)*pr, (Math.random()<0.35?'#FFDD66':'#FF7722'), 'explosion');
                        }
                        addScreenShake( (ring.tier || 1) * 2 );
                        game._pendingCombustionRings.splice(i,1);
                    }
                }
                // Prevent unbounded growth if something failed to spawn far in the future (> 10s worth of frames)
                if (game._pendingCombustionRings.length > 100) {
                    const nowF = game.frame||0;
                    game._pendingCombustionRings = game._pendingCombustionRings.filter(r => r && r.spawnFrame > nowF - 600);
                }
            }
        }

    // === Tanks Alot (runaway truck + lingering fire) ===
        // Shared visual size for truck draw/collision so hitbox matches sprite size
        window.TRUCK_TARGET_H = window.TRUCK_TARGET_H || 110; // enlarge further per feedback
    // Fire field hitbox scale vs. base radius to align with rendered sprite footprint
    window.TRUCK_FIRE_HIT_SCALE = window.TRUCK_FIRE_HIT_SCALE || 1.75;

        function getTruckDrawSize(frameIndex) {
            const spr = window._truckSprite || {};
            const driveFrames = spr.frames && spr.frames.drive;
            const img = spr.image;
            const idx = Math.max(0, Math.min(frameIndex|0, driveFrames && driveFrames.length ? driveFrames.length-1 : 0));
            if (img && img.complete && !img._broken && img.naturalWidth && driveFrames && driveFrames.length) {
                const src = driveFrames[idx];
                const scale = (window.TRUCK_TARGET_H || 110) / src.h;
                return { w: src.w * scale, h: src.h * scale };
            }
            // Fallback aspect ratio when frames not ready
            const h = (window.TRUCK_TARGET_H || 110);
            return { w: h * 2.2, h };
        }
        function spawnTruck() {
            if (!Array.isArray(game.trucks)) game.trucks = [];
            const h = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || canvas.height;
            const w = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
            // Spawn from the left edge at a random vertical location (with a small top/bottom margin)
            const marginY = 40;
            const y = marginY + Math.random() * Math.max(1, (h - marginY*2));
            const speed = 7.2 + Math.random()*1.6;
            const dmg = Math.max(16, Math.floor(calculateDamage() * 1.4));
            const size = getTruckDrawSize(0);
            const truck = {
                x: -Math.max(120, size.w), y,
                vx: speed, width: size.w, height: size.h,
                state: 'driving', // 'driving' | 'impactSeq' | 'done'
                life: 0,
                damage: dmg,
                hitboxScale: 1.0,
                frame: 0, // 0-based index into drive frames
                _impactStep: 0, // 0=not started, 1=frame2, 2=frame3
                _impactTimer: 0
            };
            game.trucks.push(truck);
        }

        function getDumpsterAabb(wall) {
            // Use the same visual rect as render for precise collision
            if (typeof window.getDumpsterSpriteRect === 'function') {
                const rect = window.getDumpsterSpriteRect(wall);
                return rect ? { x: rect.x, y: rect.y, w: rect.w, h: rect.h } : { x: wall.x, y: wall.y, w: (wall.width||TILE_SIZE), h: (wall.height||TILE_SIZE) };
            }
            return { x: wall.x, y: wall.y, w: (wall.width||TILE_SIZE), h: (wall.height||TILE_SIZE) };
        }

        function updateTrucks() {
            if (!Array.isArray(game.trucks) || !game.trucks.length) return;
            const w = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
            for (let i = game.trucks.length - 1; i >= 0; i--) {
                const t = game.trucks[i];
                if (!t) { game.trucks.splice(i,1); continue; }
                // Ensure width/height reflect current frame for accurate collisions
                const curSize = getTruckDrawSize(t.frame||0);
                t.width = curSize.w; t.height = curSize.h;
                if (t.state === 'driving') {
                    t.x += t.vx;
                    t.life++;
                    // Enemy contact damage while driving
                    if (Array.isArray(game.enemies) && game.enemies.length) {
                        const ax = t.x - (t.width)/2, ay = t.y - (t.height)/2, aw = t.width, ah = t.height;
                        for (const e of game.enemies) {
                            if (!e || e.health <= 0) continue;
                            const ex = e.x - (e.size||10)/2, ey = e.y - (e.size||10)/2, es = (e.size||10);
                            if (ax < ex + es && ax + aw > ex && ay < ey + es && ay + ah > ey) {
                                const now = performance.now ? performance.now() : Date.now();
                                if (!e._lastTruckHitAt || now - e._lastTruckHitAt > 200) {
                                    e._lastTruckHitAt = now;
                                    const hitDmg = Math.max(6, Math.floor(t.damage * 0.6));
                                    e.health -= hitDmg;
                                    addDamageNumber && addDamageNumber(hitDmg, e.x, e.y - (e.size||10)/2, { type: 'impact' });
                                    // Knockback away from truck center
                                    const dx = Math.max(-1e-3, e.x - t.x), dy = Math.max(-1e-3, e.y - t.y);
                                    const len = Math.max(0.001, Math.hypot(dx, dy));
                                    const kx = dx / len, ky = dy / len;
                                    if (typeof applySmoothKnockback === 'function') applySmoothKnockback(e, kx*2.0, ky*2.0, 12);
                                    else if (typeof applyKnockback === 'function') applyKnockback(e, kx, ky, 8);
                                    else { e.vx = (e.vx||0) + kx*2.2; e.vy = (e.vy||0) + ky*2.2; }
                                }
                            }
                        }
                    }
                    // Check dumpster collisions only
                    if (Array.isArray(game.walls) && game.walls.length) {
                        for (const wall of game.walls) {
                            if (wall.type !== 'dumpster') continue;
                            const a = { x: t.x - (t.width)/2, y: t.y - (t.height)/2, w: t.width, h: t.height };
                            const b = getDumpsterAabb(wall);
                            if (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y) {
                                // Start impact sequence: show frame 2 then 3, then explode
                                t.state = 'impactSeq';
                                t._impactStep = 1; // show frame index 1
                                t._impactTimer = 0;
                                t.vx = 0; // stop moving while impacting
                                wall.flashTimer = 10; // brief dumpster flash
                                break;
                            }
                        }
                    }
                    if (t.x - t.width > w + 80) { t.state = 'done'; }
                } else if (t.state === 'impactSeq') {
                    t._impactTimer++;
                    // Also apply contact damage during impact frames
                    if (Array.isArray(game.enemies) && game.enemies.length) {
                        const ax = t.x - (t.width)/2, ay = t.y - (t.height)/2, aw = t.width, ah = t.height;
                        for (const e of game.enemies) {
                            if (!e || e.health <= 0) continue;
                            const ex = e.x - (e.size||10)/2, ey = e.y - (e.size||10)/2, es = (e.size||10);
                            if (ax < ex + es && ax + aw > ex && ay < ey + es && ay + ah > ey) {
                                const now = performance.now ? performance.now() : Date.now();
                                if (!e._lastTruckHitAt || now - e._lastTruckHitAt > 220) {
                                    e._lastTruckHitAt = now;
                                    const hitDmg = Math.max(6, Math.floor(t.damage * 0.5));
                                    e.health -= hitDmg;
                                    addDamageNumber && addDamageNumber(hitDmg, e.x, e.y - (e.size||10)/2, { type: 'impact' });
                                    const dx = Math.max(-1e-3, e.x - t.x), dy = Math.max(-1e-3, e.y - t.y);
                                    const len = Math.max(0.001, Math.hypot(dx, dy));
                                    const kx = dx / len, ky = dy / len;
                                    if (typeof applySmoothKnockback === 'function') applySmoothKnockback(e, kx*2.2, ky*2.2, 12);
                                    else if (typeof applyKnockback === 'function') applyKnockback(e, kx, ky, 9);
                                    else { e.vx = (e.vx||0) + kx*2.4; e.vy = (e.vy||0) + ky*2.4; }
                                }
                            }
                        }
                    }
                    // Sequence: ~8 frames on frame 2, then ~8 frames on frame 3, then explode
                    if (t._impactStep === 1) {
                        t.frame = 1; // second frame
                        if (t._impactTimer >= 8) { t._impactStep = 2; t._impactTimer = 0; }
                    } else if (t._impactStep === 2) {
                        t.frame = 2; // third frame
                        if (t._impactTimer >= 8) {
                            // Detonate now
                            const cx = t.x; const cy = t.y;
                            // Play retro explosion SFX
                            try { if (typeof playNukeExplosionSfx === 'function') playNukeExplosionSfx(); } catch(_) {}
                            // Larger explosion that pushes enemies farther and affects a wider area
                            const boom = { x: cx, y: cy, size: 42, knockback: true, damageType: 'fire', explosionRadius: 180, knockbackRadius: 260, knockbackScale: 0.42 };
                            explodeProjectile(boom, Math.floor(t.damage * 1.4));
                            addScreenShake(8);
                            spawnTruckFire(cx, cy);
                            t.state = 'done';
                        }
                    }
                }
                if (t.state === 'done') { game.trucks.splice(i,1); }
            }
        }

        function spawnTruckFire(x, y) {
            if (!Array.isArray(game.truckFires)) game.truckFires = [];
            // Lingering fire lasts 5s, ticks AoE damage periodically
            const field = { x, y, radius: 120, created: Date.now(), duration: 5000, tickEvery: 600, lastTick: 0, frame: 0 };
            game.truckFires.push(field);
        }

        function updateTruckFires() {
            if (!Array.isArray(game.truckFires) || !game.truckFires.length) return;
            const now = Date.now();
            for (let i = game.truckFires.length - 1; i >= 0; i--) {
                const f = game.truckFires[i];
                const age = now - f.created;
                if (age >= f.duration) { game.truckFires.splice(i,1); continue; }
                // Tick damage
                if (now - (f.lastTick||0) >= f.tickEvery) {
                    f.lastTick = now;
                    const base = calculateDamage();
                    const tick = Math.max(4, Math.floor(base * 0.35));
                    const effR = f.radius * (window.TRUCK_FIRE_HIT_SCALE || 1.35);
                    const r2 = effR * effR;
                    for (const e of game.enemies) {
                        if (!e || e.health <= 0) continue;
                        const dx = e.x - f.x, dy = e.y - f.y;
                        if (dx*dx + dy*dy <= r2) {
                            e.health -= tick;
                            e.burning = true;
                            e.burnTime = Math.max(e.burnTime||0, 120);
                            addDamageNumber(tick, e.x, e.y - e.size/2, { type: 'fire' });
                            if (!(game.perf && game.perf.lowFx) && Math.random() < 0.35) addParticle(e.x, e.y, '#FFAA66','impact');
                        }
                    }
                }
            }
        }

        function clampEnemiesToBounds() {
            if (!game.enemies) return;
            const w = canvas.width;
            const h = canvas.height;
            game.enemies.forEach(enemy => {
                // Determine basic facing for sprite use (horizontal priority when significant, else vertical)
                if (!enemy.facing) enemy.facing = 'down';
                const vx = enemy.vx || (game.player.x - enemy.x); // fallback to vector toward player if vx undefined
                const vy = enemy.vy || (game.player.y - enemy.y);
                if (Math.abs(vx) > Math.abs(vy)) {
                    enemy.facing = vx < 0 ? 'left' : 'right';
                } else {
                    enemy.facing = vy < 0 ? 'up' : 'down';
                }
                if (!enemy) return;
                const r = enemy.size || 16;
                // Hard OOB kill: if an enemy somehow gets fully beyond a tolerance outside the canvas, kill it.
                // Tolerance allows minor float drift without triggering death.
                const tol = r * 1.2; // 120% of radius outside view before death
                if (enemy.x < -tol || enemy.x > w + tol || enemy.y < -tol || enemy.y > h + tol) {
                    enemy.health = 0; // will be removed during enemy cleanup
                    return;
                }
                const minX = r;
                const maxX = w - r;
                const minY = r;
                const maxY = h - r;
                let clamped = false;
                if (enemy.x < minX) { enemy.x = minX; if (enemy.kbVX < 0) enemy.kbVX = 0; clamped = true; }
                if (enemy.x > maxX) { enemy.x = maxX; if (enemy.kbVX > 0) enemy.kbVX = 0; clamped = true; }
                if (enemy.y < minY) { enemy.y = minY; if (enemy.kbVY < 0) enemy.kbVY = 0; clamped = true; }
                if (enemy.y > maxY) { enemy.y = maxY; if (enemy.kbVY > 0) enemy.kbVY = 0; clamped = true; }
                // If knockback velocity would push them further outside next frame, damp further
                if (clamped && (enemy.kbVX || enemy.kbVY)) {
                    enemy.kbVX *= 0.4; enemy.kbVY *= 0.4;
                }
            });
        }

        function updatePoisonClouds() {
            if (!Array.isArray(game.poisonClouds) || game.poisonClouds.length === 0) return;
            for (let i = game.poisonClouds.length - 1; i >= 0; i--) {
                const c = game.poisonClouds[i];
                c.life--;
                c.tickTimer++;
                // Every 30 frames (0.5s) apply damage + poison to enemies inside
                if (c.tickTimer >= 30) {
                    c.tickTimer = 0;
                    const r2 = c.radius * c.radius;
                    game.enemies.forEach(e => {
                        const dx = e.x - c.x; const dy = e.y - c.y;
                        if (dx*dx + dy*dy <= r2) {
                            // Apply light damage & poison status
                            const dmg = Math.max(3, Math.round(c.life / c.maxLife * 6)); // scales down as cloud fades
                            e.health -= dmg;
                            addDamageNumber(dmg, e.x, e.y - e.size/2 - 4, { type:'toxic' });
                            // Poison effect augment
                            e.poisoned = true;
                            e.poisonTime = Math.max(e.poisonTime || 0, 120); // 2s poison refresh
                            addParticle(e.x + (Math.random()*10-5), e.y + (Math.random()*10-5), '#55FF88', 'damage');
                        }
                    });
                }
                if (c.life <= 0) {
                    game.poisonClouds.splice(i,1);
                }
            }
        }

        // Fragment Wake spark updater
        function updateFragmentSparks() {
            if (!Array.isArray(game.fragmentSparks) || game.fragmentSparks.length === 0) return;
            for (let i = game.fragmentSparks.length - 1; i >= 0; i--) {
                const s = game.fragmentSparks[i];
                s.ttl--;
                s.pulse += 0.32 + Math.random()*0.05;
                // Light jitter for lively flicker
                s.x += (Math.random()-0.5)*0.6;
                s.y += (Math.random()-0.5)*0.6;
                // Damage tick (every 12 frames baseline)
                s.dpsTick = (s.dpsTick||0)+1;
                if (s.dpsTick >= 12) {
                    s.dpsTick = 0;
                    if (game.enemies && game.enemies.length) {
                        for (const enemy of game.enemies) {
                            const dx = enemy.x - s.x; const dy = enemy.y - s.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist <= s.r + enemy.size*0.5) {
                                const key = enemy._id || (enemy._id = Symbol());
                                if (!s.hitMap.has(key)) {
                                    s.hitMap.add(key);
                                    const dmg = s.damage;
                                    enemy.health -= dmg;
                                    addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type:'fire' });
                                    if (Math.random()<0.25) addParticle(enemy.x, enemy.y, '#FFC977','spark');
                                }
                            }
                        }
                    }
                }
                if (s.ttl <= 0) {
                    game.fragmentSparks.splice(i,1);
                }
            }
        }

        // EKG Trail segment updater: damages enemies that overlap fading trail line segments
        function updateEkgTrailSegments() {
            const segs = game.ekgTrailSegments;
            if (!Array.isArray(segs) || segs.length === 0) return;
            const lowFx = !!(game.perf && game.perf.lowFx);
            const ctxLocal = ctx; // render with main ctx
            for (let i = segs.length - 1; i >= 0; i--) {
                const s = segs[i];
                s.ttl--;
                // Periodic damage tick every 10 frames
                s._tick = (s._tick||0) + 1;
                if (s._tick >= 10) {
                    s._tick = 0;
                    if (game.enemies && game.enemies.length) {
                        const x1 = s.x1, y1 = s.y1, x2 = s.x2, y2 = s.y2;
                        const vx = x2 - x1, vy = y2 - y1;
                        const len2 = vx*vx + vy*vy || 0.0001;
                        const maxR = Math.max(6, s.w * 0.8);
                        for (const e of game.enemies) {
                            if (!e || e.health <= 0) continue;
                            // project enemy point onto segment and compute distance to line segment
                            const wx = e.x - x1, wy = e.y - y1;
                            let t = (wx*vx + wy*vy) / len2; if (t < 0) t = 0; else if (t > 1) t = 1;
                            const cx = x1 + t*vx, cy = y1 + t*vy;
                            const dist = Math.hypot(e.x - cx, e.y - cy);
                            const reach = maxR + (e.size||20)*0.45;
                            if (dist <= reach) {
                                const key = e._id || (e._id = Symbol());
                                if (!s.hitMap.has(key)) {
                                    s.hitMap.set(key, 1);
                                    const dmg = Math.max(1, s.dps||2);
                                    e.health -= dmg;
                                    addDamageNumber(dmg, e.x, e.y - (e.size||20)/2, { color:'#99ffcc' });
                                    if (!lowFx && Math.random() < 0.20) addParticle(e.x, e.y, '#99FFCC', 'spark');
                                }
                            }
                        }
                    }
                }
                // Render the fading green line segment
                if (ctxLocal && s.maxTtl) {
                    const f = Math.max(0, Math.min(1, s.ttl / s.maxTtl));
                    if (f > 0) {
                        ctxLocal.save();
                        ctxLocal.globalCompositeOperation = 'lighter';
                        ctxLocal.strokeStyle = `rgba(120,255,180,${(0.08 + 0.28*f).toFixed(3)})`;
                        ctxLocal.lineWidth = Math.max(1, s.w * (0.6 + 0.4*f));
                        ctxLocal.lineCap = 'round';
                        ctxLocal.beginPath();
                        ctxLocal.moveTo(s.x1, s.y1);
                        ctxLocal.lineTo(s.x2, s.y2);
                        ctxLocal.stroke();
                        ctxLocal.restore();
                    }
                }
                if (s.ttl <= 0) { segs.splice(i,1); }
            }
        }

        // Periodic nuke strike update handler (Oppemheimer ability)
        function updateNukes() {
            if (!Array.isArray(game.nukes) || game.nukes.length === 0) return;
            const now = Date.now();
            for (let i = game.nukes.length - 1; i >= 0; i--) {
                const n = game.nukes[i];
                if (!n) { game.nukes.splice(i,1); continue; }
                // Trigger explosion when warning time elapses
                if (!n.exploded && now >= n.impactAt) {
                    n.exploded = true;
                    n.flashTime = 34; // frames of flash
                    n._flashMax = n.flashTime;
                    // SFX: big retro explosion when the nuke detonates
                    try { if (typeof playNukeExplosionSfx === 'function') playNukeExplosionSfx(); } catch(_) {}
                    addScreenShake(40);
                    // Damage enemies in radius with falloff (40% edge -> 100% center)
                    const baseDamage = calculateDamage() * 6 + 80;
                    const r = n.radius;
                    game.enemies.forEach(e => {
                        const dx = e.x - n.x; const dy = e.y - n.y; const dist = Math.hypot(dx,dy);
                        if (dist <= r) {
                            const falloff = 1 - 0.6 * (dist / r); // dist=0 =>1, dist=r => 0.4
                            const dmg = Math.round(baseDamage * falloff);
                            e.health -= dmg;
                            addDamageNumber(dmg, e.x, e.y - e.size/2 - 6, { color:'#ffdd55', big:true });
                            // Splash particles per enemy hit
                            for (let p=0;p<8;p++) {
                                const ang = Math.random()*Math.PI*2;
                                const spd = 2 + Math.random()*4;
                                addParticle(e.x, e.y, '#ffbb33', 'explosion');
                            }
                        }
                    });
                    // Central explosion particle bloom
                    for (let p=0;p<150;p++) {
                        const ang = Math.random()*Math.PI*2;
                        const dist = Math.random()*n.radius;
                        const px = n.x + Math.cos(ang)*dist*0.4; // concentrate a bit
                        const py = n.y + Math.sin(ang)*dist*0.4;
                        addParticle(px, py, (Math.random()<0.15?'#ffffff':(Math.random()<0.5?'#ffcc55':'#ff8822')), 'explosion');
                    }
                }
                // Decay flash
                if (n.exploded) {
                    n.flashTime -= 1;
                    if (n.flashTime <= 0) {
                        // Remove once flash over
                        game.nukes.splice(i,1);
                    }
                }
            }
        }

        function updateDamageNumbers() {
            if (!game.damageNumbers) return;
            for (let i = game.damageNumbers.length - 1; i >= 0; i--) {
                const dn = game.damageNumbers[i];
                dn.x += dn.vx;
                dn.y += dn.vy;
                dn.vy += 0.04; // slight gravity to curve path
                dn.life--;
                dn.scale *= 0.991; // gentle shrink
                if (dn.life <= 0) game.damageNumbers.splice(i,1);
            }
        }

        function updatePlayer() {
            let dx = 0, dy = 0;
            let speed = game.player.speed;
            
            // Apply speed multipliers
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.speedMultiplier) {
                    speed *= abilityData.effect.speedMultiplier;
                }
            });
            
            if (game.keys['w']) { dy -= speed; game.player.lastDirection = { x: 0, y: -1 }; game.player.facing = 'up'; }
            if (game.keys['s']) { dy += speed; game.player.lastDirection = { x: 0, y: 1 }; game.player.facing = 'down'; }
            if (game.keys['a']) { dx -= speed; game.player.lastDirection = { x: -1, y: 0 }; game.player.facing = 'left'; }
            if (game.keys['d']) { dx += speed; game.player.lastDirection = { x: 1, y: 0 }; game.player.facing = 'right'; }

            // Gamepad analog move/aim when present; keyboard has priority if any WASD key is down
            const anyKeyboardMove = !!(game.keys['w'] || game.keys['a'] || game.keys['s'] || game.keys['d']);
            if (game.input && game.input.gamepadEnabled && !anyKeyboardMove) {
                const mv = game.input.gpMove || {x:0,y:0};
                const av = game.input.gpAim || {x:0,y:0};
                const mvLen = Math.hypot(mv.x, mv.y);
                const avLen = Math.hypot(av.x, av.y);
                if (mvLen > 0) {
                    dx = mv.x * speed;
                    dy = mv.y * speed;
                }
                // Aim stick sets lastDirection independent of movement
                if (avLen > 0) {
                    game.player.lastDirection = { x: av.x / avLen, y: av.y / avLen };
                    // Facing from aim
                    const ax = game.player.lastDirection.x, ay = game.player.lastDirection.y;
                    if (Math.abs(ax) > Math.abs(ay)) game.player.facing = ax < 0 ? 'left' : 'right'; else game.player.facing = ay < 0 ? 'up' : 'down';
                } else if (mvLen > 0) {
                    // If no aim input, derive facing from movement
                    const nx = mv.x / mvLen, ny = mv.y / mvLen;
                    game.player.lastDirection = { x: nx, y: ny };
                    if (Math.abs(nx) > Math.abs(ny)) game.player.facing = nx < 0 ? 'left' : 'right'; else game.player.facing = ny < 0 ? 'up' : 'down';
                }
            }
            
            const newX = game.player.x + dx;
            const newY = game.player.y + dy;
            
            if (!isWall(newX, newY)) {
                game.player.x = Math.max(25, Math.min(newX, canvas.width - 25));
                game.player.y = Math.max(25, Math.min(newY, canvas.height - 25));
            }

            // Movement & animation state
            game.player.moving = (dx !== 0 || dy !== 0);
            if (game.player.spriteLoaded) {
                if (game.player.moving) {
                    game.player.animTimer++;
                    if (game.player.animTimer >= game.player.animSpeed) {
                        game.player.animTimer = 0;
                        const frameCount = (game.player.walkFrames && game.player.walkFrames.length) ? game.player.walkFrames.length : ((game.player.spriteMeta && (game.player.spriteMeta.totalFrames || game.player.spriteMeta.cols)) || 1);
                        game.player.animFrame = (game.player.animFrame + 1) % frameCount;
                    }
                } else {
                    // Idle: frame 0 (could later add separate idle row or subtle bob)
                    game.player.animFrame = 0;
                    game.player.animTimer = 0;
                }
            }
            
            // Attack handling
            // Base cooldown in ms. Previous model multiplied divisively (compounded) which blew up with many sources.
            // New model: treat (attackSpeedMultiplier - 1) as additive bonuses.
            // Example: +100% (2.0) and +150% (2.5) => total bonus = (1.0 + 1.5)=2.5 => effective multiplier = 1 + 2.5 = 3.5.
            // Effective cooldown = base / (1 + sumBonuses).
            let baseAttackCooldown = 300;
            let attackSpeedBonusSum = 0; // sum of (multiplier - 1)
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.attackSpeedMultiplier) {
                    attackSpeedBonusSum += (abilityData.effect.attackSpeedMultiplier - 1);
                }
            });
            const effectiveAttackSpeedMult = 1 + attackSpeedBonusSum;
            let attackCooldown = baseAttackCooldown / effectiveAttackSpeedMult;
            
            // If a UI container (overlay) is active, treat FIRE as UI confirm only and disable player shooting
            const uiActive = (typeof getActiveUiContainer === 'function') ? !!getActiveUiContainer() : false;
            const isFiring = !uiActive && !!(game.keys[' '] || (game.input && game.input.gpFire));
            if (isFiring && Date.now() - game.lastAttack > attackCooldown) {
                attack();
                game.lastAttack = Date.now();
            }

            // Continuous beam weapons: while holding space, spawn short beam segments at a high rate
            if (isFiring && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'laser' && ABILITIES[a].effect.continuous)) {
                // spawn extra mini-attacks without resetting lastAttack to allow continuous fire
                // create a rapid beam segment every 50ms
                if (!game._lastBeamSpawn || Date.now() - game._lastBeamSpawn > 50) {
                    if (!game._projMeta) game._projMeta = new Map();
                    let base = calculateDamage();
                    let scribble = false;
                    let homing = false;
                    let wunder = false;
                    try {
                        for (const a of (game.player.abilities||[])) {
                            const ad = ABILITIES[a] && ABILITIES[a].effect;
                            if (!ad) continue;
                            if (ad.scribble) scribble = true;
                            if (ad.homing) homing = true;
                            if (ad.wunderDoodle) { wunder = true; scribble = true; }
                            if (typeof ad.damageBonus === 'number') base += Math.floor(ad.damageBonus);
                        }
                    } catch(_) {}
                    if (wunder) base = 10;
                    const dir = game.player.lastDirection;
                    let angle = Math.atan2(dir.y, dir.x);
                    let lockTarget = null;
                    if (wunder && Array.isArray(game.enemies) && game.enemies.length) {
                        let bestD2 = (720*720);
                        for (const enemy of game.enemies) {
                            if (!enemy || enemy.dead || enemy.health <= 0) continue;
                            const dx = enemy.x - game.player.x;
                            const dy = enemy.y - game.player.y;
                            const d2 = dx*dx + dy*dy;
                            if (d2 < bestD2) {
                                bestD2 = d2;
                                lockTarget = enemy;
                            }
                        }
                        if (lockTarget) angle = Math.atan2(lockTarget.y - game.player.y, lockTarget.x - game.player.x);
                    }
                    const cosA = Math.cos(angle);
                    const sinA = Math.sin(angle);
                    if (wunder && lockTarget) {
                        game.player.lastDirection = { x: cosA, y: sinA };
                        if (Math.abs(cosA) > Math.abs(sinA)) game.player.facing = cosA < 0 ? 'left' : 'right'; else game.player.facing = sinA < 0 ? 'up' : 'down';
                    }
                    const speed = wunder ? 14 : 12;
                    const life = wunder ? 22 : 18;
                    const radius = wunder ? 5 : 4;
                    const projIdx = game.spawnProjectile({
                        x: game.player.x + cosA * 16,
                        y: game.player.y + sinA * 16,
                        vx: cosA * speed,
                        vy: sinA * speed,
                        life,
                        r: radius,
                        damage: wunder ? 10 : calculateDamage(),
                        damageType: wunder ? 'fire' : 'plasma'
                    });
                    if (projIdx >= 0) {
                        const metaObj = { beam:true, beamOwner:'player', baseDamage: (wunder ? 10 : base), energyType:'laser' };
                        if (scribble) { metaObj.scribble = true; metaObj.particleBeam = true; metaObj.damageType = 'fire'; }
                        if (wunder) {
                            metaObj.wunderDoodle = true;
                            metaObj.lockSeekRange = 720;
                            if (lockTarget) metaObj._lockedEnemy = lockTarget;
                            metaObj.baseDamage = 10;
                            if (game.projectilesSoA && game.projectilesSoA.damage) {
                                try { game.projectilesSoA.damage[projIdx] = 10; } catch(_){ }
                            }
                        }
                        if (homing) { metaObj.weakHoming = true; }
                        game._projMeta.set(projIdx, metaObj);
                    }
                    game._lastBeamSpawn = Date.now();
                    const muzzleColor = wunder ? '#FF1029' : (scribble ? '#FF4F5B' : '#99EEFF');
                    addParticle(game.player.x, game.player.y, muzzleColor, 'spark');
                }
            }

            // Particle Beam: continuous segments while holding fire (tiled along aim direction)
            if (isFiring && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'particle')) {
                // Slightly lower cadence than laser since cores are thicker; about every 60ms
                if (!game._lastPBeamSpawn || Date.now() - game._lastPBeamSpawn > 60) {
                    const dir = game.player.lastDirection;
                    const angle = Math.atan2(dir.y, dir.x);
                    const speed = 9;
                    const base = calculateDamage();
                    const idx = game.spawnProjectile({
                        x: game.player.x + Math.cos(angle) * 16,
                        y: game.player.y + Math.sin(angle) * 16,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 26, // slightly shorter life; segments will tile densely
                        r: 7,
                        damage: Math.floor(base * 1.5) + 6,
                        damageType: 'plasma'
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    // mark as particle beam so SoA beam tick logic uses thicker core and plasma tint
                    // Allow Wunder Doodle-style abilities to tint particle beams red and enable scribble homing
                    let pMeta = { beam: true, particleBeam: true, beamOwner: 'player', baseDamage: base, energyType: 'particle', _beamPatternPhase: 0 };
                    let wunder = false;
                    try {
                        for (const a of (game.player.abilities||[])) {
                            const ad = ABILITIES[a] && ABILITIES[a].effect;
                            if (!ad) continue;
                            if (ad.scribble) { pMeta.scribble = true; }
                            if (ad.homing) { pMeta.weakHoming = true; }
                            if (ad.wunderDoodle) { wunder = true; pMeta.scribble = true; pMeta.wunderDoodle = true; }
                            if (typeof ad.damageBonus === 'number') pMeta.baseDamage += Math.floor(ad.damageBonus);
                        }
                    } catch(_) {}
                    if (wunder) pMeta.damageType = 'fire';
                    if (game.player.infusions && game.player.infusions.length) pMeta.infusionElements = game.player.infusions.map(i => ({ type: i.type, potency: i.potency }));
                    game._projMeta.set(idx, pMeta);
                    game._lastPBeamSpawn = Date.now();
                    const pColor = wunder ? '#FF1A33' : (pMeta.scribble ? '#FF4F5B' : '#FFD466');
                    addParticle(game.player.x, game.player.y, pColor, 'spark');
                }
            }

            // Ion Cannon: charge while holding space, release a single heavy blast on release
            if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'ion' && ABILITIES[a].effect.chargeShot)) {
                // increment charge while holding
                if (isFiring) {
                    game._ionChargeTime = (game._ionChargeTime || 0) + 1;
                    if (game._ionChargeTime > 100) game._ionChargeTime = 100; // cap
                    if (Math.random() < 0.08) addParticle(game.player.x + (Math.random()-0.5)*24, game.player.y + (Math.random()-0.5)*24, '#99FFEE', 'spark');
                } else if (game._ionChargeTime && game._ionChargeTime > 0) {
                    // on release, fire charged ion blast (one big projectile)
                    if (!game._lastIonFire || Date.now() - game._lastIonFire > 120) {
                        const angle = Math.atan2(game.player.lastDirection.y, game.player.lastDirection.x);
                        const charge = Math.min(1.0, game._ionChargeTime / 80);
                        const speed = 10 + Math.floor(charge * 18);
                        const dmg = Math.floor(calculateDamage() * (1.4 + charge * 2.2));
                        const ionIdx = game.spawnProjectile({
                            x: game.player.x + Math.cos(angle) * 16,
                            y: game.player.y + Math.sin(angle) * 16,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 160,
                            r: 14 + Math.floor(charge * 12),
                            damage: dmg,
                            damageType: 'plasma'
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        if (ionIdx>=0) game._projMeta.set(ionIdx,{ ionCharge:true, charge, piercing:true, pierceCount:6, baseDamage:dmg, energyType:'ion' });
                        // Flash ring at muzzle to emphasize release
                        const mx = game.player.x + Math.cos(angle)*16;
                        const my = game.player.y + Math.sin(angle)*16;
                        for (let p=0;p<10;p++) addParticle(mx + (Math.random()-0.5)*22, my + (Math.random()-0.5)*22, '#AAEEFF', 'explosion');
                        // brief bright ring using particles
                        for (let r=0;r<12;r++) {
                            const a = (r/12)*Math.PI*2;
                            addParticle(mx + Math.cos(a)*(10+charge*12), my + Math.sin(a)*(10+charge*12), '#CCFFFF', 'spark');
                        }
                        addScreenShake(7 + Math.floor(charge*7));
                        game._lastIonFire = Date.now();
                    }
                    game._ionChargeTime = 0;
                }
            }
            
            // Stage cleared advance: require FIRE input with short guard delay to prevent accidental skip
            if (game.roomCleared) {
                if (!game._roomClearedAt) game._roomClearedAt = performance.now();
                const dt = performance.now() - game._roomClearedAt;
                const fireNow = !!(game.keys[' '] || (game.input && game.input.gpFire));
                game._roomAdvancePrev = game._roomAdvancePrev || false;
                if (dt >= 350) { // ~0.35s guard
                    if (fireNow && !game._roomAdvancePrev) {
                        nextRoom();
                    }
                } else {
                    // During guard window, if held, arm so we require a release first
                    if (fireNow) game._roomAdvanceArm = true;
                }
                // Clear arm when released after guard
                if (!fireNow && game._roomAdvancePrev && dt >= 350) game._roomAdvanceArm = false;
                game._roomAdvancePrev = fireNow;
            }
            
            // Handle invulnerability frames
            if (game.player.invulnerable) {
                game.player.invulnTime--;
                if (game.player.invulnTime <= 0) {
                    game.player.invulnerable = false;
                }
            }
            
            // Regeneration
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.regen) {
                    game.player.health = Math.min(game.player.maxHealth, 
                        game.player.health + abilityData.effect.regen * 0.016);
                    updateUI();
                }
            });
        }

        function attack() {
            game.shotCounter++;
            // Play a minimal attack SFX (rate-limited) once per attack invocation (not per projectile)
            if (typeof playAttackSfx === 'function') playAttackSfx();
            // Multi-shot stacking logic
            let projectileCount = 1;
            let shotgunBlast = false;
            let multiShotCount = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.projectileCount) {
                    multiShotCount += abilityData.effect.projectileCount;
                }
                if (abilityData && abilityData.effect.shotgunBlast) {
                    shotgunBlast = true;
                }
            });
            if (shotgunBlast) {
                projectileCount = multiShotCount + 5;
            } else if (multiShotCount > 0) {
                projectileCount = multiShotCount;
            }
            // Achievement: Projectile Vomit (56+ in one attack)
            try { if (projectileCount >= 56 && window.achv_unlock) achv_unlock('projectileVomit'); } catch(_) {}
            // Defensive: if lastDirection is still the old default or zeroed, realign with facing so first
            // shot direction matches the sprite orientation. This can happen if a legacy save/object
            // persisted without movement input before first attack.
            if (game.player) {
                const ld = game.player.lastDirection || {x:0,y:0};
                const nearZero = Math.abs(ld.x) < 0.0001 && Math.abs(ld.y) < 0.0001;
                const legacyRight = ld.x === 1 && ld.y === 0 && game.player.facing && game.player.facing !== 'right';
                if (nearZero || legacyRight) {
                    switch (game.player.facing) {
                        case 'up': game.player.lastDirection = {x:0,y:-1}; break;
                        case 'down': game.player.lastDirection = {x:0,y:1}; break;
                        case 'left': game.player.lastDirection = {x:-1,y:0}; break;
                        case 'right': game.player.lastDirection = {x:1,y:0}; break;
                        default: if (nearZero) game.player.lastDirection = {x:0,y:1};
                    }
                }
            }
            const dir = game.player.lastDirection;
            const baseAimAngle = Math.atan2(dir.y || 0, dir.x || 1);
            let targetEnemy = null;
            // Auto-aim
            if (game.player.abilities.includes('Auto-Aim')) {
                let closestDist = Infinity;
                game.enemies.forEach(enemy => {
                    const dist = Math.sqrt((enemy.x - game.player.x) ** 2 + (enemy.y - game.player.y) ** 2);
                    if (dist < closestDist) {
                        closestDist = dist;
                        targetEnemy = enemy;
                    }
                });
            }
            // Determine pattern modifiers from abilities
            const hasOmni = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.omniDirectional);
            const hasRadial = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.radialBurst);
            const hasSpiral = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.spiralPattern);
            const hasUzumaki = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.uzumaki);
            const hasCross = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.crossPattern);
            const hasRandomSpread = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.randomSpread);
            const hasQuackenRelease = game.player.abilities.includes('Release the Quacken!');
            const hasReleaseQuacken = game.player.abilities.includes('Release the Quacken!');

            // Pattern count handling: Some pattern abilities define a baseline number of directions.
            // Radial Burst wants 16 evenly spaced shots. Omni Shot wants 8. If the player has additional
            // multi-shot bonuses exceeding the pattern baseline, we keep the higher number so stacking
            // projectile count still scales patterns (i.e., 20-way radial if they somehow stack enough).
            // Ensure Cross Shot provides at least a baseline number BEFORE other pattern scaling so it isn't overwritten.
            const CROSS_MIN_PROJECTILES = 4; // Adjust to raise/lower baseline for Cross Shot
            if (hasCross && projectileCount < CROSS_MIN_PROJECTILES) {
                projectileCount = CROSS_MIN_PROJECTILES;
            }
            const baseMultiBeforePattern = projectileCount; // capture current multi-shot total (after Cross minimum)
            if (hasRadial) {
                // Radial Burst: baseline 16; scale if multi-shot already exceeds
                projectileCount = Math.max(baseMultiBeforePattern, 16);
            } else if (hasOmni) {
                // Omni Shot scaling: previously enforced minimum of 8.
                // New behavior: multiply base multi-shot count into directional set.
                // Example: baseMultiBeforePattern = 5 (e.g., Penta Shot) => 5 * 8 = 40-way omni.
                // If player has only Omni (base=1) => 8 directions (unchanged base case).
                const scaled = baseMultiBeforePattern * 8;
                projectileCount = Math.max(scaled, 8);
            } else if (hasCross) {
                // Cross Shot scaling:
                // Minimum 4 shots (one per orthogonal axis). When multi-shot adds more, we allocate them
                // across the 4 arms (Right, Down, Left, Up) evenly. Each arm beyond its first shot fans
                // slightly using a symmetric angular spread so stacking multi-shot meaningfully increases
                // coverage instead of just repeating the same four directions.
                // Example allocations (baseMultiBeforePattern = n after multi-shot):
                // 1..4 => upgraded to 4 (R,D,L,U)
                // 5 => R,D,L,U + 1 extra (goes to Right arm)
                // 8 => 2 per arm
                // 12 => 3 per arm, etc.
                projectileCount = Math.max(baseMultiBeforePattern, CROSS_MIN_PROJECTILES);
            }
            const patternCount = projectileCount; // final number of shots to emit

            // Defensive: ensure all pattern guard flags are defined before conditional spread tweaks
            const hasQuad = game.player.abilities.includes('Quad Shot');
            let quackenBurstSpawned = false;

            for (let i = 0; i < projectileCount; i++) {
                // Track whether this specific projectile used Auto-Aim targeting logic
                const usedAutoAimShot = !!(targetEnemy && game.player.abilities.includes('Auto-Aim') && !hasOmni && !hasRadial && !hasCross);
                let angle;
                // Base angle towards target or last direction
                if (usedAutoAimShot) {
                    const dx = targetEnemy.x - game.player.x;
                    const dy = targetEnemy.y - game.player.y;
                    angle = Math.atan2(dy, dx);
                } else {
                    angle = Math.atan2(dir.y, dir.x);
                }

                // Pattern-specific angle calculations
                if (hasOmni) {
                    angle = (i / patternCount) * Math.PI * 2;
                } else if (hasRadial) {
                    angle = (i / patternCount) * Math.PI * 2;
                } else if (hasCross) {
                    // Distribute projectiles into 4 arms with per-arm spread.
                    const baseAngles = [0, Math.PI/2, Math.PI, 3*Math.PI/2]; // R, D, L, U
                    const perArm = Math.ceil(patternCount / 4); // logical capacity per arm (not all arms may reach this if remainder)
                    // Determine which arm this index maps to using a round-robin so early extras distribute evenly.
                    // Alternative approach: fill arms sequentially (could bias Right). Round-robin is fairer.
                    const armIndex = i % 4; // 0..3
                    const occurrence = Math.floor(i / 4); // which pass on that arm
                    const armAngle = baseAngles[armIndex];
                    // Count how many projectiles actually end up on this arm to compute spread width.
                    // Derive total shots assigned to armIndex: either occurrence+1 or occurrence based on remainder.
                    // Simpler: compute allShotsForArm by iterating patternCount mod 4 distribution math.
                    let allShotsForArm = Math.floor(patternCount / 4);
                    if (armIndex < (patternCount % 4)) allShotsForArm += 1; // first remainder arms get one extra
                    // Spread parameters: max +/- spreadAngle radians for edge shots; diminishing with more per arm.
                    const spreadAngleMax = 0.35; // ~20 degrees each side
                    if (allShotsForArm <= 1) {
                        angle = armAngle;
                    } else {
                        // Map occurrence (0..allShotsForArm-1) to symmetric offsets centered at 0.
                        // Use normalized position: k in [0, allShotsForArm-1]. offsetIndex = k - (N-1)/2
                        const offsetIndex = occurrence - (allShotsForArm - 1) / 2;
                        const normalized = (allShotsForArm <= 1) ? 0 : offsetIndex / ((allShotsForArm - 1) / 2);
                        const offset = spreadAngleMax * normalized; // linear; could adopt curve if needed
                        angle = armAngle + offset;
                    }
                } else if (hasSpiral) {
                    // For spiral shots, keep the primary firing direction aligned with player,
                    // but add a very small per-shot offset so multi-shot spirals spread lightly.
                    // The in-flight spiral looping behavior is handled in updateProjectiles().
                    angle += (i - (patternCount - 1) / 2) * 0.02;
                } else if (hasUzumaki) {
                    // Uzumaki: do not change the initial firing angle. The SoA updater will
                    // take over and move the projectile along an expanding spiral around the player center.
                } else {
                    if (shotgunBlast || projectileCount > 1) {
                        const spread = shotgunBlast ? 0.6 : 0.4;
                        angle += (i - (projectileCount - 1) / 2) * spread / projectileCount;
                        // Prevent reverse-heading bug: clamp deviation to +/- 90° from base aim
                        const baseAim = Math.atan2(dir.y, dir.x);
                        let delta = angle - baseAim;
                        while (delta > Math.PI) delta -= Math.PI*2;
                        while (delta < -Math.PI) delta += Math.PI*2;
                        const maxDev = Math.PI/2;
                        if (delta > maxDev) angle = baseAim + maxDev;
                        if (delta < -maxDev) angle = baseAim - maxDev;
                    }
                }


                // Random spread abilities add unpredictable deviation
                if (hasRandomSpread) {
                    angle += (Math.random() - 0.5) * 1.2; // wide random spread
                }

                let speed = 6;
                let size = 4;
                let piercing = game.player.abilities.includes('Pierce Shot') || game.player.abilities.includes('Multi-Pierce');
                let pierceCount = game.player.abilities.includes('Multi-Pierce') ? 999 : 3;
                let homing = game.player.abilities.includes('Homing Shot');
                let weakHoming = game.player.abilities.includes('Seeking Shot');
                let bouncing = game.player.abilities.includes('Bouncing Shot');
                let explosive = game.player.abilities.includes('Explosive Shot');
                // Split Shot removed (previously set splitting flag here)
                let growing = game.player.abilities.includes('Growing Shot');
                // Spiral shot: causes the projectile to curve/rotate in-flight
                let spiral = game.player.abilities.includes('Spiral Shot');
                let bounces = 0;
                // explicit per-attack flags (populated below from ability effects)
                let boomerangFlag = false;
                let orbitalFlag = false;
                let drillingFlag = false;
                let phasingFlag = false;
                let teleportingFlag = false;

                // Map a few ability flags that weren't previously wired up
                game.player.abilities.forEach(ability => {
                    const abilityData = ABILITIES[ability];
                    if (!abilityData || !abilityData.effect) return;
                    if (abilityData.effect.projectileSpeed) speed *= abilityData.effect.projectileSpeed;
                    if (abilityData.effect.projectileSize) size *= abilityData.effect.projectileSize;
                    if (abilityData.effect.novaBlast || abilityData.effect.smartExplosive) explosive = true;
                    // Bouncing behavior: support both 'ricochet' (enemy->enemy) and 'bouncing' (wall bounces)
                    if (abilityData.effect.ricochet) {
                        bouncing = true;
                        bounces = Math.max(bounces, abilityData.effect.bounces || 3);
                    }
                    if (abilityData.effect.bouncing) {
                        bouncing = true;
                        bounces = Math.max(bounces, abilityData.effect.bounces || 3);
                    }
                    if (abilityData.effect.ricochet && abilityData.effect.bounces) bounces = Math.max(bounces, abilityData.effect.bounces);
                    if (abilityData.effect.boomerang) boomerangFlag = true;
                    if (abilityData.effect.orbital) orbitalFlag = true;
                    if (abilityData.effect.drilling) drillingFlag = true;
                    if (abilityData.effect.phasing) phasingFlag = true;
                    if (abilityData.effect.teleporting) teleportingFlag = true;
                    if (abilityData.effect.weaponType === 'dagger' && abilityData.effect.projectileCount) { /* handled by projectileCount */ }
                });
                // Defensive: if bouncing was enabled but no explicit bounces value assigned by any ability effect, fall back to 3
                if (bouncing && bounces === 0) bounces = 3;

                // Dynamic projectile travel: base life scaled for enlarged logical canvas.
                // Previously life was a flat 150 frames (~2.5s at 60fps) which limited range after expanding LOGICAL_W.
                // New approach:
                //  - Base life scaled relative to logical diagonal so projectiles can plausibly cross arena (~diagonal / avgSpeed).
                //  - We assume average base speed ~8 (tuned from typical speed variable earlier in attack()).
                //  - Clamp to avoid runaway extremely long-lived shots when future scaling changes occur.
                const logicalDiag = Math.hypot(LOGICAL_W || 1280, LOGICAL_H || 720);
                const avgSpeed = 8; // heuristic average projectile speed in px/frame
                // Travel frames to cross 1.1 * diagonal (gives a bit of off-screen continuation) divided by avg speed.
                let dynamicLife = Math.floor((logicalDiag * 1.1) / avgSpeed);
                // Double the computed life to allow shots (especially post-bounce) to traverse more of the enlarged arena.
                dynamicLife *= 2;
                // Expanded clamp range to reflect doubled lifetime while preventing runaway accumulation.
                dynamicLife = Math.max(340, Math.min(dynamicLife, 760));
                // Spawn core projectile into SoA
                const baseDamage = calculateDamage();
                const primaryIdx = game.spawnProjectile({
                    x: game.player.x + Math.cos(angle) * 16,
                    y: game.player.y + Math.sin(angle) * 16,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: dynamicLife,
                    r: Math.max(2, Math.min(32, Math.floor(size))),
                    damage: baseDamage,
                    damageType: null, // will set below via meta/infusion
                    homing: homing || weakHoming,
                    bouncing: bouncing,
                    teleporting: teleportingFlag,
                    spiralPattern: spiral,
                    sineWave: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.sineWave),
                    wackyZigzag: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.wackyZigzag),
                    ekgWave: game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.ekgWave),
                    homing: homing,
                });
                if (!game._projMeta) game._projMeta = new Map();
                const meta = { baseDamage, piercing, pierceCount, weakHoming, bouncing, bounces: (bouncing?bounces:0), explosive, growing, spiral, hasUzumaki, boomerang:boomerangFlag, orbital:orbitalFlag, drilling:drillingFlag, phasing:phasingFlag, teleporting:teleportingFlag };
                if (usedAutoAimShot) meta.autoAimShot = true;
                // Propagate pattern flags used by SoA updaters so synergies can be detected
                if (game.player.abilities.includes('Pendulum Shot')) meta.pendulumPattern = true;
                if (game.player.abilities.includes('Veering Fan')) { meta.veeringFan = true; meta._veeringTimer = 22; meta._veerMinDist = 80; meta._spawnX = game.player.x; meta._spawnY = game.player.y; }
                if (hasQuackenRelease && !quackenBurstSpawned) {
                    quackenBurstSpawned = true;
                    try {
                        spawnReleaseTheQuackenBurst(game, {
                            angle,
                            originX: game.player.x,
                            originY: game.player.y,
                            baseDamage,
                            patternCount,
                            primaryTarget: targetEnemy,
                            frame: game.frame || 0
                        });
                    } catch(_) {}
                }
                if (hasUzumaki) {
                    meta._uzuCx = game.player.x;
                    meta._uzuCy = game.player.y;
                    meta._uzuAngle = angle;
                    meta._uzuRadius = 16;
                    meta._uzuAngularVel = 0.18 + Math.random()*0.05;
                    meta._uzuRadialVel = 1.35 + Math.random()*0.35;
                    meta._uzuDrag = 0.000;
                }
                // --- Ability effect aggregation (store directly onto metadata so collision/hit logic sees them) ---
                let chosenDamageType = null; let chosenDamageTier = -1; let weaponType = null;
                game.player.abilities.forEach(ability => {
                    const aData = ABILITIES[ability]; if(!aData || !aData.effect) return; const eff = aData.effect;
                    // Damage type precedence by tier so higher-tier elemental/combos override lower
                    if (eff.damageType) {
                        if (aData.tier >= chosenDamageTier) { chosenDamageType = eff.damageType; chosenDamageTier = aData.tier; }
                    }
                    if (eff.piercing) { meta.piercing = true; if (eff.pierceCount) meta.pierceCount = Math.max(meta.pierceCount||0, eff.pierceCount); }
                    if (eff.weakHoming) meta.weakHoming = true;
                    if (eff.explosive || eff.smartExplosive) { meta.explosive = true; if (eff.smartExplosive) meta.smartExplosive = true; }
                    if (eff.novaBlast) meta.novaBlast = true;
                    if (eff.chainExplosion) meta.chainExplosion = true;
                    if (eff.timeBomb) meta.timeBomb = true; // detailed timer set below for first projectile
                    if (eff.ricochet) { meta.ricochet = true; meta.bounces = Math.max(meta.bounces||0, eff.bounces||3); }
                    if (eff.goldTooth) { meta.goldTooth = true; meta.bouncing = true; meta.bounces = Math.max(meta.bounces||0, eff.bounces||3); if (!meta.spriteKey) meta.spriteKey = 'goldtooth'; }
                    if (eff.knockback) { meta.knockback = true; if (eff.knockbackDistance) meta.knockbackDistance = Math.max(meta.knockbackDistance||0, eff.knockbackDistance); }
                    if (eff.freezes) meta.freezes = true;
                    if (eff.armorPiercing) meta.armorPiercing = true;
                    if (eff.ignoresArmor) meta.ignoresArmor = true;
                    if (eff.ignoresEverything) meta.ignoresEverything = true;
                    if (eff.lifeSteal) meta.lifeSteal = Math.max(meta.lifeSteal||0, eff.lifeSteal);
                    if (eff.hitMultipleTimes) meta.hitMultipleTimes = true;
                    if (eff.massiveExplosion) meta.massiveExplosion = true;
                    if (eff.antimatter) meta.antimatter = true;
                    if (eff.sawWave) meta.sawWave = true;
                    if (eff.crushDamage) meta.crushDamage = true;
                    if (eff.weaponType) weaponType = eff.weaponType;
                    if (eff.realityBreak) meta.realityBreak = true;
                    if (eff.quantum) meta.quantum = true;
                    if (eff.blackHole) meta.blackHole = true;
                    if (eff.vortex) meta.vortex = true;
                    if (eff.meteor) meta.meteorAbility = true; // actual meteor spawn uses dedicated block
                    if (eff.teleporting) meta.teleporting = true;
                    if (eff.areaEffect) meta.areaEffect = true;
                });
                if (chosenDamageType) meta.damageType = chosenDamageType;
                // Choose weapon visual type for the BASE projectile
                // Rule: randomize among owned NON-sword melee weapons so sword never suppresses them.
                // If Sword Throw is owned, we spawn an extra sword projectile separately (handled below).
                const ownedWeapons = ['sword','axe','spear','hammer','dagger','bread'].filter(w => game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.weaponType === w));
                const hasSword = ownedWeapons.includes('sword');
                const ownedNonSword = ownedWeapons.filter(w => w !== 'sword');
                let appliedType = null;
                if (ownedNonSword.length > 0) {
                    appliedType = ownedNonSword[Math.floor(Math.random()*ownedNonSword.length)];
                } else if (hasSword) {
                    // Only sword owned: base remains generic; we'll add a sword projectile below
                    appliedType = 'sword';
                } else if (weaponType) {
                    // Fallback: single owned melee type (non-standard cases)
                    appliedType = weaponType;
                }
                if (appliedType) {
                    // Do not tag the base as 'sword' — we spawn an additional sword projectile separately
                    weaponType = appliedType;
                    if (appliedType !== 'sword') meta.weaponType = appliedType;
                }
                // Multi-Infusion overlay (store infusionElements for applyProjectileHit)
                if (game.player && game.player.infusions && game.player.infusions.length) {
                    meta.infusionElements = game.player.infusions.map(i=>({ type:i.type, potency:i.potency }));
                    if (!meta.damageType) {
                        // choose strongest infusion potency as primary damageType for display/status
                        let best = -1; let chosen=null; meta.infusionElements.forEach(inf=>{ if(inf.potency>best){best=inf.potency; chosen=inf.type;} });
                        meta.damageType = chosen;
                    }
                }
                // Map damageType/infusions to SoA color index for visual feedback
                if (game.projectilesSoA) {
                    const so = game.projectilesSoA;
                    const colMap = { fire:1, shadow:2, poison:2, lightning:1, frost:4, ice:4, void:5, wind:3, plasma:5 };
                    let cIdx = 0;
                    if (meta.damageType && colMap[meta.damageType]!=null) cIdx = colMap[meta.damageType];
                    else if (meta.infusionElements && meta.infusionElements.length) {
                        // pick strongest infusion's color as fallback
                        let strongest = meta.infusionElements[0];
                        meta.infusionElements.forEach(el=>{ if (el.potency > strongest.potency) strongest = el; });
                        if (strongest && colMap[strongest.type]!=null) cIdx = colMap[strongest.type];
                    }
                    if (cIdx != null) so.colorIdx[primaryIdx] = cIdx;
                }
                // Photon Torpedo (instant-travel strike): perform an immediate hit on nearest enemy when fired
                // Note: keep projectile alive so this is additive to normal shots/patterns.
                if (game.player.abilities && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.instantTravel)) {
                    let target = null; let closest = Infinity;
                    for (const e of game.enemies) {
                        const d = Math.hypot(e.x - game.player.x, e.y - game.player.y);
                        if (d < closest) { closest = d; target = e; }
                    }
                    if (target) {
                        let dmg = Math.floor((meta.baseDamage || calculateDamage()) * 1.8);
                        // Pattern synergy: small bonus per additional core motion pattern owned
                        const coreFlags = ['sineWave','wackyZigzag','ekgWave','spiralPattern'];
                        const patternCount = coreFlags.reduce((n,f)=> n + (game.player.abilities.some(a=> ABILITIES[a] && ABILITIES[a].effect[f]) ? 1 : 0), 0);
                        if (patternCount >= 2) dmg = Math.floor(dmg * (1 + 0.08 * (patternCount - 1)));
                        // Infusion bonus: add partial damage per active infusion potency
                        if (game.player.infusions && game.player.infusions.length) {
                            game.player.infusions.forEach(inf => { dmg += Math.floor(dmg * 0.15 * inf.potency); });
                        }
                        target.health -= dmg;
                        addDamageNumber(dmg, target.x, target.y - target.size/2, { type:'plasma', crit:false });
                        addScreenShake(7);
                        // Apply statuses from current build
                        if (typeof applyStatusEffects === 'function') applyStatusEffects(target);
                        // Visual strike record
                        if (!Array.isArray(game.photonStrikes)) game.photonStrikes = [];
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const life = reduceRings ? 16 : 24;
                        const impactSize = Math.min(42, 22 + dmg*0.05) * (lowFx ? 0.85 : 1);
                        game.photonStrikes.push({ x1: game.player.x, y1: game.player.y, x2: target.x, y2: target.y, time: performance.now(), life, impactSize, color: '#CCFFFF' });
                        // Particles at source and impact (perf-aware)
                        const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                        if (!lowFx && !hideSparks) {
                            for (let t = 0; t < 8; t++) addParticle(target.x + (Math.random()-0.5)*30, target.y + (Math.random()-0.5)*30, '#FFFFFF', 'explosion');
                            for (let s = 0; s < 10; s++) addParticle(game.player.x + (Math.random()-0.5)*44, game.player.y + (Math.random()-0.5)*44, '#CCFFFF', 'spark');
                        }
                        // Synergies: lightning mini-chains
                        if (game.player.abilities.some(a => a.includes('Lightning Shot') || a.includes('Storm Shot'))) {
                            let chains = 0; const maxChains = 2;
                            for (const o of game.enemies) {
                                if (o === target || chains >= maxChains) break;
                                const d = Math.hypot(o.x - target.x, o.y - target.y);
                                if (d < 140) { const z = Math.max(4, Math.floor(dmg * 0.35)); o.health -= z; addDamageNumber(z, o.x, o.y - o.size/2, { type:'lightning' }); addParticle(o.x, o.y, '#FFFFAA', 'lightning'); chains++; }
                            }
                        }
                        // Explosive synergy
                        if (game.player.abilities.some(a => a.includes('Explosive Shot') || a.includes('Nova Blast'))) {
                            explodeProjectile({ x: target.x, y: target.y, size: 12 }, Math.floor(dmg * 0.5));
                        }
                        // Void synergy: light armor shred pulse
                        if (game.player.abilities.some(a => a.includes('Void Shot') || a.includes('Black Hole'))) {
                            game.enemies.forEach(o => { const d = Math.hypot(o.x - target.x, o.y - target.y); if (d < 110) { o.armorShredded = (o.armorShredded||0) + 1; if (o.armorShredded > 10) o.armorShredded = 10; } });
                        }
                    }
                }
                // Teleport Shot relocation (visual + positional) – perform once at spawn
                if (meta.teleporting) {
                    const so = game.projectilesSoA; const TELEPORT_SHOT_RADIUS = 88; const attempts=10; const margin=30;
                    const ox = so.x[primaryIdx]; const oy = so.y[primaryIdx];
                    for (let a=0;a<attempts;a++) {
                        const r = Math.pow(Math.random(),1.35)*TELEPORT_SHOT_RADIUS; const th = Math.random()*Math.PI*2;
                        let nx = game.player.x + Math.cos(th)*r; let ny = game.player.y + Math.sin(th)*r;
                        nx = Math.max(margin, Math.min(nx, LOGICAL_W - margin)); ny = Math.max(margin, Math.min(ny, LOGICAL_H - margin));
                        // (Simple wall test omitted here; integrate isWall if available in this scope)
                        so.x[primaryIdx]=nx; so.y[primaryIdx]=ny; break;
                    }
                    if (!(game.perf && game.perf.lowFx)) {
                        for (let p=0;p<8;p++) addParticle(so.x[primaryIdx] + (Math.random()-0.5)*26, so.y[primaryIdx] + (Math.random()-0.5)*26, '#FFDFAA','spark');
                        for (let t=0;t<5;t++){ const tRatio=t/4; addParticle(ox + (so.x[primaryIdx]-ox)*tRatio, oy + (so.y[primaryIdx]-oy)*tRatio, '#FFE4AA','trail'); }
                    }
                }
                // Weapon-type adjustments
                if (weaponType || hasSword) {
                    const so = game.projectilesSoA;
                    // If Sword Throw is owned, always spawn an additional sword projectile
                    if (hasSword) {
                        // Spawn sword without replacing the base shot (even if base is axe/bread/etc.)
                        const sAng = angle;
                        const sSpd = speed * 0.85;
                        const sIdx = game.spawnProjectile({
                            x: game.player.x + Math.cos(sAng) * 16,
                            y: game.player.y + Math.sin(sAng) * 16,
                            vx: Math.cos(sAng) * sSpd,
                            vy: Math.sin(sAng) * sSpd,
                            life: 100,
                            r: Math.max(14, Math.floor(size)),
                            damage: baseDamage,
                            damageType: null,
                            sineWave: false,
                            wackyZigzag: false,
                            ekgWave: false,
                            spiralPattern: false
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        const metaSword = {
                            baseDamage,
                            weaponType:'sword',
                            piercing: !!meta.piercing,
                            pierceCount: meta.pierceCount,
                            weakHoming: !!meta.weakHoming,
                            bouncing: !!meta.bouncing,
                            bounces: meta.bounces||0,
                            explosive: !!meta.explosive,
                            boomerang: !!meta.boomerang,
                            orbital: !!meta.orbital,
                            drilling: !!meta.drilling,
                            phasing: !!meta.phasing,
                            teleporting: !!meta.teleporting
                        };
                        if (usedAutoAimShot) metaSword.autoAimShot = true;
                        if (chosenDamageType) metaSword.damageType = chosenDamageType;
                        game._projMeta.set(sIdx, metaSword);
                    }
                    if (weaponType === 'axe') {
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 16);
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx]*1.6 + 12));
                        meta.knockback = true; meta.knockbackDistance = Math.max(meta.knockbackDistance||0, 55); meta.weaponType='axe'; meta.slowOnHit = true;
                    } else if (weaponType === 'spear') {
                        meta.piercing = true; meta.pierceCount = Math.max(meta.pierceCount||0, 4); meta.weaponType='spear';
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx]*1.2 + 6));
                    } else if (weaponType === 'hammer') {
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 18);
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx]*1.8 + 10));
                        meta._hammer = true; meta.knockback = true; meta.knockbackDistance = Math.max(meta.knockbackDistance||0, 40); meta.weaponType='hammer';
                    } else if (weaponType === 'dagger') {
                        // Dagger Rain: rely on projectileCount logic; small radius fast projectile adjustments could be added
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 5);
                        so.vx[primaryIdx]*=1.12; so.vy[primaryIdx]*=1.12;
                        meta.weaponType='dagger';
                    } else if (weaponType === 'bread') {
                        // Crusty Bread: chunky, high-damage spinning baguette (nerfed)
                        so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 16);
                        // Reduced bump to bring it in line with other heavy weapons
                        so.damage[primaryIdx] = Math.max(1, Math.floor(so.damage[primaryIdx] * 1.35 + 10));
                        meta.weaponType = 'bread';
                        // Optional mild knockback due to mass
                        meta.knockback = true; meta.knockbackDistance = Math.max(meta.knockbackDistance||0, 38);
                    }
                }
                // Toenail Clibbins crescents (spawn separate SoA projectiles) – migrated from legacy block
                if (i === 0 && game.player.abilities.includes('Toenail Clibbins')) {
                    const crescents = 4 + Math.floor(Math.random()*3);
                    for (let c=0;c<crescents;c++) {
                        const ang = Math.random()*Math.PI*2;
                        const spd = 3.4 + Math.random()*2.0;
                        const lifeC = 78 + Math.floor(Math.random()*40);
                        const sizeC = 11 + Math.floor(Math.random()*3);
                        const idxC = game.spawnProjectile({ x: game.player.x, y: game.player.y, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, life: lifeC, r: sizeC, damage: Math.max(1, Math.floor(baseDamage * 0.38)) });
                        if (idxC>=0) {
                            game._projMeta.set(idxC, { toenail:true, baseDamage: Math.max(1, Math.floor(baseDamage * 0.38)), _crescentPhase: Math.random()*Math.PI*2, _crescentDir: (Math.random()<0.5?-1:1), _tnThickness: 0.35 + Math.random()*0.25, _tnArcSweep: (Math.PI*(0.85+Math.random()*0.25)), _tnInnerOffset: 0.30 + Math.random()*0.15, _tnTintShift:(Math.random()*18-9) });
                        }
                    }
                }
                if (i === 0 && hasReleaseQuacken) {
                    triggerReleaseQuackenTentacle({
                        game,
                        aimAngle: baseAimAngle,
                        firingAngle: angle,
                        baseDamage,
                        targetEnemy
                    });
                }
                // SIGMA: spawn an additional large, strong-homing core projectile (stage 1)
                if (i === 0 && game.player.abilities.includes('SIGMA')) {
                    if (!game._sigma) game._sigma = {};
                    // Fire-rate limit: 1 per 2 seconds (~120 frames)
                    if (typeof game.frame === 'number') {
                        if (game._sigma._s1NextFrame && game.frame < game._sigma._s1NextFrame) {
                            // on cooldown; skip this cycle
                        } else {
                            game._sigma._s1NextFrame = game.frame + 120;
                            const sAng = angle;
                            const sSpeed = speed * 0.95;
                            const sLife = Math.max(dynamicLife, 420);
                            const sIdx = game.spawnProjectile({
                                x: game.player.x + Math.cos(sAng) * 16,
                                y: game.player.y + Math.sin(sAng) * 16,
                                vx: Math.cos(sAng) * sSpeed,
                                vy: Math.sin(sAng) * sSpeed,
                                life: sLife,
                                r: Math.max(18, Math.floor(size * 2.4)),
                                damage: Math.max(1, Math.floor(baseDamage * 1.15)),
                                damageType: null,
                                homing: true
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            const metaS1 = {
                                baseDamage: Math.max(1, Math.floor(baseDamage * 1.15)),
                                sigma1: true,
                                // stronger homing factor for sigma1 only
                                _sigmaHomingFactor: 1.9,
                                _sigmaBlendBoost: 0.08,
                                // Allow stage 1 to pass through obstacles
                                phasing: true,
                                // ensure no accidental pierce/ricochet from other abilities
                                piercing: false,
                                pierceCount: 0
                            };
                            game._projMeta.set(sIdx, metaS1);
                            // Slight cue
                            if (!(game.perf && game.perf.lowFx)) addParticle(game.player.x, game.player.y, '#CCEEFF','ring');
                        }
                    } else {
                        // Fallback if frame counter not available (spawn, but still set a timestamp gate)
                        const now = performance.now();
                        if (!game._sigma._s1NextMs || now >= game._sigma._s1NextMs) {
                            game._sigma._s1NextMs = now + 2000;
                            const sAng = angle;
                            const sSpeed = speed * 0.95;
                            const sLife = Math.max(dynamicLife, 420);
                            const sIdx = game.spawnProjectile({
                                x: game.player.x + Math.cos(sAng) * 16,
                                y: game.player.y + Math.sin(sAng) * 16,
                                vx: Math.cos(sAng) * sSpeed,
                                vy: Math.sin(sAng) * sSpeed,
                                life: sLife,
                                r: Math.max(18, Math.floor(size * 2.4)),
                                damage: Math.max(1, Math.floor(baseDamage * 1.15)),
                                damageType: null,
                                homing: true
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            const metaS1 = { baseDamage: Math.max(1, Math.floor(baseDamage * 1.15)), sigma1: true, _sigmaHomingFactor: 1.9, _sigmaBlendBoost: 0.08, piercing: false, pierceCount: 0 };
                            game._projMeta.set(sIdx, metaS1);
                            if (!(game.perf && game.perf.lowFx)) addParticle(game.player.x, game.player.y, '#CCEEFF','ring');
                        }
                    }
                }
                // Extended pattern/meta flags
                const abilityFlagNames = ['lissajousPattern','pendulumPattern','sawWave','phaseEcho','resonantPulseCore','pivotPattern','convergePair','fragmentWake','spiralBloom','harmonicSplit','temporalDrift','veeringFan','echoBloom','bloomRing','cascadeBurst','helixPair'];
                abilityFlagNames.forEach(fn=>{ meta[fn] = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect[fn]); });
                meta._initialFx = Math.cos(angle); meta._initialFy = Math.sin(angle);
                // Quantum spawn muzzle cue
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.quantum) && !(game.perf && game.perf.lowFx)) {
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!reduceRings) addParticle(game.player.x + Math.cos(angle)*16, game.player.y + Math.sin(angle)*16, '#66FFFF','ring');
                    if (!(game.fxFlags && game.fxFlags.hideSparks)) addParticle(game.player.x, game.player.y, '#AAFFFF','spark');
                    meta.quantum = true; // ensure quantum flag propagates to rendering tint as telegraph
                }
                if (meta.helixPair) {
                    meta._helixSide = -1; meta._helixRadius=26; meta._helixTargetRadius=42; meta._helixPhase=0;
                    // twin spawn
                    const twinIdx = game.spawnProjectile({
                        x: game.player.x + Math.cos(angle) * 16,
                        y: game.player.y + Math.sin(angle) * 16,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: dynamicLife,
                        r: Math.max(2, Math.min(32, Math.floor(size))),
                        damage: Math.max(1, Math.floor(baseDamage*0.85)),
                        damageType:null,
                        spiralPattern: spiral,
                        sineWave: meta.sineWave,
                        wackyZigzag: meta.wackyZigzag,
                        ekgWave: meta.ekgWave,
                        homing: homing
                    });
                    const tMeta = { ...meta, _helixSide:1, baseDamage: Math.max(1, Math.floor(baseDamage*0.85)) };
                    game._projMeta.set(twinIdx, tMeta);
                }
                if (meta.convergePair) {
                    meta._convergeSpawned = true; meta._convGroup = Symbol('convTwins'); meta._convPhase='diverge'; meta._convTimer=0; meta._convPrimary=true; meta._convSide=-1;
                    const off=0.48; const baseAng=angle; // adjust main projectile velocity
                    // adjust SoA velocity directly
                    const so = game.projectilesSoA; so.vx[primaryIdx]=Math.cos(baseAng - off)*speed; so.vy[primaryIdx]=Math.sin(baseAng - off)*speed;
                    const twinIdx = game.spawnProjectile({
                        x: game.player.x + Math.cos(baseAng) * 16,
                        y: game.player.y + Math.sin(baseAng) * 16,
                        vx: Math.cos(baseAng + off) * speed,
                        vy: Math.sin(baseAng + off) * speed,
                        life: dynamicLife,
                        r: Math.max(2, Math.min(32, Math.floor(size))),
                        damage: Math.max(1, Math.floor(baseDamage*0.9)),
                        damageType:null,
                        spiralPattern: spiral,
                        sineWave: meta.sineWave,
                        wackyZigzag: meta.wackyZigzag,
                        ekgWave: meta.ekgWave,
                        homing: homing
                    });
                    const tMeta = { ...meta, _convPrimary:false, _convSide:1, baseDamage: Math.max(1, Math.floor(baseDamage*0.9)) };
                    // Link twins by index to avoid O(N) partner scans during SoA updates
                    meta._convTwin = twinIdx; tMeta._convTwin = primaryIdx;
                    game._projMeta.set(twinIdx, tMeta);
                }
                game._projMeta.set(primaryIdx, meta);
                // Time Bomb metadata (first projectile only)
                if (i === 0 && game.player.abilities.includes('Time Bomb')) {
                    meta.timeBomb = true;
                    meta._timeBombTimer = 54; meta._timeBombArmed=false; meta.piercing=true; meta.pierceCount=4; meta._timeBombExplosionMult=2.0;
                    // Slight slow: adjust velocity in SoA
                    const so = game.projectilesSoA; so.vx[primaryIdx]*=0.62; so.vy[primaryIdx]*=0.62; so.radius[primaryIdx] = Math.max(so.radius[primaryIdx], 12);
                }
                // Meteor spawn
                if (i === 0 && game.player.abilities.includes('Meteor')) {
                    const ringRadius = 180 + Math.random()*60;
                    const spawnAng = Math.random()*Math.PI*2;
                    const spawnX = game.player.x + Math.cos(spawnAng) * ringRadius;
                    const spawnY = game.player.y + Math.sin(spawnAng) * ringRadius - (120 + Math.random()*80);
                    const targetRadius = 140; const targetAng = Math.random()*Math.PI*2;
                    const targetX = game.player.x + Math.cos(targetAng) * (40 + Math.random()*targetRadius);
                    const targetY = game.player.y + Math.sin(targetAng) * (40 + Math.random()*targetRadius);
                    const travelTime = 70 + Math.floor(Math.random()*35);
                    const mIdx = game.spawnProjectile({ x:spawnX,y:spawnY,vx:(targetX-spawnX)/travelTime, vy:(targetY-spawnY)/travelTime, life: travelTime+6, r:20, damage: Math.floor(baseDamage*2.6+45), damageType:'fire' });
                    const mMeta = { meteor:true, _meteorAoeRadius:90, _meteorDetonateAt: game.frame + travelTime, _meteorKnockback:120, _meteorTargetX:targetX, _meteorTargetY:targetY, baseDamage: Math.floor(baseDamage*2.6+45) };
                    game._projMeta.set(mIdx, mMeta);
                    if (!game.meteorMarkers) game.meteorMarkers = [];
                    game.meteorMarkers.push({ x:targetX, y:targetY, created:Date.now(), life:(travelTime/60)*1000, pulse:0, _explodeFrame:mMeta._meteorDetonateAt });
                    mMeta._meteorMarkerId = game.meteorMarkers.length -1;
                    for (let t=0;t<12;t++) addParticle(spawnX + (Math.random()-0.5)*18, spawnY + (Math.random()-0.5)*18, '#FFBB66','spark');
                }
                // Popcorn (SoA): mark the primary as a kernel that will pop later
                if (i === 0 && game.player.abilities.includes('Popcorn')) {
                    meta.isPopcornKernel = true;
                    meta._popFuse = 36; // extended fuse for farther travel before popping
                    meta._popDid = false;
                    // Reduce kernel base damage and reflect into SoA numeric channel
                    meta.baseDamage = Math.max(1, Math.floor(meta.baseDamage * 0.55));
                    const so = game.projectilesSoA; so.damage[primaryIdx] = meta.baseDamage;
                    // Store per-kernel pop scaling derived from current multishot amount
                    const multi = Math.max(1, baseMultiBeforePattern || 1);
                    meta._popPuffs = Math.min(6, 2 + Math.floor((multi - 1) / 4));
                    meta._popBursts = Math.min(6, 2 + Math.floor((multi - 1) / 3));
                }
                // Umbrella Shot (SoA): designate first projectile as umbrella core
                if (i === 0 && game.player.abilities.includes('Umbrella Shot')) {
                    meta.umbrellaCore = true;
                    meta._umbOriginX = game.player.x;
                    meta._umbOriginY = game.player.y;
                    meta._umbTravel = 0;
                    meta._umbSplitDistance = 96;
                    meta._umbDidSplit = false;
                    meta._umbCoreAge = 0;
                    // Ensure enough life to reach split distance
                    const so = game.projectilesSoA; if (so.life[primaryIdx] < 120) { so.life[primaryIdx] = 120; so.lifeMax[primaryIdx] = 120; }
                }
                // Pulse Rifle (SoA): emit a short burst of 3 shots (primary + 2 quick companions)
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'pulse' && ABILITIES[a].effect.burstFire)) {
                    const so = game.projectilesSoA;
                    const dmgBase = calculateDamage();
                    // Two companion shots with slight angular offsets and slightly faster speed
                    for (let b = 0; b < 2; b++) {
                        const off = (b === 0 ? -0.06 : 0.06);
                        const ang = Math.atan2(so.vy[primaryIdx], so.vx[primaryIdx]) + off;
                        const idxB = game.spawnProjectile({
                            x: game.player.x + Math.cos(ang) * 20,
                            y: game.player.y + Math.sin(ang) * 20,
                            vx: Math.cos(ang) * (speed * 1.1),
                            vy: Math.sin(ang) * (speed * 1.1),
                            life: dynamicLife,
                            r: Math.max(2, Math.min(18, Math.floor(size * 0.8))),
                            damage: Math.floor(dmgBase * 0.8),
                            damageType: null,
                            sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                            wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                            ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                            spiralPattern: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                        });
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idxB, { pulseBurst:true, baseDamage:dmgBase, energyType:'pulse', piercing:false, pierceCount:1, lifeSteal:0 });
                    }
                }

                // Diarrhea: spawn a rear-shot brown oval per projectile (SoA path; scales with multi-shot)
                if (game.player.abilities.includes('Diarrhea')) {
                    const rearAng = angle + Math.PI;
                    const dmgBase = (typeof baseDamage !== 'undefined' ? baseDamage : calculateDamage());
                    // Make it larger and last longer for much more travel time
                    const rearLife = Math.max(90, Math.floor(((typeof dynamicLife !== 'undefined' ? dynamicLife : 60)) * 1.7));
                    const rearRadius = Math.max(10, Math.floor(size * 1.55));
                    const rIdx = game.spawnProjectile({
                        x: game.player.x - Math.cos(angle) * 16,
                        y: game.player.y - Math.sin(angle) * 16,
                        vx: Math.cos(rearAng) * (speed * 0.9),
                        vy: Math.sin(rearAng) * (speed * 0.9),
                        life: rearLife,
                        r: rearRadius,
                        damage: Math.floor(dmgBase * 0.9),
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiralPattern: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    // Allow shape/size changes while enforcing brown-only visuals; copy pattern flags into metadata for SoA updaters
                    // Also propagate Uzumaki (global spiral) so the rear-shot is affected the same as primaries
                    const md = {
                        baseDamage: Math.floor(dmgBase * 0.9),
                        _diarrheaBrown: true,
                        growing: game.player.abilities.includes('Growing Shot'),
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiral: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern),
                        pendulumPattern: game.player.abilities.includes('Pendulum Shot'),
                        pivotPattern: game.player.abilities.includes('Vector Pivot')
                    };
                    if (hasUzumaki) {
                        md.hasUzumaki = true;
                        md._uzuCx = game.player.x;
                        md._uzuCy = game.player.y;
                        md._uzuAngle = rearAng; // seed; updater derives from position too
                        md._uzuRadius = 16;
                        md._uzuAngularVel = 0.18 + Math.random()*0.05;
                        md._uzuRadialVel = 1.35 + Math.random()*0.35;
                        md._uzuDrag = 0.000;
                    }
                    game._projMeta.set(rIdx, md);
                }
                continue; // fully handled via SoA metadata

                // Multi-Infusion overlay: attach active infusion elements
                if (game.player && game.player.infusions && game.player.infusions.length) {
                    projectile.infusionElements = game.player.infusions.map(i => ({ type: i.type, potency: i.potency }));
                    // If projectile has no inherent damageType, pick the strongest infusion as primary displayed damageType (for color numbers)
                    if (!projectile.damageType) {
                        let chosen = null; let best = -1;
                        game.player.infusions.forEach(i => { if (i.potency > best) { best = i.potency; chosen = i.type; } });
                        projectile.damageType = chosen;
                    } else {
                        // Already elemental; small additive damage from each infusion (applied later) - mark flag
                        projectile._elementalCore = true;
                    }
                }

                // Toenail Clibbins: emit a cluster of random yellow crescent clippings once per attack primary projectile
                if (i === 0 && game.player.abilities.includes('Toenail Clibbins')) {
                    // Spawn 4–6 crescents each attack cycle
                    const crescents = 4 + Math.floor(Math.random()*3);
                    for (let c=0;c<crescents;c++) {
                        const ang = Math.random() * Math.PI * 2;
                        // Range Tuning: slight speed increase + higher base life to extend outward arc.
                        // Previous: spd 3.1–5.1, life 54–82
                        // New:     spd 3.4–5.4, life 78–118 (~+45% median travel distance)
                        const spd = 3.4 + Math.random()*2.0;
                        const life = 78 + Math.floor(Math.random()*40);
                        const size = 11 + Math.floor(Math.random()*3);
                        const thicknessRatio = 0.35 + Math.random()*0.25; // controls crescent thickness
                        const arcSweep = (Math.PI * (0.85 + Math.random()*0.25)); // length of visible arc
                        const innerOffset = 0.30 + Math.random()*0.15; // how far to offset inner cut to shape
                        const tintShift = (Math.random()*18 - 9); // slight hue/value shift later
                        game.spawnProjectile({
                            x: game.player.x, y: game.player.y,
                            vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
                            life, size, enemy:false,
                            baseDamage: Math.max(1, Math.floor((projectile.baseDamage||calculateDamage()) * 0.38)),
                            damage: Math.max(1, Math.floor((projectile.baseDamage||calculateDamage()) * 0.38)),
                            toenail:true,
                            _crescentPhase: Math.random()*Math.PI*2,
                            _crescentDir: (Math.random()<0.5?-1:1),
                            _tnThickness: thicknessRatio,
                            _tnArcSweep: arcSweep,
                            _tnInnerOffset: innerOffset,
                            _tnTintShift: tintShift
                        });
                    }
                }

                // Popcorn: replace primary projectile with a kernel that later pops into:
                //  - Two random-direction "kernel burst" mini bullets (new)
                //  - Two angled puffs (existing)
                //  - Each puff still produces crumbs on impact (existing chain)
                // Extended fuse increases forward travel distance for better spacing before proliferation.
                if (i === 0 && game.player.abilities.includes('Popcorn')) {
                    // Mark in metadata instead of mutating legacy projectile object
                    meta.isPopcornKernel = true;
                    meta._popFuse = 36; // extended fuse for farther travel
                    meta._popDid = false;
                    // Adjust stored baseDamage for kernel (SoA damage already set from baseDamage)
                    meta.baseDamage = Math.max(1, Math.floor(meta.baseDamage * 0.55));
                    // Reflect reduced damage into SoA numeric channel
                    const so = game.projectilesSoA; so.damage[primaryIdx] = meta.baseDamage;
                }

                // Umbrella Shot: designate the FIRST projectile of the attack as the umbrella core.
                // It will travel a short distance then split into two arc projectiles that swing overhead and return.
                if (i === 0 && game.player.abilities.includes('Umbrella Shot')) {
                    meta.umbrellaCore = true;
                    meta._umbOriginX = game.player.x;
                    meta._umbOriginY = game.player.y;
                    meta._umbTravel = 0;
                    meta._umbSplitDistance = 180; // travel further before splitting
                    meta._umbDidSplit = false;
                    meta._umbCoreAge = 0;
                    // Ensure sufficient lifetime in SoA array
                    const so = game.projectilesSoA; if (so.life[primaryIdx] < 160) { so.life[primaryIdx] = 160; so.lifeMax[primaryIdx] = 160; }
                }

                // Laser Beam special-case: continuous beam energy weapon
                // If player has Laser Beam (energyType: 'laser' and continuous=true), spawn a short-lived beam segment
                if (projectile.energyType === 'laser' && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.continuous)) {
                    // beam segments are shorter-lived and tile along forward direction while holding fire
                    projectile.size = 8;
                    projectile.life = 18; // lifespan of each segment (frames)
                    projectile.vx = Math.cos(angle) * 12;
                    projectile.vy = Math.sin(angle) * 12;
                    projectile.beam = true;
                    projectile.beamOwner = 'player';
                    projectile.damage = calculateDamage();
                    // Beam pattern blending: inherit motion flags for visual modulation, not trajectory displacement
                    projectile.sineWave = projectile.sineWave || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave);
                    projectile.wackyZigzag = projectile.wackyZigzag || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag);
                    projectile.ekgWave = projectile.ekgWave || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave);
                    projectile.spiral = projectile.spiral || game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern);
                    projectile._beamPatternPhase = 0;
                }
                // Particle Beam (SoA)
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'particle')) {
                    const beamAngle = angle;
                    const dmgBase = calculateDamage();
                    const idx = game.spawnProjectile({
                        x: game.player.x + Math.cos(beamAngle) * 8,
                        y: game.player.y + Math.sin(beamAngle) * 8,
                        vx: Math.cos(beamAngle) * 9,
                        vy: Math.sin(beamAngle) * 9,
                        life: 28,
                        r: 7,
                        damage: Math.floor(dmgBase * 1.6) + 8,
                        damageType: 'plasma',
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiralPattern: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    game._projMeta.set(idx, { beam:true, particleBeam:true, beamOwner:'player', baseDamage:dmgBase, energyType:'particle', _beamPatternPhase:0, infusionElements: (game.player.infusions && game.player.infusions.length) ? game.player.infusions.map(i=>({type:i.type,potency:i.potency})) : null });
                }

                // Pulse Rifle: emit a short burst of 3 shots quickly instead of single projectile
                if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.energyType === 'pulse' && ABILITIES[a].effect.burstFire)) {
                    for (let b=0;b<2;b++) {
                        const ang = angle + (b===0?-0.06:0.06);
                        const dmgBase = calculateDamage();
                        const idx = game.spawnProjectile({
                            x: game.player.x + Math.cos(ang) * 20,
                            y: game.player.y + Math.sin(ang) * 20,
                            vx: Math.cos(ang) * (speed * 1.1),
                            vy: Math.sin(ang) * (speed * 1.1),
                            life: 36,
                            r: Math.max(2, Math.min(18, Math.floor(size*0.8))),
                            damage: Math.floor(dmgBase * 0.8),
                            damageType: null,
                            sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                            wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                            ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave)
                        });
                        if (!game._projMeta) game._projMeta=new Map();
                        game._projMeta.set(idx,{ pulseBurst:true, baseDamage:dmgBase, energyType:'pulse', piercing:false, pierceCount:1, lifeSteal:0 });
                    }
                }
                // Diarrhea: spawn a rear-shot brown oval once per attack
                if (i === 0 && game.player.abilities.includes('Diarrhea')) {
                    const rearAng = angle + Math.PI;
                    const dmgBase = calculateDamage();
                    const rIdx = game.spawnProjectile({
                        x: game.player.x - Math.cos(angle) * 16,
                        y: game.player.y - Math.sin(angle) * 16,
                        vx: Math.cos(rearAng) * (speed * 0.9),
                        vy: Math.sin(rearAng) * (speed * 0.9),
                        life: 42,
                        r: Math.max(6, Math.floor(size * 1.1)),
                        damage: Math.floor(dmgBase * 0.9),
                        // Carry pattern flags so object-mode update hooks can act (render stays brown-only)
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiral: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    });
                    if (!game._projMeta) game._projMeta = new Map();
                    // Allow shape/size changes from other abilities (e.g., Growing Shot) while enforcing brown-only visuals
                    // Propagate pattern flags and Uzumaki metadata so the rear-shot respects pattern alterations
                    const md = {
                        baseDamage: Math.floor(dmgBase * 0.9),
                        _diarrheaBrown: true,
                        growing: game.player.abilities.includes('Growing Shot'),
                        pendulumPattern: game.player.abilities.includes('Pendulum Shot'),
                        pivotPattern: game.player.abilities.includes('Vector Pivot'),
                        // Mirror object-mode flags for consistency (update loop reads either proj flags or metadata)
                        sineWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.sineWave),
                        wackyZigzag: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.wackyZigzag),
                        ekgWave: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.ekgWave),
                        spiral: game.player.abilities.some(a=>ABILITIES[a]&&ABILITIES[a].effect.spiralPattern)
                    };
                    if (game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.uzumaki)) {
                        md.hasUzumaki = true;
                        md._uzuCx = game.player.x;
                        md._uzuCy = game.player.y;
                        md._uzuAngle = rearAng;
                        md._uzuRadius = 16;
                        md._uzuAngularVel = 0.18 + Math.random()*0.05;
                        md._uzuRadialVel = 1.35 + Math.random()*0.35;
                        md._uzuDrag = 0.000;
                    }
                    game._projMeta.set(rIdx, md);
                }

                // Teleport on spawn: instant blink forward a short distance
                if (projectile.teleporting) {
                    // New behavior: Teleport Shot relocates EACH fired projectile (including multi-shot patterns)
                    // to a random position within a radius around the player, then resumes forward travel.
                    // This occurs only once at spawn. We attempt to find a non-wall location.
                    // Tunable teleport field radius (reduced from 140 to tighten spread for better accuracy)
                    const TELEPORT_SHOT_RADIUS = 88; // px (adjust here for balance)
                    const maxRadius = TELEPORT_SHOT_RADIUS;
                    const attempts = 12;
                    const origX = projectile.x;
                    const origY = projectile.y;
                    let placed = false;
                    for (let a = 0; a < attempts; a++) {
                        // Biased random point: favor nearer teleports so shots stay relatively close.
                        // Use pow(rand, 1.35) to skew toward smaller radii (1 => uniform, >1 => bias inward)
                        const r = Math.pow(Math.random(), 1.35) * maxRadius;
                        const theta = Math.random() * Math.PI * 2;
                        let nx = game.player.x + Math.cos(theta) * r;
                        let ny = game.player.y + Math.sin(theta) * r;
                        // Clamp to arena bounds with small margin
                        const margin = 30;
                        nx = Math.max(margin, Math.min(nx, canvas.width - margin));
                        ny = Math.max(margin, Math.min(ny, canvas.height - margin));
                        if (!isWall(nx, ny, Math.max(10, projectile.size))) {
                            projectile.x = nx;
                            projectile.y = ny;
                            placed = true;
                            break;
                        }
                    }
                    // Visual effects: portal burst at destination + faint trail from origin
                    const trailSteps = 6;
                    for (let i=0;i<trailSteps;i++) {
                        const t = i / (trailSteps - 1);
                        const ix = origX + (projectile.x - origX) * t;
                        const iy = origY + (projectile.y - origY) * t;
                        if (Math.random() < 0.6) addParticle(ix + (Math.random()-0.5)*8, iy + (Math.random()-0.5)*8, '#FFE4AA', 'spark');
                    }
                    for (let p=0;p<10;p++) {
                        addParticle(projectile.x + (Math.random()-0.5)*24, projectile.y + (Math.random()-0.5)*24, '#FFDFAA', 'spark');
                    }
                    // Synergy: augment portal visuals depending on other pattern flags
                    if (projectile.spiral) {
                        for (let s=0;s<8;s++) addParticle(projectile.x, projectile.y, '#FFC877', 'explosion');
                    }
                    if (projectile.sineWave) {
                        for (let w=0;w<6;w++) addParticle(projectile.x + Math.sin(w)*18, projectile.y + Math.cos(w)*18, '#FFF2CC', 'spark');
                    }
                    if (projectile.wackyZigzag) {
                        for (let z=0;z<5;z++) addParticle(projectile.x + (Math.random()-0.5)*30, projectile.y + (Math.random()-0.5)*30, '#FFE0AA', 'spark');
                    }
                    if (projectile.ekgWave) {
                        for (let e=0;e<6;e++) addParticle(projectile.x + (Math.random()-0.5)*14, projectile.y + (Math.random()-0.5)*38, '#FFF6DD', 'spark');
                    }
                }
                if (projectile.meteor) {
                    // Gentle steering toward telegraphed target
                    if (projectile._meteorTargetX != null) {
                        const dxT = projectile._meteorTargetX - projectile.x;
                        projectile.vx = dxT / 140; // slower correction for natural descent
                    }
                    // Impact check: when reaching target Y (or bottom safety) trigger explosion once
                    if (!projectile._meteorDetonated && projectile.y >= (projectile._meteorTargetY || (canvas.height*0.6))) {
                        projectile._meteorDetonated = true;
                        const aoe = projectile._meteorAoeRadius || 80;
                        const dmg = projectile.baseDamage || calculateDamage();
                        // Damage enemies in radius
                        game.enemies.forEach(en => {
                            const dx = en.x - projectile.x; const dy = en.y - projectile.y;
                            if (dx*dx + dy*dy <= aoe*aoe) {
                                en.health -= dmg;
                                addDamageNumber(dmg, en.x, en.y - en.size/2, { type:'fire'});
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                            }
                        });
                        // Visual explosion + screen shake
                        addScreenShake(10);
                        explodeProjectile({x:projectile.x,y:projectile.y,size:projectile.size}, Math.floor(dmg*0.6));
                        for (let p=0;p<30;p++) addParticle(projectile.x + (Math.random()-0.5)*aoe*1.4, projectile.y + (Math.random()-0.5)*aoe*1.4, '#FF8844','explosion');
                        // Clear marker if still present
                        if (typeof projectile._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[projectile._meteorMarkerId]) {
                            game.meteorMarkers[projectile._meteorMarkerId].life = 0; // let render prune it
                        }
                        projectile.life = 0; // remove meteor projectile
                    }
                }
                // (Legacy projectile object push removed – all spawning handled via SoA earlier.)
                // Rear clone (Diarrhea) already handled in core SoA firing path earlier.
                // Weapon-type: Sword Throw -> convert base projectile into spinning blade instead of spawning an extra blocky projectile
                if (projectile.weaponType === 'sword') {
                    // Re-shape / flag existing projectile for sword rendering (drawing code branches on weaponType)
                    projectile.size = Math.max(projectile.size || 10, 14);
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.spin = true;
                    projectile.spinAngle = angle;
                    projectile.spinSpeed = 0.45;
                    // Slightly slow it for readability
                    projectile.vx *= 0.85;
                    projectile.vy *= 0.85;
                    // Shorter lifespan so it feels like a thrown arc
                    projectile.life = Math.min(projectile.life, 34);
                    addParticle(projectile.x, projectile.y, '#CCCCCC', 'spark');
                }
                // Weapon-type: Axe Hurl - heavy single projectile with knockback
                if (projectile.weaponType === 'axe') {
                    projectile.size = Math.max(projectile.size, 16);
                    // If projectile was flagged as growing, ensure its baseline reflects post-weapon inflation so growth can continue.
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.6 + 12);
                    projectile.knockback = true;
                    projectile.piercing = false;
                    projectile.slowOnHit = true;
                }
                // Spear Thrust: ensure strong piercing behavior
                if (projectile.weaponType === 'spear') {
                    projectile.piercing = true;
                    projectile.pierceCount = Math.max(projectile.pierceCount || 3, 4);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.2 + 6);
                }
                // Hammer Slam: heavy knockback and stun on impact
                if (projectile.weaponType === 'hammer') {
                    projectile.size = Math.max(projectile.size, 18);
                    if (projectile.growing) projectile._initialSize = Math.max(projectile._initialSize||projectile.size, projectile.size);
                    projectile.damage = Math.floor((projectile.baseDamage || calculateDamage()) * 1.8 + 10);
                    projectile._hammer = true; // handle stun in collision
                }
                // Removed dead projectile.instantTravel branch; Photon Torpedo handled during fire by ability check.
            }
            // Screen shake for shooting
            // Shockwave ability: emit one traveling wave per attack (cooldown gated)
            if (game.player.abilities && game.player.abilities.includes('Shockwave')) {
                const nowSW = Date.now();
                const swCooldown = 600; // ms
                if (!game._lastShockwave || nowSW - game._lastShockwave >= swCooldown) {
                    const dir = game.player.lastDirection || {x:1,y:0};
                    const ang = Math.atan2(dir.y, dir.x);
                    spawnShockwave(game.player.x, game.player.y, ang);
                    game._lastShockwave = nowSW;
                }
            }
            addScreenShake(2);
        }

    // Dynamic orbital management moved into ensureOrbitals() (called each frame in update())
    function ensureOrbitals() {
            if (!game.player) return;
            const hasOrbital = game.player.abilities && game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.orbital);
            if (!hasOrbital) {
                // Clean up existing orbital metadata by marking any meta entries with _orbital for recycling
                if (game._projMeta) {
                    for (const [idx, meta] of game._projMeta.entries()) {
                        if (meta && meta._orbital) {
                            // Recycle projectile slot directly
                            if (game.recycleProjectile) game.recycleProjectile(idx);
                            game._projMeta.delete(idx);
                        }
                    }
                }
                return;
            }
            // Determine current orbital indices from metadata
            let existing = [];
            if (game._projMeta) {
                for (const [idx, meta] of game._projMeta.entries()) if (meta && meta._orbital) existing.push(idx);
            }
            // Track respawn cooldown
            if (!game._orbitalRegen) game._orbitalRegen = { nextAt: 0 };
            // Derive desired count using multi-shot style bonuses (simplified mirror of attack logic)
            let multiShotCount = 0; let shotgunBlast = false;
            game.player.abilities.forEach(ab => { const data = ABILITIES[ab]; if (!data||!data.effect) return; if (data.effect.projectileCount) multiShotCount += data.effect.projectileCount; if (data.effect.shotgunBlast) shotgunBlast = true; });
            let desired = 2;
            if (shotgunBlast) desired = multiShotCount + 5; else if (multiShotCount > 0) desired = multiShotCount; else desired = 2;
            if (desired < 2) desired = 2; desired = Math.min(desired, 40);
            // Adjust counts: trim or spawn
            if (existing.length > desired) {
                // Recycle extras beyond desired
                const toRemove = existing.slice(desired);
                toRemove.forEach(idx => { if (game.recycleProjectile) game.recycleProjectile(idx); if (game._projMeta) game._projMeta.delete(idx); });
                existing = existing.slice(0, desired);
            }
            if (existing.length < desired) {
                const now = performance.now();
                if (now < game._orbitalRegen.nextAt) {
                    // too soon to respawn; skip this frame
                } else {
                if (!game._projMeta) game._projMeta = new Map();
                const needed = desired - existing.length;
                const sineWave = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.sineWave);
                const wackyZigzag = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.wackyZigzag);
                const ekgWave = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.ekgWave);
                const spiralPattern = game.player.abilities.some(a => ABILITIES[a] && ABILITIES[a].effect.spiralPattern);
                for (let s=0; s<needed; s++) {
                    const baseRadius = 72 + Math.min(36, desired * 1.2);
                    const idx = game.spawnProjectile({
                        x: game.player.x + baseRadius, // provisional placement at angle 0; re-spaced below
                        y: game.player.y,
                        vx: 0, vy:0,
                        r: 6,
                        life: 99999,
                        damage: 0 // purely positional / cosmetic until collision logic optionally added
                    });
                    if (idx >= 0) {
                        game._projMeta.set(idx, {
                            _orbital:true,
                            _orbitAngle:0,
                            _orbitRadius: baseRadius,
                            _orbitSpeed: 0.055 + Math.random()*0.035,
                            sineWave: sineWave,
                            wackyZigzag: !sineWave && wackyZigzag,
                            ekgWave: !sineWave && !wackyZigzag && ekgWave,
                            spiral: spiralPattern,
                            spinAngle:0,
                            spinSpeed: spiralPattern ? (0.25 + Math.random()*0.2) : 0,
                            _inheritedPattern:true
                        });
                        existing.push(idx);
                    }
                }
                // set a small regen cooldown to avoid instant spam on mass loss
                game._orbitalRegen.nextAt = now + 450; // ms
                }
            }
            // Animate orbit: increment each orbital's angle and place around player
            if (game.projectilesSoA && existing.length) {
                const { x, y } = game.projectilesSoA;
                const baseSpin = 0.045; // rad/frame baseline
                for (let i=0;i<existing.length;i++) {
                    const idx = existing[i];
                    const meta = game._projMeta.get(idx); if (!meta) continue;
                    // Initialize angle based on slot if not set, to distribute around
                    if (meta._orbitAngle == null) meta._orbitAngle = (i / existing.length) * Math.PI * 2;
                    // Per-orbital spin speed with small variance (respect any existing _orbitSpeed)
                    const spd = (typeof meta._orbitSpeed === 'number' ? meta._orbitSpeed : (baseSpin + i*0.002)) * 1.0;
                    meta._orbitAngle += spd;
                    // Keep within 0..2PI to avoid float growth
                    if (meta._orbitAngle > Math.PI*2) meta._orbitAngle -= Math.PI*2;
                    // Optional tiny breathing on radius for life
                    const breathe = 1 + Math.sin((game.frame||0)*0.02 + i*0.7) * 0.03;
                    const rad = meta._orbitRadius * breathe;
                    x[idx] = game.player.x + Math.cos(meta._orbitAngle) * rad;
                    y[idx] = game.player.y + Math.sin(meta._orbitAngle) * rad;
                }
            }
        }

        // --- Beartrap Ability ---
        function dropBeartrap() {
            if (!game.traps) game.traps = [];
            const MAX_TRAPS = 12;
            if (game.traps.length >= MAX_TRAPS) {
                game.traps.sort((a,b)=>a.created-b.created);
                game.traps.splice(0,1);
            }
            game.traps.push({
                x: game.player.x,
                y: game.player.y,
                radius: 20,
                created: Date.now(),
                triggered: false,
                triggerTime: 0,
                damage: Math.floor(calculateDamage() * 2.2),
                immobilizeMs: 5000
            });
        }

        function updateTraps() {
            if (!game.traps) return;
            const now = Date.now();
            for (let i = game.traps.length - 1; i >= 0; i--) {
                const trap = game.traps[i];
                if (!trap.triggered && now - trap.created > 60000) { game.traps.splice(i,1); continue; }
                if (trap.triggered && now - trap.triggerTime > 800) { game.traps.splice(i,1); continue; }
                if (!trap.triggered) {
                    for (const enemy of game.enemies) {
                        const dx = enemy.x - trap.x;
                        const dy = enemy.y - trap.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < trap.radius) {
                            enemy.health -= trap.damage;
                            // Standardize on frame-based stunTime for reliability and keep a timestamp backup
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, Math.floor(trap.immobilizeMs / 16)); // convert ms -> frames
                            enemy._trapImmobilizeUntil = Date.now() + trap.immobilizeMs; // fallback timestamp in case frame timer desyncs
                            delete enemy.stunnedTime; // remove ms-based variant to avoid confusion
                            addParticle(trap.x, trap.y, '#CCCCCC', 'impact');
                            addDamageNumber(trap.damage, enemy.x, enemy.y - enemy.size, { type:'physical' });
                            // Achievements: accumulate trap damage
                            try { if (window.achv_addTrapDamage) achv_addTrapDamage(trap.damage); } catch(_) {}
                            trap.triggered = true;
                            trap.triggerTime = now;
                            addScreenShake(3);
                            break;
                        }
                    }
                }
            }
        }

        // --- Punji Pit Ability ---
        function dropPunjiPit() {
            if (!game.pits) game.pits = [];
            const MAX_PITS = 10;
            if (game.pits.length >= MAX_PITS) {
                game.pits.sort((a,b)=>a.created-b.created);
                game.pits.splice(0,1);
            }
            game.pits.push({
                x: game.player.x,
                y: game.player.y,
                radius: 28,
                created: Date.now(),
                duration: 15000, // 15s field
                damageTick: Math.floor(calculateDamage() * 0.5),
                tickInterval: 800, // ms between repeat ticks per enemy
                enemiesHit: {}, // track last tick time per enemy id/hash
                poison: true,
                // Precompute spike layout for consistent rendering (array of {x,y,h,lean})
                spikes: (function(){
                    const arr = [];
                    const count = 18; // dense cluster
                    for (let i=0;i<count;i++) {
                        // random point inside inner disc (avoid edge so heads visible)
                        const ang = Math.random()*Math.PI*2;
                        const rad = Math.sqrt(Math.random()) * 0.75; // bias toward center
                        const rx = Math.cos(ang)*rad;
                        const ry = Math.sin(ang)*rad;
                        const h = 10 + Math.random()*14; // spike height
                        const lean = (Math.random()-0.5)*0.4; // slight lean factor for top offset
                        arr.push({ x: rx, y: ry, h, lean });
                    }
                    return arr;
                })()
            });
        }

        function updatePits() {
            if (!game.pits) return;
            const now = Date.now();
            for (let i = game.pits.length - 1; i >= 0; i--) {
                const pit = game.pits[i];
                if (now - pit.created > pit.duration) { game.pits.splice(i,1); continue; }
                // process enemies
                for (const enemy of game.enemies) {
                    const dx = enemy.x - pit.x;
                    const dy = enemy.y - pit.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < pit.radius) {
                        const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                        const last = pit.enemiesHit[key] || 0;
                        if (now - last >= pit.tickInterval) {
                            // apply damage over time tick
                            enemy.health -= pit.damageTick;
                            addDamageNumber(pit.damageTick, enemy.x, enemy.y - enemy.size, { type:'poison' });
                            enemy.poisoned = true;
                            enemy.poisonTime = Math.max(enemy.poisonTime || 0, 180); // 3s poison baseline or refresh
                            pit.enemiesHit[key] = now;
                            if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#55FF55', 'poison');
                            // Achievements: accumulate trap damage from Punji tick
                            try { if (window.achv_addTrapDamage) achv_addTrapDamage(pit.damageTick); } catch(_) {}
                        }
                    }
                }
            }
        }

        function updateEnemies() {
            game.enemies.forEach(enemy => {
                // If enemy is currently under Rizz pull animation, we only interpolate position (handled elsewhere) and skip AI.
                if (enemy._rizzPull && enemy._rizzPull.active) {
                    // decay fear timer if already applied (post pull) else defer.
                    return; // skip rest of processing this frame until pull completes
                }

                        // === Enemy Spatial Hash (mirrors projectile hash) ===
                        (function initEnemyHash(){
                            const CELL = 64; // same as projectile hash for simplicity
                            game.enemyHash = { cell:CELL, buckets:new Map(), frame:0 };
                            function key(cx,cy){ return (cx<<16)^cy; }
                            game.rebuildEnemyHash = function(){
                                const buckets = game.enemyHash.buckets; buckets.clear();
                                const cs = CELL;
                                for (let i=0;i<game.enemies.length;i++){
                                    const e = game.enemies[i]; if(!e || e.dead || e.health<=0) continue;
                                    const cx = (e.x/cs)|0; const cy = (e.y/cs)|0;
                                    const k = key(cx,cy); let arr = buckets.get(k); if(!arr){ arr=[]; buckets.set(k,arr);} arr.push(i);
                                }
                                game.enemyHash.frame++;
                            };
                        })();
                // Status effects
                const nowTs = Date.now();
                // Decay crushed timer
                if (enemy.crushedTimer && enemy.crushedTimer > 0) {
                    enemy.crushedTimer -= 16; // approximate per-frame ms
                    if (enemy.crushedTimer < 0) enemy.crushedTimer = 0;
                }
                // Armor shred decay: every ~2200ms remove one stack
                if (enemy.armorShredded && enemy.armorShredded > 0) {
                    if (!enemy._armorShredDecay) enemy._armorShredDecay = nowTs;
                    if (nowTs - enemy._armorShredDecay > 2200) {
                        enemy.armorShredded = Math.max(0, enemy.armorShredded - 1);
                        enemy._armorShredDecay = nowTs;
                    }
                }
                // Freeze stack decay (if not refreshed)
                if (enemy.freezeStacks && enemy.freezeStacks > 0) {
                    if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                        enemy.frozenTimer -= 16;
                        if (enemy.frozenTimer <= 0) enemy.frozenTimer = 0; // will rely on stack decay afterwards
                    }
                    if (enemy.lastFreezeHit && nowTs - enemy.lastFreezeHit > 2000 && !enemy.frozenTimer) {
                        enemy.freezeStacks--;
                        enemy.lastFreezeHit = nowTs; // reset so further decay is spaced
                        if (enemy.freezeStacks <= 0) {
                            enemy.freezeStacks = 0; delete enemy.lastFreezeHit;
                        }
                    }
                }
                if (enemy.poisoned) {
                    enemy.poisonTime--;
                    if (enemy.poisonTime <= 0) {
                        enemy.poisoned = false;
                    } else {
                        let poisonTick = 0.8;
                        const abil = game.player.abilities;
                        const hasVoid = abil.includes('Void Shot') || abil.includes('Black Hole');
                        const hasFire = abil.includes('Fire Shot') || abil.includes('Inferno') || abil.includes('Magma Shot');
                        if (hasVoid) poisonTick *= 1.25; // void amplifies decay
                        if (hasFire) poisonTick *= 1.12; // fire + poison magma synergy
                        enemy.health -= poisonTick;
                        if (Math.random() < 0.1) {
                            addParticle(enemy.x, enemy.y, '#44FF44', 'poison');
                        }
                    }
                }
                
                if (enemy.burning) {
                    enemy.burnTime--;
                    if (enemy.burnTime <= 0) {
                        enemy.burning = false;
                    } else {
                        let burnTick = 1.2;
                        const abil = game.player.abilities;
                        const hasWind = abil.includes('Wind Blade') || abil.includes('Blizzard');
                        const hasPoison = abil.includes('Poison Shot') || abil.includes('Toxic Cloud') || abil.includes('Silent But Deadly');
                        if (hasWind) burnTick *= 1.15; // oxygen fan effect
                        if (hasPoison) burnTick *= 1.10; // toxic combustion
                        enemy.health -= burnTick;
                        if (Math.random() < 0.2) {
                            addParticle(enemy.x, enemy.y, '#FF4444', 'fire');
                        }
                    }
                }

                if (enemy.wunderScribble) {
                    enemy.wunderScribbleTime--;
                    if (enemy.wunderScribbleTime <= 0 || enemy.health <= 0) {
                        enemy.wunderScribble = false;
                        enemy.wunderScribbleTime = 0;
                        enemy._wunderScribbleTick = 0;
                        enemy.wunderScribbleTickDamage = 0;
                    } else {
                        const interval = enemy.wunderScribbleInterval || 14;
                        enemy._wunderScribbleTick = (enemy._wunderScribbleTick || 0) - 1;
                        if (enemy._wunderScribbleTick <= 0) {
                            enemy._wunderScribbleTick = interval;
                            let scribTick = enemy.wunderScribbleTickDamage || 1.2;
                            const abil = (game.player && game.player.abilities) || [];
                            const hasVoid = abil.includes('Void Shot') || abil.includes('Black Hole');
                            const hasLightning = abil.includes('Lightning Shot') || abil.includes('Storm Shot');
                            if (hasVoid) scribTick *= 1.08;
                            if (hasLightning) scribTick *= 1.05;
                            // Mild synergy with burning encourages combo builds
                            if (enemy.burning) scribTick *= 1.06;
                            enemy.health -= scribTick;
                            if (!(game.perf && game.perf.lowFx)) {
                                const pulse = '#FF1E46';
                                addParticle(enemy.x + (Math.random()-0.5)*8, enemy.y + (Math.random()-0.5)*8, pulse, 'spark');
                                if (Math.random() < 0.18) addParticle(enemy.x, enemy.y, '#FF0F32', 'ring');
                            }
                        }
                    }
                }
                if (enemy.quackenSnared) {
                    enemy.quackenSnareTime--;
                    if (enemy.quackenSnareTime <= 0 || enemy.health <= 0) {
                        enemy.quackenSnared = false;
                        enemy.quackenSnareTime = 0;
                        enemy._quackenStack = 0;
                        enemy._quackenTick = 0;
                    } else {
                        enemy._quackenTick = (enemy._quackenTick || 0) - 1;
                        const cadence = Math.max(14, 28 - Math.min(4, (enemy._quackenStack || 1) - 1) * 3);
                        if (enemy._quackenTick <= 0) {
                            enemy._quackenTick = cadence;
                            const base = enemy._quackenBaseDamage || (typeof calculateDamage === 'function' ? calculateDamage() : 8);
                            const dotScale = enemy._quackenDotScale || 0.24;
                            const stackBonus = 1 + Math.min(4, Math.max(0, (enemy._quackenStack || 1) - 1)) * 0.33;
                            const dot = Math.max(2, Math.floor(base * dotScale * stackBonus));
                            enemy.health -= dot;
                            addDamageNumber(dot, enemy.x, enemy.y - enemy.size/2, { type: 'void' });
                            if (!(game.perf && game.perf.lowFx)) {
                                addParticle(enemy.x + (Math.random() - 0.5) * 14, enemy.y + (Math.random() - 0.5) * 14, '#5B49C8', 'spark');
                            }
                        }
                        enemy._quackenRingCd = (enemy._quackenRingCd || 0) - 1;
                        if (enemy._quackenRingCd <= 0) {
                            enemy._quackenRingCd = 18;
                            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                            if (!(game.perf && game.perf.lowFx) && !reduceRings) {
                                addParticle(enemy.x, enemy.y, '#6651D8', 'ring');
                            }
                        }
                    }
                } else {
                    enemy._quackenStack = 0;
                    enemy._quackenTick = 0;
                }
                
                if (enemy.slowed) {
                    enemy.slowTime--;
                    if (enemy.slowTime <= 0) {
                        enemy.slowed = false;
                    }
                }
                // Blind status decay: reduces detection and accuracy
                if (enemy.blinded) {
                    enemy.blindTime = (enemy.blindTime || 0) - 1;
                    if (enemy.blindTime <= 0) {
                        enemy.blinded = false; enemy.blindTime = 0;
                    } else {
                        // Occasional disoriented shuffle (random small drift)
                        if (Math.random() < 0.02) {
                            enemy._blindWanderAngle = Math.random()*Math.PI*2;
                        }
                        if (enemy._blindWanderAngle != null) {
                            enemy.x += Math.cos(enemy._blindWanderAngle) * 0.4;
                            enemy.y += Math.sin(enemy._blindWanderAngle) * 0.4;
                        }
                    }
                }
                
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Process smooth knockback BEFORE stun/freeze early returns so sliding occurs even if stunned.
                if (enemy.kbFrames && enemy.kbFrames > 0 && (enemy.kbVX || enemy.kbVY)) {
                    // Move enemy by current knockback velocity
                    let nx = enemy.x + enemy.kbVX;
                    let ny = enemy.y + enemy.kbVY;
                    // Wall collision: if blocked, zero out remaining knockback to avoid jitter
                    if (!isWall(nx, ny, enemy.size/2)) {
                        enemy.x = nx; enemy.y = ny;
                    } else {
                        enemy.kbFrames = 0; enemy.kbVX = 0; enemy.kbVY = 0; enemy._knockbacking = false;
                    }
                    // Apply decay
                    const decay = enemy._kbDecay || 0.88;
                    enemy.kbVX *= decay; enemy.kbVY *= decay;
                    enemy.kbFrames--;
                    // Edge clamp handled globally after all movement; local failsafe (hard clamp to canvas bounds using size)
                    const r = enemy.size || 16;
                    const minX = r; const maxX = canvas.width - r;
                    const minY = r; const maxY = canvas.height - r;
                    if (enemy.x < minX) { enemy.x = minX; if (enemy.kbVX < 0) enemy.kbVX = 0; }
                    if (enemy.x > maxX) { enemy.x = maxX; if (enemy.kbVX > 0) enemy.kbVX = 0; }
                    if (enemy.y < minY) { enemy.y = minY; if (enemy.kbVY < 0) enemy.kbVY = 0; }
                    if (enemy.y > maxY) { enemy.y = maxY; if (enemy.kbVY > 0) enemy.kbVY = 0; }
                    if (enemy.kbFrames <= 0 || (Math.abs(enemy.kbVX) < 0.1 && Math.abs(enemy.kbVY) < 0.1)) {
                        enemy.kbFrames = 0; enemy.kbVX = 0; enemy.kbVY = 0; enemy._knockbacking = false;
                    }
                    // Generic sliding feedback
                    if (Math.random() < 0.10) addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.4, enemy.y + enemy.size*0.4, '#FFFFFF', 'spark');
                    // Earth-style debris (brown / stone chips) when flagged
                    if (enemy._earthKBFrames && enemy._earthKBFrames > 0) {
                        enemy._earthKBFrames--;
                        if (Math.random() < 0.45) {
                            const debrisColor = Math.random() < 0.5 ? '#6b4a2b' : '#4a3420';
                            addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.6, enemy.y + (Math.random()-0.2)*enemy.size*0.5, debrisColor, 'spark');
                        }
                    }
                    // Skip AI movement & attack this frame while in knockback motion
                    return;
                }

                // Handle stunned / immobilized enemies (beartrap etc.)
                if (enemy.stunned) {
                    // Primary: frame-based stunTime
                    if (enemy.stunTime != null) {
                        enemy.stunTime--;
                        if (enemy.stunTime <= 0) {
                            enemy.stunTime = 0;
                        }
                    }
                    // Fallback: timestamp window (from beartrap)
                    if (enemy._trapImmobilizeUntil && Date.now() >= enemy._trapImmobilizeUntil) {
                        enemy._trapImmobilizeUntil = null;
                        if (!enemy.stunTime || enemy.stunTime <= 0) enemy.stunned = false;
                    }
                    // Legacy ms-based stunnedTime support (convert to frames roughly)
                    if (enemy.stunnedTime != null) {
                        enemy.stunnedTime -= 16;
                        if (enemy.stunnedTime <= 0) { enemy.stunnedTime = 0; if (!enemy.stunTime || enemy.stunTime <= 0) enemy.stunned = false; }
                    }
                    // Failsafe: if flagged stunned but both stunTime and stunnedTime are 0/undefined and no trap immobilize, clear it.
                    if (enemy.stunned && (!enemy.stunTime || enemy.stunTime <= 0) && (enemy.stunnedTime == null || enemy.stunnedTime <= 0) && !enemy._trapImmobilizeUntil) {
                        enemy.stunned = false;
                    }
                    // Watchdog: track total consecutive frames of being stunned to auto-clear pathological cases (e.g., logic bug leaving stun forever)
                    if (enemy.stunned) {
                        enemy._stunWatch = (enemy._stunWatch || 0) + 1;
                        if (enemy._stunWatch > 360) { // 6 seconds at 60fps
                            enemy.stunned = false;
                            enemy.stunTime = 0;
                            enemy.stunnedTime = 0;
                            delete enemy._trapImmobilizeUntil;
                        }
                    } else if (enemy._stunWatch) {
                        // reset counter when not stunned
                        enemy._stunWatch = 0;
                    }
                    // Visual feedback for immobilization root
                    if (Math.random() < 0.15) addParticle(enemy.x + (Math.random()-0.5)*enemy.size*0.6, enemy.y + enemy.size/2, '#BBBBBB', 'spark');
                    if (enemy.stunned) return; // still immobilized
                }
                // Full freeze immobilization
                if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                    // visually could add subtle frost particles
                    if (Math.random() < 0.04) addParticle(enemy.x, enemy.y, '#AAEEFF', 'spark');
                    return;
                }

                // Ranged enemy attacks (silenced enemies cannot attack)
                // Increase non-blinded detection so ranged enemies engage from farther out
                const detectionRange = enemy.blinded ? 120 : 420;
                const enemyCooldown = (ENEMY_TYPES[enemy.type] && ENEMY_TYPES[enemy.type].rangedCooldown) ? ENEMY_TYPES[enemy.type].rangedCooldown : 2500;
                // Global opening delay for ranged attacks: prevent shooting during first 2000ms of a room
                const openingDelayMs = 2000;
                const roomAge = Date.now() - (game.roomStartTime || 0);
                if (roomAge < openingDelayMs) {
                    // ensure lastAttack is at least roomStartTime to avoid burst after delay
                    if (!enemy._openingDelayApplied) {
                        enemy.lastAttack = Date.now();
                        enemy._openingDelayApplied = true;
                    }
                }
                if (roomAge >= openingDelayMs && !enemy.silenced && enemy.ranged) {
                    // Allow special long-range behavior for Wunderswan
                    let effectiveDetection = detectionRange;
                    if (enemy.type === 'Wunderswan') effectiveDetection = Math.max(effectiveDetection, 1200);
                    if (!(dist < effectiveDetection) || Date.now() - enemy.lastAttack <= enemyCooldown) {
                        // skip firing this frame if out of range or on cooldown
                    } else {
                    const baseSpeed = 4;
                    const shots = [];
                    if (enemy.type === 'The Big Quack') {
                        // Triple fan shot: center + slight left/right spread
                        const baseAng = Math.atan2(dy, dx);
                        const spreads = [0, -0.18, 0.18];
                        spreads.forEach(off => {
                            const a = baseAng + off;
                            shots.push({ vx: Math.cos(a)*baseSpeed, vy: Math.sin(a)*baseSpeed, dmgMul: 0.85 });
                        });
                    } else if (enemy.type === 'Boss Gangster') {
                        // Two-round burst (slight vertical jitter)
                        const baseAng = Math.atan2(dy, dx);
                        const jitter = [ -0.05, 0.05 ];
                        jitter.forEach(off => {
                            const a = baseAng + off;
                            shots.push({ vx: Math.cos(a)*baseSpeed*1.05, vy: Math.sin(a)*baseSpeed*1.05, dmgMul: 0.8 });
                        });
                    } else if (enemy.type === '2Honk Shakur') {
                        // 2Honk Shakur: 3-bullet spreadshot (left, center, right)
                        const baseAng = Math.atan2(dy, dx);
                        const spreads = [ -0.12, 0, 0.12 ];
                        const honkSpeed = baseSpeed * 1.3; // a bit faster pellets
                        spreads.forEach(off => {
                            const a = baseAng + off;
                            shots.push({ vx: Math.cos(a)*honkSpeed, vy: Math.sin(a)*honkSpeed, dmgMul: 0.85 });
                        });
                    } else if (enemy.type === 'Golden Goose') {
                        const baseAng = Math.atan2(dy, dx);
                        const toothSpeed = baseSpeed * 1.45;
                        shots.push({ vx: Math.cos(baseAng)*toothSpeed, vy: Math.sin(baseAng)*toothSpeed, dmgMul: 1, goldTooth: true, life: 220, r: 12, bounces: 3 });
                    } else {
                        shots.push({ vx: (dx / dist) * baseSpeed, vy: (dy / dist) * baseSpeed, dmgMul: 0.8 });
                    }
                    // Wunderswan special laser attack
                    if (enemy.type === 'Wunderswan') {
                        shots.length = 0; // clear any default shots
                        // Bright red long laser: spawn a beam-like projectile with weak homing and enemy flag
                        const baseAng = Math.atan2(dy, dx);
                        const laserSpeed = 7.0;
                        const a = baseAng; // single centered laser
                        shots.push({ vx: Math.cos(a)*laserSpeed, vy: Math.sin(a)*laserSpeed, dmgMul: 2.5, beam: true, r: 10 });
                        // No fragment pellets — Wunderswan should fire only a single red laser beam for easier testing
                        // Ensure periodic audio: on first attack after spawn, also trigger spawn cue
                        try {
                        if (!enemy._wunderswanSpawnedAt) {
                                enemy._wunderswanSpawnedAt = Date.now();
                                // Play a spawn quack: pick a random clip to avoid deterministic repeats
                                try {
                                    if (game._wunderswanAudioList && game._wunderswanAudioList.length) {
                                            try {
                                                // Create a fresh Audio object per-play using the same src so the element can be
                                                // started/stopped repeatedly without being tied to a previously-played element.
                                                const ri = Math.floor(Math.random() * game._wunderswanAudioList.length);
                                                const src = (game._wunderswanAudioList[ri] && game._wunderswanAudioList[ri].src) ? game._wunderswanAudioList[ri].src : null;
                                                if (src) {
                                                    const fresh = new Audio(src);
                                                    fresh.preload = 'auto';
                                                    fresh.onended = () => { try { if (game && game._wunderswanAudioPlaying === fresh) game._wunderswanAudioPlaying = null; } catch(_){} };
                                                    try { fresh.currentTime = 0; } catch(_){}
                                                    const p = fresh.play();
                                                    if (p && typeof p.then === 'function') {
                                                        p.catch(e => console.warn('[Wunderswan][AUDIO] spawn fresh play rejected', e));
                                                        p.then(()=>{ try { game._wunderswanAudioPlaying = fresh; } catch(_){} });
                                                    } else {
                                                        game._wunderswanAudioPlaying = fresh;
                                                    }
                                                }
                                            } catch(e) { console.warn('[Wunderswan][AUDIO] spawn play failed', e); }
                                        }
                                } catch(e) { console.warn('[Wunderswan][AUDIO] spawn selection failed', e); }
                                enemy._wunderswanAudioNextAt = Date.now() + 10000; // 10s until next queued sound
                            }
                        } catch(_) {}
                        }
                    const isGoldenGoose = enemy.type === 'Golden Goose';
                    let gooseMouthCache;
                    const getGoldenGooseMouthPos = ()=>{
                        if (gooseMouthCache !== undefined) return gooseMouthCache;
                        gooseMouthCache = null;
                        try {
                            if (!isGoldenGoose) return gooseMouthCache;
                            const gg = (game.enemySprites && (game.enemySprites['Golden Goose'] || game.enemySprites.goldengoose)) || null;
                            if (!gg) return gooseMouthCache;
                            const frames = gg.frames || null;
                            let box = null;
                            if (frames) {
                                const facingKey = (enemy.facing && frames[enemy.facing]) ? enemy.facing : null;
                                box = facingKey ? frames[facingKey] : (frames.down || frames.right || frames.up || null);
                            }
                            if ((!box) && gg.anim && Array.isArray(gg.anim.frames) && gg.anim.frames.length) {
                                const idx = (typeof enemy._goldenAnimFrame === 'number') ? (enemy._goldenAnimFrame % gg.anim.frames.length) : 0;
                                box = gg.anim.frames[idx] || gg.anim.frames[0];
                            }
                            if (!box) return gooseMouthCache;
                            const size = enemy.size || 0;
                            const scale = gg.baseScaleForSize ? gg.baseScaleForSize(size) : ((size*2) / ((box && box.h) || 1));
                            let hitOffsetX = 0;
                            let hitOffsetY = 0;
                            if (typeof gg.computeHitbox === 'function') {
                                const hb = gg.computeHitbox(enemy) || null;
                                if (hb) {
                                    if (typeof hb.ox === 'number' || typeof hb.oy === 'number') {
                                        hitOffsetX = (hb.ox || 0) + (hb.w || 0)/2;
                                        hitOffsetY = (hb.oy || 0) + (hb.h || 0)/2;
                                    } else if (typeof hb.x === 'number' && typeof hb.y === 'number') {
                                        hitOffsetX = (hb.x + (hb.w||0)/2) - enemy.x;
                                        hitOffsetY = (hb.y + (hb.h||0)/2) - enemy.y;
                                    }
                                }
                            }
                            if (hitOffsetX === 0 && hitOffsetY === 0 && enemy.hitbox) {
                                const hb = enemy.hitbox;
                                if (typeof hb.x === 'number' && typeof hb.y === 'number' && typeof hb.w === 'number' && typeof hb.h === 'number') {
                                    hitOffsetX = (hb.x + hb.w/2) - enemy.x;
                                    hitOffsetY = (hb.y + hb.h/2) - enemy.y;
                                }
                            }
                            const anchorX = (typeof box.anchorX === 'number') ? box.anchorX : box.w / 2;
                            const anchorY = (typeof box.anchorY === 'number') ? box.anchorY : box.h / 2;
                            const drawW = box.w * scale;
                            const drawH = box.h * scale;
                            const anchorOffsetX = (anchorX - box.w/2) * scale;
                            const anchorOffsetY = (anchorY - box.h/2) * scale;
                            const destX = -drawW/2 + anchorOffsetX;
                            const destY = -drawH/2 + anchorOffsetY;
                            const originX = (enemy.x + hitOffsetX) + destX;
                            const originY = (enemy.y + hitOffsetY) + destY;
                            const mouthRatios = (gg && gg.mouthRatios) || { x: 0.82, y: 0.36 };
                            let ratioX = typeof mouthRatios.x === 'number' ? mouthRatios.x : 0.82;
                            let ratioY = typeof mouthRatios.y === 'number' ? mouthRatios.y : 0.36;
                            if (!(ratioX >= 0 && ratioX <= 1)) ratioX = Math.min(Math.max(ratioX, 0), 1);
                            if (!(ratioY >= 0 && ratioY <= 1)) ratioY = Math.min(Math.max(ratioY, 0), 1);
                            const centerX = enemy.x + hitOffsetX;
                            const playerOnRight = (game && game.player && typeof game.player.x === 'number') ? (game.player.x >= centerX) : ((dx >= 0));
                            const mirrored = !playerOnRight;
                            const pxRatioX = mirrored ? (1 - ratioX) : ratioX;
                            const mouthX = originX + drawW * pxRatioX;
                            const mouthY = originY + drawH * ratioY;
                            gooseMouthCache = { x: mouthX, y: mouthY, mirrored, ratioX, ratioY, drawW, drawH, scale };
                        } catch(_) {
                            gooseMouthCache = null;
                        }
                        return gooseMouthCache;
                    };
                    shots.forEach(s => {
                        // Pass through beam/weakHoming flags to spawnProjectile so the SoA object contains them
                        let projX = enemy.x;
                        let projY = enemy.y;
                        
                        // For Gangster and Boss Gangster, offset bullet spawn to gun position
                        if (enemy.type === 'Gangster' || enemy.type === 'Boss Gangster') {
                            const gunOffsetX = 20; // pixels to the right (accounting for mirroring)
                            const gunOffsetY = -8; // slightly above feet (gun is roughly at center-chest)
                            
                            // Determine if facing left for mirroring
                            const playerX = (game && game.player && typeof game.player.x === 'number') ? game.player.x : null;
                            const facingLeft = playerX !== null && playerX < enemy.x;
                            
                            // Apply offset based on facing direction
                            projX = enemy.x + (facingLeft ? -gunOffsetX : gunOffsetX);
                            projY = enemy.y + gunOffsetY;
                        }
                        
                        const projArgs = {
                            x: projX,
                            y: projY,
                            vx: s.vx,
                            vy: s.vy,
                            life: 140,
                            r: s.r || (enemy.type === 'The Big Quack' ? 5 : 3),
                            damage: Math.floor(enemy.damage * s.dmgMul)
                        };
                        if (s.life) projArgs.life = s.life;
                        if (s.goldTooth) {
                            projArgs.damage = 25;
                            projArgs.life = s.life || 240;
                            projArgs.r = s.r || 12;
                            projArgs.bouncing = true;
                            projArgs.bounces = typeof s.bounces === 'number' ? s.bounces : 3;
                            projArgs.damageType = 'gold';
                            projArgs.spriteKey = 'goldtooth';
                            try {
                                if (window._bulletImages) {
                                    if (typeof window._bulletImages.loadGoldTooth === 'function') window._bulletImages.loadGoldTooth();
                                    const gimg = window._bulletImages.goldtooth;
                                    if (gimg && !gimg.src) {
                                        const src = gimg._deferredSrc || 'assets/bullets/goldtooth.png';
                                        gimg.src = src;
                                    }
                                }
                            } catch(_) {}
                        }
                        if (isGoldenGoose && (s.goldTooth || projArgs.spriteKey === 'goldtooth')) {
                            const mouthPos = getGoldenGooseMouthPos();
                            if (mouthPos) {
                                projArgs.x = mouthPos.x;
                                projArgs.y = mouthPos.y;
                                const gooseSprite = (game && game.enemySprites) ? (game.enemySprites.goldengoose || game.enemySprites['Golden Goose']) : null;
                                let leadDistance = 0;
                                const scale = (mouthPos && typeof mouthPos.scale === 'number') ? mouthPos.scale : (gooseSprite && typeof gooseSprite.baseScaleForSize === 'function' ? gooseSprite.baseScaleForSize(enemy.size || 0) : 1);
                                if (gooseSprite) {
                                    const forwardPx = (typeof gooseSprite.mouthForwardPx === 'number') ? gooseSprite.mouthForwardPx : null;
                                    const forwardFactor = (typeof gooseSprite.mouthForwardFactor === 'number') ? gooseSprite.mouthForwardFactor : null;
                                    if (forwardPx && forwardPx !== 0) {
                                        leadDistance = Math.max(leadDistance, Math.abs(forwardPx * (scale || 1)));
                                    }
                                    if ((!leadDistance || leadDistance < 0.5) && forwardFactor && forwardFactor !== 0) {
                                        leadDistance = Math.max(leadDistance, Math.abs((enemy.size || 0) * forwardFactor));
                                    }
                                    if ((!leadDistance || leadDistance < 0.5) && typeof gooseSprite.mouthForward === 'number') {
                                        // backwards compatibility with legacy factor-based metadata
                                        leadDistance = Math.max(leadDistance, Math.abs((enemy.size || 0) * gooseSprite.mouthForward));
                                    }
                                }
                                if (leadDistance > 0.5) {
                                    const speedLen = Math.hypot(s.vx, s.vy) || 1;
                                    const clampedLead = Math.min(leadDistance, Math.max(10, (enemy.size || 0) * 0.25));
                                    projArgs.x += (s.vx / speedLen) * clampedLead;
                                    projArgs.y += (s.vy / speedLen) * clampedLead;
                                }
                            }
                        }
                        if (s.beam) projArgs.beam = true;
                        if (s.weakHoming) projArgs.weakHoming = true;
                        // Act III ranged enemies fire a swan laser instead of the default red pellet
                        try {
                            if (ENEMY_TYPES[enemy.type] && ENEMY_TYPES[enemy.type].act === 'III' && enemy.ranged) {
                                projArgs.laser = true;
                                // slightly larger visual radius for the laser sprite
                                projArgs.r = s.r || Math.max(6, (enemy.type === 'The Big Quack' ? 6 : 6));
                                projArgs.life = projArgs.life || 160;
                            }
                        } catch(_) {}
                        const pIdx = game.spawnProjectile(projArgs);
                        if (enemy.type === 'Wunderswan' && s.beam) {
                            console.info('[Wunderswan] attempting to spawn beam proj', { pIdx, projArgs });
                        }
                        // Log Act III laser spawns (one-off per enemy instance spawn to help debug sprite availability)
                        try {
                            if (pIdx >= 0 && projArgs && projArgs.laser) {
                                const img = window._bulletImages && window._bulletImages.swanlaser;
                                console.info('[LaserSpawn] Act III laser spawned', { idx: pIdx, imgExists: !!img, img_ok: img?!!img._ok:false, img_complete: img?!!img.complete:false, img_naturalWidth: img?img.naturalWidth:0 });
                                // Play firing SFX (best-effort, may be blocked by browser autoplay policies)
                                try {
                                    const sfx = window._sfx && window._sfx.laser_fire;
                                    if (sfx) {
                                        try { sfx.currentTime = 0; } catch(_) {}
                                        const p = sfx.play(); if (p && p.catch) p.catch(()=>{});
                                    }
                                } catch(_) {}
                            }
                        } catch(_) {}
                        // Mark as enemy-owned so SoA player->enemy collisions skip these, and record metadata (beam/weakHoming)
                        if (pIdx >= 0) {
                            if (!game._projMeta) game._projMeta = new Map();
                            const meta = { enemy: true };
                            // Prefer explicit projArgs.damage when provided (allows boss to override beam damage)
                            try { meta.baseDamage = (typeof projArgs !== 'undefined' && projArgs.damage != null) ? projArgs.damage : Math.floor(enemy.damage * s.dmgMul); } catch(_) { meta.baseDamage = Math.floor(enemy.damage * s.dmgMul); }
                            if (s.beam) meta.beam = true;
                            if (s.weakHoming) meta.weakHoming = true;
                            if (s.goldTooth) {
                                meta.goldTooth = true;
                                meta.bouncing = true;
                                meta.bounces = typeof s.bounces === 'number' ? s.bounces : 3;
                                meta.damageType = 'gold';
                                meta.spriteKey = 'goldtooth';
                                if (typeof meta._goldSpin !== 'number') meta._goldSpin = Math.random() * Math.PI * 2;
                                if (typeof meta._goldSpinSpeed !== 'number') {
                                    const spd = Math.hypot(s.vx || 0, s.vy || 0);
                                    meta._goldSpinSpeed = 0.18 + Math.min(0.20, spd * 0.04);
                                }
                            }
                            // Propagate laser marker into metadata so update/render code can special-case it
                            if (projArgs && projArgs.laser) meta.laser = true;
                            game._projMeta.set(pIdx, meta);
                            if (game.projectilesSoA && game.projectilesSoA.colorIdx) {
                                // Palette index 2 is red in current palette; for lasers prefer a distinct fallback
                                if (s.goldTooth) {
                                    game.projectilesSoA.colorIdx[pIdx] = 1;
                                } else {
                                    game.projectilesSoA.colorIdx[pIdx] = meta.laser ? 4 : 2;
                                }
                            }
                            // If this is a beam, enqueue a one-frame overlay to guarantee immediate visual
                            try {
                                if (meta && meta.beam) {
                                    game._oneFrameBeamOverlays = game._oneFrameBeamOverlays || [];
                                    game._oneFrameBeamOverlays.push({ idx: pIdx, x: projArgs.x || enemy.x, y: projArgs.y || enemy.y, vx: projArgs.vx || 0, vy: projArgs.vy || 0, enemy: true, frame: (game.frame || 0) });
                                }
                            } catch(_) {}
                        }
                        addParticle(enemy.x, enemy.y, '#FFAA00', 'muzzle');
                        });
                        enemy.lastAttack = Date.now();
                    }
                }

                // Movement AI
                // Reconstruct baseline each frame from stored baseSpeed to prevent cumulative slow stacking bugs
                if (enemy.baseSpeed == null) enemy.baseSpeed = enemy.speed || 1; // defensive backfill
                enemy.speed = enemy.baseSpeed; // reset any accidental permanent reduction
                let moveSpeed = enemy.speed;
                if (enemy.slowed) moveSpeed *= 0.4;
                if (enemy.quackenSnared) moveSpeed *= 0.22;
                // Apply partial freeze slow scaling by stacks (1 or 2 stacks only; 3 is full freeze handled above)
                if (enemy.freezeStacks && enemy.freezeStacks > 0 && (!enemy.frozenTimer || enemy.frozenTimer <= 0)) {
                    if (enemy.freezeStacks === 1) moveSpeed *= 0.6;
                    else if (enemy.freezeStacks === 2) moveSpeed *= 0.35;
                }
                // Blind movement dampening + wandering: do NOT fully immobilize
                if (enemy.blinded) {
                    // Cap blind duration defensively
                    if (enemy.blindTime > 300) enemy.blindTime = 300;
                    moveSpeed *= 0.55; // reduced precision movement
                    // If player out of (very short) pursuit range, wander
                    const shortRange = 70;
                    if (dist > shortRange) {
                        // Create / update wander direction every ~45 frames
                        enemy._blindWanderTicker = (enemy._blindWanderTicker || 0) + 1;
                        if (enemy._blindWanderTicker > 45 || enemy._blindWanderAngle == null) {
                            enemy._blindWanderTicker = 0;
                            enemy._blindWanderAngle = Math.random() * Math.PI * 2;
                        }
                        const wx = Math.cos(enemy._blindWanderAngle) * moveSpeed * 0.7;
                        const wy = Math.sin(enemy._blindWanderAngle) * moveSpeed * 0.7;
                        const nx = enemy.x + wx;
                        const ny = enemy.y + wy;
                        if (!isWall(nx, ny, 15)) { enemy.x = nx; enemy.y = ny; }
                        // Continue to next enemy (skip normal chase) this frame
                        return;
                    }
                }
                // Ensure movement never fully zeroed unless explicitly stunned/frozen
                if (!enemy.stunned && !enemy.frozenTimer) {
                    const minFloor = enemy.baseSpeed * 0.18; // floor at 18% baseline
                    if (moveSpeed < minFloor) moveSpeed = minFloor;
                }

                // Terrifying Aura proximity fear application (room-based only now)
                if (game.player && game.player.auraActive) {
                    const auraRadius = 60; // contact radius
                    const adx = enemy.x - game.player.x;
                    const ady = enemy.y - game.player.y;
                    if (adx*adx + ady*ady <= auraRadius * auraRadius) {
                        // Apply fear for 3s (180 frames) if not already feared or refresh shorter remaining
                        const newFear = 180;
                        if (!enemy.fearTime || enemy.fearTime < newFear * 0.5) {
                            enemy.fearTime = newFear;
                            enemy.feared = true;
                            // one-off particles for feedback
                            addParticle(enemy.x, enemy.y - 12, '#AA44FF', 'spark');
                        }
                    }
                }

                // Fear behavior: run directly away from player
                if (enemy.feared) {
                    enemy.fearTime--;
                    if (enemy.fearTime <= 0) { enemy.feared = false; } else {
                        const fdx = enemy.x - game.player.x;
                        const fdy = enemy.y - game.player.y;
                        const fd = Math.max(1, Math.sqrt(fdx*fdx + fdy*fdy));
                        const fleeSpeed = moveSpeed * 1.15; // slight haste when fleeing
                        const nx = enemy.x + (fdx / fd) * fleeSpeed;
                        const ny = enemy.y + (fdy / fd) * fleeSpeed;
                        if (!isWall(nx, ny, 15)) { enemy.x = nx; enemy.y = ny; }
                        return; // skip rest of AI while feared
                    }
                }

                // Fleeing enemies move away from player
                if (enemy.fleeing) {
                    enemy.fleeTime--;
                    if (enemy.fleeTime <= 0) enemy.fleeing = false;
                    // Move opposite direction
                    const nx = enemy.x - (dx / Math.max(dist, 1)) * moveSpeed;
                    const ny = enemy.y - (dy / Math.max(dist, 1)) * moveSpeed;
                    if (!isWall(nx, ny, 15)) {
                        enemy.x = nx;
                        enemy.y = ny;
                    }
                    return;
                }

                // Charmed enemies: become temporary allies that seek and damage other (non-charmed) enemies.
                if (enemy.charmed) {
                    enemy.charmTime--;
                    if (enemy.charmTime <= 0) { enemy.charmed = false; return; }
                    // Acquire nearest valid hostile target
                    let target = null; let tDist = Infinity;
                    for (const other of game.enemies) {
                        if (other === enemy) continue;
                        if (other.health <= 0) continue;
                        if (other.charmed) continue; // don't attack allies
                        const dx2 = other.x - enemy.x; const dy2 = other.y - enemy.y;
                        const d2 = dx2*dx2 + dy2*dy2;
                        if (d2 < tDist) { tDist = d2; target = other; }
                    }
                    if (target) {
                        const d2 = Math.sqrt(tDist) || 1;
                        const step = moveSpeed * 0.85; // slightly faster than normal to be useful
                        const mx = enemy.x + (target.x - enemy.x)/d2 * step;
                        const my = enemy.y + (target.y - enemy.y)/d2 * step;
                        if (!isWall(mx, my, 15)) { enemy.x = mx; enemy.y = my; }
                        // Contact damage vs target (reduced from original enemy.damage to avoid overpowering)
                        if (Math.sqrt((target.x - enemy.x)**2 + (target.y - enemy.y)**2) < (target.size/2 + enemy.size/2 + 4)) {
                            if (!enemy._charmAttackCooldown || enemy._charmAttackCooldown <= 0) {
                                const base = enemy.damage || 10;
                                const dealt = Math.max(1, Math.floor(base * 0.55));
                                target.health -= dealt;
                                addDamageNumber(dealt, target.x, target.y - target.size/2, { type:'charm' });
                                // Small heart particle burst
                                if (Math.random()<0.6) addParticle(target.x, target.y, '#FF88CC', 'spark');
                                enemy._charmAttackCooldown = 28; // ~0.46s at 60fps
                            }
                        }
                    }
                    if (enemy._charmAttackCooldown) enemy._charmAttackCooldown--;
                    // Occasional ambient charm heart
                    if (Math.random() < 0.04) addParticle(enemy.x + (Math.random()-0.5)*enemy.size, enemy.y - enemy.size/2 - 4, '#FF66BB', 'spark');
                    return; // skip hostile AI
                }

                if (dist > 30) {
                    // Simple pathfinding - try to avoid walls
                    let targetX = enemy.x + (dx / dist) * moveSpeed;
                    let targetY = enemy.y + (dy / dist) * moveSpeed;

                    if (isWall(targetX, targetY, 15)) {
                        // Try alternative paths
                        const perpX = -dy / dist;
                        const perpY = dx / dist;

                        if (!isWall(enemy.x + perpX * moveSpeed * 2, enemy.y + perpY * moveSpeed * 2, 15)) {
                            enemy.x += perpX * moveSpeed;
                            enemy.y += perpY * moveSpeed;
                        } else if (!isWall(enemy.x - perpX * moveSpeed * 2, enemy.y - perpY * moveSpeed * 2, 15)) {
                            enemy.x -= perpX * moveSpeed;
                            enemy.y -= perpY * moveSpeed;
                        }
                    } else {
                        enemy.x = targetX;
                        enemy.y = targetY;
                    }
                }
            });
            
            // Remove dead enemies and award XP
            const deadEnemies = game.enemies.filter(enemy => enemy.health <= 0);
            deadEnemies.forEach(enemy => {
                game.totalKills++;
                // Per-player kill counter (initialize lazily if missing)
                if (game.player) {
                    if (typeof game.player.killCount !== 'number') game.player.killCount = 0;
                    game.player.killCount++;
                    // Terrifying Aura activation: every 25 kills grant aura lasting for 2 rooms (level tracking removed)
                    if (game.player.abilities.includes('Terrifying Aura') && game.player.killCount % 25 === 0) {
                        game.player.auraActive = true;
                        // Level-based fields removed
                        game.player.auraActivatedRoom = game.room || 1;
                        game.player.auraExpireRoom = (game.room || 1) + 2; // expires after 2 rooms
                        // Visual feedback particles
                        for (let k=0;k<18;k++) {
                            const ang = (k/18)*Math.PI*2;
                            const px = game.player.x + Math.cos(ang)*38;
                            const py = game.player.y + Math.sin(ang)*38;
                            addParticle(px, py, '#AA44FF', 'spark');
                        }
                        addScreenShake(4);
                    }
                }
                game.score += enemy.xp;
                
                // Feather poof (white burst then falling) - ensure helper exists
                if (typeof spawnFeatherPoof === 'function') {
                    spawnFeatherPoof(enemy);
                }

                // Death effects: legacy bursts + on-kill pop ring keyed to last damage type
                {
                    for (let i = 0; i < 5; i++) {
                        addParticle(enemy.x, enemy.y, enemy.color, 'explosion');
                    }
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx) {
                        // Damage-type keyed ring and a couple sparks
                        let col = '#FFE6AA';
                        switch (enemy._lastHitType) {
                            case 'fire': col = '#FFAA55'; break;
                            case 'ice': case 'frost': col = '#AAE6FF'; break;
                            case 'poison': case 'toxic': col = '#88FFAA'; break;
                            case 'lightning': case 'storm': col = '#FFF277'; break;
                            case 'void': case 'shadow': col = '#CC88FF'; break;
                            case 'plasma': col = '#FF6688'; break;
                            case 'blizzard': col = '#C0F8FF'; break;
                            case 'inferno': col = '#FF5522'; break;
                        }
                        if (!reduceRings) addParticle(enemy.x, enemy.y, col, 'ring');
                        for (let s=0;s<3;s++) addParticle(enemy.x + (Math.random()-0.5)*12, enemy.y + (Math.random()-0.5)*12, col, 'spark');
                    }
                    addScreenShake(3);
                }

                    // Wunderswan death: drop 3 irradiated trash cans and stop queued audio
                    if (enemy.type === 'Wunderswan') {
                        try {
                            // Defensive: ensure pickups array exists
                            if (!game.pickups) game.pickups = [];
                            console.info('[Wunderswan] death - spawning 3 irradiated cans at', Math.round(enemy.x), Math.round(enemy.y));
                            // Debug trace
                            try { game._debug = game._debug || {}; game._debug.lastWunderswanDeath = { x: enemy.x, y: enemy.y, time: performance.now() }; console.info('[Wunderswan] debug.lastWunderswanDeath set', game._debug.lastWunderswanDeath); } catch(_) {}
                            // Preselect up to 3 distinct abilities to attach to each can so pickups grant predictable, unique choices
                            try {
                                // Build Tier-3 pool dynamically so drops reflect the current abilities set
                                const tier3Pool = Object.keys(ABILITIES).filter(a => (ABILITIES[a] && (ABILITIES[a].tier || 1) === 3));
                                // Shuffle pool copy
                                const pool = tier3Pool.slice();
                                for (let i = pool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); const tmp = pool[i]; pool[i] = pool[j]; pool[j] = tmp; }
                                const picks = pool.slice(0, 3);
                                for (let k = 0; k < 3; k++) {
                                    const dxk = (Math.random() - 0.5) * 40; const dyk = (Math.random() - 0.5) * 40;
                                    const assigned = picks[k] || null;
                                    game.pickups.push({ type: 'irradiatedCan', variant: 'irradiated', x: enemy.x + dxk, y: enemy.y + dyk, spawnTime: performance.now(), collected: false, abilityChoice: assigned });
                                    try { console.debug('[Wunderswan][DEBUG] pickup created', game.pickups[game.pickups.length - 1]); } catch(_) {}
                                }
                                console.info('[Wunderswan] assigned irradiatedCan abilities', picks);
                            } catch (e) {
                                // Fallback: spawn generic cans if anything goes wrong
                                for (let k=0;k<3;k++) {
                                    const dxk = (Math.random()-0.5)*40; const dyk = (Math.random()-0.5)*40;
                                    const pObj = { type: 'irradiatedCan', variant: 'irradiated', x: enemy.x + dxk, y: enemy.y + dyk, spawnTime: performance.now(), collected: false };
                                    game.pickups.push(pObj);
                                    try { console.debug('[Wunderswan][DEBUG] fallback pickup created', pObj); } catch(_) {}
                                }
                            }
                            // Schedule quick follow-up diagnostic dumps so we can see if pickups are removed/collected
                            try {
                                setTimeout(() => { try { console.info('[Wunderswan][DEBUG] pickups snapshot @200ms', (game.pickups||[]).map(p=>({x:Math.round(p.x), y:Math.round(p.y), type:p.type, collected:!!p.collected}))); } catch(_){} }, 200);
                                setTimeout(() => { try { console.info('[Wunderswan][DEBUG] pickups snapshot @1000ms', (game.pickups||[]).map(p=>({x:Math.round(p.x), y:Math.round(p.y), type:p.type, collected:!!p.collected}))); } catch(_){} }, 1000);
                            } catch(_){}
                            console.info('[Wunderswan] pickups array length after push:', game.pickups.length, game.pickups.slice(-3));
                            // stop audio playback
                            if (game._wunderswanAudioPlaying) { try { game._wunderswanAudioPlaying.pause(); game._wunderswanAudioPlaying.currentTime = 0; } catch(_) {} game._wunderswanAudioPlaying = null; }
                            // Clear any scheduled autoplay timer and mark audio as stopped for Wunderswan
                            try {
                                if (game._wunderswanAudioTimer) { try { clearTimeout(game._wunderswanAudioTimer); } catch(_){} game._wunderswanAudioTimer = null; }
                                game._wunderswanAudioStopped = true;
                                // Also null out primed flag so scheduler won't attempt to play until re-primed
                                game._wunderswanAudioPrimed = false;
                                try { console.info('[Wunderswan][AUDIO] global audio timer cleared and stopped'); } catch(_){}
                            } catch(_){}
                            } catch(e) { console.warn('Wunderswan death handler failed', e); }
                                // Ensure defeating the secret boss reliably unlocks Act III for future runs
                                try {
                                    try { if (typeof devLog === 'function') devLog('[Wunderswan] defeated - unlocking Act III'); } catch(_){}
                                    // Extra defensive write: set flags/persistence immediately to avoid ordering issues
                                    try { if (!game) window.game = window.game || {}; } catch(_){ }
                                    try { game._actIIIUnlocked = true; } catch(_){ }
                                    try { if (localStorage && localStorage.setItem) localStorage.setItem('actIIIUnlocked','1'); } catch(_){ }
                                    try { if (typeof showToast === 'function') showToast('Act III unlocked!'); } catch(_){}
                                    try { if (typeof unlockActIII === 'function') { unlockActIII('Wunderswan defeat'); } else { try { console.warn('[Wunderswan] unlockActIII not available at death time'); } catch(_){} } } catch(_){ }
                                    try { if (typeof window._flushUnlockActIIIQueue === 'function') { window._flushUnlockActIIIQueue(); } } catch(_){}
                                } catch(_){ }
                    }

                // Spontaneous Combustion: on kill, emit radial burning shards
                if (game.player && game.player.abilities.includes('Spontaneous Combustion')) {
                    const shardCount = 12; // base number of shards
                    const baseDmg = calculateDamage();
                    for (let s=0; s<shardCount; s++) {
                        const ang = (s / shardCount) * Math.PI * 2;
                        const sp = 5.5; // speed of emitted shard
                        game.spawnProjectile({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(ang) * sp,
                            vy: Math.sin(ang) * sp,
                            life: 70,
                            size: 5,
                            enemy: false,
                            baseDamage: Math.max(1, Math.floor(baseDmg * 0.45)),
                            damageType: 'fire',
                            burningShard: true,
                            piercing: false
                        });
                    }
                    // Visual combustion particles
                    for (let p=0;p<30;p++) {
                        const pang = Math.random()*Math.PI*2;
                        const pr = Math.random()*28;
                        addParticle(enemy.x + Math.cos(pang)*pr, enemy.y + Math.sin(pang)*pr, (Math.random()<0.3?'#FFDD66':'#FF7722'), 'explosion');
                    }
                    addScreenShake(5);

                    // Synergy: if player also has Explosive Shot or Chain Explosion, schedule delayed secondary rings.
                    const hasExplosive = game.player.abilities.includes('Explosive Shot');
                    const hasChainExplosion = game.player.abilities.includes('Chain Explosion');
                    if (hasExplosive || hasChainExplosion) {
                        if (!game._pendingCombustionRings) game._pendingCombustionRings = [];
                        // Secondary ring (slightly larger, fewer but stronger shards)
                        game._pendingCombustionRings.push({
                            x: enemy.x,
                            y: enemy.y,
                            spawnFrame: (game.frame||0) + 10, // ~0.16s delay
                            count: hasChainExplosion ? 14 : 10,
                            speed: 6.0,
                            dmgFrac: hasChainExplosion ? 0.5 : 0.42,
                            fire: true,
                            tier: 2
                        });
                        if (hasChainExplosion) {
                            // Tertiary micro-ring (fast fade, crowd control filler)
                            game._pendingCombustionRings.push({
                                x: enemy.x,
                                y: enemy.y,
                                spawnFrame: (game.frame||0) + 22,
                                count: 18,
                                speed: 6.8,
                                dmgFrac: 0.34,
                                fire: true,
                                tier: 3
                            });
                        }
                    }
                }

                // Final boss defeat check
                if (enemy.type === 'The Big Quack') {
                    game._bigQuackDefeated = true;
                    console.info('[Endgame] The Big Quack defeated. Preparing ending overlay.');
                    // Swap to ending music (play cleansing theme regardless of previous track)
                    try {
                        if (game.bgMusic) { try { game.bgMusic.pause(); } catch(e) {} }
                        game.bgMusic = new Audio('assets/audio/Cleansing.mp3');
                        game.bgMusic.loop = true;
                        try { game.bgMusic.play().catch(()=>{}); } catch(e) {}
                    } catch(e) {}
                    // Display ending image overlay
                    if (!document.getElementById('endingOverlay')) {
                        const overlay = document.createElement('div');
                        overlay.id = 'endingOverlay';
                        overlay.style.cssText = 'position:fixed;left:0;top:0;width:100%;height:100%;background:#000;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:30000;';
                        const img = document.createElement('img');
                        img.src = 'assets/Ending.png';
                        img.alt = 'Ending';
                        img.style.maxWidth = '90%';
                        img.style.maxHeight = '80%';
                        img.style.marginBottom = '24px';
                        overlay.appendChild(img);
                        const prompt = document.createElement('div');
                        prompt.textContent = 'Press FIRE to choose a permanent ability';
                        prompt.style.cssText = 'color:#ffd700;font:20px Arial;text-shadow:0 0 8px #aa8800;';
                                // Make the prompt a controller-focusable target so gamepads can confirm the ending screen
                                try {
                                    prompt.setAttribute('data-gp-focus', '1');
                                    prompt.tabIndex = 0; // allow focus/scrollIntoView
                                    prompt.style.cursor = 'pointer';
                                    prompt.onclick = (ev) => {
                                        try { if (document.getElementById('endingOverlay')) document.getElementById('endingOverlay').remove(); } catch(_) {}
                                        try { offerPermanentAbilityChoice(); } catch(_) {}
                                        game._finalAbilityOffered = true;
                                        if (ev && typeof ev.preventDefault === 'function') ev.preventDefault();
                                    };
                                } catch(_) {}
                                overlay.appendChild(prompt);
                                // Immediately set controller focus to the ending overlay so A/Fire will activate the prompt
                                try {
                                    game.uiNav = game.uiNav || {};
                                    game.uiNav.container = overlay;
                                    game.uiNav.items = gatherFocusables(overlay);
                                    // Prefer the prompt element when present
                                    let idx = 0;
                                    for (let i=0;i<game.uiNav.items.length;i++) {
                                        const el = game.uiNav.items[i];
                                        if (el && el.getAttribute && el.getAttribute('data-gp-focus') === '1') { idx = i; break; }
                                    }
                                    game.uiNav.index = idx;
                                    applyGpFocus();
                                    // Gate immediate confirm: if the player is holding the fire button when
                                    // the overlay appears, require them to release then press again. Also
                                    // start a short guard timer so accidental taps don't immediately confirm.
                                    try {
                                        const now = (performance && performance.now) ? performance.now() : Date.now();
                                        game.uiNav.lastFire = !!(game.input && game.input.gpFire);
                                        game.uiNav.lastFireAt = now;
                                    } catch(_) {}
                                } catch(_) {}
                        document.body.appendChild(overlay);
                        console.info('[Endgame] Ending overlay displayed. Awaiting SPACE for permanent ability choice.');
                    }
                }

                // The Quacken defeat: announce release once per profile
                try {
                    const eq = (enemy && enemy.type) ? String(enemy.type).trim() : '';
                    if (eq && /quacken/i.test(eq)) {
                        let alreadyReleased = false;
                        try {
                            if (game && game._quackenReleased) alreadyReleased = true;
                            if (!alreadyReleased && typeof localStorage !== 'undefined' && localStorage && typeof localStorage.getItem === 'function') {
                                const stored = localStorage.getItem('quackenReleased');
                                if (stored === '1') {
                                    alreadyReleased = true;
                                    try { game._quackenReleased = true; } catch(_){ }
                                }
                            }
                        } catch(_){ }
                        const firstDefeat = !alreadyReleased;
                        if (firstDefeat) {
                            try { game._quackenReleased = true; } catch(_){ }
                            try { if (typeof localStorage !== 'undefined' && localStorage && typeof localStorage.setItem === 'function') localStorage.setItem('quackenReleased', '1'); } catch(_){ }
                            try {
                                game.player = game.player || {};
                                game.player._seenAbilities = game.player._seenAbilities || {};
                                game.player._seenAbilities['Release the Quacken!'] = true;
                                if (typeof saveSeenAbilities === 'function') saveSeenAbilities();
                            } catch(_){ }
                        } else {
                            try { game._quackenReleased = true; } catch(_){ }
                        }
                        try { if (window._bulletImages && typeof window._bulletImages.loadQuackenTentacle === 'function') window._bulletImages.loadQuackenTentacle(); } catch(_){ }
                        try { if (typeof unlock === 'function') unlock('releaseTheQuacken'); } catch(_){ }
                        const toastNeeded = firstDefeat || !game._quackenToastShownRun;
                        try { console.info('[Quacken] defeat', { firstDefeat, toastNeeded, runShown: game && game._quackenToastShownRun }); } catch(_){ }
                        if (toastNeeded) {
                            try {
                                try { console.info('[Quacken] toast helpers', { stackType: typeof showStackedToast, windowStack: typeof (window && window.showStackedToast), toastType: typeof showToast, windowToast: typeof (window && window.showToast) }); } catch(_){ }
                                try { if (typeof window !== 'undefined' && window && typeof showStackedToast === 'function' && !window.showStackedToast) window.showStackedToast = showStackedToast; } catch(_){ }
                                try { if (typeof window !== 'undefined' && window && typeof showToast === 'function' && !window.showToast) window.showToast = showToast; } catch(_){ }
                                const toastMsg = firstDefeat ? 'The Quacken has been released!' : 'The Quacken has been defeated!';
                                const toastSubtitle = firstDefeat ? 'New ability added to pool' : 'Release the Quacken! added to ability pool';
                                const ttl = firstDefeat ? 12000 : 12000;
                                if (typeof showStackedToast === 'function') {
                                    try { console.info('[Quacken] using stacked toast'); } catch(_){ }
                                    showStackedToast(toastMsg, { subtitle: toastSubtitle, ttl });
                                } else if (typeof showToast === 'function') {
                                    try { console.info('[Quacken] stacked toast unavailable; using standard toast'); } catch(_){ }
                                    showToast(toastMsg, { subtitle: toastSubtitle, ttl });
                                } else if (typeof window !== 'undefined' && window && typeof window.showToast === 'function') {
                                    try { console.info('[Quacken] using window.showToast fallback'); } catch(_){ }
                                    window.showToast(toastMsg, { subtitle: toastSubtitle, ttl });
                                }
                            } catch(_){ }
                            try { game._quackenToastShownRun = true; } catch(_){ }
                        }
                        if (firstDefeat) {
                            try { if (typeof devLog === 'function') devLog('[Quacken] first defeat recorded'); } catch(_){ }
                        }
                    }
                } catch(e) { try { console.warn('[Quacken] death-check failed', e); } catch(_){ } }

                // Golden Goose defeat: unlock Act II (robust match + debug log)
                try { console.info('[Death] processing dead enemy type:', enemy && enemy.type); } catch(_){}
                try {
                    game._goldenGooseDefeated = game._goldenGooseDefeated || false;
                    const et = (enemy && enemy.type) ? String(enemy.type).trim() : '';
                    if (et && /golden\s*goose/i.test(et)) {
                        try { game._goldenGooseDefeated = true; } catch(_){ }
                        try {
                            if (!game._actIIUnlocked) {
                                try {
                                    // Log and show toast for non-final-spawn kills so the player sees the unlock immediately
                                    try { if (enemy && enemy.finalBoss) {
                                        safeUnlockActII('Golden Goose defeat;final-boss');
                                    } else {
                                        try { if (typeof devLog === 'function') devLog('[GoldenGoose] unlocking Act II (normal spawn)'); } catch(_){}
                                        try { if (typeof showToast === 'function') showToast('Act II unlocked!'); } catch(_){}
                                        safeUnlockActII('Golden Goose defeat');
                                    } } catch(e) { throw e; }
                                } catch(e) { try { console.warn('[GoldenGoose] unlock handler failed', e); } catch(_){} }
                            }
                        // Also unlock the Golden Goose achievement. Make the special ability
                        // available in the ability chest/pool (do NOT grant it permanently here).
                        try { if (typeof unlock === 'function') unlock('gooseGoldenTeeth'); } catch(_) {}
                        try {
                            // Do NOT grant the ability immediately on defeat. Instead mark it as discovered/unlocked
                            // so it can appear in future ability chests. Persist the seen state so future runs know it's
                            // available. Also start the deferred load for the gold-tooth sprite so it's ready if the
                            // player later obtains the ability from a chest.
                            try {
                                game.player._seenAbilities = game.player._seenAbilities || {};
                                game.player._seenAbilities['Gooster Teeth'] = true;
                                try { if (typeof saveSeenAbilities === 'function') saveSeenAbilities(); } catch(_) {}
                            } catch(_) {}
                            try { if (window._bulletImages && typeof window._bulletImages.loadGoldTooth === 'function') window._bulletImages.loadGoldTooth(); } catch(_) {}
                            try {
                                if (typeof showStackedToast === 'function') {
                                    showStackedToast('A strange golden ability is now discoverable in ability chests.', { ttl: 12000 });
                                } else if (typeof showToast === 'function') {
                                    showToast('A strange golden ability is now discoverable in ability chests.', { ttl: 12000 });
                                }
                            } catch(_) {}
                        } catch(_) {}
                        } catch(e) { try { console.warn('[GoldenGoose] unlock handler failed', e); } catch(_){} }
                    }
                } catch(e) { try { console.warn('[GoldenGoose] death-check failed', e); } catch(_){} }
                // Wunderswan defeat: unlock 'Wunderbar' achievement on first kill
                try {
                    const et2 = (enemy && enemy.type) ? String(enemy.type).trim() : '';
                    if (et2 && /wunderswan/i.test(et2)) {
                        try { game._wunderswanDefeated = game._wunderswanDefeated || false; } catch(_){}
                        if (!game._wunderswanDefeated) {
                            try { game._wunderswanDefeated = true; } catch(_){ }
                            try { if (typeof unlock === 'function') unlock('wunderbar'); } catch(_){}
                            try { if (typeof showToast === 'function') showToast('Wunderbar! The Wunderswan has been defeated.'); } catch(_){}
                            // Mark Wunder Doodle as discoverable (do NOT grant on this run). Persist seen state and
                            // start lazy-loading the asset so chests offering it will display it correctly.
                            try {
                                game.player._seenAbilities = game.player._seenAbilities || {};
                                game.player._seenAbilities['Wunder Doodle'] = true;
                                try { if (typeof saveSeenAbilities === 'function') saveSeenAbilities(); } catch(_) {}
                            } catch(_) {}
                            try { if (window._bulletImages && typeof window._bulletImages.loadWunderDoodle === 'function') window._bulletImages.loadWunderDoodle(); } catch(_) {}
                            try { if (window._bulletImages && typeof window._bulletImages.loadWunderScribble === 'function') window._bulletImages.loadWunderScribble(); } catch(_) {}
                            try { if (typeof showToast === 'function') showToast('A new strange ability (Wunder Doodle) is now discoverable in ability chests.'); } catch(_) {}
                        }
                    }
                } catch(e) { try { console.warn('[Wunderswan] death-check failed', e); } catch(_){} }
                
                // Life steal healing
                let totalLifeSteal = 0;
                game.player.abilities.forEach(ability => {
                    const abilityData = ABILITIES[ability];
                    if (abilityData && abilityData.effect.lifeSteal) {
                        totalLifeSteal += abilityData.effect.lifeSteal;
                    }
                });
                
                if (totalLifeSteal > 0) {
                    const healAmount = Math.floor(25 * totalLifeSteal);
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + healAmount);
                    addParticle(game.player.x, game.player.y - 20, '#00FF00', 'heal');
                    updateUI();
                }

                // Chance to drop a health bread slice (pickup heals 25)
                // Base 10% chance; modified by Treasure Hunter (breadDropBonus adds percentage multiplicatively)
                let dropChance = 0.10;
                if (game.player.abilities.includes('Treasure Hunter')) {
                    const th = ABILITIES['Treasure Hunter'];
                    if (th && th.effect && th.effect.breadDropBonus) {
                        dropChance *= (1 + th.effect.breadDropBonus); // e.g., 0.10 * 1.5 = 0.15
                    }
                }
                if (Math.random() < dropChance && game.pickups.length < 40) {
                    game.pickups.push({
                        type: 'bread',
                        x: enemy.x + (Math.random()-0.5)*12,
                        y: enemy.y + (Math.random()-0.5)*12,
                        spawnTime: performance.now(),
                        collected: false
                    });
                }
            });
            
            game.enemies = game.enemies.filter(enemy => enemy.health > 0);
        }

        // Post-update status ticks: doom and weakness durations
        (function postStatusTick() {
            game.enemies.forEach(enemy => {
                if (enemy.doomed) {
                    enemy.doomTime = (enemy.doomTime || 0) - 1;
                    if (enemy.doomTime <= 0) {
                        enemy.doomed = false;
                    } else {
                        enemy.health -= 0.9;
                        if (Math.random() < 0.12) addParticle(enemy.x, enemy.y, '#880088', 'impact');
                    }
                }
                // Corrosion: periodic true damage & temporary armor reduction
                if (enemy.corroded) {
                    enemy.corrodeTime = (enemy.corrodeTime || 0) - 1;
                    if ((enemy.corrodeTime % 30) === 0) {
                        enemy.health -= 2; // small true damage
                        addParticle(enemy.x, enemy.y, '#44FF44', 'impact');
                    }
                    if (enemy.corrodeTime <= 0) {
                        enemy.corroded = false;
                        // remove one stack of armorShredded if present
                        if (enemy.armorShredded) enemy.armorShredded = Math.max(0, enemy.armorShredded - 1);
                    }
                }
                // Void touched: small periodic true damage
                if (enemy.voidTouched) {
                    enemy.voidTime = (enemy.voidTime || 0) - 1;
                    if ((enemy.voidTime % 40) === 0) {
                        enemy.health -= 3;
                        addParticle(enemy.x, enemy.y, '#AA00FF', 'impact');
                    }
                    if (enemy.voidTime <= 0) enemy.voidTouched = false;
                }
                // Bleeding: periodic physical damage (half mitigated by armor)
                if (enemy.bleeding) {
                    enemy.bleedTime = (enemy.bleedTime || 0) - 1;
                    if ((enemy.bleedTime % 25) === 0) {
                        const base = 4;
                        const mitigated = Math.max(1, base - (enemy.armor || 0) * 0.5);
                        enemy.health -= mitigated;
                        addParticle(enemy.x, enemy.y, '#CC2222', 'impact');
                    }
                    if (enemy.bleedTime <= 0) enemy.bleeding = false;
                }
                if (enemy.weakness) {
                    enemy.weaknessTime = (enemy.weaknessTime || 0) - 1;
                    if (enemy.weaknessTime <= 0) enemy.weakness = false;
                }
                if (enemy.cursed) {
                    enemy.curseTime = (enemy.curseTime || 0) - 1;
                    if (enemy.curseTime <= 0) enemy.cursed = false;
                }

                // Wunderswan periodic audio queue: if scheduled and not currently playing, start next sound every ~10s
                if (enemy.type === 'Wunderswan') {
                    try {
                        // Respect global stop flag set on Wunderswan death to avoid orphaned playback
                        if (game && game._wunderswanAudioStopped) return;
                        const now = Date.now();
                        // Ensure newly spawned Wunderswan instances get an initial scheduled time
                        if (!enemy._wunderswanAudioNextAt) {
                            try { const jitterInit = Math.floor(Math.random() * 3000); enemy._wunderswanAudioNextAt = now + 8000 + jitterInit; } catch(_) { enemy._wunderswanAudioNextAt = now + 10000; }
                        }
                        if (enemy._wunderswanAudioNextAt && now >= enemy._wunderswanAudioNextAt) {
                            // Always advance the timer so clips don't bunch when SFX are disabled
                            const baseNext = now + 10000;
                            // Small random jitter so clips don't feel robotic
                            const jitter = Math.floor(Math.random() * 2500); // 0..2499 ms
                            enemy._wunderswanAudioNextAt = baseNext + jitter;

                            // Respect global SFX toggle
                            if (game && game.sfxEnabled === false) {
                                // do not attempt to play, but keep scheduling
                                /* skip play while SFX disabled */
                            }

                            // Defensive: ensure we have a preloaded list
                            const list = game._wunderswanAudioList && game._wunderswanAudioList.length ? game._wunderswanAudioList : null;
                            if (!list) {
                                // nothing to play
                                /* skip: no audio list available */
                            }

                            // Attempt to start a clip each interval (don't permanently skip if one is playing).
                                if (list && list.length && game && game.sfxEnabled !== false) {
                                const ri = Math.floor(Math.random() * list.length);
                                const src = (list[ri] && list[ri].src) ? list[ri].src : null;
                                if (src) {
                                    try {
                                        // Debug: trace attempt to play a Wunderswan clip
                                        try { console.debug('[Wunderswan][AUDIO] attempt play (freshAudio)', { time: Date.now(), ri: ri, playingPtr: !!game._wunderswanAudioPlaying }); } catch(_){ }
                                        // Create a fresh Audio each interval to avoid issues where an <audio> element
                                        // cannot be reused due to browser state or prior failed play attempts.
                                        const fresh = new Audio(src);
                                        fresh.preload = 'auto';
                                        fresh.onended = function() { try { if (game && game._wunderswanAudioPlaying === fresh) { game._wunderswanAudioPlaying = null; try { console.debug('[Wunderswan][AUDIO] onended cleared pointer'); } catch(_){} } } catch(_){} };
                                        try { fresh.currentTime = 0; } catch(_){}
                                        const p = fresh.play();
                                        if (p && typeof p.then === 'function') {
                                            p.then(() => { try { game._wunderswanAudioPlaying = fresh; try { console.debug('[Wunderswan][AUDIO] play() resolved, pointer set'); } catch(_){} } catch(_){} }).catch((err)=>{ try{ if (game && game._wunderswanAudioPlaying === fresh) game._wunderswanAudioPlaying = null; try { console.warn('[Wunderswan][AUDIO] play() rejected', err && err.message ? err.message : err); } catch(_){} }catch(_){} });
                                        } else {
                                            game._wunderswanAudioPlaying = fresh;
                                            try { console.debug('[Wunderswan][AUDIO] play() returned no-promise, pointer set'); } catch(_){ }
                                        }
                                    } catch(err) {
                                        try { if (game && game._wunderswanAudioPlaying === fresh) game._wunderswanAudioPlaying = null; } catch(_){ }
                                        try { console.warn('[Wunderswan][AUDIO] play attempt threw', err && err.message ? err.message : err); } catch(_){ }
                                    }
                                }
                            }
                        }
                        // Clean pointer if current audio has ended naturally
                        if (game._wunderswanAudioPlaying && game._wunderswanAudioPlaying.ended) {
                            game._wunderswanAudioPlaying = null;
                        }
                    } catch(_) {}
                }
            });
        })();

        // Legacy projectile update retained for reference (now superseded by SoA: game.updateProjectilesSoA)
        function updateProjectiles() {
            return; // no-op: all projectile motion handled in SoA system
            // Helper to safely obtain (or recompute) projectile speed.
            const getProjSpeed = (p) => {
                if (!p) return 0.0001;
                if (p._agg && p._agg.baseSpeed) return p._agg.baseSpeed;
                return Math.sqrt(p.vx*p.vx + p.vy*p.vy) || 0.0001;
            };
            game.projectiles = game.projectiles.filter(proj => {
                // Pattern Amplification (SHOOTING INTENSIFIES)
                // We apply a one-time per-frame amplification to pattern-induced lateral/oscillatory components.
                // Implementation approach: after each pattern block mutates velocity (later in the function), we scale
                // key stored intermediate amplitudes. To avoid deep invasive edits across every pattern branch, we
                // apply a consolidated multiplier early that downstream calculations reference. New patterns should
                // consult proj._patternAmpFactor if needing amplitude. Existing code using literal values will receive
                // a post-hoc velocity inflation (controlled) to approximate amplitude boost.
                if (!proj._patternAmpTagged) {
                    // Base factor: +40% amplitude/speed for wave/spiral like motions.
                    let amp = 1.0;
                    if (!proj.enemy && game.player && game.player.abilities && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.patternAmplify)) {
                        amp = 1.6; // increased from 1.4 to make the ability more noticeable
                        // Slight scaling if multiple core patterns active (diminishing stacking): add up to +10% more.
                        const patternFlags = ['sineWave','wackyZigzag','ekgWave','spiral','spiralPattern','uzumaki','helixPair','lissajousPattern','slalomPattern','pendulumPattern','sawWave','pivotPattern','convergePair','spiralBloom','temporalDrift','veeringFan','echoBloom'];
                        let count = 0; for (const f of patternFlags) if (proj[f]) count++;
                        if (count > 1) amp *= (1 + Math.min(0.10, (count-1)*0.025));
                        // Store factor for downstream logic that may reference it.
                        proj._patternAmpFactor = amp;
                    } else {
                        proj._patternAmpFactor = 1.0;
                    }
                    proj._patternAmpTagged = true; // mark so we don't recompute excessively
                }
                // Capture pre-pattern position each frame for reliable bounce rewind when complex patterns adjust position before base move.
                proj._prePatternX = proj.x;
                proj._prePatternY = proj.y;
                // Lightning projectile spark trail (visual only)
                if (!proj.enemy && (proj.damageType === 'lightning' || proj.damageType === 'storm')) {
                    if (Math.random() < 0.45) {
                        addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFFFAA', 'lightning');
                    }
                    if (Math.random() < 0.18) {
                        addParticle(proj.x, proj.y, '#FFF6AA', 'spark');
                    }
                }
                // Dimensional Rift projectile interaction: refraction, bending, occasional duplication / teleport
                if (!proj.enemy && !proj.beam && game._dimRifts && game._dimRifts.length) {
                    for (let ri = 0; ri < game._dimRifts.length; ri++) {
                        const rift = game._dimRifts[ri];
                        if (!rift) continue;
                        const dxR = proj.x - rift.x;
                        const dyR = proj.y - rift.y;
                        const distR2 = dxR*dxR + dyR*dyR;
                        const rr = rift.r;
                        if (distR2 <= rr*rr) {
                            const distR = Math.sqrt(distR2) || 1;
                            // Lens bending: mix current velocity with a tangential component to create an arc around center
                            if (!proj._riftBent) {
                                const vx = proj.vx; const vy = proj.vy;
                                // Tangent vector (perpendicular to radius) for swirling deflection
                                const tx = -dyR / distR; const ty = dxR / distR;
                                // Strength scales with closeness to center (stronger near core)
                                const closeness = 1 - (distR / rr);
                                const bend = 0.35 * closeness; // tunable
                                // Blend velocities
                                proj.vx = vx * (1 - bend) + tx * getProjSpeed(proj) * bend;
                                proj.vy = vy * (1 - bend) + ty * getProjSpeed(proj) * bend;
                                proj._riftBent = true;
                                // Slight life extension so refracted shots persist visually
                                proj.life += 4;
                            }
                            // Refraction / duplication (single time per projectile per rift)
                            if (!proj._riftRefracted) {
                                const canDuplicate = game.projectilesSoA ? (game.projectilePool.active() < 1200) : false; // safety cap via SoA count
                                if (canDuplicate && Math.random() < 0.34) {
                                    const copies = (Math.random() < 0.25) ? 2 : 1; // occasionally spawn two extra
                                    for (let c=0; c<copies; c++) {
                                        const ang = Math.atan2(proj.vy, proj.vx) + (Math.random()*0.9 - 0.45); // wide scatter
                                        const spd = getProjSpeed(proj) * (0.75 + Math.random()*0.4);
                                        const lifeChild = Math.max(40, Math.floor(proj.life * (0.55 + Math.random()*0.25)));
                                        const childBase = Math.max(1, Math.floor((proj.baseDamage || proj.damage || calculateDamage()) * 0.8));
                                        const dupIdx = game.spawnProjectile({
                                            x: proj.x + Math.cos(ang)*6,
                                            y: proj.y + Math.sin(ang)*6,
                                            vx: Math.cos(ang)*spd,
                                            vy: Math.sin(ang)*spd,
                                            life: lifeChild,
                                            r: Math.max(2, Math.min(28, Math.floor((proj.size||6)*0.9))),
                                            damage: childBase,
                                            damageType: proj.damageType || null,
                                            sineWave: proj.sineWave, wackyZigzag: proj.wackyZigzag, ekgWave: proj.ekgWave, spiralPattern: proj.spiral
                                        });
                                        if (!game._projMeta) game._projMeta = new Map();
                                        if (dupIdx>=0) game._projMeta.set(dupIdx,{ baseDamage: childBase, _riftChild:true, _riftBent:true, _riftRefracted:true });
                                        addParticle((proj.x + Math.cos(ang)*6), (proj.y + Math.sin(ang)*6), '#AA44FF', 'spark');
                                    }
                                }
                                proj._riftRefracted = true;
                            }
                            // Chance to micro-teleport projectile to rim, preserving direction
                            if (!proj._riftTeleported && Math.random() < 0.12) {
                                const dirAng = Math.atan2(proj.vy, proj.vx);
                                // place on circumference slightly ahead in direction to create skip feel
                                const offsetAng = dirAng + (Math.random()*0.4 - 0.2);
                                const radius = rr * (0.85 + Math.random()*0.15);
                                proj.x = rift.x + Math.cos(offsetAng) * radius;
                                proj.y = rift.y + Math.sin(offsetAng) * radius;
                                // Slight speed boost to emphasize warp
                                proj.vx *= 1.12; proj.vy *= 1.12;
                                proj._riftTeleported = true;
                                addParticle(proj.x, proj.y, '#DD88FF', 'explosion');
                            }
                            // Mark projectile to ignore armor while inside rift (per ability desc) until it leaves radius once
                            proj.ignoresArmor = true;
                            break; // only interact with first rift per frame
                        } else if (proj._riftBent && distR2 > rr*rr*1.21) {
                            // Once clearly outside, allow future bending again if it re-enters another rift
                            proj._riftBent = false;
                        }
                    }
                }
                if (proj.smartExplosive && !proj.enemy && proj.life > 0) {
                    let closest = Infinity;
                    for (let e of game.enemies) {
                        const d = Math.hypot(e.x - proj.x, e.y - proj.y);
                        if (d < closest) closest = d;
                    }
                    if (closest < 60) {
                        // Pre-fuse cue when very close but before detonation
                        if (closest > 26 && !(game.fxFlags && game.fxFlags.reduceRings)) {
                            if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFCC99', radius: 22, life: 120 });
                        }
                        // Draw a brief inner safe-radius halo and a last-moment radial tick as it arms
                        if (closest <= 32) {
                            // cache one-time arming timestamp to time the tick
                            if (!proj._sbArmAt) proj._sbArmAt = performance.now();
                            const since = performance.now() - proj._sbArmAt;
                            // Safe halo (transient effect): small, persistent hint around the smart bomb core
                            if (since < 220 && typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFE4CC', radius: 14, life: 120 });
                            }
                            // Last-moment tick: very short inner pulse right before detonation
                            if (since > 140 && since < 180 && typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFFFFF', radius: 10, life: 60 });
                                if (!(game.perf && game.perf.lowFx)) addScreenShake(0.75);
                            }
                        } else {
                            // reset arming timer if we drift farther away again
                            proj._sbArmAt = null;
                        }
                    }
                    if (closest < 48) {
                        explodeProjectile(proj, calculateDamage());
                        proj.life = 0;
                        return false;
                    }
                }
                // Growing effect (enhanced):
                //  - Higher max size (≈4.25x base) with soft cap & diminishing returns near end
                //  - Early growth slightly faster; slows as it approaches cap
                //  - Pattern synergy: if projectile also has spiral OR sineWave, grant mild extra growth potential
                //  - Infusion synergy: active infusions raise cap modestly (stacking small boosts)
                if (proj.growing && !proj.enemy) {
                    const start = (typeof proj._initialSize === 'number') ? proj._initialSize : 4;
                    if (!proj._growInit) {
                        proj._growInit = true;
                        proj._growTicks = 0;
                        // Base cap multiplier
                        let baseCapMult = 4.0; // from 2.5 -> 4.0 baseline
                        // Motion pattern synergy adds headroom
                        if (proj.spiral) baseCapMult += 0.35;
                        if (proj.sineWave) baseCapMult += 0.25;
                        // Wacky / EKG minor extra (avoid runaway)
                        if (proj.wackyZigzag) baseCapMult += 0.15;
                        if (proj.ekgWave) baseCapMult += 0.15;
                        // Infusion scaling (each adds 4% cap up to +12%)
                        if (proj.infusionElements && proj.infusionElements.length) {
                            baseCapMult += Math.min(0.12, 0.04 * proj.infusionElements.length);
                        }
                        // Store absolute cap and softCap start (where diminishing returns start)
                        proj._growHardCap = start * baseCapMult; // absolute max
                        proj._growSoftCap = start * (baseCapMult * 0.78); // start easing here
                    }
                    proj._growTicks++;
                    const size = proj.size;
                    const hardCap = proj._growHardCap;
                    const softCap = proj._growSoftCap;
                    if (size < hardCap - 0.05) {
                        // Base growth factor: early faster (first 40 ticks), then normal
                        const earlyPhase = proj._growTicks < 40;
                        let growthRate = earlyPhase ? 1.032 : 1.018; // multiplicative
                        // Diminishing returns after soft cap: interpolate toward 1.0 multiplier
                        if (size > softCap) {
                            const t = (size - softCap) / (hardCap - softCap); // 0..1
                            const damp = 1 - Math.min(1, t); // remaining growth influence
                            growthRate = 1 + (growthRate - 1) * damp * 0.85; // reduce acceleration steeply
                        }
                        // Safety clamp (avoid micro-floating above cap)
                        const newSize = Math.min(size * growthRate, hardCap);
                        proj.size = newSize;
                    }
                }
                // Spiral in-flight motion: looping swirl around the forward path
                if (proj.spiral && !proj.enemy) {
                    // Initialize loop parameters on first pass
                    if (!proj._loopInitialized) {
                        proj._loopInitialized = true;
                        // Prefer the initial firing direction if present so spirals curve around the original path
                        proj._forwardSpeed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) || 0.0001;
                        const initFx = typeof proj._initialFx === 'number' ? proj._initialFx : (proj.vx / proj._forwardSpeed);
                        const initFy = typeof proj._initialFy === 'number' ? proj._initialFy : (proj.vy / proj._forwardSpeed);
                        // normalize captured forward vector
                        const inorm = Math.sqrt(initFx*initFx + initFy*initFy) || 0.0001;
                        proj._fx = initFx / inorm;
                        proj._fy = initFy / inorm;
                        proj._px = -proj._fy; // perpendicular unit
                        proj._py = proj._fx;
                        proj._loopRadius = 6 + Math.random() * 10; // loop radius in px
                        proj._loopAngle = 0;
                        proj._loopSpeed = 0.22 + Math.random() * 0.36; // how fast it spins around
                        proj._lastLoopOffsetX = 0;
                        proj._lastLoopOffsetY = 0;
                    }
                    // advance loop angle (spinDir keeps earlier randomness)
                    proj._loopAngle += proj._loopSpeed * (proj.spinDir || 1);

                    // Optionally modulate radius slightly for breathing effect
                    const radiusMod = proj._loopRadius * (0.85 + 0.3 * Math.sin(proj._loopAngle * 0.7));

                    // compute offset in perpendicular direction to create loops around centerline
                    const offsetX = proj._px * Math.cos(proj._loopAngle) * radiusMod;
                    const offsetY = proj._py * Math.cos(proj._loopAngle) * radiusMod;

                    // forward motion remains the principal velocity
                    const forwardMoveX = proj._fx * proj._forwardSpeed;
                    const forwardMoveY = proj._fy * proj._forwardSpeed;

                    // desired velocity is forward plus the delta of offset to create local loop travel
                    const desiredVx = forwardMoveX + (offsetX - proj._lastLoopOffsetX) * 0.6;
                    const desiredVy = forwardMoveY + (offsetY - proj._lastLoopOffsetY) * 0.6;

                    proj._lastLoopOffsetX = offsetX;
                    proj._lastLoopOffsetY = offsetY;

                    // softly lerp current velocity toward desired velocity so motion is smooth
                    // If Uzumaki is also active, give Spiral a touch more influence so local loops remain apparent
                    const spMix = (proj.uzumaki ? 0.22 : 0.16);
                    proj.vx = proj.vx * (1 - spMix) + desiredVx * spMix;
                    proj.vy = proj.vy * (1 - spMix) + desiredVy * spMix;
                    // keep life stable
                    proj.life -= 0;
                }
                // Uzumaki (object-mode): initialize only; actual motion contribution is applied via the pattern aggregator below
                if (proj.uzumaki && !proj.enemy) {
                    if (!proj._uzuInit) {
                        proj._uzuInit = true;
                        // Anchor center at player's position at spawn (stationary center) for consistent swirl.
                        proj._uzuCx = proj._spawnPlayerX || game.player.x; // fallback if not set
                        proj._uzuCy = proj._spawnPlayerY || game.player.y;
                        proj._uzuAngle = Math.atan2(proj.y - proj._uzuCy, proj.x - proj._uzuCx);
                        proj._uzuRadius = 18; // initial radius from center
                        proj._uzuAngularVel = 0.18 + Math.random()*0.04; // base rotational speed
                        proj._uzuRadialVel = 1.4 + Math.random()*0.4; // outward expansion speed
                        proj._uzuDrag = 0.000; // radial drag currently unused (kept for tuning)
                        // Shorter life so spiral stream refreshes
                        proj.life = Math.min(proj.life, 120 + (Math.random()*30)|0);
                    }
                    // State evolution + velocity contribution occurs inside aggregator to stack with other patterns
                }
                // Pattern amplification has been moved later (near base-move integration) so that it consistently
                // amplifies both velocity-modifying patterns and position-based pattern displacements. See later
                // insertion for the consolidated implementation.
                // === New Pattern Motions ===
                // Helix Pair lateral orbiting around forward trajectory (applied before aggregation so it influences basis subtly)
                if (proj.helixPair && proj._helixSide) {
                    if (!proj._helixInit) {
                        proj._helixInit = true;
                        // capture forward direction
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._helixSpeed = sp;
                        proj._helixFx = proj.vx / sp; proj._helixFy = proj.vy / sp;
                        proj._helixPx = -proj._helixFy; proj._helixPy = proj._helixFx;
                    }
                    proj._helixPhase += 0.25; // spin speed
                    // Ease radius toward target (wider look) then gently breathe
                    if (proj._helixTargetRadius) {
                        const diff = proj._helixTargetRadius - proj._helixRadius;
                        proj._helixRadius += diff * 0.045; // approach target smoothly
                    }
                    // Mild breathing after near target
                    if (Math.abs(proj._helixTargetRadius - proj._helixRadius) < 1.5) {
                        proj._helixRadius += Math.sin(proj._helixPhase*0.18 + (proj._helixSide||1)) * 0.20;
                    }
                    const radius = proj._helixRadius * 0.55; // scaling to keep on-screen clarity
                    const off = Math.sin(proj._helixPhase) * radius * proj._helixSide;
                    proj.x += proj._helixPx * off * 0.11;
                    proj.y += proj._helixPy * off * 0.11;
                }
                // Lissajous pattern: evolving figure-eight / knot path with dynamic frequency ratio, amplitude flips, and motion pulses (intensified)
                if (proj.lissajousPattern && !proj.enemy && !proj.beam) {
                    if (!proj._lissaInit) {
                        proj._lissaInit = true;
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._lissaFx = proj.vx / sp; proj._lissaFy = proj.vy / sp; // forward basis
                        proj._lissaPx = -proj._lissaFy; proj._lissaPy = proj._lissaFx; // lateral basis
                        proj._lissaT = 0;
                        // amplitude envelope (wider for clearer figure)
                        // Tunables: widen factor allows quick global scaling.
                        proj._lissaWidenFactor = 2.05; // intensified
                        proj._lissaBaseA = (24 + Math.random()*10) * proj._lissaWidenFactor;
                        proj._lissaBaseB = (16 + Math.random()*8) * (proj._lissaWidenFactor * 0.85);
                        proj._lissaA = proj._lissaBaseA;
                        proj._lissaB = proj._lissaBaseB;
                        // start with near 1:2 ratio then morph toward 2:3 or 3:4 to create evolving shape
                        proj._lissaFreqA = 0.16; // base horizontal component
                        proj._lissaFreqB = 0.32; // vertical double
                        proj._lissaTargetSets = [ [0.21,0.31], [0.24,0.40], [0.18,0.27] ];
                        proj._lissaCurTarget = 0;
                        proj._lissaPhase = Math.random()*Math.PI*2;
                        proj._lissaRot = 0; // slow rotation of local frame
                        proj._lissaLast = { x:0, y:0 };
                        proj._lissaFlipTimer = 70 + Math.floor(Math.random()*45); // slightly more frequent
                        proj._lissaPulseTimer = 50 + Math.floor(Math.random()*34); // slightly more frequent
                        proj._lissaSpeedPulse = 0; // frames of active speed modulation
                    }
                    proj._lissaT++;
                    // Periodically retarget frequency pair for evolving curve
                    if (proj._lissaT % 160 === 0) {
                        proj._lissaCurTarget = (proj._lissaCurTarget + 1) % proj._lissaTargetSets.length;
                    }
                    const tgt = proj._lissaTargetSets[proj._lissaCurTarget];
                    // Ease current freqs toward target
                    proj._lissaFreqA += (tgt[0] - proj._lissaFreqA) * 0.015;
                    proj._lissaFreqB += (tgt[1] - proj._lissaFreqB) * 0.015;
                    // Light amplitude breathing
                    const ampPulse = 1 + Math.sin(proj._lissaT*0.02)*0.08;
                    proj._lissaA = proj._lissaBaseA * ampPulse;
                    proj._lissaB = proj._lissaBaseB * (1 - Math.sin(proj._lissaT*0.017)*0.06);
                    // Amplitude flip event (swap roles & invert one axis briefly)
                    proj._lissaFlipTimer--;
                    if (proj._lissaFlipTimer === 0) {
                        const tmp = proj._lissaBaseA;
                        proj._lissaBaseA = proj._lissaBaseB;
                        proj._lissaBaseB = tmp * (0.90 + Math.random()*0.25);
                        proj._lissaFlipTimer = 95 + Math.floor(Math.random()*70);
                        // minor inversion of Y component for dramatic knot
                        proj._lissaFreqB *= (Math.random()<0.5? -1:1);
                        addParticle(proj.x, proj.y, '#66E0FF','spark');
                    }
                    // Speed pulse event: temporarily exaggerate lateral displacement
                    proj._lissaPulseTimer--;
                    if (proj._lissaPulseTimer === 0) {
                        proj._lissaPulseTimer = 140 + Math.floor(Math.random()*70);
                        proj._lissaSpeedPulse = 26; // frames, longer
                        addParticle(proj.x, proj.y, '#44F6FF','spark');
                    }
                    // path sample
                    const ax = Math.sin(proj._lissaT * proj._lissaFreqA + proj._lissaPhase) * proj._lissaA;
                    const ay = Math.sin(proj._lissaT * proj._lissaFreqB) * proj._lissaB * Math.sin(proj._lissaT*0.005 + proj._lissaPhase*0.5);
                    // diff to last sample -> local displacement
                    const dx = ax - proj._lissaLast.x;
                    const dy = ay - proj._lissaLast.y;
                    proj._lissaLast.x = ax; proj._lissaLast.y = ay;
                    // Rotate local frame slowly around forward vector to create figure-eight twist
                    proj._lissaRot += 0.0035;
                    const cosr = Math.cos(proj._lissaRot), sinr = Math.sin(proj._lissaRot);
                    // rotated perpendicular basis
                    const rPxX = proj._lissaPx * cosr + proj._lissaFx * sinr * 0.4; // slight coupling of forward to lateral for depth
                    const rPxY = proj._lissaPy * cosr + proj._lissaFy * sinr * 0.4;
                    const rFxX = proj._lissaFx * cosr - proj._lissaPx * sinr * 0.4;
                    const rFxY = proj._lissaFy * cosr - proj._lissaPy * sinr * 0.4;
                    // apply displacement
                    let pulseScale = 1;
                    if (proj._lissaSpeedPulse > 0) { pulseScale = 1.85; proj._lissaSpeedPulse--; }
                    // Increased displacement multipliers to widen path (scaled by widen factor)
                    const lateralScale = 0.34 * (proj._lissaWidenFactor || 1);
                    const forwardScale = 0.18 * (proj._lissaWidenFactor || 1); // slightly stronger forward component
                    proj.x += (rPxX * dx * lateralScale + rFxX * dy * forwardScale) * pulseScale;
                    proj.y += (rPxY * dx * lateralScale + rFxY * dy * forwardScale) * pulseScale;
                    // trailing particles with higher density during pulse
                    if (Math.random() < (proj._lissaSpeedPulse > 0 ? 0.22 : 0.085)) {
                        const col = proj._lissaSpeedPulse>0?'#55FFFF':'#AAEEFF';
                        addParticle(proj.x, proj.y, col,'spark');
                        // Occasional accent ring when pulse active for readability
                        if (proj._lissaSpeedPulse>0 && Math.random()<0.15) addParticle(proj.x, proj.y, '#66FFFF','ring');
                    }
                }
                // Slalom pattern: sharp gated zigzag (hold straight segments, sudden corner turns) (intensified)
                if (proj.slalomPattern && !proj.enemy && !proj.beam) {
                    if (!proj._slalomInit) {
                        proj._slalomInit = true;
                        proj._slalomSegment = 0; // frames into current segment
                        proj._slalomSegmentLen = 12; // shorter straight run
                        proj._slalomTurnAngle = 0.62; // stronger corner
                        proj._slalomDir = 1; // next turn direction sign
                        proj._slalomMaxSegments = 10; // after this revert to straight
                        proj._slalomMade = 0;
                        proj._slalomTrailTick = 0;
                    }
                    proj._slalomSegment++;
                    proj._slalomTrailTick++;
                    // Pre-cue the upcoming lane change shortly before the turn
                    if (proj._slalomMade < proj._slalomMaxSegments && proj._slalomSegment === (proj._slalomSegmentLen - 2)) {
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#AEEBFF', radius: 14, life: 110 });
                        }
                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) {
                            addParticle(proj.x, proj.y, '#AEEBFF', 'ring');
                        }
                        if (!(game.perf && game.perf.lowFx)) {
                            addScreenShake(0.5);
                        }
                    }
                    // light trailing particles while in segment to emphasize straightness
                    if (proj._slalomTrailTick % 7 === 0 && proj._slalomMade < proj._slalomMaxSegments) {
                        addParticle(proj.x, proj.y, '#BBD9FF','trail');
                    }
                    if (proj._slalomSegment >= proj._slalomSegmentLen && proj._slalomMade < proj._slalomMaxSegments) {
                        proj._slalomSegment = 0;
                        proj._slalomMade++;
                        // perform sharp corner turn
                        const ang = Math.atan2(proj.vy, proj.vx);
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        const newAng = ang + proj._slalomDir * proj._slalomTurnAngle;
                        const boost = 1.06;
                        proj.vx = Math.cos(newAng) * sp * boost;
                        proj.vy = Math.sin(newAng) * sp * boost;
                        // flip direction for next corner
                        proj._slalomDir *= -1;
                        // corner visual burst
                        for (let k=0;k<4;k++) addParticle(proj.x, proj.y, '#88C4FF','spark');
                    }
                    // After finishing designated segments, damp pattern to avoid wave illusions
                    if (proj._slalomMade >= proj._slalomMaxSegments) {
                        proj.slalomPattern = false; // stop further zigzagging; projectile resumes straight path
                    }
                }
                // Pendulum pattern: now additive — computes desired instantaneous velocity from swing physics
                // and contributes delta-V to the aggregator instead of directly overriding position/velocity.
                if (proj.pendulumPattern && !proj.enemy && !proj.beam) {
                    if (!proj._pendInit) {
                        proj._pendInit = true;
                        const sp = Math.hypot(proj.vx, proj.vy)||0.0001;
                        proj._pendBaseSpeed = sp; // base linear speed reference
                        proj._pendFx = proj.vx/sp; proj._pendFy = proj.vy/sp;
                        proj._pendPx = -proj._pendFy; proj._pendPy = proj._pendFx;
                        proj._pendAnchorX = proj.x; proj._pendAnchorY = proj.y;
                        proj._pendAngle = (Math.random()<0.5?1:-1) * 0.85; // larger initial deflection (~49°) to differentiate visually
                        proj._pendAngVel = 0;
                        proj._pendLength = 42 + Math.random()*14; // longer to exaggerate arc
                        proj._pendGravity = 0.07; // slightly higher for natural period
                        proj._pendDamp = 0.991;   // very gentle damping
                        proj._pendFrame = 0;
                        proj._pendMaxFrames = 240; // slightly longer showcase
                        proj._pendMinSwingVel = 0.0022;
                        proj._pendLastSign = Math.sign(proj._pendAngle);
                        proj._pendPeaks = 0;
                        proj._pendPrevSag = 0;
                    }
                    proj._pendFrame++;
                    // Physics integration
                    const angAcc = -proj._pendGravity * Math.sin(proj._pendAngle);
                    proj._pendAngVel += angAcc;
                    proj._pendAngVel *= proj._pendDamp;
                    proj._pendAngle += proj._pendAngVel;
                    // Detect peak (sign change in angular velocity or near-zero crossing of angle with opposite sign soon)
                    if (proj._pendLastSign !== 0) {
                        const curSign = Math.sign(proj._pendAngVel);
                        if (curSign !== 0 && curSign !== proj._pendLastSign) {
                            proj._pendPeaks++;
                            // Peak particle fan
                            if (!(game.fxFlags && game.fxFlags.hideSparks)) {
                                for (let k=0;k<5;k++) addParticle(proj.x + (Math.random()-0.5)*12, proj.y + (Math.random()-0.5)*12, '#FFD580','spark');
                            }
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) addParticle(proj.x, proj.y, '#88EEFF', 'ring');
                            if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#88EEFF', radius: 22, life: 160 });
                            if (!(game.perf && game.perf.lowFx)) addScreenShake(1);
                        }
                        proj._pendLastSign = curSign;
                    }
                    // Variable forward anchor advance: scaled by |cos(angle)| so it nearly pauses at peaks
                    const forwardScale = Math.max(0.15, Math.abs(Math.cos(proj._pendAngle))); // never fully zero
                    const fStep = proj._pendBaseSpeed * 0.9 * forwardScale; // slightly reduced base
                    // Anchor advances only for physics reference, not applied to absolute pos
                    proj._pendAnchorX += proj._pendFx * fStep;
                    proj._pendAnchorY += proj._pendFy * fStep;
                    // Lateral displacement and vertical sag (for visual depth estimation)
                    const lateral = Math.sin(proj._pendAngle) * proj._pendLength;
                    const sag = (1 - Math.cos(proj._pendAngle)) * (proj._pendLength * 0.20);
                    // Instantaneous velocity approximation as desired target
                    const latVel = Math.cos(proj._pendAngle) * proj._pendLength * proj._pendAngVel;
                    const instVx = proj._pendFx * fStep + proj._pendPx * latVel;
                    const instVy = proj._pendFy * fStep + proj._pendPy * latVel + (sag * 0.25 - (proj._pendPrevSag||0))*0.9;
                    proj._pendPrevSag = sag * 0.25;
                    // Contribute delta-V relative to current forward baseline
                    const curSp = Math.hypot(proj.vx, proj.vy) || 0.0001;
                    const curFx = proj.vx / curSp, curFy = proj.vy / curSp;
                    const baseVx = curFx * curSp;
                    const baseVy = curFy * curSp;
                    const dVX = instVx - baseVx;
                    const dVY = instVy - baseVy;
                    proj._aggDX = (proj._aggDX||0) + dVX;
                    proj._aggDY = (proj._aggDY||0) + dVY;
                    // Mark that a pattern contributed this frame
                    patternApplied = true;
                    // Trail particles more intense near center (fast) using cos-based intensity
                    const trailIntensity = 0.06 + Math.abs(Math.cos(proj._pendAngle))*0.12;
                    if (Math.random() < trailIntensity) addParticle(proj.x, proj.y, '#FFC899','spark');
                    // Termination: when angular velocity minimal OR time cap
                    if ((Math.abs(proj._pendAngVel) < proj._pendMinSwingVel && Math.abs(proj._pendAngle) < 0.12) || proj._pendFrame >= proj._pendMaxFrames) {
                        // Forward speed boost proportional to how many peaks (diminishing) — contribute as delta
                        const boost = 1 + Math.min(0.35, proj._pendPeaks * 0.05);
                        const finalSp = proj._pendBaseSpeed * boost;
                        const curSp2 = Math.hypot(proj.vx, proj.vy) || 0.0001;
                        const curFx2 = proj.vx / curSp2, curFy2 = proj.vy / curSp2;
                        const dVfx = curFx2 * (finalSp - curSp2);
                        const dVfy = curFy2 * (finalSp - curSp2);
                        proj._aggDX = (proj._aggDX||0) + dVfx;
                        proj._aggDY = (proj._aggDY||0) + dVfy;
                        for (let b=0;b<8;b++) addParticle(proj.x + (Math.random()-0.5)*14, proj.y + (Math.random()-0.5)*14, '#FFD9AA','spark');
                        proj.pendulumPattern = false;
                    }
                }
                // Sawtooth wave: slow drift then snap
                if (proj.sawWave && !proj.enemy && !proj.beam) {
                    if (!proj._sawInit) {
                        proj._sawInit = true;
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        proj._sawFx = proj.vx/sp; proj._sawFy = proj.vy/sp;
                        proj._sawPx = -proj._sawFy; proj._sawPy = proj._sawFx;
                        proj._sawT = 0;
                        proj._sawPeriod = 38 + Math.floor(Math.random()*14);
                        proj._sawAmp = 24 + Math.random()*10;
                    }
                    proj._sawT = (proj._sawT + 1) % proj._sawPeriod;
                    const t = proj._sawT / proj._sawPeriod; // 0..1
                    let wave = t; // ramp
                    // At snap point, invert quickly
                    if (t > 0.92) {
                        // One-frame flash ring to indicate the snap
                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) addParticle(proj.x, proj.y, '#FFE0B0', 'ring');
                        if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFD9AA', radius: 18, life: 120 });
                        if (!(game.perf && game.perf.lowFx)) addScreenShake(0.5);
                        wave = -1 + (t - 0.92)/0.08; // rapid return
                    }
                    const lateral = (wave - 0.46) * 2 * proj._sawAmp; // center
                    const dl = (lateral - (proj._sawLast||0));
                    proj._sawLast = lateral;
                    proj.x += proj._sawPx * dl * 0.12;
                    proj.y += proj._sawPy * dl * 0.12;
                }
                // Vector Pivot (pivotPattern): straight flight segments punctuated by crisp quarter-turn pivots.
                // Vector Pivot: now additive — computes a target turn and contributes delta-V rather than directly setting velocity.
                if (proj.pivotPattern && !proj.enemy && !proj.beam && !proj._orbital) {
                    if (!proj._pivotInit) {
                        proj._pivotInit = true;
                        proj._pivotInterval = 26 + Math.floor(Math.random()*10); // frames between pivots
                        proj._pivotTimer = 0;
                        proj._pivotDir = (Math.random()<0.5?1:-1); // rotation direction sign
                        proj._pivotEasing = 0; // 0..1 during active pivot
                        proj._pivotActive = false;
                        proj._pivotTurns = 0;
                        proj._pivotMaxTurns = 6;
                        proj._pivotBaseSpeed = Math.hypot(proj.vx, proj.vy)||1;
                    }
                    proj._pivotTimer++;
                    if (!proj._pivotActive && proj._pivotTimer >= proj._pivotInterval && proj._pivotTurns < proj._pivotMaxTurns) {
                        proj._pivotActive = true;
                        proj._pivotTimer = 0;
                        proj._pivotEasing = 0;
                        const sp = Math.hypot(proj.vx, proj.vy)||1;
                        proj._pivotStartVX = proj.vx/sp; proj._pivotStartVY = proj.vy/sp;
                        const tx = proj._pivotDir * -proj._pivotStartVY;
                        const ty = proj._pivotDir * proj._pivotStartVX;
                        proj._pivotTargetVX = tx; proj._pivotTargetVY = ty;
                        proj._pivotTurns++;
                        // choose next turn randomly instead of alternation
                        proj._pivotDir = (Math.random()<0.5?1:-1);
                        for (let k=0;k<4;k++) addParticle(proj.x, proj.y, '#FFD980','spark');
                        // Pivot start cue
                        if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) {
                            addParticle(proj.x, proj.y, '#66D6FF','ring');
                        }
                        // Reticule ringflash indicating new direction
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#9FE6FF', radius: 16, life: 120 });
                        }
                    }
                    if (proj._pivotActive) {
                        proj._pivotEasing += 0.12;
                        const p = proj._pivotEasing;
                        const ease = p < 1 ? (1 - Math.pow(1-p, 3)) : 1; // cubic ease-out
                        const nx = proj._pivotStartVX * (1 - ease) + proj._pivotTargetVX * ease;
                        const ny = proj._pivotStartVY * (1 - ease) + proj._pivotTargetVY * ease;
                        const spd = proj._pivotBaseSpeed;
                        const desiredVx = nx * spd;
                        const desiredVy = ny * spd;
                        // contribute delta relative to current velocity
                        proj._aggDX = (proj._aggDX||0) + (desiredVx - proj.vx);
                        proj._aggDY = (proj._aggDY||0) + (desiredVy - proj.vy);
                        patternApplied = true;
                        if (p >= 1) {
                            proj._pivotActive = false;
                            addParticle(proj.x, proj.y, '#FFC040','spark');
                            if (!(game.perf && game.perf.lowFx)) addParticle(proj.x, proj.y, '#AEEBFF','spark');
                        }
                    }
                    if (proj._pivotTurns >= proj._pivotMaxTurns) {
                        proj.pivotPattern = false;
                    }
                }
                // Temporal Drift: stronger cadence (object-mode): adjust both velocity and perceived displacement
                if (proj.temporalDrift && !proj.enemy && !proj.beam) {
                    if (!proj._tdInit) {
                        proj._tdInit = true;
                        proj._tdPhase = 0; // 0 slow-stretch, 1 hold, 2 surge
                        proj._tdTimer = 0;
                        // Capture base speed for clamping
                        const sp0 = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        proj._tdBaseSpeed = sp0;
                        // On-spawn ripple cue
                        const col = '#9FE6FF';
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color: col, radius: Math.max(10, (proj.size||6) * 1.2), life: 120 });
                        } else {
                            addParticle(proj.x, proj.y, col, 'ring');
                        }
                    }
                    proj._tdTimer++;
                    if (proj._tdPhase === 0) { // slow stretch (heavier)
                        const f = 0.94;
                        proj.vx *= f; proj.vy *= f;
                        const base = proj._tdBaseSpeed || (Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001);
                        const spNow = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        const minSp = base * 0.55;
                        if (spNow < minSp) { const s = (minSp / spNow); proj.vx*=s; proj.vy*=s; }
                        if (proj._tdTimer > 30) { proj._tdPhase = 1; proj._tdTimer = 0; if (Math.random()<0.55) addParticle(proj.x, proj.y, '#C0F0FF','spark'); }
                    } else if (proj._tdPhase === 1) { // hold (shorter)
                        if (proj._tdTimer > 10) { proj._tdPhase = 2; proj._tdTimer = 0; if (Math.random()<0.55) addParticle(proj.x, proj.y, '#80E0FF','spark'); }
                    } else if (proj._tdPhase === 2) { // surge (stronger)
                        const f = 1.08;
                        proj.vx *= f; proj.vy *= f;
                        const base = proj._tdBaseSpeed || (Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001);
                        const spNow = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                        const maxSp = base * 2.0;
                        if (spNow > maxSp) { const s = (maxSp / spNow); proj.vx*=s; proj.vy*=s; }
                        if (proj._tdTimer > 18) { proj._tdPhase = 0; proj._tdTimer = 0; for (let k=0;k<2;k++) if (Math.random()<0.75) addParticle(proj.x, proj.y, '#44D0FF','spark'); }
                    }
                }
                // Pattern motion aggregation: multiple pattern flags stack by contributing delta-Vs.
                // Ensure aggregator initialized once per projectile.
                if (!proj._patternInit) {
                    proj._patternInit = true;
                    proj._agg = { baseSpeed: null, fwX: null, fwY: null, px: null, py: null };
                }
                // Reset per-frame external deltas from patterns that contributed directly (e.g., pivot/pendulum)
                proj._aggDX = 0; proj._aggDY = 0;
                let patternApplied = false;
                let aggDX = 0, aggDY = 0; // additive velocity deltas from patterns
                // Establish forward & perpendicular bases lazily
                const ensureBasis = () => {
                    if (proj._agg.baseSpeed) return;
                    const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                    proj._agg.baseSpeed = sp;
                    proj._agg.fwX = proj.vx / sp;
                    proj._agg.fwY = proj.vy / sp;
                    // choose a stable perpendicular (seeded by projectile id via random) for repeatability
                    if (Math.random() < 0.5) { proj._agg.px = -proj._agg.fwY; proj._agg.py = proj._agg.fwX; }
                    else { proj._agg.px = proj._agg.fwY; proj._agg.py = -proj._agg.fwX; }
                };
                // Sine wave lateral oscillation (now stackable)
                if (proj.sineWave && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    // Initialize sine metadata once
                    if (!proj._sineInit) {
                        proj._sineInit = true;
                        // capture forward direction unit vector
                        proj._fwx = proj._agg.fwX; proj._fwy = proj._agg.fwY;
                        proj._px = proj._agg.px;  proj._py = proj._agg.py;
                        // amplitude scales lightly with speed but clamped
                        const ampBase = 14 + Math.random()*8; // 14-22
                        // Use stored baseSpeed (captured in ensureBasis) instead of undefined 'sp'
                        const baseSp = proj._agg && proj._agg.baseSpeed ? proj._agg.baseSpeed : Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                        proj._sineAmp = Math.min(26, ampBase + baseSp*1.2);
                        // frequency determines how tight the wave is (cycles per 60 frames)
                        proj._sineFreq = 0.18 + Math.random()*0.10; // radians increment per frame
                        proj._sinePhase = Math.random() * Math.PI * 2; // starting phase
                        proj._lastOffset = 0;
                        // store a stable forward speed so homing/other minor steering keeps wave consistent
                        proj._baseSpeed = proj._agg.baseSpeed;
                    }
                    // advance phase
                    proj._sinePhase += proj._sineFreq;
                    // desired lateral offset relative to centerline
                    const offset = Math.sin(proj._sinePhase) * proj._sineAmp;
                    // delta lateral movement this frame
                    const delta = offset - proj._lastOffset;
                    proj._lastOffset = offset;
                    aggDX += proj._px * delta;
                    aggDY += proj._py * delta;
                    patternApplied = true;
                }
                // Uzumaki contribution (object-mode): evolve state and add delta toward swirl target
                if (proj.uzumaki && !proj.enemy && !proj.beam) {
                    // Evolve Uzumaki state
                    proj._uzuRadius += proj._uzuRadialVel;
                    proj._uzuRadialVel *= (1 - proj._uzuDrag);
                    proj._uzuAngle += proj._uzuAngularVel;
                    proj._uzuAngularVel *= 1.003;
                    // Target point on the spiral
                    const targetX = proj._uzuCx + Math.cos(proj._uzuAngle) * proj._uzuRadius;
                    const targetY = proj._uzuCy + Math.sin(proj._uzuAngle) * proj._uzuRadius;
                    const dVx = (targetX - proj.x);
                    const dVy = (targetY - proj.y);
                    // If local Spiral is active, give Uzumaki a bit less authority to keep loops visible
                    const uzBlend = (proj.spiral ? 0.40 : 0.65);
                    aggDX += dVx * uzBlend;
                    aggDY += dVy * uzBlend;
                    patternApplied = true;
                    if (Math.random() < 0.08) addParticle(proj.x, proj.y, '#FFAaff', 'swirl');
                }
                // Wacky zigzag: adds perpendicular velocity component flips (stackable; reduced amplitude if combined)
                if (proj.wackyZigzag && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    if (!proj._wackyInit) {
                        proj._wackyInit = true;
                        const sp = proj._agg.baseSpeed;
                        // Store base forward speed for reference
                        proj._baseSpeed = sp;
                        // New omni-directional jitter system:
                        // Instead of just flipping perpendicular, we pick a random direction vector (including diagonals)
                        // every few frames and blend it in as a steering impulse.
                        proj._wackyTimer = 0;
                        proj._wackyInterval = 5 + Math.floor(Math.random()*8); // 5-12 frames per direction
                        proj._wackyAmpBase = Math.min(32, 14 + sp * 1.8 + Math.random()*10); // base magnitude potential
                        proj._wackyVec = { x: 0, y: 0 };
                        proj._wackyTarget = { x: 0, y: 0 };
                        proj._wackyJitterPhase = Math.random()*Math.PI*2;
                        // Helper to choose next direction from 8-way set (including diagonals) with slight random magnitude skew
                        proj._pickWackyDir = function() {
                            // No-op: global Wunderswan audio list initialized at game startup.
                            // If it's missing for some reason, log a debug message instead of reinitializing here.
                            if (!game._wunderswanAudioList || !game._wunderswanAudioList.length) {
                                console.warn('[Wunderswan][AUDIO] global audio list missing during proj._pickWackyDir.');
                            }
                        };
                        proj._pickWackyDir();
                        // Chaos variant minor initialization adjustments (if flagged at spawn)
                        if (proj._wackyChaos) {
                            // Slightly higher starting amplitude ceiling
                            proj._wackyAmpBase = Math.min(40, proj._wackyAmpBase + 6 + Math.random()*4);
                            // Shorter first interval for instant flair
                            proj._wackyInterval = 4 + Math.floor(Math.random()*5);
                        }
                    }
                    proj._wackyTimer++;
                    if (proj._wackyTimer >= proj._wackyInterval) {
                        proj._wackyTimer = 0;
                        proj._wackyInterval = 5 + Math.floor(Math.random()*8);
                        proj._pickWackyDir();
                        // occasional spark to indicate sudden re-vectoring
                        if (Math.random() < 0.5) addParticle(proj.x, proj.y, '#FFDD55', 'spark');
                        // mild amplitude modulation on each pick
                        const ampJitter = (Math.random()*6 - 3);
                        proj._wackyAmpBase = Math.max(10, Math.min(36, proj._wackyAmpBase + ampJitter));
                    }
                    // Chaos variant overlay behavior
                    let chaosFactor = 1;
                    if (proj._wackyChaos) {
                        // Frame-based timers (fallback if no global frame counter by using projectile life inverse)
                        const frameNow = (typeof game.frame === 'number') ? game.frame : (game.tick || (6000 - proj.life));
                        proj._wackyChaosTimer = (proj._wackyChaosTimer||0) + 1;
                        if (proj._wackyChaosTimer >= (proj._wackyChaosInterval||12)) {
                            proj._wackyChaosTimer = 0;
                            // Re-roll next chaos interval (tighter range than normal steering interval)
                            proj._wackyChaosInterval = 4 + Math.floor(Math.random()*6); // 4-9
                            // 20% chance: amplitude surge burst
                            if (Math.random() < 0.20) {
                                proj._wackyAmpBase = Math.min(48, proj._wackyAmpBase + 8 + Math.random()*6);
                                proj._wackyChaosBurst = 6 + Math.floor(Math.random()*6); // sustain heightened amplitude
                                addParticle(proj.x, proj.y, '#FFBB44', 'spark');
                            }
                            // 10% chance: dramatic 180 flip (cooldown 24 frames to avoid spam)
                            if (Math.random() < 0.10 && (proj._wackyChaosLastFlip||0) + 24 < frameNow) {
                                proj._wackyTarget.x *= -1; proj._wackyTarget.y *= -1;
                                proj._wackyChaosLastFlip = frameNow;
                                addParticle(proj.x, proj.y, '#FFA722', 'spark');
                            } else {
                                // Otherwise occasionally force an immediate new dir (55%)
                                if (Math.random() < 0.55) proj._pickWackyDir();
                            }
                            // Rare lateral micro explosion impulse (5%)
                            if (Math.random() < 0.05) {
                                const burstAng = Math.random()*Math.PI*2;
                                const impulse = 6 + Math.random()*10;
                                aggDX += Math.cos(burstAng) * impulse;
                                aggDY += Math.sin(burstAng) * impulse;
                                addParticle(proj.x + Math.cos(burstAng)*4, proj.y + Math.sin(burstAng)*4, '#FFD155', 'spark');
                            }
                        }
                        if (proj._wackyChaosBurst && proj._wackyChaosBurst > 0) {
                            proj._wackyChaosBurst--;
                            const t = proj._wackyChaosBurst/10; // 0..~1
                            chaosFactor = 1 + 0.35 * Math.sin(t*Math.PI); // smooth ease in/out
                            if (Math.random() < 0.18) addParticle(proj.x, proj.y, '#FFC966', 'spark');
                        }
                        // Additional subtle random lateral twitches (very small, frequent)
                        if (Math.random() < 0.12) {
                            aggDX += (Math.random()-0.5) * 4;
                            aggDY += (Math.random()-0.5) * 4;
                        }
                    }
                    // Smoothly steer current vector toward target (gives curve instead of instant snap)
                    proj._wackyVec.x = proj._wackyVec.x * 0.72 + proj._wackyTarget.x * 0.28;
                    proj._wackyVec.y = proj._wackyVec.y * 0.72 + proj._wackyTarget.y * 0.28;
                    // Add a subtle sinusoidal micro jitter layered on top (breathing motion)
                    proj._wackyJitterPhase += 0.35 + Math.random()*0.15;
                    const micro = Math.sin(proj._wackyJitterPhase) * 0.35;
                    let vx = proj._wackyVec.x + micro*(Math.random()<0.5?1:-1);
                    let vy = proj._wackyVec.y + micro*(Math.random()<0.5?1:-1);
                    // Normalize vector then scale by dynamic amplitude with pattern dampening
                    const len = Math.sqrt(vx*vx + vy*vy) || 1;
                    vx /= len; vy /= len;
                    const patternDampen = (proj.sineWave ? 0.55 : 1) * (proj.ekgWave ? 0.75 : 1) * (proj.spiral ? 0.85 : 1);
                    const amp = proj._wackyAmpBase * patternDampen * (chaosFactor || 1);
                    aggDX += vx * amp;
                    aggDY += vy * amp;
                    patternApplied = true;
                }
                // EKG wave: path-relative cardiogram-like offset spikes (stackable)
                if (proj.ekgWave && !proj.enemy && !proj.beam) {
                    ensureBasis();
                    if (!proj._ekgInit) {
                        proj._ekgInit = true;
                        proj._fwx = proj._agg.fwX; proj._fwy = proj._agg.fwY;
                        // Lock perpendicular direction and force it to point toward screen-up (negative Y)
                        let px = proj._agg.px, py = proj._agg.py;
                        if (py > 0) { px = -px; py = -py; }
                        proj._px = px;  proj._py = py;
                        proj._baseSpeed = proj._agg.baseSpeed;
                        // Phase timing (frames) sequence: flat -> pre-pulse -> spike ascend -> spike descend -> recovery
                        // We'll encode as state machine
                        proj._ekgState = 'flat';
                        proj._ekgTimer = 0;
                        proj._ekgCycle = 0; // count completed cycles to schedule mega-spike
                        // randomize cycle length slightly so multiple shots desync
                        proj._ekgFlatDur = 10 + Math.floor(Math.random()*8); // shorter baseline
                        proj._ekgPreDur = 1;   // very brief telegraph
                        proj._ekgAscDur = 4;   // longer up for visibility
                        proj._ekgDescDur = 4;  // longer down
                        proj._ekgRecoverDur = 1; // snap settle
                        // Max spike lateral amplitude (increased for more dramatic spikes)
                        // Tunable constants: adjust EKG_AMP_BASE / EKG_AMP_VAR / EKG_AMP_MULT to quickly rebalance.
                        // Baseline jitter amount
                        proj._ekgJitter = 0.8;
                        proj._ekgSeed = Math.random() * Math.PI * 2;
                        // Small vs big spike amplitudes (px)
                        proj._ekgSmallAmp = 3.0 + Math.random()*1.5; // ~3.0–4.5
                        proj._ekgBigAmp   = 12 + Math.random()*6;    // ~12–18
                        // Uniform scale-up so jitter and spikes increase equally
                        const EKG_SCALE = 3.8; // ~+27% stronger scale for jitter + spikes
                        proj._ekgJitter *= EKG_SCALE;
                        proj._ekgSmallAmp *= EKG_SCALE;
                        proj._ekgBigAmp *= EKG_SCALE;
                        proj._ekgUseAmp   = proj._ekgSmallAmp;
                        proj._lastOffset = 0;
                        // Ensure at least one spike early in life
                        proj._ekgGuaranteeAt = 10 + ((Math.random()*8)|0);
                        proj._ekgGuaranteeBigAt = 6 + ((Math.random()*8)|0);
                        proj._ekgBigDone = false;
                        proj._ekgSpikedOnce = false;
                    }
                    proj._ekgTimer++;
                    let offset = 0;
                    const st = proj._ekgState;
                    if (st === 'flat') {
                        // tiny baseline flicker (two-phase)
                        const a = Math.sin((proj._ekgTimer*3.1) + (proj._ekgSeed||0)) * (proj._ekgJitter*0.7);
                        const b = Math.sin((proj._ekgTimer*1.7) + (proj._ekgSeed||0)*0.53) * (proj._ekgJitter*0.3);
                        offset = a + b;
                        if (proj._ekgTimer >= proj._ekgFlatDur || (!proj._ekgSpikedOnce && proj._ekgTimer >= proj._ekgGuaranteeAt)) {
                            if (!proj._ekgBigDone && proj._ekgTimer >= proj._ekgGuaranteeBigAt) {
                                proj._ekgUseAmp = proj._ekgBigAmp; proj._ekgBigDone = true;
                            } else {
                                proj._ekgUseAmp = (Math.random() < 0.18 ? proj._ekgBigAmp : proj._ekgSmallAmp);
                                if (proj._ekgUseAmp === proj._ekgBigAmp) proj._ekgBigDone = true;
                            }
                            proj._ekgState = 'pre'; proj._ekgTimer = 0;
                        }
                    } else if (st === 'pre') {
                        // brief telegraph
                        const t = proj._ekgTimer / Math.max(1, proj._ekgPreDur);
                        offset = Math.sin(proj._ekgTimer*3) * (0.6 + t*0.2);
                        if (proj._ekgTimer >= proj._ekgPreDur) { proj._ekgState = 'asc'; proj._ekgTimer = 0; }
                    } else if (st === 'asc') {
                        // Linear up
                        const t = Math.min(1, proj._ekgTimer / proj._ekgAscDur);
                        offset = Math.abs(proj._ekgUseAmp) * t; // always upward along locked perp
                        if (proj._ekgTimer >= proj._ekgAscDur) { proj._ekgState = 'desc'; proj._ekgTimer = 0; proj._ekgSpikedOnce = true; }
                    } else if (st === 'desc') {
                        const t = Math.min(1, proj._ekgTimer / proj._ekgDescDur);
                        offset = Math.abs(proj._ekgUseAmp) * (1 - t); // linear back to 0
                        if (proj._ekgTimer >= proj._ekgDescDur) { proj._ekgState = 'recover'; proj._ekgTimer = 0; }
                    } else if (st === 'recover') {
                        const t = proj._ekgTimer / Math.max(1, proj._ekgRecoverDur);
                        offset = (proj._lastOffset) * (1 - t); // snap settle
                        if (proj._ekgTimer >= proj._ekgRecoverDur) {
                            proj._ekgState = 'flat';
                            proj._ekgTimer = 0;
                            proj._ekgFlatDur = 10 + Math.floor(Math.random()*8);
                            proj._ekgCycle = (proj._ekgCycle||0)+1;
                            proj._lastOffset = 0; // hard reset baseline
                        }
                    }
                    // Convert offset to perpendicular delta and apply directly to position (avoid velocity drift)
                    let delta = offset - (proj._lastOffset || 0);
                    proj._lastOffset = offset;
                    // Clamp per-frame step; allow larger steps during spikes for visibility
                    const isSpike = (st==='asc' || st==='desc');
                    let maxStep;
                    if (isSpike) {
                        const amp = Math.abs(proj._ekgUseAmp || 0);
                        const dur = Math.max(1, (st==='asc' ? proj._ekgAscDur : proj._ekgDescDur));
                        maxStep = Math.min(31, Math.max(7.7, (amp / dur) * 1.4));
                    } else {
                        maxStep = 2.05; // baseline clamp scaled up ~28% to match amplitude increase
                    }
                    if (delta > maxStep) delta = maxStep; else if (delta < -maxStep) delta = -maxStep;
                    const spikeScale = isSpike ? 1.0 : 0.85;
                    proj.x += proj._px * delta * spikeScale;
                    proj.y += proj._py * delta * spikeScale;
                    patternApplied = true;
                    // subtle trail particle at spike apex / transition
                    if (st === 'desc' && proj._ekgTimer === 0) { addParticle(proj.x, proj.y, '#66FFCC', 'spark'); }
                }
                // Apply aggregated pattern adjustments (only for non-orbital, non-beam, non-enemy projectiles)
                if (patternApplied && !proj._orbital && !proj.beam && !proj.enemy) {
                    // Rebuild forward component from stored basis, add aggregated lateral
                    const fwSpeed = proj._agg.baseSpeed;
                    // Keep forward velocity magnitude stable while adding lateral influence
                    let desiredVx = proj._agg.fwX * fwSpeed + aggDX + (proj._aggDX||0);
                    let desiredVy = proj._agg.fwY * fwSpeed + aggDY + (proj._aggDY||0);
                    // Gyro Stabilizer: reduce lateral displacement influence (acts like damping)
                    if (proj.gyroStabilizer) {
                        const lateralVx = desiredVx - proj._agg.fwX * fwSpeed;
                        const lateralVy = desiredVy - proj._agg.fwY * fwSpeed;
                        desiredVx = proj._agg.fwX * fwSpeed + lateralVx * 0.48; // stronger damping
                        desiredVy = proj._agg.fwY * fwSpeed + lateralVy * 0.48;
                    }
                    // Soft normalization to avoid runaway speed inflation
                    const maxSpeed = fwSpeed * 1.85;
                    const sp2 = Math.sqrt(desiredVx*desiredVx + desiredVy*desiredVy) || 0.0001;
                    if (sp2 > maxSpeed) {
                        desiredVx = desiredVx / sp2 * maxSpeed;
                        desiredVy = desiredVy / sp2 * maxSpeed;
                    }
                    // Blend for smoothness
                    proj.vx = proj.vx * 0.58 + desiredVx * 0.42;
                    proj.vy = proj.vy * 0.58 + desiredVy * 0.42;
                }
                // === Emission / Lifecycle Behaviors (new abilities) ===
                if (!proj.enemy && !proj.beam) {
                    // Bloom Ring: emit expanding pellet ring periodically
                    if (proj.bloomRing) {
                        // Hybrid mode C: Occasional small sub-ring emissions from projectiles (low density)
                        // while main large rings are handled at player level (updateBloomRings())
                        // Use per-projectile stagger so not all cores emit on same frame
                        const subInterval = 160 + ((proj._bloomSubRand)||(proj._bloomSubRand = Math.floor(Math.random()*90))); // ~2.5s avg
                        proj._bloomSubTimer = (proj._bloomSubTimer||0)+1;
                        if (proj._bloomSubTimer >= subInterval) {
                            proj._bloomSubTimer = 0;
                            // Emit a tiny petal burst (6) for visual continuity
                            const count = 6;
                            const baseDmg = proj.baseDamage || calculateDamage();
                            for (let r=0;r<count;r++) {
                                const ang = (r/count)*Math.PI*2;
                                const spd = 3.6 + Math.random()*0.5;
                                game.spawnProjectile({
                                    x: proj.x, y: proj.y,
                                    vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
                                    life: 34,
                                    size: Math.max(2, Math.floor(proj.size*0.45)),
                                    enemy:false,
                                    damage: Math.max(1, Math.floor(baseDmg * 0.22)),
                                    baseDamage: Math.max(1, Math.floor(baseDmg * 0.22)),
                                    bloomChild:true,
                                    _petal:true
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFEEDD','spark');
                        }
                    }
                    // Cascade Burst: pulsing forward micro-bursts
                    if (proj.cascadeBurst) {
                        if (!proj._cascInit) { proj._cascInit=true; proj._cascTimer=12; }
                        proj._cascTimer--;
                        if (proj._cascTimer<=0) {
                            proj._cascTimer = 14; // reset
                            const ang = Math.atan2(proj.vy, proj.vx);
                            const parts = 3;
                            for (let k=0;k<parts;k++) {
                                const off = (k - (parts-1)/2)*0.08;
                                game.spawnProjectile({
                                    x: proj.x + Math.cos(ang)*8,
                                    y: proj.y + Math.sin(ang)*8,
                                    vx: Math.cos(ang+off)* (getProjSpeed(proj)*1.05),
                                    vy: Math.sin(ang+off)* (getProjSpeed(proj)*1.05),
                                    life: 40,
                                    size: Math.max(2, proj.size*0.45),
                                    enemy:false,
                                    damage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.32)),
                                    baseDamage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.32)),
                                    cascadeChild:true,
                                    _initialFx: Math.cos(ang+off), _initialFy: Math.sin(ang+off)
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFD4AA','spark');
                            for (let q=0;q<3;q++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFB866','spark');
                        }
                    }
                    // Fragment Wake: trailing small lingering damaging sparks (new system)
                    if (proj.fragmentWake) {
                        // Initialize per-projectile emission tracking
                        if (!proj._fwPrevX) { proj._fwPrevX = proj.x; proj._fwPrevY = proj.y; proj._fwDistAcc = 0; }
                        const dx = proj.x - proj._fwPrevX, dy = proj.y - proj._fwPrevY;
                        const dist = Math.hypot(dx, dy);
                        proj._fwDistAcc += dist;
                        proj._fwPrevX = proj.x; proj._fwPrevY = proj.y;
                        // Emit a spark every ~18px traveled (slightly randomized spacing)
                        const spacing = 14 + (proj._fwRandOff || (proj._fwRandOff = Math.random()*6));
                        while (proj._fwDistAcc >= spacing) {
                            proj._fwDistAcc -= spacing;
                            const baseDmg = (proj.baseDamage||calculateDamage());
                            if (!Array.isArray(game.fragmentSparks)) game.fragmentSparks = [];
                            if (game.fragmentSparks.length > 220) game.fragmentSparks.splice(0, game.fragmentSparks.length - 220);
                            // Perf-aware pre-shed spark for readability
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                addParticle(proj.x, proj.y, '#FFE6AA','spark');
                            }
                            game.fragmentSparks.push({
                                x: proj.x + (Math.random()-0.5)*6,
                                y: proj.y + (Math.random()-0.5)*6,
                                r: 6 + Math.random()*3,
                                ttl: 38,
                                maxTtl: 38,
                                damage: Math.max(1, Math.floor(baseDmg * 0.10)),
                                dpsTick: 0,
                                hitMap: new Set(),
                                pulse: Math.random()*Math.PI*2
                            });
                        }
                    }
                    // Phase Echo: spawn afterimages that later pop for mini-hit
                    if (proj.phaseEcho) {
                        if (!proj._echoInit) { proj._echoInit=true; proj._echoTimer=10; }
                        proj._echoTimer--;
                        if (proj._echoTimer<=0) {
                            proj._echoTimer = 26; // cadence
                            if ((proj._echoesSpawned||0) < 3) {
                                const gDmg = Math.max(1, Math.floor((proj.baseDamage||calculateDamage())*0.25));
                                const gIdx = game.spawnProjectile({ x: proj.x, y: proj.y, vx:0, vy:0, life:22, r: Math.max(2, Math.floor((proj.size||6)*0.6)), damage: gDmg });
                                if (!game._projMeta) game._projMeta = new Map();
                                if (gIdx>=0) game._projMeta.set(gIdx,{ phaseGhost:true, parentRef: proj, baseDamage:gDmg });
                                proj._echoesSpawned=(proj._echoesSpawned||0)+1;
                            }
                        }
                    }
                    // Resonant Pulse Core: emits periodic expanding ring that grants temporary speed/damage/homing buff
                    if (proj.resonantPulseCore) {
                        proj._resCoreTimer = (proj._resCoreTimer||0)+1;
                        proj._resActiveRings = proj._resActiveRings || [];
                        const interval = 60; // frames between pulses (was 90)
                        if (proj._resCoreTimer >= interval) {
                            proj._resCoreTimer = 0;
                            const ring = { r: 0, max: 150, life: 38 };
                            proj._resActiveRings.push(ring);
                            // Telegraph pulse (perf-aware)
                            const lowFx = !!(game.perf && game.perf.lowFx);
                            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                            if (!lowFx && !hideSparks) {
                                for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*16, proj.y + (Math.random()-0.5)*16, '#C7A4FF','spark');
                            }
                        }
                        // Update rings
                        for (let i=proj._resActiveRings.length-1;i>=0;i--) {
                            const ring = proj._resActiveRings[i];
                            ring.r += (ring.max - ring.r) * 0.18; // ease out expansion
                            ring.life--;
                            // Apply buff to touched projectiles this frame
                            const rad2 = ring.r*ring.r;
                            game.projectiles.forEach(p2=>{
                                if (p2===proj || p2.enemy || p2.beam) return;
                                const dx = p2.x - proj.x; const dy = p2.y - proj.y;
                                const d2 = dx*dx+dy*dy;
                                    if (d2 <= rad2) {
                                    // Set/refresh buff timers on each pulse
                                    p2._resBuffSpeed = Math.max(p2._resBuffSpeed||0, 26); // speed buff frames
                                    p2._resBuffDamage = Math.max(p2._resBuffDamage||0, 30); // damage buff frames
                                    p2._resBuffHoming = Math.max(p2._resBuffHoming||0, 24); // slight homing assistance
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                                    if (!lowFx && !hideSparks) addParticle(p2.x, p2.y, '#C7A4FF','spark');
                                }
                            });
                            if (ring.life <= 0 || ring.r > ring.max*0.98) proj._resActiveRings.splice(i,1);
                        }
                        // Local optional glow particle
                        if (!(game.perf && game.perf.lowFx) && Math.random()<0.08) addParticle(proj.x, proj.y, '#B88CFF','ambient');
                    }
                    // Spiral Bloom: projectile corkscrews inward tightening radius then detonates into rotating petal spiral
                    if (proj.spiralBloom) {
                        if (!proj._sbInit) {
                            proj._sbInit=true;
                            proj._sbPhase='tighten';
                            proj._sbTimer=0;
                            proj._sbRadius=34;
                            proj._sbAngle = 0; // rotation phase for visible spiral motion
                            // capture forward & perpendicular for local spiral positioning
                            const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||0.0001;
                            proj._sbFx = proj.vx/sp; proj._sbFy = proj.vy/sp;
                            proj._sbPx = -proj._sbFy; proj._sbPy = proj._sbFx;
                        }
                        proj._sbTimer++;
                        if (proj._sbTelegraph && proj._sbTelegraph>0) proj._sbTelegraph--;
                        if (proj._sbPhase==='tighten') {
                            proj._sbAngle += 0.38; // spin
                            proj._sbRadius *= 0.965; // contract
                            // apply a local spiral offset around the forward axis (minor visual swirl)
                            const swirl = proj._sbRadius*0.12;
                            const sx = Math.cos(proj._sbAngle)*swirl;
                            const sy = Math.sin(proj._sbAngle)*swirl;
                            proj.x += proj._sbPx * sx * 0.08 + proj._sbFx * sy * 0.02;
                            proj.y += proj._sbPy * sx * 0.08 + proj._sbFy * sy * 0.02;
                            // Pre-bloom telegraph shortly before detonating
                            if (!proj._sbTelegraph && (proj._sbTimer>46 || proj._sbRadius<8.5)) {
                                proj._sbTelegraph = 12;
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                    for (let k=0;k<4;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE6AA','spark');
                                }
                            }
                            if (proj._sbTimer>52 || proj._sbRadius<5.5) { proj._sbPhase='bloom'; proj._sbTimer=0; }
                            if (Math.random()<0.18) addParticle(proj.x, proj.y, '#FFE6AA','spark');
                        } else if (proj._sbPhase==='bloom') {
                            if (!proj._sbBloomed) {
                                proj._sbBloomed = true;
                                const petals = 8;
                                const base = proj.baseDamage||calculateDamage();
                                // Emit petals with initial angular offset to create rotating ring that expands
                                for (let p=0;p<petals;p++) {
                                    const ang = (p/petals)*Math.PI*2;
                                    const speed = 2.4 + (p%2)*0.8; // slight alternation
                                    const vx = Math.cos(ang)*speed;
                                    const vy = Math.sin(ang)*speed;
                                    game.spawnProjectile({
                                        x: proj.x, y: proj.y,
                                        vx, vy,
                                        life: 75,
                                        size: Math.max(10, proj.size * 1.10 * 2.0), enemy:false,
                                        damage: Math.max(1, Math.floor(base*0.42)), baseDamage: Math.max(1, Math.floor(base*0.42)),
                                        petal:true,
                                        // Attach sprite + spin meta so renderer can pick image and rotate
                                        petalImg: ('bloom' + (1 + Math.floor(Math.random()*6))),
                                        _petalAngle: Math.random()*Math.PI*2,
                                        petalSpin: (Math.random()<0.5?1:-1) * (0.06 + Math.random()*0.04)
                                    });
                                }
                                // central burst particles
                                addParticle(proj.x, proj.y, '#FFEEAA','explosion');
                                for (let k=0;k<10;k++) addParticle(proj.x, proj.y, '#FFC870','spark');
                            }
                            // After bloom, remove core projectile
                            proj.life = 0;
                        }
                    }
                    // Harmonic Split: spawn angled child pair at life thresholds; parent continues until all splits done
                    if (proj.harmonicSplit && proj._harmonicThresholds && !proj._harmonicDoneAll) {
                        if (!proj._harmonicDone) proj._harmonicDone = {};
                        if (proj._harmonicTele && proj._harmonicTele>0) proj._harmonicTele--;
                        const ang = Math.atan2(proj.vy, proj.vx);
                        for (let idx=0; idx<proj._harmonicThresholds.length; idx++) {
                            const th = proj._harmonicThresholds[idx];
                            // Pre-split telegraph within a small window above the threshold
                            if (!proj._harmonicDone[th] && proj.life <= th + 8 && proj.life > th) {
                                if (!proj._harmonicTele || proj._harmonicTele<4) proj._harmonicTele = 6;
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks) && Math.random()<0.25) {
                                    addParticle(proj.x, proj.y, '#FFE2BB','spark');
                                }
                            }
                            if (proj.life <= th && !proj._harmonicDone[th]) {
                                proj._harmonicDone[th] = true;
                                const base = proj.baseDamage||calculateDamage();
                                const childSpeed = getProjSpeed(proj) * 0.92;
                                const spread = 0.34; // radians offset (~19.5 deg)
                                for (let dir=-1; dir<=1; dir+=2) {
                                    const cAng = ang + dir*spread;
                                    game.spawnProjectile({
                                        x: proj.x, y: proj.y,
                                        vx: Math.cos(cAng) * childSpeed,
                                        vy: Math.sin(cAng) * childSpeed,
                                        life: Math.max(12, Math.floor(proj.life * 0.78)),
                                        size: Math.max(2, proj.size*0.65), enemy:false,
                                        damage: Math.max(1, Math.floor(base * 0.58)), baseDamage: Math.max(1, Math.floor(base * 0.58)),
                                        harmonicChild:true,
                                        // inherit some pattern flags for visual continuity
                                        sineWave: proj.sineWave, wackyZigzag: proj.wackyZigzag, ekgWave: proj.ekgWave,
                                        spiral: proj.spiral, lissajousPattern: proj.lissajousPattern
                                    });
                                }
                                // Visual burst
                                for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE2BB','spark');
                                addParticle(proj.x, proj.y, '#FFC070','trail');
                                // Optionally trim parent damage slightly each split so total DPS doesn't overscale
                                if (proj.baseDamage) proj.baseDamage = Math.max(1, Math.floor(proj.baseDamage * 0.9));
                            }
                        }
                        if (Object.keys(proj._harmonicDone).length === proj._harmonicThresholds.length) {
                            proj._harmonicDoneAll = true;
                            // Small final marker particle
                            addParticle(proj.x, proj.y, '#FFCC88','ambient');
                        }
                    }
                    // (Legacy umbrella & popcorn blocks removed – logic now handled in SoA metadata update loop)
                    // Echo Bloom: staged echo spawning culminating in amplified bloom burst
                    if (proj.echoBloom) {
                        if (!proj._echoInit) {
                            proj._echoInit = true;
                            proj._echoStage = 0; // stages 0..N then final bloom
                            proj._echoNextLifePoint = Math.floor(proj.life * 0.70); // initial trigger threshold
                            proj._echoMaxStages = 2; // number of intermediate echoes before final
                            proj._echoPetalColor = '#FFE0FF';
                            proj._echoTelegraph = 0; // grows near bloom
                            proj._echoTelegraphMax = 42; // frames of max telegraph before bloom
                        }
                        // Spawn echoes at descending life thresholds
                        if (proj.life <= proj._echoNextLifePoint && proj._echoStage < proj._echoMaxStages) {
                            const scale = 0.55 + proj._echoStage*0.15; const dmgScale = 0.30 + proj._echoStage*0.1;
                            const baseDmgLocal = (proj.baseDamage||calculateDamage());
                            const eIdx = game.spawnProjectile({
                                x: proj.x, y: proj.y,
                                vx: proj.vx*(0.35 + proj._echoStage*0.1), vy: proj.vy*(0.35 + proj._echoStage*0.1),
                                life: proj.life + 18 + proj._echoStage*6,
                                r: Math.max(2, Math.floor((proj.size||6)*scale)),
                                damage: Math.max(1, Math.floor(baseDmgLocal*dmgScale))
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            if (eIdx>=0) game._projMeta.set(eIdx,{ echoChild:true, parentRef: proj, baseDamage: Math.max(1, Math.floor(baseDmgLocal*dmgScale)) });
                            for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFC8FF','spark');
                            proj._echoStage++;
                            // schedule next threshold deeper into life (fractional)
                            proj._echoNextLifePoint = Math.floor(proj.life * (0.55 - proj._echoStage*0.10));
                        }
                        // Check for echoes converging; when all spawned echoes have converged, trigger bloom
                        if (proj._echoStage === proj._echoMaxStages && !proj._echoBloomed) {
                            let converged = true; let echoCount = 0;
                            if (game._projMeta && game.projectilesSoA) {
                                const so = game.projectilesSoA; const { x, y, alive, MAX } = so;
                                for (let si=0; si<MAX; si++) if (alive[si]) {
                                    const m2 = game._projMeta.get(si); if (!m2 || !m2.echoChild || m2.parentRef !== proj) continue;
                                    echoCount++;
                                    const dxc = x[si]-proj.x; const dyc = y[si]-proj.y; if (dxc*dxc+dyc*dyc > 36) { converged=false; break; }
                                }
                            }
                            // Telegraph growth once all echoes spawned
                            if (echoCount && !proj._echoBloomed) {
                                proj._echoTelegraph = Math.min(proj._echoTelegraph + 1, proj._echoTelegraphMax);
                                if (proj._echoTelegraph > proj._echoTelegraphMax * 0.65 && Math.random()<0.25) {
                                    addParticle(proj.x + (Math.random()-0.5)*20, proj.y + (Math.random()-0.5)*20, '#FFD6FF','spark');
                                }
                            }
                            if (echoCount && converged) {
                                // Perform bloom: radial petal ring + explosion damage
                                proj._echoBloomed = true;
                                const base = proj.baseDamage||calculateDamage();
                                const burstDmg = Math.max(1, Math.floor(base * 1.10)); // stronger central pop
                                explodeProjectile({x:proj.x,y:proj.y,size:proj.size,enemy:false}, burstDmg);
                                addScreenShake(6);
                                // Larger petal count scaling with multi-shot patterns (optional simple scale)
                                const petals = 10 + Math.floor(Math.random()*4);
                                for (let p=0;p<petals;p++) {
                                    const ang = (p/petals)*Math.PI*2;
                                    game.spawnProjectile({
                                        x: proj.x, y: proj.y,
                                        vx: Math.cos(ang)*(2.8 + Math.random()*0.6), vy: Math.sin(ang)*(2.8 + Math.random()*0.6),
                                        life: 65,
                                        size: Math.max(2, proj.size*0.55), enemy:false,
                                        damage: Math.max(1, Math.floor(base*0.42)), baseDamage: Math.max(1, Math.floor(base*0.42)),
                                        echoPetal:true
                                    });
                                }
                                // Resonance field: lingering aura dealing periodic pulse damage near center
                                const field = {
                                    x: proj.x, y: proj.y,
                                    radius: 140,
                                    createdAt: Date.now(),
                                    duration: 2000,
                                    tickEvery: 260,
                                    lastTick: 0,
                                    baseDamage: Math.max(1, Math.floor(base * 0.30)),
                                    type: 'echoBloom'
                                };
                                if (!game.echoBloomFields) game.echoBloomFields = [];
                                game.echoBloomFields.push(field);
                                addParticle(proj.x, proj.y, '#FFE6FF','explosion');
                                for (let r=0;r<20;r++) addParticle(proj.x + (Math.random()-0.5)*140, proj.y + (Math.random()-0.5)*140, '#FFC8FF','spark');
                                // consume echoes
                                if (game._projMeta && game.projectilesSoA) {
                                    const so = game.projectilesSoA; const { alive, life, MAX } = so;
                                    for (let si=0; si<MAX; si++) if (alive[si]) {
                                        const m2 = game._projMeta.get(si); if (m2 && m2.echoChild && m2.parentRef === proj) { life[si]=0; }
                                    }
                                }
                            }
                        }
                    }
                    // Veering Fan: mid-flight conversion to multi-shot
                    if (proj.veeringFan && proj._veeringTimer !== undefined) {
                        // Distance gating: ensure projectile traveled enough before considering split.
                        const dxSpawn = proj.x - (proj._spawnX||proj.x);
                        const dySpawn = proj.y - (proj._spawnY||proj.y);
                        const distSq = dxSpawn*dxSpawn + dySpawn*dySpawn;
                        if (distSq < (proj._veerMinDist||0)*(proj._veerMinDist||0)) {
                            // Defer countdown until distance met.
                        } else {
                            proj._veeringTimer--;
                        }
                        if (proj._veeringTimer === 0 && !proj._veered) {
                            proj._veered = true;
                            const ang = Math.atan2(proj.vy, proj.vx);
                            const speed = getProjSpeed(proj);
                            const base = proj.baseDamage||calculateDamage();
                            const sideCount = 4; // number of side projectiles (excludes original center)
                            const maxSpread = 0.55; // total radians from far left to far right (~31 deg)
                            // Keep original projectile as CENTER; adjust its stats slightly
                            proj.baseDamage = Math.max(1, Math.floor(base * 0.65));
                            proj.damage = proj.baseDamage;
                            proj.size = Math.max(2, proj.size * 0.75);
                            proj._centerVeer = true;
                            // Generate side projectiles in symmetrical pairs with easing spread
                            for (let i=0;i<sideCount;i++) {
                                const t = (i/(sideCount-1)) * 2 - 1; // -1 .. 1
                                // Ease towards extremes (quadratic) so inner shots cluster near center
                                const eased = t * Math.abs(t); // stronger near edges
                                const offset = eased * (maxSpread/2);
                                if (Math.abs(offset) < 0.0001) continue; // skip near-zero offset (center occupied)
                                const vx = Math.cos(ang + offset) * speed * 0.97;
                                const vy = Math.sin(ang + offset) * speed * 0.97;
                                game.spawnProjectile({
                                    x: proj.x, y: proj.y,
                                    vx, vy,
                                    life: Math.floor(proj.life * 0.85),
                                    size: Math.max(2, proj.size * 0.60), enemy:false,
                                    damage: Math.max(1, Math.floor(base * 0.45)), baseDamage: Math.max(1, Math.floor(base * 0.45)),
                                    veerChild:true,
                                    _initialFx: Math.cos(ang + offset), _initialFy: Math.sin(ang + offset)
                                });
                            }
                            addParticle(proj.x, proj.y, '#FFF2CC','spark');
                        }
                    }
                    // Converging Twins (new phased behavior): diverge -> curve inward -> fuse -> fused projectile persists (fix left-aim wrap)
                    if (proj.convergePair && proj._convGroup) {
                        proj._convTimer = (proj._convTimer||0)+1;
                        const phase = proj._convPhase || 'diverge';
                        const sp = Math.hypot(proj.vx, proj.vy) || 0.0001;
                        const ang = Math.atan2(proj.vy, proj.vx);
                        if (phase === 'diverge') {
                            // Maintain slight outward lateral drift for a set duration
                            if (proj._convTimer > 14) {
                                // Telegraph the curve-in (perf-aware)
                                if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.reduceRings)) addParticle(proj.x, proj.y, '#AEEBFF','ring');
                                proj._convPhase = 'curveIn';
                                proj._convTimer = 0;
                            }
                        } else if (phase === 'curveIn') {
                            // Apply curvature toward central forward direction gradually
                            // Determine average heading of group by sampling partner
                            let partner = null;
                            for (const p2 of game.projectiles) {
                                if (p2!==proj && p2._convGroup === proj._convGroup && !p2._fused && !proj._fused) { partner = p2; break; }
                            }
                            const forwardAng = partner ? Math.atan2((proj.vy+partner.vy)/2, (proj.vx+partner.vx)/2) : ang;
                            const blend = 0.05 + Math.min(0.18, proj._convTimer*0.004);
                            // Normalize smallest angle delta to avoid wrap causing vertical motion when aiming left
                            let delta = forwardAng - ang; delta = (delta + Math.PI) % (Math.PI*2); if (delta < 0) delta += Math.PI*2; delta -= Math.PI;
                            const newAng = ang + delta*blend;
                            proj.vx = Math.cos(newAng)*sp;
                            proj.vy = Math.sin(newAng)*sp;
                            if (proj._convTimer > 26) {
                                proj._convPhase = 'fuseCheck';
                                proj._convTimer = 0;
                            }
                        } else if (phase === 'fuseCheck') {
                            // Only one (primary) attempts fusion logic
                            if (proj._convPrimary) {
                                let partner = null;
                                for (const p2 of game.projectiles) {
                                    if (p2!==proj && p2._convGroup === proj._convGroup && !p2._fused && !proj._fused) { partner = p2; break; }
                                }
                                if (partner) {
                                    const dx = partner.x - proj.x; const dy = partner.y - proj.y; const d2 = dx*dx+dy*dy;
                                    // Allow fairly wide detection so they fuse mid-screen; shrink over time
                                    const fuseRadius = 110 - Math.min(70, proj._convTimer*2); // starts large, narrows
                                    if (d2 <= fuseRadius*fuseRadius) {
                                        // If very close perform actual fusion
                                        if (d2 < 38*38) {
                                            const baseCombined = (proj.baseDamage||calculateDamage()) + (partner.baseDamage||calculateDamage());
                                            const fuseX = (proj.x+partner.x)/2; const fuseY = (proj.y+partner.y)/2;
                                            const fuseVx = (proj.vx+partner.vx)/2; const fuseVy = (proj.vy+partner.vy)/2;
                                            // Spawn fused projectile with boosted size and damage (not full sum to avoid runaway)
                                            const fusedDmg = Math.max(1, Math.floor(baseCombined * 0.95));
                                            game.spawnProjectile({
                                                x: fuseX, y: fuseY,
                                                vx: fuseVx, vy: fuseVy,
                                                life: Math.max(proj.life, partner.life) + 40,
                                                size: Math.max(proj.size, partner.size) + 4,
                                                enemy:false,
                                                damage: fusedDmg,
                                                baseDamage: fusedDmg,
                                                fusedTwin:true,
                                                _fuseAuraTimer: 0,
                                                _convFused:true
                                            });
                                            proj._fused = true; partner._fused = true; proj.life = 0; partner.life = 0;
                                            // AoE burst on fuse (reward mid-range)
                                            const burstR = 90;
                                            const burstDamage = Math.max(2, Math.floor(fusedDmg * 0.45));
                                            if (game.enemies && game.enemies.length) {
                                                for (const en of game.enemies) {
                                                    const ex = en.x - fuseX; const ey = en.y - fuseY;
                                                    if (ex*ex+ey*ey <= burstR*burstR) {
                                                        en.health -= burstDamage;
                                                        addDamageNumber(burstDamage, en.x, en.y - en.size/2, { type:'arcane' });
                                                    }
                                                }
                                            }
                                            addParticle(fuseX, fuseY, '#BBAAFF','explosion');
                                        }
                                    }
                                    // After some time, if not fused yet, gently pull them together
                                    if (!proj._fused && proj._convTimer > 40 && partner) {
                                        const dx2 = partner.x - proj.x; const dy2 = partner.y - proj.y; const d = Math.hypot(dx2, dy2) || 1;
                                        const pull = Math.min(0.35, 12/d);
                                        proj.vx += dx2/d * pull * 0.5; proj.vy += dy2/d * pull * 0.5;
                                        partner.vx -= dx2/d * pull * 0.5; partner.vy -= dy2/d * pull * 0.5;
                                    }
                                }
                            }
                            proj._convTimer++;
                            // Fail-safe: stop checking after long time to avoid infinite state retention
                            if (proj._convTimer > 160) proj._convPhase = 'expired';
                        }
                    }
                }
                // Resonance framework: count active core motion patterns (excluding orbital/beam/enemy)
                if (!proj.enemy && !proj.beam) {
                    const motionPatterns = [proj.sineWave, proj.wackyZigzag, proj.ekgWave, proj.spiral];
                    let patternCount = 0;
                    for (let mp of motionPatterns) if (mp) patternCount++;
                    if (patternCount >= 2) {
                        // light intrinsic damage amplification stored on projectile
                        if (!proj._resonanceApplied) {
                            proj._resonanceApplied = true;
                            // store a multiplier rather than immediately mutating baseDamage so later scaling uses it
                            proj._resonanceMult = 1 + (patternCount === 2 ? 0.08 : patternCount === 3 ? 0.15 : 0.22);
                        }
                        // escalate multiplier if projectile later gains more patterns (e.g., via inheritance)
                        if (proj._resonanceMult) {
                            const desiredMult = 1 + (patternCount === 2 ? 0.08 : patternCount === 3 ? 0.15 : 0.22);
                            if (desiredMult > proj._resonanceMult) proj._resonanceMult = desiredMult;
                        }
                        // resonance pulse setup for >=3 patterns
                        if (patternCount >= 3) {
                            proj._resPulseTimer = (proj._resPulseTimer || 0) + 1;
                            // base interval shrinks slightly with patternCount (e.g., 90 -> 70 frames)
                            const interval = patternCount === 3 ? 90 : 70;
                            if (proj._resPulseTimer >= interval) {
                                proj._resPulseTimer = 0;
                                // spawn a lightweight pulse marker (handled immediately here for simplicity)
                                const pulseRadius = 52 + patternCount * 10;
                                const baseDmg = (proj.baseDamage || calculateDamage());
                                const pulseDamage = Math.floor(baseDmg * (0.18 + 0.04 * (patternCount - 3))); // 18% or 22%
                                game.enemies.forEach(en => {
                                    const dx = en.x - proj.x; const dy = en.y - proj.y;
                                    if (dx*dx + dy*dy <= pulseRadius * pulseRadius) {
                                        en.health -= pulseDamage;
                                        addParticle(en.x, en.y, '#AA66FF', 'impact');
                                    }
                                });
                                // visual ring particles
                                for (let k=0;k<24;k++) {
                                    const ang = (k/24)*Math.PI*2;
                                    addParticle(proj.x + Math.cos(ang)*pulseRadius, proj.y + Math.sin(ang)*pulseRadius, patternCount===3?'#66DDFF':'#FF55FF', 'spark');
                                }
                            }
                        }
                        // Quad resonance (all four patterns) occasional hypersurge: brief speed spike & particle
                        if (patternCount === 4) {
                            proj._quadTick = (proj._quadTick || 0) + 1;
                            if (proj._quadTick % 120 === 0) {
                                // small forward burst
                                const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                                proj.vx *= 1.25; proj.vy *= 1.25;
                                // clamp after burst
                                const nsp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                                const max = sp * 1.8;
                                if (nsp > max) { proj.vx = proj.vx / nsp * max; proj.vy = proj.vy / nsp * max; }
                                addParticle(proj.x, proj.y, '#FF99FF', 'spark');
                            }
                        }
                    }
                }
                // Homing behavior (full homing and weak homing)
                if (!proj.enemy && game.enemies.length > 0 && (proj.homing || proj.weakHoming)) {
                    // find nearest enemy
                    let target = null;
                    let closestDist = Infinity;
                    game.enemies.forEach(enemy => {
                        const dist = Math.sqrt((enemy.x - proj.x) ** 2 + (enemy.y - proj.y) ** 2);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = enemy;
                        }
                    });
                    if (target) {
                        const dx = target.x - proj.x;
                        const dy = target.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;
                        if (proj.homing) {
                            // stronger homing: steer more aggressively and normalize
                            const steer = 0.35;
                            proj.vx += (dx / dist) * steer;
                            proj.vy += (dy / dist) * steer;
                            const sp = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy) || 0.0001;
                            const desired = Math.max(0.6, sp);
                            proj.vx = (proj.vx / sp) * desired;
                            proj.vy = (proj.vy / sp) * desired;
                        } else if (proj.weakHoming) {
                            // weak homing: slightly stronger to remain noticeable next to patterns
                            const steer = 0.16;
                            proj.vx += (dx / dist) * steer;
                            proj.vy += (dy / dist) * steer;
                        }
                    }
                }
                // Pattern Trail Visuals: emit lightweight particles indicating motion synergy
                if (!proj.enemy && !proj.beam) {
                    // Determine if projectile should spawn a trail this frame
                    // Base chance for any projectile with motion pattern; higher for chaos wacky
                    let spawnTrail = false;
                    let baseChance = 0;
                    const motionCount = (proj.sineWave?1:0)+(proj.wackyZigzag?1:0)+(proj.ekgWave?1:0)+(proj.spiral?1:0);
                    if (motionCount > 0) baseChance = 0.10 + motionCount * 0.03; // 10% +3% per pattern
                    if (proj.wackyZigzag) baseChance += 0.05;
                    if (proj._wackyChaos) baseChance += 0.12; // more intense trail for chaos variant
                    if (Math.random() < baseChance) spawnTrail = true;
                    if (spawnTrail) {
                        const hex = getProjectileSynergyColor(proj);
                        // Particle size scales with motion complexity
                        const pSize =  proj._wackyChaos ? 6 : (3 + Math.min(3, motionCount));
                        // Emit 1-2 particles, slight backward offset along velocity
                        const backX = proj.x - proj.vx*0.08;
                        const backY = proj.y - proj.vy*0.08;
                        addParticle(backX, backY, hex, 'spark');
                        if (proj._wackyChaos && Math.random()<0.5) addParticle(backX + (Math.random()-0.5)*6, backY + (Math.random()-0.5)*6, hex, 'spark');
                    }
                }
                // Beam pattern blending (visual modulation) - apply after homing but before movement finalize
                if (proj.beam && !proj.enemy) {
                    // increment phase
                    proj._beamPatternPhase = (proj._beamPatternPhase || 0) + 1;
                    // slight oscillation perpendicular to direction for sine
                    if (!proj._beamBasis) {
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy)||1;
                        proj._beamBasis = { fx: proj.vx/sp, fy: proj.vy/sp };
                        proj._beamBasis.px = -proj._beamBasis.fy; proj._beamBasis.py = proj._beamBasis.fx;
                    }
                    let offX = 0, offY = 0;
                    const phase = proj._beamPatternPhase;
                    if (proj.sineWave) {
                        const amp = 4 + (proj.spiral?2:0);
                        const s = Math.sin(phase * 0.3) * amp;
                        offX += proj._beamBasis.px * s; offY += proj._beamBasis.py * s;
                    }
                    if (proj.wackyZigzag) {
                        const dirFlip = ((phase/6)|0)%2===0?1:-1;
                        offX += proj._beamBasis.px * dirFlip * 3;
                        offY += proj._beamBasis.py * dirFlip * 3;
                    }
                    if (proj.ekgWave) {
                        const cyc = phase % 50;
                        if (cyc < 8) {
                            const t = cyc/8; const spike = -Math.sin(t*Math.PI)*10;
                            offX += proj._beamBasis.px * spike; offY += proj._beamBasis.py * spike;
                        }
                    }
                    if (proj.spiral) {
                        const rotAng = phase * 0.15;
                        // rotate offset around small circle
                        offX += Math.cos(rotAng)*2; offY += Math.sin(rotAng)*2;
                    }
                    proj.x += offX * 0.25; // damp to avoid large displacement changing collision fairness
                    proj.y += offY * 0.25;
                    // occasional pattern particle
                    if (Math.random() < 0.12) {
                        const color = proj.spiral?'#FF66FF': (proj.ekgWave?'#66FFCC': (proj.wackyZigzag?'#FFDD55':'#66AAFF'));
                        addParticle(proj.x, proj.y, color, 'spark');
                    }
                }
                // Boomerang behavior (ensured return + chaining + movement bias + wind synergy)
                if (proj.boomerang && !proj.enemy) {
                    // Initialization of boomerang arc parameters
                    if (!proj._boomInit) {
                        proj._boomInit = true;
                        // Store origin and initial forward unit vector
                        const sp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 1;
                        proj._boomFx = proj.vx / sp; proj._boomFy = proj.vy / sp;
                        // Random lateral sign for variety
                        proj._boomSide = (Math.random() < 0.5 ? -1 : 1);
                        // Max lateral offset radius (arc width)
                        proj._boomMaxLat = 90 + Math.random()*30; // px
                        // Distance before turning back
                        proj._boomOutboundDist = 180 + Math.random()*40; // slightly shorter to ensure visible return
                        proj._boomTravel = 0; // accumulated forward distance
                        proj._boomReturn = false;
                        proj._boomChained = false; // echo spawn flag
                        proj._boomOriginX = proj.x; proj._boomOriginY = proj.y;
                        proj._boomAge = 0; // frames alive for safety timeout
                        proj._boomForced = false; // whether forced return occurred
                        proj._boomBaseLife = proj.life || 140;
                    }
                    proj._boomAge++;
                    // Compute forward speed magnitude
                    let speed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.01;
                    // Update forward travel distance using projection onto initial forward vector
                    const stepForward = (proj.vx*proj._boomFx + proj.vy*proj._boomFy);
                    // Accumulate more aggressively so high lateral components still progress outbound timer
                    proj._boomTravel += Math.max(0, stepForward * 0.9);
                    // Fallback: also measure radial distance from origin; if that exceeds outboundDist * 0.9, trigger return
                    if (!proj._boomReturn) {
                        const ox = proj.x - proj._boomOriginX; const oy = proj.y - proj._boomOriginY;
                        const radial = Math.hypot(ox,oy);
                        if (radial > proj._boomOutboundDist * 0.95) proj._boomReturn = true;
                    }

                    // Trigger return when outbound distance met OR if exceeded arena bounds
                    if (!proj._boomReturn && proj._boomTravel >= proj._boomOutboundDist) {
                        proj._boomReturn = true;
                    }
                    // Safety timeout: if not yet returning by frame 90, force it
                    if (!proj._boomReturn && proj._boomAge > 90) {
                        proj._boomReturn = true; proj._boomForced = true;
                    }

                    // Movement bias: if player currently moving, gently bias lateral side toward movement perpendicular (outbound only)
                    if (!proj._boomReturn) {
                        const mvx = (game.keys['d']?1:0) - (game.keys['a']?1:0);
                        const mvy = (game.keys['s']?1:0) - (game.keys['w']?1:0);
                        if (mvx || mvy) {
                            const ml = Math.hypot(mvx,mvy)||1; const nmx = mvx/ml, nmy = mvy/ml;
                            const cross = (proj._boomFx * nmy - proj._boomFy * nmx); // signed relation
                            if (Math.abs(cross) > 0.2) {
                                proj._boomSide = cross > 0 ? 1 : -1;
                            }
                        }
                    }

                    // Base forward direction: outbound uses initial forward; return aims toward player gradually
                    let fx = proj._boomFx, fy = proj._boomFy;
                    if (proj._boomReturn) {
                        const dxp = game.player.x - proj.x;
                        const dyp = game.player.y - proj.y;
                        const dpl = Math.hypot(dxp,dyp)||1;
                        const tFx = dxp / dpl, tFy = dyp / dpl;
                        // Smoothly rotate toward player direction (lerp of unit vectors) stronger when forced
                        const blend = proj._boomForced ? 0.25 : 0.12;
                        fx = fx * (1-blend) + tFx * blend; fy = fy * (1-blend) + tFy * blend;
                        const norm = Math.hypot(fx,fy)||1; fx/=norm; fy/=norm;
                        proj._boomFx = fx; proj._boomFy = fy;
                        // Mirror arc side for return for a classic boomerang path
                        proj._boomSide = proj._boomSide || 1; // safety
                        proj._boomReturnSide = (typeof proj._boomReturnSide==='number')?proj._boomReturnSide: -proj._boomSide;
                        // Extend life on entering return so it doesn't vanish prematurely
                        if (!proj._boomLifeExtended) { proj.life = Math.max(proj.life, 60); proj._boomLifeExtended = true; }
                    }

                    // Lateral progress (0..1) along outbound or return; use sine for graceful arc
                    const phaseFrac = Math.min(1, proj._boomTravel / proj._boomOutboundDist);
                    // Ease the lateral amplitude: outbound grows then stabilizes, return decreases
                    let lateralFrac;
                    if (!proj._boomReturn) {
                        lateralFrac = Math.sin(phaseFrac * Math.PI * 0.9); // peaks before full outbound
                    } else {
                        lateralFrac = Math.sin((1 - phaseFrac) * Math.PI * 0.9); // fade down
                    }
                    lateralFrac = Math.max(0, lateralFrac);
                    const latMag = proj._boomMaxLat * lateralFrac;
                    // Perpendicular vector to forward (fx,fy)
                    const px = -fy, py = fx;
                    // Determine side: outbound uses _boomSide, return uses mirrored side for a figure
                    const side = proj._boomReturn ? (proj._boomReturnSide) : proj._boomSide;
                    // Target lateral position relative to straight-line forward ray
                    proj._boomLat = latMag * side;
                    // We convert lateral displacement into a small velocity tweak pulling the projectile outward along perpendicular
                    // Then speed toward forward direction is slightly reduced near peak arc to curve naturally.
                    const lateralStrength = 0.12;
                    proj.vx = fx * speed * 0.97 + px * (proj._boomLat/ proj._boomMaxLat) * lateralStrength * speed;
                    proj.vy = fy * speed * 0.97 + py * (proj._boomLat/ proj._boomMaxLat) * lateralStrength * speed;
                    // Minimum forward speed clamp so it doesn't stall mid-air
                    const curSpeed = Math.hypot(proj.vx, proj.vy) || 0.01;
                    if (curSpeed < 2) {
                        const boost = (proj._boomReturn ? 1.25 : 1.12);
                        proj.vx = (proj.vx / curSpeed) * (curSpeed * boost + 0.05);
                        proj.vy = (proj.vy / curSpeed) * (curSpeed * boost + 0.05);
                    }
                    // Slight acceleration on return to ensure timely comeback
                    if (proj._boomReturn) {
                        proj.vx *= 1.012; proj.vy *= 1.012;
                    }
                    // Wind synergy: dynamic widening & swirl particles
                    if (game.player && game.player.abilities && game.player.abilities.includes('Wind Blade')) {
                        proj._boomMaxLat = Math.min(170, proj._boomMaxLat * 1.004 + 0.05);
                        if (Math.random() < 0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#AEEFFF','spark');
                    }
                    // Multi-boomerang chaining (echo spawns) during outbound
                    if (!proj._boomReturn && !proj._boomChained && !proj._boomEcho && proj._boomTravel > proj._boomOutboundDist * 0.50) {
                        proj._boomChained = true;
                        const echoCount = 1 + (Math.random()<0.45 ? 1 : 0);
                        for (let e=0;e<echoCount;e++) {
                            const angJ = (Math.random()-0.5)*0.3;
                            const baseSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) * (0.85 - e*0.1);
                            const ang = Math.atan2(proj.vy, proj.vx) + angJ;
                            const eIdx = game.spawnProjectile({
                                x: proj.x + Math.cos(ang)*6,
                                y: proj.y + Math.sin(ang)*6,
                                vx: Math.cos(ang)*baseSpeed,
                                vy: Math.sin(ang)*baseSpeed,
                                life: Math.min(160, (proj.life||140)),
                                r: Math.max(4, Math.floor(((proj.size)||6)*0.85)),
                                damage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage()) * 0.55)),
                                damageType: proj.damageType || null
                            });
                            if (!game._projMeta) game._projMeta = new Map();
                            if (eIdx>=0) game._projMeta.set(eIdx,{ boomerang:true, boomerangReturned:false, _boomInit:false, _boomEcho:true, piercing:proj.piercing, pierceCount:proj.pierceCount||0, pierceHits:0, baseDamage: Math.max(1, Math.floor((proj.baseDamage||calculateDamage()) * 0.55)) });
                            for (let p=0;p<6;p++) addParticle((proj.x + Math.cos(ang)*6) + (Math.random()-0.5)*10, (proj.y + Math.sin(ang)*6) + (Math.random()-0.5)*10, '#FFFFFF','spark');
                        }
                    }
                    // Arrival check (close to player once returning)
                    const dxp2 = proj.x - game.player.x;
                    const dyp2 = proj.y - game.player.y;
                    if (proj._boomReturn && Math.hypot(dxp2,dyp2) < 22) {
                        for (let k=0;k<5;k++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFFFFF', 'spark');
                        return false;
                    }
                    // Decorative trailing sparkle (subtle) while returning
                    if (proj._boomReturn && Math.random()<0.18) addParticle(proj.x, proj.y, '#E0F8FF','spark');
                }
                // Time Bomb: delayed explosion after a timer
                if (proj.timeBomb && !proj.enemy) {
                    proj._timeBombTimer = (typeof proj._timeBombTimer === 'number') ? proj._timeBombTimer : 54; // default short fuse
                    // Cache the initial fuse length for normalized glow intensity
                    if (typeof proj._tbFuseMax !== 'number') proj._tbFuseMax = proj._timeBombTimer;
                    proj._timeBombTimer--;
                    const t = proj._timeBombTimer;
                    // Pulse visuals escalate quickly
                    if (t % 10 === 0) addParticle(proj.x, proj.y, '#FFECAA', 'spark');
                    if (t < 36 && t % 5 === 0) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFC744', 'spark');
                    if (t < 18 && t % 2 === 0) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FF9922', 'spark');
                    if (t === 20) proj._timeBombArmed = true;
                    // Fuse glow intensifies as timer approaches 0 (0..1 non-linear easing)
                    {
                        const maxFuse = Math.max(1, proj._tbFuseMax || 54);
                        const frac = 1 - Math.max(0, Math.min(1, t / maxFuse));
                        // Ease-in squared for stronger late-stage emphasis
                        proj._tbGlowI = Math.min(1, frac*frac * (proj._timeBombArmed ? 1.2 : 1));
                    }
                    // Arming ring cue (once at arm) and pre-detonation ring cue (very short)
                    if (typeof addTransientEffect === 'function') {
                        const lowFx = !!(game.perf && game.perf.lowFx);
                        const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                        if (!lowFx && !reduceRings) {
                            if (t === 20) addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFD38A', radius: 16, life: 140 });
                            if (t === 4) addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFAA55', radius: 18, life: 110 });
                        }
                    }
                    // Mild flashing scale indicator when armed
                    if (proj._timeBombArmed && t % 4 === 0) {
                        addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFD777', 'spark');
                    }
                    if (t <= 0) {
                        const damage = Math.floor((proj.baseDamage || calculateDamage()) * (proj._timeBombExplosionMult || 2.0));
                        explodeProjectile(proj, damage);
                        proj.life = 0;
                    }
                }
                // Meteor: guided descent toward target; guaranteed timed explosion with knockback
                if (proj.meteor && !proj.enemy) {
                    // Flame / trail particles
                    proj._flameTick = (proj._flameTick || 0) + 1;
                    if (proj._flameTick % 2 === 0) {
                        addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFB347', 'spark');
                        if (Math.random() < 0.30) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFD27F', 'spark');
                    }
                    if (proj._flameTick % 5 === 0) addParticle(proj.x + (Math.random()-0.5)*16, proj.y + (Math.random()-0.5)*16, '#663300', 'explosion');
                    // Deterministic interpolation based on spawn/detonate frames
                    if (proj._meteorDetonateAt && proj._meteorSpawnFrame != null && proj._meteorStartY != null) {
                        const total = Math.max(1, proj._meteorDetonateAt - proj._meteorSpawnFrame);
                        const elapsed = Math.min(total, game.frame - proj._meteorSpawnFrame);
                        const t = Math.min(1, elapsed / total);
                        if (proj._meteorTargetX != null && proj._meteorStartX != null) {
                            const easeT = t < 0.5 ? (2*t*t) : (-1 + (4 - 2*t)*t); // easeInOut
                            proj.x = proj._meteorStartX + (proj._meteorTargetX - proj._meteorStartX) * easeT;
                        }
                        if (proj._meteorTargetY != null) {
                            proj.y = proj._meteorStartY + (proj._meteorTargetY - proj._meteorStartY) * t;
                        }
                    }
                    if (game.frame >= proj._meteorDetonateAt && !proj._meteorExploded) {
                        proj._meteorExploded = true;                        
                        const dmg = proj.baseDamage || calculateDamage();
                        const radius = proj._meteorAoeRadius || 90;
                        // Damage + knockback
                        game.enemies.forEach(en => {
                            const dx = en.x - proj.x; const dy = en.y - proj.y; const dist = Math.hypot(dx,dy);
                            if (dist <= radius) {
                                const mult = (1 - dist / radius) * 0.75 + 0.25; // soften edge
                                const dealt = Math.floor(dmg * mult);
                                en.health -= dealt;
                                addDamageNumber(dealt, en.x, en.y - en.size/2, { type: 'fire' });
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                                // Knockback outward
                                const k = (proj._meteorKnockback || 120) * (1 - dist / radius);
                                if (k > 8) applyKnockback(en, k, dx, dy);
                            }
                        });
                        addScreenShake(11);
                        // Visual blast
                        explodeProjectile({ x: proj.x, y: proj.y, size: proj.size, damageType: 'fire', knockback: true, knockbackDistance: proj._meteorKnockback || 120 }, dmg);
                        for (let p=0;p<38;p++) addParticle(proj.x + (Math.random()-0.5)*radius*1.4, proj.y + (Math.random()-0.5)*radius*1.4, '#FF8844','explosion');
                        // Retire telegraph marker
                        if (typeof proj._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[proj._meteorMarkerId]) {
                            game.meteorMarkers[proj._meteorMarkerId].dead = true;
                        }
                        proj.life = 0;
                    } else if (proj.life <= 0 && !proj._meteorExploded) {
                        // Fallback: if life ended prematurely (e.g., offscreen cull modification) still trigger explosion
                        proj._meteorExploded = true;
                        const dmg = proj.baseDamage || calculateDamage();
                        const radius = proj._meteorAoeRadius || 90;
                        game.enemies.forEach(en => {
                            const dx = en.x - proj.x; const dy = en.y - proj.y; const dist = Math.hypot(dx,dy);
                            if (dist <= radius) {
                                const mult = (1 - dist / radius) * 0.75 + 0.25;
                                const dealt = Math.floor(dmg * mult);
                                en.health -= dealt;
                                addDamageNumber(dealt, en.x, en.y - en.size/2, { type: 'fire' });
                                en.burning = true; en.burnTime = Math.max(en.burnTime||0, 120);
                                const k = (proj._meteorKnockback || 120) * (1 - dist / radius);
                                if (k > 8) applyKnockback(en, k, dx, dy);
                            }
                        });
                        addScreenShake(9);
                        explodeProjectile({ x: proj.x, y: proj.y, size: proj.size, damageType: 'fire', knockback: true, knockbackDistance: proj._meteorKnockback || 120 }, dmg);
                        for (let p=0;p<26;p++) addParticle(proj.x + (Math.random()-0.5)*radius*1.2, proj.y + (Math.random()-0.5)*radius*1.2, '#FF7744','explosion');
                        if (typeof proj._meteorMarkerId==='number' && game.meteorMarkers && game.meteorMarkers[proj._meteorMarkerId]) {
                            game.meteorMarkers[proj._meteorMarkerId].dead = true;
                        }
                    }
                }
                // Quantum shot: slight life regen so it can hit multiple times
                if (proj.quantum && !proj.enemy) {
                    proj.life += 0.15;
                }
                // Reality field refraction: if projectile passes through an active reality field, bend its velocity
                if (!proj.enemy && game.activeRealityFields && game.activeRealityFields.length > 0) {
                    game.activeRealityFields.forEach(field => {
                        const dx = proj.x - field.x;
                        const dy = proj.y - field.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < field.radius) {
                            // compute vector from field center to projectile and apply small lateral impulse
                            const angleToCenter = Math.atan2(proj.y - field.y, proj.x - field.x);
                            const lateral = (Math.cos(angleToCenter + Math.PI/2) * 0.6);
                            // nudge velocity perpendicular to radial vector to create refraction-like bend
                            const spd = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                            proj.vx += lateral * (1 - dist / field.radius) * 0.6;
                            proj.vy += Math.sin(angleToCenter + Math.PI/2) * (1 - dist / field.radius) * 0.6;
                            // normalize to keep speed stable
                            const nsp = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy) || 0.0001;
                            proj.vx = (proj.vx / nsp) * spd;
                            proj.vy = (proj.vy / nsp) * spd;
                            // small visual cue
                            if (Math.random() < 0.08) addParticle(proj.x, proj.y, '#66FFFF', 'spark');
                        }
                    });
                }
                // Orbital projectiles: now inherit motion pattern modifiers for dynamic paths & resonance
                if (proj._orbital && !proj.enemy) {
                    // Initialize pattern fusion state once
                    if (!proj._orbitalInit) {
                        proj._orbitalInit = true;
                        proj._baseRadius = proj._orbitRadius;
                        proj._sinePhase = Math.random() * Math.PI * 2;
                        proj._wackyTimer = 0;
                        proj._ekgState = 'flat'; proj._ekgTimer = 0;
                        proj._spiralPhase = 0;
                        // Derive pattern presence flags from existing projectile flags (inherited at spawn)
                        proj._patSine = !!proj.sineWave;
                        proj._patWacky = !!proj.wackyZigzag;
                        proj._patEKG = !!proj.ekgWave;
                        proj._patSpiral = !!proj.spiral;
                        // Base resonance multiplier grows with number of patterns (match non-orbital logic but reduced)
                        const pc = (proj._patSine?1:0)+(proj._patWacky?1:0)+(proj._patEKG?1:0)+(proj._patSpiral?1:0);
                        proj._resonanceOrbMult = pc>=4?1.18: pc===3?1.13: pc===2?1.08:1.0; // gentler than projectile version
                    }
                    proj._orbitAngle += proj._orbitSpeed;
                    let dynamicRadius = proj._baseRadius;
                    // Sine: smooth pulsation of radius
                    if (proj._patSine) {
                        proj._sinePhase += 0.07; // slow pulse
                        dynamicRadius += Math.sin(proj._sinePhase) * (8 + Math.min(18, proj._baseRadius * 0.12));
                    }
                    // Wacky: small angular jitter & radius micro noise
                    if (proj._patWacky) {
                        proj._wackyTimer++;
                        if (proj._wackyTimer % 14 === 0) {
                            proj._orbitAngle += (Math.random() - 0.5) * 0.9; // burst re-vector
                        }
                        dynamicRadius += (Math.random() - 0.5) * 10;
                    }
                    // EKG: periodic sharp contraction / expansion pulses
                    if (proj._patEKG) {
                        proj._ekgTimer++;
                        const cyc = proj._ekgTimer % 120; // 120f cycle (~2s)
                        if (cyc < 12) {
                            // Ascending spike – rapid contraction
                            const t = cyc / 12;
                            dynamicRadius -= (18 + proj._baseRadius * 0.15) * Math.sin(t * Math.PI/2);
                        } else if (cyc >= 12 && cyc < 24) {
                            // Descend & rebound
                            const t = (cyc-12)/12;
                            dynamicRadius -= (18 + proj._baseRadius * 0.15) * (1 - t) * 0.6;
                        }
                    }
                    // Spiral: slow precession of orbital angle and mild radius growth/decay wave
                    if (proj._patSpiral) {
                        proj._spiralPhase += 0.03;
                        proj._orbitAngle += Math.sin(proj._spiralPhase * 0.8) * 0.015;
                        dynamicRadius += Math.sin(proj._spiralPhase * 1.3) * 12;
                    }
                    // Clamp radius to safe bounds
                    const minR = Math.max(40, proj._baseRadius * 0.55);
                    const maxR = Math.min(260, proj._baseRadius * 1.45);
                    if (dynamicRadius < minR) dynamicRadius = minR;
                    if (dynamicRadius > maxR) dynamicRadius = maxR;
                    proj._orbitRadius = dynamicRadius;
                    // Position orbital
                    proj.x = game.player.x + Math.cos(proj._orbitAngle) * dynamicRadius;
                    proj.y = game.player.y + Math.sin(proj._orbitAngle) * dynamicRadius;
                    // Pattern particle trail (color shift with resonance strength)
                    if (Math.random() < 0.22) {
                        const pc = (proj._patSine?1:0)+(proj._patWacky?1:0)+(proj._patEKG?1:0)+(proj._patSpiral?1:0);
                        const color = pc>=4?'#FF99FF': pc===3?'#AA88FF': pc===2?'#88EEFF':'#88EEFF';
                        addParticle(proj.x, proj.y, color, 'spark');
                    }
                    // Damage nearby enemies (resonance multiplier applied)
                    const baseTick = Math.floor(calculateDamage() * 0.6 * (proj._resonanceOrbMult || 1));
                    game.enemies.forEach(enemy => {
                        if (enemy.health<=0) return;
                        const dx = proj.x - enemy.x; const dy = proj.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < (enemy.size/2 + proj.size)) {
                            enemy.health -= Math.max(1, baseTick);
                            addParticle(enemy.x, enemy.y, '#88EEFF', 'impact');
                        }
                    });
                    proj.life = 99999; // persistent
                }
                // Spinning blade (weapon) visual/logic (unchanged behavior for weapon spin)
                if (proj.spin && !proj.enemy && !proj.spiral) {
                    proj.spinAngle += proj.spinSpeed || 0.5;
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    game.enemies.forEach((enemy) => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        if (d < (enemy.size/2 + (proj.size||10))) {
                            enemy.health -= Math.floor(calculateDamage() * 0.9);
                            addParticle(enemy.x, enemy.y, '#CCCCCC', 'impact');
                        }
                    });
                }
                // True Spiral Shot motion: projectiles with proj.spiral orbit along a local circular path while advancing forward.
                if (proj.spiral && !proj.enemy) {
                    // Initialize spiral state once
                    if (!proj._spiralInit) {
                        proj._spiralInit = true;
                        // Base forward direction from initial velocity
                        const baseDirAngle = Math.atan2(proj.vy, proj.vx);
                        proj._spiralBaseAngle = baseDirAngle; // stored for forward drift
                        proj._spiralPhase = 0; // current angle around local loop
                        // Enlarged spiral parameters for more dramatic looping
                        proj._spiralRadius = Math.max(10, Math.min(42, (proj.size||6) * 2.2)); // bigger starting loop
                        proj._spiralRadiusGrowth = 0.085; // faster outward expansion
                        proj._spiralAngularSpeed = 0.30 + Math.random()*0.10; // slightly slower to keep large loops readable
                        proj._spiralForwardSpeed = Math.sqrt(proj.vx*proj.vx + proj.vy*proj.vy);
                        // Stronger damping so forward drift doesn't stretch the spiral too quickly
                        proj._spiralForwardSpeed *= 0.70;
                        // Preserve damage tracking
                    }
                    // Advance spiral phase & radius (cap radius growth to avoid huge loops)
                    proj._spiralPhase += proj._spiralAngularSpeed;
                    // Increase cap for new bigger loops
                    proj._spiralRadius = Math.min(110, proj._spiralRadius + proj._spiralRadiusGrowth);
                    // Compute local circular offset
                    const ox = Math.cos(proj._spiralPhase) * proj._spiralRadius;
                    const oy = Math.sin(proj._spiralPhase) * proj._spiralRadius;
                    // Forward drift anchor moves along base direction each frame
                    proj._spiralAnchorX = (proj._spiralAnchorX == null ? proj.x : proj._spiralAnchorX) + Math.cos(proj._spiralBaseAngle) * proj._spiralForwardSpeed;
                    proj._spiralAnchorY = (proj._spiralAnchorY == null ? proj.y : proj._spiralAnchorY) + Math.sin(proj._spiralBaseAngle) * proj._spiralForwardSpeed;
                    proj.x = proj._spiralAnchorX + ox;
                    proj.y = proj._spiralAnchorY + oy;
                    // Slight spin for visual flair if rendering uses spinAngle
                    proj.spinAngle = (proj.spinAngle || 0) + (proj.spinSpeed || 0.3);
                    // Life decay (already applied below normally) – we override base movement so skip the generic proj.x+=vx/vy step later by flagging
                    proj._skipBaseMove = true;
                    // Optional: emit small spiral particles occasionally
                    if (Math.random() < 0.18) addParticle(proj.x + (Math.random()-0.5)*4, proj.y + (Math.random()-0.5)*4, '#FF66FF', 'spark');
                }
                // Drilling shot: increases pierce and leaves a dust trail
                if (proj.drilling && !proj.enemy) {
                    proj.piercing = true;
                    proj.pierceCount = Math.max(proj.pierceCount, 6);
                    if (Math.random() < 0.2) addParticle(proj.x, proj.y, '#CCCCCC', 'spark');
                    proj._drillTicks = (proj._drillTicks || 0) + 1;
                    if (proj._drillTicks % 30 === 0) {
                        proj.baseDamage = Math.floor((proj.baseDamage || calculateDamage()) * 1.05);
                        addParticle(proj.x, proj.y, '#EEEEEE', 'spark');
                    }
                }
                if (!proj._skipBaseMove) {
                    // CONSOLIDATED PATTERN AMPLIFICATION (moved here so it runs after all pattern logic but before
                    // the base position integration). This scales both lateral velocity components (once per frame)
                    // and also scales any direct position displacement produced by patterns (proj.x/proj.y overrides)
                    // so that both velocity-driven and position-driven patterns are magnified by the ability.
                    const amp = (proj._patternAmpFactor && proj._patternAmpFactor > 1) ? proj._patternAmpFactor : 1.0;
                    if (amp > 1.0) {
                        // Velocity-side amplification: apply once per frame (use game._frameNow to avoid alternating state)
                        if (proj._patternAmpLastAppliedFrame !== game._frameNow) {
                            const speed = Math.hypot(proj.vx, proj.vy) || 0.0001;
                            let fx = proj._initialFx, fy = proj._initialFy;
                            if (typeof fx !== 'number' || typeof fy !== 'number') { fx = proj.vx / speed; fy = proj.vy / speed; }
                            const forwardMag = proj.vx*fx + proj.vy*fy;
                            const forwardVx = fx * forwardMag;
                            const forwardVy = fy * forwardMag;
                            let lateralVx = proj.vx - forwardVx;
                            let lateralVy = proj.vy - forwardVy;
                            lateralVx *= amp; lateralVy *= amp;
                            proj.vx = forwardVx + lateralVx; proj.vy = forwardVy + lateralVy;
                            // Clamp total speed to avoid runaway (allow up to +25% total speed boost)
                            const newSpeed = Math.hypot(proj.vx, proj.vy) || 0.0001;
                            const maxSpeed = speed * 1.25;
                            if (newSpeed > maxSpeed) {
                                const scale = maxSpeed / newSpeed; proj.vx *= scale; proj.vy *= scale;
                            }
                            proj._patternAmpLastAppliedFrame = game._frameNow;
                        }
                        // Position displacement amplification: if patterns directly set proj.x/proj.y (orbital/spiral/etc),
                        // scale that displacement relative to the saved pre-pattern position captured earlier.
                        if (proj._prePatternX != null && proj._prePatternY != null) {
                            const dx = proj.x - proj._prePatternX; const dy = proj.y - proj._prePatternY;
                            proj.x = proj._prePatternX + dx * amp;
                            proj.y = proj._prePatternY + dy * amp;
                        }
                    }

                    // Store last safe position before movement for bounce recovery
                    proj._lastX = proj.x;
                    proj._lastY = proj.y;
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                }
                // Apply Resonant buff effects (speed/damage/homing) after base movement so velocity mod applies next frame
                if (!proj.enemy) {
                    if (proj._resBuffSpeed && proj._resBuffSpeed>0) {
                        proj._resBuffSpeed--;
                        proj.vx *= 1.045; proj.vy *= 1.045;
                    }
                    if (proj._resBuffDamage && proj._resBuffDamage>0) {
                        proj._resBuffDamage--;
                        if (proj.baseDamage) proj.damage = Math.max(proj.damage||1, Math.floor(proj.baseDamage * 1.15));
                    }
                    if (proj._resBuffHoming && proj._resBuffHoming>0) {
                        proj._resBuffHoming--;
                        // mild steering toward nearest enemy
                        let nearest=null; let nd2=Infinity;
                        for (const enemy of game.enemies) {
                            if (enemy.dead) continue;
                            const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const d2 = dx*dx+dy*dy; if (d2<nd2) { nd2=d2; nearest=enemy; }
                        }
                        if (nearest) {
                            const sp = Math.hypot(proj.vx, proj.vy)||1;
                            const tx = (nearest.x - proj.x)/Math.sqrt(nd2||1);
                            const ty = (nearest.y - proj.y)/Math.sqrt(nd2||1);
                            // blend velocity slightly
                            proj.vx = proj.vx*0.92 + tx*sp*0.08;
                            proj.vy = proj.vy*0.92 + ty*sp*0.08;
                        }
                    }
                }
                // Reset skip flag for next frame
                proj._skipBaseMove = false;
                // Prevent life decay for orbitals (already set high) to avoid unnecessary churn
                if (!proj._orbital) proj.life--;
                // Bouncing: handle wall and edge collisions robustly
                // Phasing synergy: if phasing is active, we still decrement bounces on edge contact, and we allow
                // ricochet chaining (enemy-to-enemy) without requiring an actual wall collision.
                if (proj.bouncing && proj.bounces > 0) {
                    let bounced = false;
                    // Predict next position to determine collision normal
                    const nextX = proj.x + proj.vx;
                    const nextY = proj.y + proj.vy;

                    // If we are already overlapping a wall (pattern lateral shift pushed us inside), rewind to last safe and force bounce
                    if (!proj.phasing && isWall(proj.x, proj.y, Math.max(8, proj.size))) {
                        // Use last base move position or pre-pattern snapshot if available
                        if (proj._lastX != null && proj._lastY != null) {
                            proj.x = proj._lastX; proj.y = proj._lastY;
                        } else if (proj._prePatternX != null) {
                            proj.x = proj._prePatternX; proj.y = proj._prePatternY;
                        }
                        // Determine which axis caused penetration by testing offset separately
                        const testXBlocked = isWall(proj.x + proj.vx, proj.y, Math.max(8, proj.size));
                        const testYBlocked = isWall(proj.x, proj.y + proj.vy, Math.max(8, proj.size));
                        if (testXBlocked && !testYBlocked) {
                            proj.vx = -proj.vx * 0.85;
                        } else if (testYBlocked && !testXBlocked) {
                            proj.vy = -proj.vy * 0.85;
                        } else {
                            proj.vx = -proj.vx * 0.78;
                            proj.vy = -proj.vy * 0.78;
                        }
                        bounced = true;
                    }

                    // Bounce off canvas edges (phasing still bounces on arena bounds)
                    if (nextX - proj.size <= 0 || nextX + proj.size >= canvas.width) {
                        proj.vx = -proj.vx * 0.86;
                        bounced = true;
                    }
                    if (nextY - proj.size <= 0 || nextY + proj.size >= canvas.height) {
                        proj.vy = -proj.vy * 0.86;
                        bounced = true;
                    }

                    // Bounce off walls (skip internal walls if phasing, but edge bounce already handled above)
                    if (!proj.phasing) {
                        // Check collision at next position with a modest size to detect wall contact
                        if (isWall(nextX, nextY, Math.max(8, proj.size))) {
                            // Determine which axis to reflect based on wall overlap by sampling small offsets
                            // If horizontal offset is more obstructed, flip vx, else flip vy.
                            const horBlocked = isWall(proj.x + proj.vx, proj.y, Math.max(8, proj.size));
                            const verBlocked = isWall(proj.x, proj.y + proj.vy, Math.max(8, proj.size));
                            if (horBlocked && !verBlocked) {
                                proj.vx = -proj.vx * 0.82;
                            } else if (verBlocked && !horBlocked) {
                                proj.vy = -proj.vy * 0.82;
                            } else {
                                // both blocked or unclear - reflect both with damping
                                proj.vx = -proj.vx * 0.76;
                                proj.vy = -proj.vy * 0.76;
                            }
                            bounced = true;
                            // Split Shot: split on wall bounce
                            // (Split Shot removed – no wall-bounce splitting)
                        }
                    }

                    if (bounced) {
                        proj.bounces = Math.max(0, proj.bounces - 1);
                        proj.life += 40;
                        addParticle(proj.x, proj.y, '#FFFFFF', 'spark');
                        // Impact ring and spark shower for visual clarity
                        if (typeof addTransientEffect === 'function') {
                            addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#FFFFFF', radius: 20, life: 140 });
                        }
                        for (let s=0;s<4;s++) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#DDDDFF', 'spark');
                        // Maintain a reasonable minimum travel speed after damping so projectiles don't stall
                        const sp = Math.hypot(proj.vx, proj.vy) || 0;
                        const minSpeed = 3.8;
                        if (sp < minSpeed) {
                            // Re-normalize velocity to minSpeed preserving direction
                            const nx = (proj.vx || 0) / (sp || 1);
                            const ny = (proj.vy || 0) / (sp || 1);
                            proj.vx = nx * minSpeed;
                            proj.vy = ny * minSpeed;
                        }
                        // Phasing bounce visual accent (a faint cyan flash) so player sees the virtual ricochet
                        if (proj.phasing) {
                            addParticle(proj.x, proj.y, '#66EEFF', 'spark');
                            // Added brief cyan ring flash for clearer phasing ricochet feedback
                            if (typeof addTransientEffect === 'function') {
                                addTransientEffect({ type:'ringFlash', x:proj.x, y:proj.y, color:'#66EEFF', radius:24, life:18 });
                            } else {
                                // Fallback: spawn extra outward spark petals
                                for (let rf=0; rf<5; rf++) {
                                    addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#AAFFFF', 'spark');
                                }
                            }
                        }
                    }
                } else {
                    // Non-bouncing projectiles collide with walls and are removed (unless phasing)
                    if (!proj.phasing && isWall(proj.x, proj.y, Math.max(5, proj.size))) {
                        // Split Shot: split on wall impact
                        // (Split Shot removed – no wall-impact splitting)
                        return false;
                    }
                }
                // Beam segments: continuous tick damage (not orbital)
                if (proj.beam && !proj.enemy) {
                    if (!proj._beamHitTimes) proj._beamHitTimes = {};
                    proj._beamTickFrame = (proj._beamTickFrame || 0) + 1;
                    if (Math.random() < 0.15) addParticle(proj.x + (Math.random()-0.5)*proj.size, proj.y + (Math.random()-0.5)*proj.size, '#99EEFF', 'spark');
                    const tickIntervalFrames = 5;
                    const base = (proj.damage || calculateDamage());
                    const tickDamage = Math.max(1, Math.floor(base * 0.18));
                    game.enemies.forEach(enemy => {
                        const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const r = enemy.size/2 + proj.size;
                        if (dx*dx + dy*dy <= r*r) {
                            const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                            const last = proj._beamHitTimes[key] || 0;
                            if (proj._beamTickFrame - last >= tickIntervalFrames) {
                                proj._beamHitTimes[key] = proj._beamTickFrame;
                                enemy.health -= tickDamage;
                                addDamageNumber(tickDamage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType || 'laser' });
                                if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#55CCFF', 'impact');
                            }
                        }
                    });
                    // Close-range fallback: if an enemy is extremely close to the player along the beam's forward arc but
                    // not caught due to the beam segment offset, apply a reduced tick so hugging enemies still get hurt.
                    if (game.player) {
                        const originX = game.player.x;
                        const originY = game.player.y;
                        const dirX = proj.vx || Math.cos(proj.spinAngle || 0) || 1;
                        const dirY = proj.vy || Math.sin(proj.spinAngle || 0) || 0;
                        const dirLen = Math.hypot(dirX, dirY) || 1;
                        const ux = dirX / dirLen; const uy = dirY / dirLen;
                        const fallbackRadius = 42; // small circle around player
                        const arcCos = Math.cos(Math.PI/2); // 90 deg half-angle (only slight forward bias)
                        const miniTick = Math.max(1, Math.floor(base * 0.12));
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - originX; const dy = enemy.y - originY;
                            const dist2 = dx*dx + dy*dy;
                            if (dist2 <= fallbackRadius * fallbackRadius) {
                                const dist = Math.sqrt(dist2) || 1;
                                const dot = (dx/dist)*ux + (dy/dist)*uy;
                                if (dot >= arcCos) { // roughly within forward 180° (wide) to avoid punishing behind player
                                    const key = enemy._id || (enemy._id = Math.random().toString(36).slice(2));
                                    const last = proj._beamHitTimes[key] || 0;
                                    if (proj._beamTickFrame - last >= tickIntervalFrames) {
                                        proj._beamHitTimes[key] = proj._beamTickFrame;
                                        enemy.health -= miniTick;
                                        addDamageNumber(miniTick, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType || 'laser' });
                                        if (Math.random() < 0.18) addParticle(enemy.x, enemy.y, '#66BBFF', 'impact');
                                    }
                                }
                            }
                        });
                    }
                }
                // Final positional cull / life check
                // Extended off-screen tolerance: allow projectiles to travel further outside view before culling so
                // longer-lived shots (larger logical canvas) aren't prematurely despawned right at edge.
                const OFFSCREEN_PAD = 140; // previously 20; generous margin for effects that arc back or explode
                const alive = proj.life > 0 &&
                              proj.x > -OFFSCREEN_PAD && proj.x < canvas.width + OFFSCREEN_PAD &&
                              proj.y > -OFFSCREEN_PAD && proj.y < canvas.height + OFFSCREEN_PAD;
                if (!alive && proj.damageType === 'crystal' && !proj._crystalShattered) {
                    createCrystalShatter(proj.x, proj.y, proj.baseDamage || proj.damage || calculateDamage(), proj);
                }
                return alive;
            });
            // Orphan meteor marker cleanup: remove markers whose scheduled explode frame passed without a meteor claiming them
            if (Array.isArray(game.meteorMarkers)) {
                for (let i = game.meteorMarkers.length - 1; i >= 0; i--) {
                    const m = game.meteorMarkers[i];
                    if (!m) { game.meteorMarkers.splice(i,1); continue; }
                    if (m.dead) { game.meteorMarkers.splice(i,1); continue; }
                    if (m._explodeFrame && game.frame > m._explodeFrame + 5) { // small grace period
                        // If no meteor set dead flag, prune to prevent misleading lingering marker
                        game.meteorMarkers.splice(i,1);
                    }
                }
            }
        }

        function updateParticles() {
            const fast = game.perf && game.perf.lowFx;
            game.particles = game.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= fast ? 2 : 1;
                particle.alpha = particle.life / particle.maxLife;
                return particle.life > 0;
            });
        }

        function checkCollisions() {
            // --- Helper utilities (declared inside so they capture freshest sprites) ---
            function getEnemyAABB(enemy) {
                if (!enemy) return null;
                if (!game.enemySprites) return null;
                const map = {
                    'Thug':'thug',
                    'Street Dog':'streetDog',
                    'Punk':'punk',
                    'Gangster':'gangster',
                    'Dealer':'dealer',
                    'Enforcer':'enforcer',
                    'Boss Thug':'bossThug',
                    'Boss Gangster':'bossGangster',
                    'Golden Goose':'goldengoose',
                    'The Big Quack':'bigQuack'
                };
                const key = map[enemy.type];
                if (!key) return null;
                const entry = game.enemySprites[key];
                if (!entry || !entry.loaded) return null;
                // computeHitbox original APIs differ: thug returned {w,h,ox,oy}; new ones return either offset style or absolute; normalize.
                if (entry.computeHitbox) {
                    try {
                        const hb = entry.computeHitbox(enemy);
                        if (!hb) return null;
                        if ('ox' in hb || 'oy' in hb) {
                            // Some sprites historically returned ox/oy as top-left-style offsets
                            // (eg. ox = -w/2). Convert to a proper AABB by shifting ox/oy by half
                            // the width/height so the returned box is world-space top-left.
                            const halfW = (hb.w || 0) / 2;
                            const halfH = (hb.h || 0) / 2;
                            const centerX = enemy.x + ((hb.ox || 0) + halfW);
                            const centerY = enemy.y + ((hb.oy || 0) + halfH);
                            return { x: centerX - (hb.w||0)/2, y: centerY - (hb.h||0)/2, w: hb.w, h: hb.h };
                        } else if ('x' in hb && 'y' in hb) {
                            return { x: hb.x, y: hb.y, w: hb.w, h: hb.h };
                        }
                    } catch(e) { /* fallback later */ }
                }
                return null;
            }
            function circleIntersectsAABB(cx, cy, r, box) {
                const clampedX = Math.max(box.x, Math.min(cx, box.x + box.w));
                const clampedY = Math.max(box.y, Math.min(cy, box.y + box.h));
                const dx = cx - clampedX; const dy = cy - clampedY;
                return (dx*dx + dy*dy) <= r*r;
            }
            // Expose helpers to renderer/SoA update paths that run outside this scope
            window.getEnemyAABB = getEnemyAABB; window.circleIntersectsAABB = circleIntersectsAABB;
            function playerCircleRadius() { return 24; } // enlarged to match bigger player sprite

            // --- Player contact damage (enemy -> player) using AABB when available ---
            if (!game.player.invulnerable) {
                // Force-bind: pre-compute and store enemy.hitbox from sprite.computeHitbox
                // so collisions earlier in the frame use the same rectangle the renderer
                // would place under the visible sprite. This helps when draw-time
                // hitbox assignment happens after collision checks.
                try {
                    if (Array.isArray(game.enemies)) {
                        for (let ei=0; ei<game.enemies.length; ei++) {
                            const en = game.enemies[ei]; if (!en) continue;
                            try {
                                const map = {
                                    'Thug':'thug','Street Dog':'streetDog','Punk':'punk','Gangster':'gangster','Dealer':'dealer','Enforcer':'enforcer','Boss Thug':'bossThug','Boss Gangster':'bossGangster','Golden Goose':'goldengoose','The Big Quack':'bigQuack'
                                };
                                const key = map[en.type];
                                const entry = (game.enemySprites && key) ? game.enemySprites[key] : null;
                                if (entry && entry.computeHitbox && typeof entry.computeHitbox === 'function') {
                                    const hb = entry.computeHitbox(en) || null;
                                    if (hb) {
                                        if ('ox' in hb || 'oy' in hb) {
                                            en.hitbox = { x: (en.x||0) + (hb.ox||0), y: (en.y||0) + (hb.oy||0), w: hb.w, h: hb.h };
                                        } else if ('x' in hb && 'y' in hb) {
                                            en.hitbox = { x: hb.x, y: hb.y, w: hb.w, h: hb.h };
                                        }
                                    }
                                }
                            } catch(_) {}
                        }
                    }
                } catch(_) {}
                const pr = playerCircleRadius();
                game.enemies.forEach(enemy => {
                    if (enemy.dead || enemy.health <= 0) {
                        try { if (enemy && /golden/i.test(String(enemy.type||''))) { try { safeUnlockActII('early-loop-skip'); } catch(_){} } } catch(_) {}
                        return;
                    }
                    // During active Rizz pull, temporarily disable player contact for this enemy
                    if (enemy._rizzPull && enemy._rizzPull.active) return;
                    const box = getEnemyAABB(enemy);
                    let collide = false;
                    if (box) {
                        collide = circleIntersectsAABB(game.player.x, game.player.y, pr, box);
                    } else {
                        // fallback circle vs circle
                        const dx = game.player.x - enemy.x; const dy = game.player.y - enemy.y;
                        if (Math.sqrt(dx*dx + dy*dy) < pr + enemy.size/2) collide = true;
                    }
                    if (collide) {
                        const incoming = Math.floor(enemy.damage * (enemy.cursed ? 0.7 : 1));
                        try {
                            // Rate-limited debug log to help find invisible/duplicate enemies causing player damage
                            game._debug = game._debug || {};
                            const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
                            if (!game._debug._lastPlayerHitLog || now - game._debug._lastPlayerHitLog > 250) {
                                game._debug._lastPlayerHitLog = now;
                                try {
                                    const idx = game.enemies.indexOf(enemy);
                                    console.info('[PlayerHitByEnemy]', { idx, type: enemy.type, x: enemy.x, y: enemy.y, speed: enemy.speed, _noFallback: !!enemy._noFallback, hitbox: (typeof getEnemyAABB === 'function' ? getEnemyAABB(enemy) : enemy.hitbox) });
                                } catch(_){}
                            }
                        } catch(_){}
                        takeDamage(incoming);
                    }
                });

                // Enemy projectiles hitting player (remain circle-based for now)
                game.projectiles = game.projectiles.filter(proj => {
                    if (proj.enemy) {
                        const dx = proj.x - game.player.x;
                        const dy = proj.y - game.player.y;
                        if (Math.sqrt(dx * dx + dy * dy) < pr) {
                            takeDamage(proj.damage || 15);
                            addParticle(proj.x, proj.y, '#FF4444', 'impact');
                            return false;
                        }
                    }
                    return true;
                });
            }

            // SoA enemy projectiles vs player collision
            (function soaEnemyProjectilePlayerCollisions(){
                const ps = game.projectilesSoA; if (!ps || !game._projMeta || !game.player) return;
                const { x:PX, y:PY, radius:PR, alive:PA, MAX:PM } = ps;
                const pr2 = playerCircleRadius();
                for (let i=0;i<PM;i++){
                    if (!PA[i]) continue;
                    const meta = game._projMeta.get(i); if (!meta || !meta.enemy) continue;
                    const dx = PX[i] - game.player.x; const dy = PY[i] - game.player.y;
                    const r = PR[i] || 4;
                    if (dx*dx + dy*dy <= (r + pr2)*(r + pr2)) {
                        // Instrumentation: log and mark SoA enemy projectile hits for debugging invisible projectiles
                        try {
                            console.info('[SoA][Hit->Player]', { idx: i, x: PX[i], y: PY[i], r: r, meta: meta });
                            // conspicuous debug transient: large ringFlash / particle to show origin
                            if (typeof addTransientEffect === 'function') {
                                addTransientEffect({ type: 'ringFlash', x: PX[i], y: PY[i], color: '#FF4444', radius: 60, life: 60 });
                            } else {
                                addParticle(PX[i], PY[i], '#FF4444', 'ring');
                                addParticle(PX[i], PY[i], '#FF4444', 'impact');
                            }
                            // store last hit for quick console inspection
                            try { game._lastSoAHit = { idx: i, x: PX[i], y: PY[i], r: r, meta: meta, frame: game.frame || 0, time: Date.now() }; } catch(_){}
                        } catch(_){}
                        // If this is an enemy beam, force damage to 25 to avoid one-shot kills from legacy baseDamage values
                        if (meta && meta.beam && meta.enemy) {
                            takeDamage(25);
                        } else {
                            takeDamage((meta.baseDamage || 10));
                        }
                        addParticle(PX[i], PY[i], '#FF4444', 'impact');
                        // recycle this projectile
                        game.recycleProjectile(i);
                    }
                }
            })();

            // --- Player projectiles vs enemies (SoA + enemy hash accelerated) ---
            (function soaPlayerProjectileEnemyCollisions(){
                const ps = game.projectilesSoA;
                if (!ps) return; // safety
                const { x:PX, y:PY, radius:PR, damage:PD, alive:PA, life:PL, MAX:PM, flags:PF } = ps;
                const collisionStats = game.collisionStats || (game.collisionStats = { frame:0, checks:0, hits:0, buckets:0 });
                collisionStats.frame++;
                let bucketLookups = 0; let checks = 0; let hits = 0;
                const useHash = !!(game.enemyHash && game.enemyHash.buckets && game.enemyHash.buckets.size);
                const cs = useHash ? game.enemyHash.cell : 0;
                // Iterate SoA pool
                for (let i=0;i<PM;i++) {
                    if (!PA[i]) continue;
                    // Future: differentiate enemy projectiles via a flag bit; for now rely on metadata or placeholder flags
                    // If metadata marks enemy projectile, skip player->enemy collision.
                    const meta = game._projMeta && game._projMeta.get(i);
                    if (meta && meta.enemy) continue;
                    // Skip beam / special continuous effects (handled elsewhere) if flagged in metadata.
                    if (meta && meta.beam) continue;
                    const r = PR[i] || 6;
                    // Tumbleweed impulse: if this player projectile overlaps the tumbleweed, kick it
                    if (game._tumbleweedIndex != null && game._tumbleweedIndex >= 0 && game._projMeta) {
                        const ti = game._tumbleweedIndex;
                        // Ensure index is valid and alive
                        if (ti < PM && PA[ti] && ti !== i) {
                            const twMeta = game._projMeta.get(ti);
                            if (twMeta && twMeta.tumbleweed) {
                                const dxTW = (PX[ti] - PX[i]);
                                const dyTW = (PY[ti] - PY[i]);
                                const rr = (PR[ti]||14) + r + 2; // small pad
                                if (dxTW*dxTW + dyTW*dyTW <= rr*rr) {
                                    // Impulse along shot velocity (fallback to direction from projectile to tumbleweed)
                                    let ivx = ps.vx ? ps.vx[i] : 0;
                                    let ivy = ps.vy ? ps.vy[i] : 0;
                                    if (!ivx && !ivy) {
                                        const dist = Math.hypot(dxTW, dyTW) || 1;
                                        ivx = dxTW / dist; ivy = dyTW / dist;
                                    }
                                    const shotSpeed = Math.hypot(ivx, ivy) || 1;
                                    const k = Math.min(5.0, 1.2 + shotSpeed * 0.55);
                                    if (ps.vx && ps.vy) {
                                        ps.vx[ti] += ivx * k;
                                        ps.vy[ti] += ivy * k;
                                    }
                                    // Small on-kick ring cue
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!lowFx && !reduceRings) addParticle(PX[ti], PY[ti], '#EED7AA','ring');
                                }
                            }
                        }
                    }
                    // Kick the Can impulse: same as Tumbleweed but uses separate index and tint
                    if (game._kickCanIndex != null && game._kickCanIndex >= 0 && game._projMeta) {
                        const ki = game._kickCanIndex;
                        if (ki < PM && PA[ki] && ki !== i) {
                            const kcMeta = game._projMeta.get(ki);
                            if (kcMeta && kcMeta.kickTheCan) {
                                const dxK = (PX[ki] - PX[i]);
                                const dyK = (PY[ki] - PY[i]);
                                const rr = (PR[ki]||13) + r + 2;
                                if (dxK*dxK + dyK*dyK <= rr*rr) {
                                    let ivx = ps.vx ? ps.vx[i] : 0;
                                    let ivy = ps.vy ? ps.vy[i] : 0;
                                    if (!ivx && !ivy) {
                                        const dist = Math.hypot(dxK, dyK) || 1;
                                        ivx = dxK / dist; ivy = dyK / dist;
                                    }
                                    const shotSpeed = Math.hypot(ivx, ivy) || 1;
                                    const k = Math.min(5.0, 1.2 + shotSpeed * 0.55);
                                    if (ps.vx && ps.vy) {
                                        ps.vx[ki] += ivx * k;
                                        ps.vy[ki] += ivy * k;
                                    }
                                    // Achievements: beans can was shot
                                    try { if (window.achv_onBeansHit) achv_onBeansHit(); } catch(_) {}
                                    const lowFx = !!(game.perf && game.perf.lowFx);
                                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                                    if (!lowFx && !reduceRings) addParticle(PX[ki], PY[ki], '#D8F0FF','ring');
                                }
                            }
                        }
                    }
                    let consumed = false;
                    if (useHash) {
                        const cx = (PX[i] / cs)|0; const cy = (PY[i] / cs)|0;
                        for (let cyOff=-1; cyOff<=1 && !consumed; cyOff++) {
                            for (let cxOff=-1; cxOff<=1 && !consumed; cxOff++) {
                                const key = ((cx+cxOff)<<16) ^ (cy+cyOff);
                                const bucket = game.enemyHash.buckets.get(key); if(!bucket) continue; bucketLookups++;
                                for (let bi=0; bi<bucket.length && !consumed; bi++) {
                                    const enemy = game.enemies[bucket[bi]]; if(!enemy || enemy.dead || enemy.health<=0) continue; checks++;
                                    let hit=false; const box = getEnemyAABB(enemy);
                                    if (box) hit = circleIntersectsAABB(PX[i], PY[i], r, box); else {
                                        const dx = PX[i] - enemy.x; const dy = PY[i] - enemy.y; if (dx*dx + dy*dy < (enemy.size/2 + r)**2) hit=true;
                                    }
                                    if (hit) {
                                        hits++;
                                        // Build a temporary lightweight projectile descriptor for hit logic expecting object props.
                                        const projObj = meta || { };
                                        projObj.x = PX[i]; projObj.y = PY[i]; projObj.size = r; projObj.damage = PD[i];
                                        // Ensure commonly used ability fields exist on the temporary object
                                        if (meta) {
                                            if (meta.damageType) projObj.damageType = meta.damageType;
                                            if (meta.infusionElements) projObj.infusionElements = meta.infusionElements;
                                            if (meta.lifeSteal) projObj.lifeSteal = meta.lifeSteal;
                                            if (meta.knockback) { projObj.knockback = true; projObj.knockbackDistance = meta.knockbackDistance; }
                                            if (meta.piercing) { projObj.piercing = true; projObj.pierceCount = meta.pierceCount; projObj.pierceHits = meta.pierceHits||0; }
                                            if (meta.ricochet) { projObj.ricochet = true; projObj.bounces = meta.bounces||3; }
                                            if (meta.freezes) projObj.freezes = true;
                                            if (meta._hammer) projObj._hammer = true;
                                            if (meta.weaponType) projObj.weaponType = meta.weaponType;
                                            if (meta.drilling) projObj.drilling = true;
                                            if (meta.armorPiercing) projObj.armorPiercing = true;
                                            if (meta.ignoresArmor) projObj.ignoresArmor = true;
                                            if (meta.ignoresEverything) projObj.ignoresEverything = true;
                                            if (meta.crushDamage) projObj.crushDamage = true;
                                            if (meta.realityBreak) projObj.realityBreak = true;
                                            if (meta.hitMultipleTimes) projObj.hitMultipleTimes = true;
                                            if (meta.areaEffect) projObj.areaEffect = true;
                                            if (meta.smartExplosive) projObj.smartExplosive = true;
                                            if (meta.vortex) projObj.vortex = true;
                                            if (meta.slowOnHit) projObj.slowOnHit = true;
                                            if (meta.quackenTentacle) {
                                                projObj.quackenTentacle = true;
                                                if (meta.quackenSlowFrames) projObj.quackenSlowFrames = meta.quackenSlowFrames;
                                                if (meta.quackenSnareFrames) projObj.quackenSnareFrames = meta.quackenSnareFrames;
                                                if (meta.quackenDotScale) projObj.quackenDotScale = meta.quackenDotScale;
                                                projObj._tentacleStage = meta._tentacleStage;
                                            }
                                        }
                                        // Preserve/forward some pattern flags if caller logic inspects them.
                                        projObj.sineWave = !!(PF[i] & ps.FLAG.SINE);
                                        projObj.wackyZigzag = !!(PF[i] & ps.FLAG.WACKY);
                                        projObj.ekgWave = !!(PF[i] & ps.FLAG.EKG);
                                        projObj.spiral = !!(PF[i] & ps.FLAG.SPIRAL);
                                        let consumedNow = applyProjectileHit(enemy, projObj);
                                        // Never consume the Tumbleweed / Kick the Can projectile
                                        if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                                            consumedNow = false;
                                            // Ensure pierce remains effectively unlimited and persistent
                                            meta.piercing = true; meta.pierceCount = Math.max(meta.pierceCount||0, 999999);
                                            meta.indestructible = true;
                                        }
                                        if (consumedNow) { PL[i]=0; PA[i]=0; /* recycle stack push */ }
                                        consumed = consumedNow;
                                    }
                                }
                            }
                        }
                    } else {
                        for (let ei=0; ei<game.enemies.length && !consumed; ei++) {
                            const enemy = game.enemies[ei]; if(!enemy || enemy.dead || enemy.health<=0) continue; checks++;
                            let hit=false; const box = getEnemyAABB(enemy);
                            if (box) hit = circleIntersectsAABB(PX[i], PY[i], r, box); else {
                                const dx = PX[i] - enemy.x; const dy = PY[i] - enemy.y; if (dx*dx + dy*dy < (enemy.size/2 + r)**2) hit = true;
                            }
                            if (hit) {
                                hits++;
                                const projObj = meta || { };
                                projObj.x = PX[i]; projObj.y = PY[i]; projObj.size = r; projObj.damage = PD[i];
                                if (meta) {
                                    if (meta.damageType) projObj.damageType = meta.damageType;
                                    if (meta.infusionElements) projObj.infusionElements = meta.infusionElements;
                                    if (meta.lifeSteal) projObj.lifeSteal = meta.lifeSteal;
                                    if (meta.knockback) { projObj.knockback = true; projObj.knockbackDistance = meta.knockbackDistance; }
                                    if (meta.piercing) { projObj.piercing = true; projObj.pierceCount = meta.pierceCount; projObj.pierceHits = meta.pierceHits||0; }
                                    if (meta.ricochet) { projObj.ricochet = true; projObj.bounces = meta.bounces||3; }
                                    if (meta.freezes) projObj.freezes = true;
                                    if (meta._hammer) projObj._hammer = true;
                                    if (meta.weaponType) projObj.weaponType = meta.weaponType;
                                    if (meta.drilling) projObj.drilling = true;
                                    if (meta.armorPiercing) projObj.armorPiercing = true;
                                    if (meta.ignoresArmor) projObj.ignoresArmor = true;
                                    if (meta.ignoresEverything) projObj.ignoresEverything = true;
                                    if (meta.crushDamage) projObj.crushDamage = true;
                                    if (meta.realityBreak) projObj.realityBreak = true;
                                    if (meta.hitMultipleTimes) projObj.hitMultipleTimes = true;
                                    if (meta.areaEffect) projObj.areaEffect = true;
                                    if (meta.smartExplosive) projObj.smartExplosive = true;
                                    if (meta.vortex) projObj.vortex = true;
                                    if (meta.slowOnHit) projObj.slowOnHit = true;
                                    if (meta.quackenTentacle) {
                                        projObj.quackenTentacle = true;
                                        if (meta.quackenSlowFrames) projObj.quackenSlowFrames = meta.quackenSlowFrames;
                                        if (meta.quackenSnareFrames) projObj.quackenSnareFrames = meta.quackenSnareFrames;
                                        if (meta.quackenDotScale) projObj.quackenDotScale = meta.quackenDotScale;
                                        projObj._tentacleStage = meta._tentacleStage;
                                    }
                                }
                                projObj.sineWave = !!(PF[i] & ps.FLAG.SINE);
                                projObj.wackyZigzag = !!(PF[i] & ps.FLAG.WACKY);
                                projObj.ekgWave = !!(PF[i] & ps.FLAG.EKG);
                                projObj.spiral = !!(PF[i] & ps.FLAG.SPIRAL);
                                let consumedNow = applyProjectileHit(enemy, projObj);
                                if (meta && (meta.tumbleweed || meta.kickTheCan)) {
                                    consumedNow = false;
                                    meta.piercing = true; meta.pierceCount = Math.max(meta.pierceCount||0, 999999);
                                    meta.indestructible = true;
                                }
                                if (consumedNow) { PL[i]=0; PA[i]=0; }
                                consumed = consumedNow;
                            }
                        }
                    }
                }
                collisionStats.checks += checks; collisionStats.hits += hits; collisionStats.buckets += bucketLookups;
            })();
            
            // Chest interactions
            game.chests.forEach(chest => {
                if (!chest.opened) {
                    const dx = game.player.x - chest.x;
                    const dy = game.player.y - chest.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 35) {
                        openChest(chest);
                    }
                }
            });
        }
        // Periodic collision stats logger (every ~5s)
        (function initCollisionStatsLogger(){
            if (game._collisionLoggerStarted) return; game._collisionLoggerStarted = true;
            setInterval(()=>{
                const c = game.collisionStats; if(!c) return;
                const avgChecks = c.frame ? Math.round(c.checks / c.frame) : 0;
                const hitRate = c.checks ? (c.hits / c.checks * 100).toFixed(1) : '0.0';
                const avgBuckets = c.frame ? (c.buckets / c.frame).toFixed(1) : '0.0';
                console.info(`[CollisionStats] frame:${c.frame} checks:${c.checks} hits:${c.hits} hitRate:${hitRate}% avgChecks/frame:${avgChecks} avgBuckets/frame:${avgBuckets}`);
            }, 5000);
        })();
        // Lightweight on-canvas debug overlay for collision hits (optional)
        ;(function injectCollisionDebugHUD(){
            if (game._collisionHUDInjected) return; game._collisionHUDInjected = true;
            const el = document.createElement('div');
            el.style.position='absolute'; el.style.right='6px'; el.style.bottom='6px'; el.style.padding='4px 6px';
            el.style.font='10px monospace'; el.style.background='rgba(0,0,0,0.35)'; el.style.color='#9f9'; el.style.pointerEvents='none';
            el.style.border='1px solid rgba(80,255,80,0.25)'; el.style.borderRadius='4px'; el.style.zIndex=9999;
            el.textContent='collisions: --';
            document.body.appendChild(el);
            let lastFrame = 0; let lastHits = 0; let lastChecks = 0;
            function upd(){
                const c = game.collisionStats; if (c && c.frame !== lastFrame) {
                    lastFrame = c.frame; lastHits = c.hits; lastChecks = c.checks;
                    const rate = c.checks ? ((c.hits / c.checks)*100).toFixed(1) : '0.0';
                    el.textContent = `hits:${c.hits} checks:${c.checks} rate:${rate}%`;
                }
                requestAnimationFrame(upd);
            }
            requestAnimationFrame(upd);
        })();

        // Utility: Blend a projectile's motion pattern & infusion colors into one representative hex.
        function getProjectileSynergyColor(proj) {
            if (proj && proj._diarrheaBrown) return '#8B4513';
            const colors = [];
            if (proj.sineWave) colors.push('#66AAFF');
            if (proj.wackyZigzag && !proj._wackyChaos) colors.push('#FFDD55');
            if (proj._wackyChaos) colors.push('#FFAA33');
            if (proj.ekgWave) colors.push('#66FFCC');
            if (proj.spiral) colors.push('#FF66FF');
            if (proj.infusionElements && proj.infusionElements.length) {
                let strongest = proj.infusionElements[0];
                proj.infusionElements.forEach(el=>{ if (el.potency > strongest.potency) strongest = el; });
                const infusionMap = { fire:'#FF5533', poison:'#55FF55', ice:'#99DDFF', arc:'#DDDDFF', shadow:'#AA66FF', lightning:'#FFFF99', void:'#8844AA', wind:'#BBFFEE' };
                const infCol = infusionMap[strongest.type] || '#FFFFFF';
                colors.push(infCol);
            }
            if (!colors.length) return '#CCCCCC';
            let r=0,g=0,b=0; colors.forEach(c=>{ const v=parseInt(c.slice(1),16); r+=(v>>16)&255; g+=(v>>8)&255; b+=v&255; });
            r=Math.min(255, Math.floor(r/colors.length)); g=Math.min(255, Math.floor(g/colors.length)); b=Math.min(255, Math.floor(b/colors.length));
            if (proj._wackyChaos && Math.random()<0.35) { r=Math.min(255,r+35); g=Math.min(255,g+20);} // subtle flicker
            return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).toUpperCase();
        }

        // Utility: Map damage/element types to canonical colors for consistent FX tints.
        function getDamageTypeColor(type) {
            switch (type) {
                case 'fire':
                case 'inferno':
                    return '#FF5533';
                case 'ice':
                case 'frost':
                case 'blizzard':
                    return '#99DDFF';
                case 'lightning':
                case 'storm':
                    return '#FFFF99';
                case 'poison':
                case 'toxic':
                    return '#55CC55';
                case 'void':
                case 'antimatter':
                    return '#8844AA';
                case 'acid':
                    return '#A8FFAA';
                case 'plasma':
                    return '#FF6677';
                case 'earth':
                    return '#C6A16A';
                case 'crystal':
                    return '#88EEFF';
                case 'shadow':
                    return '#AA66FF';
                case 'wind':
                    return '#BBFFEE';
                case 'solar':
                    return '#FFEFA5';
                default:
                    return null;
            }
        }

        // Utility: Determine the best element color for a projectile (damageType primary, infusion fallback)
        function getProjElementColor(proj) {
            if (!proj) return null;
            const byType = getDamageTypeColor(proj.damageType || proj.energyType);
            if (byType) return byType;
            if (proj.infusionElements && proj.infusionElements.length) {
                let strongest = proj.infusionElements[0];
                proj.infusionElements.forEach(el=>{ if (el.potency > strongest.potency) strongest = el; });
                // Map common infusion names to colors
                const map = { fire:'#FF5533', poison:'#55CC55', ice:'#99DDFF', lightning:'#FFFF99', void:'#8844AA', wind:'#BBFFEE', shadow:'#AA66FF' };
                return map[strongest.type] || null;
            }
            return null;
        }

        function calculateDamage() {
            let damage = 25;
            
            // Base damage bonuses
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageBonus) {
                    damage += abilityData.effect.damageBonus;
                }
            });
            
            // Rage mode
            if (game.player.abilities.includes('Rage Mode')) {
                damage += game.totalKills * 3;
            }
            
            // Berserker
            if (game.player.abilities.includes('Berserker')) {
                const healthPercent = game.player.health / game.player.maxHealth;
                const berserkerMultiplier = 1 + (1 - healthPercent) * 0.5;
                damage = Math.floor(damage * berserkerMultiplier);
            }
            
            // Critical strikes
            let critChance = 0;
            let critMultiplier = 2;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.critChance) {
                    critChance = Math.max(critChance, abilityData.effect.critChance);
                }
                if (abilityData && abilityData.effect.critMultiplier) {
                    critMultiplier = abilityData.effect.critMultiplier;
                }
            });
            
            if (Math.random() < critChance) {
                damage *= critMultiplier;
                addScreenShake(5);
            }
            
            // Death touch
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.deathTouch) {
                    if (Math.random() < abilityData.effect.deathTouch) {
                        damage = 9999; // Instant kill
                        addScreenShake(8);
                    }
                }
            });

            // If player has an ability that ignores armor globally, we may want to
            // reflect that in damage by ensuring armor reductions aren't applied later.
            // For now we keep calculateDamage generic; the per-projectile ignoresArmor flag
            // will be used at damage application time.
            
            return damage;
        }

        // Centralized hit resolution for projectiles. Returns true if projectile is consumed.
        function applyProjectileHit(enemy, proj) {
            if (!enemy || !proj) return true;
            try {
                // Rate-limited instrumentation to trace which enemy object received projectile hits
                game._debug = game._debug || {};
                const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
                if (!game._debug._lastProjHitLog || now - game._debug._lastProjHitLog > 120) {
                    game._debug._lastProjHitLog = now;
                    try {
                        const idx = game.enemies.indexOf(enemy);
                        console.info('[ProjHit->Enemy]', { enemyIdx: idx, type: enemy.type, x: enemy.x, y: enemy.y, speed: enemy.speed, size: enemy.size, hitbox: enemy.hitbox || (typeof getEnemyAABB === 'function' ? getEnemyAABB(enemy) : null), proj: { x: proj.x, y: proj.y, damage: proj.damage || proj.baseDamage, meta: proj && proj._meta ? '[meta]' : undefined } });
                    } catch(_){}
                }
            } catch(_){}
            // Achievements: per-hit tracking
            try { if (window.achv_onHit) achv_onHit(proj); } catch(_) {}
            // Track last hit damage type for death telegraph coloring
            if (proj.damageType) enemy._lastHitType = proj.damageType;
            // Speed-scaled damage and impact cue for Tumbleweed / Kick the Can
            if (proj.tumbleweed || proj.kickTheCan) {
                const sp = Math.hypot(proj.vx||0, proj.vy||0);
                const mult = Math.min(2.2, 1.0 + sp * 0.12); // up to ~2.2x at high speeds
                proj.damage = Math.max(1, Math.floor((proj.damage || calculateDamage()) * mult));
                // Impact cue: dust ring, stronger with speed (perf-aware)
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx) {
                    const dustCount = Math.min(8, 2 + Math.floor(sp * 0.8));
                    const col = proj.kickTheCan ? '#D8F0FF' : '#EFDDBF';
                    for (let d=0; d<dustCount; d++) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, col, 'spark');
                }
                if (!reduceRings) addParticle(enemy.x, enemy.y, '#EED7AA', 'ring');
            }
            // Popcorn: if a kernel dies early by impact (should rarely happen) force pop immediately
            if (proj.isPopcornKernel && !proj._popDid) {
                proj._popDid = true;
                const base = proj.baseDamage || calculateDamage();
                // Early impact: also spawn kernel burst shots (scaled)
                const bursts = Math.max(2, Math.min(6, (proj._popBursts||2)));
                for (let b=0;b<bursts;b++) {
                    const angB = Math.random()*Math.PI*2;
                    const speedB = 4.2 + Math.random()*1.6;
                    game.spawnProjectile({
                        x: proj.x, y: proj.y,
                        vx: Math.cos(angB)*speedB,
                        vy: Math.sin(angB)*speedB,
                        life: 48 + Math.floor(Math.random()*18),
                        size: 7, enemy:false,
                        baseDamage: Math.max(1, Math.floor(base * 0.55)),
                        damage: Math.max(1, Math.floor(base * 0.55)),
                        popcornKernelBurst: true,
                        realityBreak: !!proj.realityBreak
                    });
                }
                const puffN = Math.max(2, Math.min(6, (proj._popPuffs||2)));
                for (let k=0;k<puffN;k++) {
                    const ang = Math.atan2(proj.vy||0, proj.vx||1) + (Math.random()*0.9 - 0.45);
                    const speed = (Math.sqrt((proj.vx||0)**2 + (proj.vy||0)**2) * 0.85) + Math.random()*1.2;
                    game.spawnProjectile({
                        x: proj.x, y: proj.y,
                        vx: Math.cos(ang)*speed,
                        vy: Math.sin(ang)*speed,
                        life: 40 + Math.floor(Math.random()*18),
                        size: 12, enemy:false,
                        popcornPuff:true,
                        baseDamage: Math.max(1, Math.floor(base * 0.75)),
                        damage: Math.max(1, Math.floor(base * 0.75)),
                        _puffSpin: Math.random()*Math.PI*2,
                        _puffDir: (Math.random()<0.5? -1:1),
                        realityBreak: !!proj.realityBreak
                    });
                }
                for (let s=0;s<10;s++) addParticle(proj.x + (Math.random()-0.5)*12, proj.y + (Math.random()-0.5)*12, '#FFEFA0','spark');
                proj.life = 0;
                return true; // kernel consumed
            }
            // Time Bomb: armed hits near fuse end can trigger early detonation (feels responsive)
            if (proj.timeBomb && proj._timeBombArmed && proj._timeBombTimer <= 16) {
                const dmg = Math.floor((proj.baseDamage || calculateDamage()) * (proj._timeBombExplosionMult || 2.0));
                explodeProjectile(proj, dmg);
                proj.life = 0;
                return true;
            }
            let damage = proj.damage || proj.baseDamage || calculateDamage();
            // Apply resonance multiplier if present
            if (proj._resonanceMult) {
                damage = Math.floor(damage * proj._resonanceMult);
            }
            // Multi-Infusion bonus pre-modifiers: each infusion adds scaled portion of base (diminishing after first)
            if (proj.infusionElements && proj.infusionElements.length) {
                // Sort by potency to apply strongest first
                const sorted = [...proj.infusionElements].sort((a,b)=>b.potency-a.potency);
                let bonus = 0; let idx=0;
                sorted.forEach(inf => { const weight = (idx===0?1: (idx===1?0.6:0.4)); bonus += (damage * inf.potency * weight); idx++; });
                damage = Math.floor(damage + bonus);
            }
            // Elemental amplifier pre-processing: gather player elemental ability presence
            if (!proj._elemAmpComputed) {
                proj._elemAmpComputed = true;
                const abil = game.player.abilities;
                proj._hasFire = abil.some(a=>a.includes('Fire Shot')||a.includes('Inferno')||a.includes('Magma')||a.includes('Inferno')||a.includes('Steam Shot')||a.includes('Magma Shot'));
                proj._hasWind = abil.some(a=>a.includes('Wind Blade')||a.includes('Blizzard'));
                proj._hasIce = abil.some(a=>a.includes('Ice Shot')||a.includes('Frost')||a.includes('Blizzard'));
                proj._hasLightning = abil.some(a=>a.includes('Lightning Shot')||a.includes('Storm Shot'));
                proj._hasPoison = abil.some(a=>a.includes('Poison Shot')||a.includes('Toxic')||a.includes('Silent But Deadly'));
                proj._hasVoid = abil.some(a=>a.includes('Void Shot')||a.includes('Black Hole'));
                proj._hasEarth = abil.some(a=>a.includes('Earth Spike')||a.includes('Magma Shot'));
            }
            // Fire + Wind: slight damage amp and faster burn tick (handled in status) -> immediate small boost
            if (proj._hasFire && proj._hasWind) {
                damage = Math.floor(damage * 1.06);
            }
            // Ice + Lightning: chance to shatter for bonus burst (simulate crit-like extra)
            if (proj._hasIce && proj._hasLightning) {
                if (Math.random() < 0.12) {
                    const extra = Math.floor(damage * 0.35);
                    enemy.health -= extra; // apply directly
                    addDamageNumber(extra, enemy.x, enemy.y - enemy.size/2 - 14, { type: 'frost', crit: true });
                    addParticle(enemy.x, enemy.y, '#AAEEFF','impact');
                }
            }
            // Poison + Void: amplify damage over time potential (apply immediate small amp)
            if (proj._hasPoison && proj._hasVoid) {
                damage = Math.floor(damage * 1.08);
            }
            // Fire + Poison (Magma/Inferno synergy) further increases immediate hit slightly
            if (proj._hasFire && proj._hasPoison) {
                damage = Math.floor(damage * 1.05);
            }
            // Fire + Earth (true Magma combustion) additional micro-boost beyond Fire+Poison if Earth present
            if (proj._hasFire && proj._hasEarth) {
                damage = Math.floor(damage * 1.04);
            }
            // Earth + Wind: modest knockback amplification (applied post-damage as status effect via enemy displacement)
            if (proj._hasEarth && proj._hasWind && proj.knockbackDistance) {
                proj.knockbackDistance = Math.floor(proj.knockbackDistance * 1.15 + 6);
            }
            // Freeze escalation (before armor so bonus can apply later if desired)
            if (proj.freezes && proj.damageType === 'frost') {
                // initialize freeze tracking fields
                enemy.freezeStacks = Math.min(3, (enemy.freezeStacks || 0) + 1);
                enemy.lastFreezeHit = Date.now();
                if (enemy.freezeStacks === 3) {
                    enemy.frozenTimer = Math.max(enemy.frozenTimer || 0, 900); // full freeze 0.9s
                    // Visual: freeze-locked ring and sparkles (perf-aware)
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx) {
                        if (!reduceRings) addParticle(enemy.x, enemy.y, '#AEEBFF','ring');
                        for (let s=0;s<4;s++) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, '#C0F8FF','spark');
                    }
                }
            }
            // Crush logic: first hammer impact applies crushedTimer + stun; subsequent impacts during window deal amplified damage
            if (proj.crushDamage || proj.weaponType === 'hammer' || proj._hammer) {
                if (!enemy.crushedTimer || enemy.crushedTimer <= 0) {
                    enemy.crushedTimer = 700; // ms window
                    enemy.stunned = true; enemy.stunTime = Math.max(enemy.stunTime || 0, 60);
                    // apply an armor shred stack (temporary) and schedule its decay timer if not existing
                    enemy.armorShredded = (enemy.armorShredded || 0) + 1;
                    if (enemy.armorShredded > 8) enemy.armorShredded = 8; // cap
                    enemy._armorShredDecay = enemy._armorShredDecay || Date.now();
                    addParticle(enemy.x, enemy.y, '#EECCAA','impact');
                } else {
                    // Already crushed: bonus damage multiplier
                    damage = Math.floor(damage * 1.4);
                    addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, crit: true });
                }
            }
            if (enemy.weakness) damage = Math.floor(damage * 1.35);
            if (proj.ignoresEverything) damage = Math.floor(damage * 1.25);
            if (!proj.ignoresEverything && !proj.ignoresArmor && !proj.armorPiercing) {
                const shred = enemy.armorShredded || 0;
                const effectiveArmor = Math.max(0, (enemy.armor || 0) - shred);
                const preArmor = damage;
                damage = Math.max(1, damage - effectiveArmor);
                if (effectiveArmor > 0) {
                    // Armor mitigation sparkle cue: brief metallic flecks when damage is reduced
                    const mitig = Math.max(0, preArmor - damage);
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    if (!lowFx && mitig > 0) {
                        const flecks = Math.min(6, 2 + Math.floor(mitig / Math.max(1, preArmor) * 6));
                        for (let f=0; f<flecks; f++) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, '#D0D0D0', 'spark');
                    }
                    addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, armor: true });
                }
            }
            // Bonus damage while fully frozen
            if (enemy.frozenTimer && enemy.frozenTimer > 0) {
                damage = Math.floor(damage * 1.2);
            }
            enemy.health -= damage;
            if (!proj._suppressDamageNumber) {
                addDamageNumber(damage, enemy.x, enemy.y - enemy.size/2, { type: proj.damageType, crit: proj.ignoresEverything });
            }
            // Achievements: if this hit killed the enemy, attribute the kill to this projectile
            if (enemy.health <= 0) {
                try { if (window.achv_onKill) achv_onKill(proj); } catch(_) {}
                try {
                    // If Wunderswan was defeated, unlock Act III for future runs
                    if (enemy && enemy.type === 'Wunderswan') {
                        try { unlockActIII('Wunderswan kill'); } catch(_){ }
                    }
                } catch(_) {}
                try {
                    // Backup: projectile kill — if Golden Goose, ensure Act II unlock
                    if (enemy && /golden/i.test(String(enemy.type||''))) {
                        try { safeUnlockActII('proj-kill'); } catch(_){ }
                    }
                } catch(_) {}
            }
            // Standardized elemental impact tint + optional ring telegraph
            {
                const impactHex = getProjElementColor(proj) || '#FFAA00';
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                if (!hideSparks) addParticle(enemy.x, enemy.y, impactHex, 'impact');
                if (!lowFx && !reduceRings) addParticle(enemy.x, enemy.y, impactHex, 'ring');
            }
            // Drill Shot: eject shrapnel on exit/kill (overpenetrate + shrapnel)
            // Extended: optional overrides to control shard count and base angle
            function spawnDrillShrapnel(originX, originY, vx, vy, baseDmg, opts) {
                // opts: { count?: number, angle?: number, spread?: number }
                const speed = 6.0;
                const lowFx = !!(game.perf && game.perf.lowFx);
                // Default dynamic count (perf-aware)
                let count = 4;
                try {
                    const active = game.projectilePool && game.projectilePool.active && game.projectilePool.active();
                    if (active && active > 1200) count = 3;
                    if (active && active > 2000) count = 2;
                } catch(_) {}
                if (lowFx) count = Math.max(2, Math.floor(count * 0.75));
                // Apply override if provided
                if (opts && typeof opts.count === 'number') count = opts.count;
                const ang0 = (opts && typeof opts.angle === 'number') ? opts.angle : Math.atan2(vy||0, vx||1);
                const spread = (opts && typeof opts.spread === 'number') ? opts.spread : 0.5; // total spread in radians
                const shardDmg = Math.max(1, Math.floor((baseDmg||calculateDamage()) * 0.35));
                for (let i=0;i<count;i++) {
                    const off = (-spread/2) + (i * (spread / ((count-1)||1))); // symmetric spread
                    const a = ang0 + off + (Math.random()-0.5)*0.10; // tiny jitter
                    const idx = game.spawnProjectile({
                        x: originX,
                        y: originY,
                        vx: Math.cos(a) * speed,
                        vy: Math.sin(a) * speed,
                        life: 34,
                        r: 4,
                        damage: shardDmg,
                        damageType: proj.damageType || null,
                        enemy: false
                    });
                    if (idx>=0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idx, { baseDamage: shardDmg, piercing:false, pierceCount:0, drillingShard:true });
                    }
                }
            }
            // Void on-hit flash: a brief luminous ringFlash distinct from generic impact
            if (proj.damageType === 'void' || proj.energyType === 'void') {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') {
                    const rr = Math.max(12, (proj.size || proj.r || 6) * 1.6);
                    addTransientEffect({ type:'ringFlash', x: enemy.x, y: enemy.y, color: getDamageTypeColor('void') || '#8844AA', radius: rr, life: 100 });
                }
            }
            // Shadow on-hit flash: darker purple pulse distinct from Void
            if (proj.damageType === 'shadow' || proj.energyType === 'shadow') {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings && typeof addTransientEffect === 'function') {
                    const rr = Math.max(10, (proj.size || proj.r || 6) * 1.5);
                    addTransientEffect({ type:'ringFlash', x: enemy.x, y: enemy.y, color: getDamageTypeColor('shadow') || '#AA66FF', radius: rr, life: 95 });
                }
            }
            // Armor-piercing/Acid melt ring cue (perf-aware)
            {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const isArmorPunch = proj.armorPiercing || proj.damageType === 'acid';
                if (isArmorPunch && !lowFx && !reduceRings) {
                    addParticle(enemy.x, enemy.y, '#A8FFAA', 'ring');
                }
            }
            // On-hit AoE hooks for elemental combos
            if ((proj.damageType === 'blizzard' || proj.areaEffect === true) && !proj.beam) {
                // Light area slow to make Blizzard noticeable even without explicit explode trigger
                const cx = proj.x || enemy.x, cy = proj.y || enemy.y;
                for (let i = 0; i < 6; i++) addParticle(cx + (Math.random()-0.5)*50, cy + (Math.random()-0.5)*50, '#AEEBFF', 'fire');
                game.enemies.forEach(en => {
                    const dx = en.x - cx, dy = en.y - cy; const d = Math.hypot(dx, dy);
                    if (d < 100) { en.slowed = true; en.slowTime = Math.max(en.slowTime||0, 160); }
                });
            }
            // Plasma splash: on hit create small area heat burst (excludes original enemy for secondary damage)
            if (proj.damageType === 'plasma' && !proj._plasmaSplashed) {
                proj._plasmaSplashed = true;
                const splashRadius = 60;
                const splashDmg = Math.max(1, Math.floor(damage * 0.6));
                // visual burst particles (plasma hue)
                for (let p=0;p<14;p++) {
                    const ang = Math.random()*Math.PI*2;
                    const dist = Math.random()*splashRadius*0.9;
                    addParticle(enemy.x + Math.cos(ang)*dist, enemy.y + Math.sin(ang)*dist, '#ff4455', 'spark');
                }
                game.enemies.forEach(other => {
                    if (other === enemy || other.health <= 0) return;
                    const dx = other.x - enemy.x;
                    const dy = other.y - enemy.y;
                    if (dx*dx + dy*dy <= splashRadius * splashRadius) {
                        other.health -= splashDmg;
                        addDamageNumber(splashDmg, other.x, other.y - other.size/2, { type: 'plasma' });
                        // brief burn extension
                        other.burning = true;
                        other.burnTime = Math.max(other.burnTime || 0, 120);
                    }
                });
            }
            // Vortex on-hit trigger: if projectile carries vortex ability, spawn one at impact (rate-limited)
            if (proj.vortex && typeof createVortex === 'function') {
                const nowV = Date.now();
                const cd = 900; // ms cooldown between vortex spawns
                if (!game._lastVortexSpawn || nowV - game._lastVortexSpawn >= cd) {
                    game._lastVortexSpawn = nowV;
                    const cx = proj.x != null ? proj.x : enemy.x;
                    const cy = proj.y != null ? proj.y : enemy.y;
                    createVortex(cx, cy);
                }
            }
            // SIGMA stage handling
            if (proj.sigma1 && !proj._sigmaSplit) {
                proj._sigmaSplit = true;
                // spawn 3 smaller homing sigma2 shots at slight angle offsets
                const base = proj.baseDamage || proj.damage || calculateDamage();
                const count = 3;
                const baseAng = Math.atan2((proj.vy||0), (proj.vx||1));
                if (!game._sigma) game._sigma = {};
                if (!game._sigma.trackers) game._sigma.trackers = new Map();
                const token = Symbol('sigmaChain');
                const children = [];
                for (let k=0; k<count; k++) {
                    const off = (-0.22) + (k * (0.22)); // -0.22, 0, +0.22 rad
                    const ang = isFinite(baseAng) ? baseAng + off : Math.random()*Math.PI*2;
                    const spd = Math.max(4.5, Math.hypot(proj.vx||0, proj.vy||0) * 0.9);
                    const idx = game.spawnProjectile({
                        x: proj.x, y: proj.y,
                        vx: Math.cos(ang) * spd,
                        vy: Math.sin(ang) * spd,
                        life: 240,
                        r: Math.max(8, Math.floor((proj.size||10) * 0.66)),
                        damage: Math.max(1, Math.floor(base * 0.7)),
                        damageType: null,
                        homing: true
                    });
                        if (idx >= 0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idx, { baseDamage: Math.max(1, Math.floor(base * 0.7)), sigma2: true, _sigmaToken: token, phasing: true });
                        children.push(idx);
                    }
                }
                // track this trio to spawn sigma3 when all 3 children are gone (expired or hit and consumed)
                const cFrame = (typeof game.frame==='number') ? game.frame : 0;
                game._sigma.trackers.set(token, { kids: children, originX: proj.x, originY: proj.y, _spawned:false, createdFrame: cFrame });
                // consume sigma1
                proj.life = 0;
                return true;
            }
            // Sigma2 completion rule: when all 3 sigma2 children have disappeared, spawn sigma3 at their last center
            if (proj.sigma2 && proj._sigmaToken && game._sigma && game._sigma.trackers) {
                const tr = game._sigma.trackers.get(proj._sigmaToken);
                if (tr && tr.kids && tr.kids.length && !tr._spawned) {
                    // Update a centroid of existing kids each time one hits to place sigma3 near the last activity
                    tr._centroidX = (tr._centroidX || 0) * 0.5 + (enemy.x) * 0.5;
                    tr._centroidY = (tr._centroidY || 0) * 0.5 + (enemy.y) * 0.5;
                }
            }
            // (Meteor on-hit explosion removed; meteor now detonates strictly at telegraph end for consistency)
            // Infusion status application (projectile-specific overlay)
            if (proj.infusionElements && proj.infusionElements.length) {
                proj.infusionElements.forEach(inf => {
                    switch(inf.type) {
                        case 'fire': enemy.burning = true; enemy.burnTime = Math.max(enemy.burnTime||0, 120 + Math.floor(60*inf.potency)); break;
                        case 'ice': enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime||0, 140 + Math.floor(40*inf.potency)); break;
                        case 'poison': enemy.poisoned = true; enemy.poisonTime = Math.max(enemy.poisonTime||0, 180 + Math.floor(60*inf.potency)); break;
                        case 'lightning': // small chain mini pulse
                            if (Math.random() < 0.15 + inf.potency*0.3) {
                                let chained = 0;
                                game.enemies.forEach(o => {
                                    if (o === enemy || chained >= 2) return;
                                    const d = Math.hypot(o.x - enemy.x, o.y - enemy.y);
                                    if (d < 120) {
                                        const zap = Math.max(4, Math.floor(damage * 0.25));
                                        o.health -= zap;
                                        addDamageNumber(zap, o.x, o.y - o.size / 2, { type: 'lightning' });
                                        addParticle(o.x, o.y, '#FFFF99', 'spark');
                                        chained++;
                                    }
                                });
                            }
                            break;
                    }
                });
            }

            if (proj.wunderDoodle) {
                try { if (window._bulletImages && typeof window._bulletImages.loadWunderScribble === 'function') window._bulletImages.loadWunderScribble(); } catch(_) {}
                enemy.wunderScribble = true;
                enemy.wunderScribbleTime = Math.max(enemy.wunderScribbleTime || 0, 180);
                enemy.wunderScribbleInterval = Math.max(10, Math.min(22, enemy.wunderScribbleInterval || 14));
                const baseTick = Math.max(1.05, Math.min(2.6, (proj.damage || proj.baseDamage || calculateDamage()) * 0.14));
                enemy.wunderScribbleTickDamage = Math.max(enemy.wunderScribbleTickDamage || 0, baseTick);
                enemy._wunderScribbleTick = Math.min(enemy._wunderScribbleTick || 0, 3);
            }

            const pdx = enemy.x - proj.x;
            const pdy = enemy.y - proj.y;
            const pd = Math.hypot(pdx, pdy) || 1;
            let kbDist = proj.knockbackDistance || 0;
            if (!kbDist && proj.weaponType === 'hammer') kbDist = 40; // hammer baseline
            if (!kbDist) kbDist = 28; // default fallback
            // Earth Spike / Magma derived impacts: always use smooth knockback (less jarring)
            // proj._hasEarth is precomputed earlier (includes Magma combo). We slightly reduce raw distance
            // so the slide duration feels physical instead of a huge displacement burst.
            const isEarthStyle = proj._hasEarth;
            if (isEarthStyle) {
                const earthDist = Math.max(14, Math.floor(kbDist * 0.75)); // temper distance for smoother slide
                applySmoothKnockback(enemy, pdx / pd, pdy / pd, earthDist);
                enemy._earthKBFrames = Math.max(enemy._earthKBFrames || 0, Math.min(38, Math.floor(earthDist * 0.9))); // debris duration
            } else {
                // Large knockback distances (e.g. Wind Blade 120) look like teleporting when instant.
                // Use smooth velocity-based knockback if threshold exceeded; otherwise keep instant push.
                if (kbDist >= 60) {
                    applySmoothKnockback(enemy, pdx / pd, pdy / pd, kbDist);
                } else {
                    applyKnockback(enemy, kbDist, pdx, pdy);
                }
            }
            if (proj._hammer) {
                enemy.stunned = true; enemy.stunTime = Math.max(enemy.stunTime || 0, 46); addParticle(enemy.x, enemy.y, '#FFDFFF', 'impact');
            }
            if (proj.weaponType === 'axe') { enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime || 0, 90); }
            if (proj.chaining) {
                let next=null, nd=Infinity; game.enemies.forEach(o=>{ if(o===enemy) return; const d=Math.hypot(o.x-enemy.x,o.y-enemy.y); if(d<140&&d<nd){nd=d;next=o;} });
                if (next) { const cd=Math.max(1, Math.floor(damage*0.5)); next.health -= cd; addParticle(next.x,next.y,'#FFDFAA','impact'); addDamageNumber(cd, next.x, next.y - next.size/2, { type: proj.damageType }); }
            }
            // Reality break projectile single-target hit also boosts distortion a bit
            if (proj.realityBreak) {
                if (!game.realityBreakDistort) game.realityBreakDistort = { time:0, intensity:0 };
                game.realityBreakDistort.time = Math.min(game.realityBreakDistort.time + 24, 160);
                game.realityBreakDistort.intensity = Math.min(0.65, game.realityBreakDistort.intensity + 0.08);
                // Brief auto-enable of overlay so distortion displays even if setting is off
                if (!game.settings) game.settings = {};
                game.settings._rbAutoOverlay = 4; // frames to force on (shorter)
                // Add a tiny burst of screen shake for jitter
                if (typeof addScreenShake === 'function' && !(game.perf && game.perf.lowFx)) addScreenShake(1.5);
                // Also spawn a small Reality Break field at impact (rate-limited) so the ability has visible gameplay effect without requiring an explosion
                const nowRB = Date.now();
                const cd = 900; // ms cooldown between spawns
                if (!game._lastRealityBreakSpawn || nowRB - game._lastRealityBreakSpawn >= cd) {
                    game._lastRealityBreakSpawn = nowRB;
                    const base = proj.baseDamage || proj.damage || calculateDamage();
                    // Place field slightly biased toward enemy position for readability
                    const fx = (proj.x != null ? (proj.x*0.4 + enemy.x*0.6) : enemy.x);
                    const fy = (proj.y != null ? (proj.y*0.4 + enemy.y*0.6) : enemy.y);
                    if (typeof createRealityBreak === 'function') {
                        createRealityBreak(fx, fy, Math.max(80, Math.floor(base * 1.0)));
                    }
                }
            }
            // Split trigger (primary): ensure Split Shot triggers on first enemy impact even if projectile will continue (piercing, ricochet, etc.).
            // Exclude beams and orbitals to avoid excessive child spam.
            // (Split Shot primary enemy-impact trigger removed)
            // Crystal Shot shatter: spawn shards on first enemy impact (before potential pierce continuation) once.
            if (proj.damageType === 'crystal' && !proj._crystalShattered) {
                createCrystalShatter(enemy.x, enemy.y, proj.baseDamage || proj.damage || calculateDamage(), proj);
            }
            if (proj.hitMultipleTimes) {
                proj.remainingHits = (typeof proj.remainingHits === 'number') ? proj.remainingHits : 3; proj.remainingHits--; proj.life += 12;
                // Stronger telegraph when Quantum extra hit triggers
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings) addParticle(proj.x, proj.y, '#66FFFF', 'ring');
                addParticle(proj.x, proj.y, '#66FFFF','spark');
                if (!lowFx) {
                    // a couple of faint shimmer sparks for readability
                    if (!(game.fxFlags && game.fxFlags.hideSparks)) {
                        addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#AAFFFF','spark');
                        if (Math.random()<0.5) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#88EEFF','spark');
                    }
                }
                if (proj.remainingHits > 0) { const sp=Math.hypot(proj.vx,proj.vy)||1; proj.vx = (proj.vx/sp)*(sp*1.04); proj.vy=(proj.vy/sp)*(sp*1.04); return false; }
            }
            if (proj.antimatter || proj.massiveExplosion) {
                const explosDmg = Math.max(200, Math.floor((proj.baseDamage || damage) * 1.5));
                explodeProjectile(proj, explosDmg); proj.life = 0; return true;
            }
            // (Legacy) Popcorn puff impact crumb spawn removed after SoA migration. Will reintroduce via metadata if needed.
            // Ricochet chaining: allow when ricochet flag set AND remaining bounces >0; phasing no longer blocks logic.
            if (proj.ricochet && proj.bounces > 0) {
                // Initialize ricochet state
                if (!proj._ricochetHits) proj._ricochetHits = [];
                // Prevent hitting same enemy consecutively unless only one remains
                proj._ricochetHits.push(enemy._id || (enemy._id = Math.random().toString(36).slice(2)));
                const already = new Set(proj._ricochetHits);
                const maxRange = 240; // search radius for next bounce
                let nextTarget = null, nextDist = Infinity;
                game.enemies.forEach(o => {
                    if (o === enemy || o.health <= 0) return;
                    const oid = o._id || (o._id = Math.random().toString(36).slice(2));
                    // Allow re-targeting if we've hit nearly everyone (fallback) after 3 unique hits
                    const allowRepeat = proj._ricochetHits.length > 3 && proj._ricochetHits.length > game.enemies.length - 2;
                    if (!allowRepeat && already.has(oid)) return;
                    const d = Math.hypot(o.x - proj.x, o.y - proj.y);
                    if (d < nextDist && d <= maxRange) { nextDist = d; nextTarget = o; }
                });
                if (nextTarget) {
                    const ang = Math.atan2(nextTarget.y - proj.y, nextTarget.x - proj.x);
                    // Preserve existing speed but enforce a floor and mild retention (avoid cumulative slowdown)
                    const prevSpeed = Math.hypot(proj.vx, proj.vy) || 0;
                    const sp = Math.max(5, prevSpeed * 0.95); // slight damping only
                    // Blend direction for smoother turn instead of instant snap
                    const desiredVx = Math.cos(ang) * sp;
                    const desiredVy = Math.sin(ang) * sp;
                    proj.vx = desiredVx;
                    proj.vy = desiredVy;
                    proj.bounces--;
                    // Extend life a bit so chained ricochets travel meaningful distance
                    proj.life = Math.max(proj.life + 55, proj.life);
                    // Small flash particle at source to indicate energy jump
                    // Light energy arc particle burst
                    for (let k=0;k<6;k++) addParticle(proj.x + (Math.random()-0.5)*14, proj.y + (Math.random()-0.5)*14, '#FFEFAA','spark');
                    // Telegraph: faint source ring + short forward dash
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx && !reduceRings) addParticle(proj.x, proj.y, '#FFE6AA','ring');
                    if (typeof addTransientEffect === 'function') {
                        addTransientEffect({ type:'dashTick', x: proj.x, y: proj.y, ang, len: 18, color:'#FFE6AA', life: 100 });
                    }
                    // Telegraph: draw a quick lightning arc or tracer towards the next target
                    if (typeof createLightningArc === 'function') {
                        createLightningArc(proj.x, proj.y, nextTarget.x, nextTarget.y, 7);
                    } else if (ctx && ctx.beginPath) {
                        // Fallback tracer stored as transient effect end-ring only
                        addTransientEffect && addTransientEffect({ type:'ringFlash', x: nextTarget.x, y: nextTarget.y, color:'#FFEFAA', radius: 18, life: 140 });
                    }
                    // Destination ring flash to mark impact point
                    if (typeof addTransientEffect === 'function') {
                        addTransientEffect({ type:'ringFlash', x: nextTarget.x, y: nextTarget.y, color:'#FFDDAA', radius: 22, life: 160 });
                    }
                    if (typeof addScreenShake === 'function') addScreenShake(2);
                    return false; // keep projectile alive
                }
            }
            if (proj.piercing) {
                proj.pierceHits=(proj.pierceHits||0)+1;
                // Do NOT split again here; primary split already occurred above if applicable.
                if (proj.pierceHits < proj.pierceCount) {
                    // Drill shrapnel on successful pass-through
                    if (proj.drilling) {
                        const vx = (proj.vx!=null?proj.vx:(proj._lastVX||1));
                        const vy = (proj.vy!=null?proj.vy:(proj._lastVY||0));
                        // Eject shrapnel slightly ahead of exit point in travel direction
                        const ex = enemy.x + Math.sign(vx||1) * Math.min(enemy.size||16, 8);
                        const ey = enemy.y + Math.sign(vy||0) * Math.min(enemy.size||16, 8);
                        spawnDrillShrapnel(ex, ey, vx, vy, proj.baseDamage || proj.damage || damage);
                    }
                    // If only one pierce remains after this hit, enable a brief warning aura on the projectile
                    const remaining = Math.max(0, (proj.pierceCount||0) - proj.pierceHits);
                    if (remaining === 1) {
                        proj._pierceWarn = Math.max(proj._pierceWarn||0, 18);
                    }
                    // Telegraph: quick exit ring where it passed through (perf-aware)
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    if (!lowFx && !reduceRings) addParticle(enemy.x, enemy.y, '#AEEFD4','ring');
                    // Mark a brief forward streak flash on the projectile itself (renderer will show and then decay)
                    // Note: proj here is the same metadata object stored in game._projMeta for SoA bullets.
                    if (proj) {
                        proj._pierceFlash = Math.max(proj._pierceFlash||0, 9);
                    }
                    return false; // keep traveling until pierce limit reached
                }
            }
            // (Split Shot final consumption trigger removed)
            // Drill Shot: if this hit killed the enemy, also eject shrapnel once
            if (proj.drilling && enemy.health <= 0 && !proj._drillShrapThisHit) {
                // Determine enemy facing vector (fallback to projectile travel if unavailable)
                let fx = 0, fy = 1;
                const facing = enemy.facing || 'down';
                if (facing === 'left') { fx = -1; fy = 0; }
                else if (facing === 'right') { fx = 1; fy = 0; }
                else if (facing === 'up') { fx = 0; fy = -1; }
                else { fx = 0; fy = 1; }
                // Fire shrapnel opposite the enemy facing
                const angOpp = Math.atan2(-fy, -fx);
                // Use exactly 3 shards, tighter spread
                const baseDmg = proj.baseDamage || proj.damage || damage;
                spawnDrillShrapnel(enemy.x, enemy.y, 1, 0, baseDmg, { count: 3, angle: angOpp, spread: 0.35 });
                proj._drillShrapThisHit = true;
            }
            // Time Bomb safeguard: do not consume the projectile via normal hit logic before its fuse expires.
            // Rationale: Previously the projectile could reach its pierce limit and be removed before the countdown hit 0,
            // preventing the explosion from ever triggering. We allow it to keep traveling (no extra special damage changes)
            // until the timer section in updateProjectiles() detonates it, or the armed early-detonation condition fires above.
            if (proj.timeBomb && proj._timeBombTimer > 0) {
                return false; // keep projectile alive until explosion
            }
            if (proj.slowOnHit) {
                enemy.slowed = true;
                enemy.slowTime = Math.max(enemy.slowTime || 0, 160);
            }
            if (proj.quackenTentacle) {
                const slowFrames = proj.quackenSlowFrames || 200;
                const snareFrames = proj.quackenSnareFrames || (slowFrames + 20);
                enemy.slowed = true;
                enemy.slowTime = Math.max(enemy.slowTime || 0, slowFrames);
                enemy.quackenSnared = true;
                enemy.quackenSnareTime = Math.max(enemy.quackenSnareTime || 0, snareFrames);
                enemy._quackenStack = Math.min(5, (enemy._quackenStack || 0) + 1);
                enemy._quackenBaseDamage = Math.max(enemy._quackenBaseDamage || 0, proj.damage || proj.baseDamage || (typeof calculateDamage === 'function' ? calculateDamage() : 8));
                enemy._quackenDotScale = proj.quackenDotScale || enemy._quackenDotScale || 0.24;
                enemy._quackenTick = Math.max(enemy._quackenTick || 0, 6);
                enemy._quackenRingCd = Math.max(enemy._quackenRingCd || 0, 4);
                if (!(game.perf && game.perf.lowFx)) {
                    addParticle(enemy.x, enemy.y, '#6A55D4', 'ring');
                    addParticle(enemy.x + (Math.random() - 0.5) * 12, enemy.y + (Math.random() - 0.5) * 12, '#5F4BCE', 'spark');
                }
                proj._tentacleHit = true;
                proj._tentacleStage = 'retract';
                proj._tentacleStageTimer = 0;
            }
            // If this projectile is a Gooster Teeth gold-tooth projectile, spawn gold-dust pool now (idempotent).
            try {
                if (proj && proj.goldTooth && !proj._goldExploded) {
                    try {
                        const px = (proj.x != null) ? proj.x : (enemy && enemy.x) || 0;
                        const py = (proj.y != null) ? proj.y : (enemy && enemy.y) || 0;
                        const size = Math.max(6, (proj.size || proj.r || 6));
                        const poolRadius = Math.max(48, size * 6);
                        const poolDur = 5200; // ms
                        const baseDmg = proj.baseDamage || proj.damage || damage || 8;
                        explodeProjectile({ x: px, y: py, size: size, enemy: false, damageType: 'solar', goldDust: true, goldDustRadius: poolRadius, goldDustDuration: poolDur, baseDamage: baseDmg }, baseDmg);
                        proj._goldExploded = true;
                    } catch(_) {}
                }
            } catch(_) {}
            return true;
        }

        function ensureReleaseQuackenState(g) {
            const host = g || game;
            if (!host) return null;
            if (!host._releaseQuacken) host._releaseQuacken = {};
            const state = host._releaseQuacken;
            if (!Array.isArray(state.tentacles)) state.tentacles = [];
            if (typeof state.nextFrame !== 'number') state.nextFrame = 0;
            return state;
        }

        function triggerReleaseQuackenTentacle(opts) {
            const g = (opts && opts.game) || game;
            if (!g || !g.player) return;
            const state = ensureReleaseQuackenState(g);
            if (!state) return;
            const frame = (typeof g.frame === 'number') ? g.frame : 0;
            const cooldown = 150;
            if (state.nextFrame && frame < state.nextFrame) return;
            state.nextFrame = frame + cooldown;
            const aimAngle = (opts && typeof opts.aimAngle === 'number') ? opts.aimAngle : 0;
            const firingAngle = (opts && typeof opts.firingAngle === 'number') ? opts.firingAngle : aimAngle;
            const baseDamage = Math.max(1, Math.floor((opts && opts.baseDamage) || calculateDamage()));
            const anchor = { x: g.player.x, y: g.player.y };
            const dirX = Math.cos(firingAngle);
            const dirY = Math.sin(firingAngle);
            const maxReachBase = 320;
            let target = opts && opts.targetEnemy;
            if (!target || target.health <= 0 || !Array.isArray(g.enemies) || g.enemies.indexOf(target) === -1) {
                target = null;
                if (Array.isArray(g.enemies) && g.enemies.length) {
                    let bestScore = Infinity;
                    for (let k = 0; k < g.enemies.length; k++) {
                        const enemy = g.enemies[k];
                        if (!enemy || enemy.health <= 0) continue;
                        const dx = enemy.x - anchor.x;
                        const dy = enemy.y - anchor.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist <= 28) continue;
                        const denom = dist || 1;
                        const alignment = (dx * dirX + dy * dirY) / denom;
                        if (alignment <= Math.cos(Math.PI / 2.6)) continue; // ~55° cone
                        const score = dist - alignment * 140;
                        if (score < bestScore) {
                            bestScore = score;
                            target = enemy;
                        }
                    }
                }
            }
            const fallbackPoint = { x: anchor.x + dirX * maxReachBase, y: anchor.y + dirY * maxReachBase };
            const targetPoint = target ? { x: target.x, y: target.y } : fallbackPoint;
            const maxReach = Math.min(maxReachBase, Math.hypot(targetPoint.x - anchor.x, targetPoint.y - anchor.y) || maxReachBase);
            const tentacle = {
                anchor,
                angle: aimAngle,
                controlAngle: firingAngle,
                baseDamage,
                createdFrame: frame,
                extendFrames: 14,
                holdFrames: 26,
                retractFrames: 22,
                progress: 0,
                phase: 'extend',
                segments: [],
                segmentCount: 7,
                waveAmp: 26,
                maxReachBase,
                maxReach,
                target,
                targetPoint,
                hitCooldown: 18,
                slowDuration: 200,
                knockbackDistance: 40,
                damageScale: 0.80,
                _hitMap: new Map()
            };
            state.tentacles.push(tentacle);
            const lowFx = !!(g.perf && g.perf.lowFx);
            const reduceRings = !!(g.fxFlags && g.fxFlags.reduceRings);
            if (!lowFx) {
                for (let p = 0; p < 8; p++) {
                    addParticle(anchor.x + (Math.random() - 0.5) * 18, anchor.y + (Math.random() - 0.5) * 18, '#7E4AFF', 'spark');
                }
            }
            if (!reduceRings) addParticle(anchor.x, anchor.y, '#7E4AFF', 'ring');
            if (typeof addScreenShake === 'function') addScreenShake(2.5);
            if (typeof playQuackenReleaseSfx === 'function') {
                try { playQuackenReleaseSfx(); } catch(_) {}
            }
        }

        function updateReleaseQuackenTentacles() {
            const state = ensureReleaseQuackenState(game);
            if (!state || !state.tentacles || state.tentacles.length === 0) return;
            const g = game;
            const enemies = Array.isArray(g.enemies) ? g.enemies : [];
            const frame = (typeof g.frame === 'number') ? g.frame : 0;
            const lowFx = !!(g.perf && g.perf.lowFx);
            for (let i = state.tentacles.length - 1; i >= 0; i--) {
                const tent = state.tentacles[i];
                if (!tent) { state.tentacles.splice(i, 1); continue; }
                if (!g.player) { state.tentacles.splice(i, 1); continue; }
                tent.age = (tent.age || 0) + 1;
                const dirX = Math.cos(tent.controlAngle);
                const dirY = Math.sin(tent.controlAngle);
                if (tent.target && (tent.target.health <= 0 || enemies.indexOf(tent.target) === -1)) {
                    tent.target = null;
                }
                if (tent.target) {
                    tent.targetPoint.x = tent.target.x;
                    tent.targetPoint.y = tent.target.y;
                } else if (!tent.targetPoint) {
                    tent.targetPoint = { x: tent.anchor.x + dirX * tent.maxReachBase, y: tent.anchor.y + dirY * tent.maxReachBase };
                }
                tent.maxReach = Math.min(tent.maxReachBase, Math.hypot(tent.targetPoint.x - tent.anchor.x, tent.targetPoint.y - tent.anchor.y) || tent.maxReachBase);
                const extendFrames = Math.max(1, tent.extendFrames);
                const retractFrames = Math.max(1, tent.retractFrames);
                if (tent.phase === 'extend') {
                    tent.progress += 1 / extendFrames;
                    if (tent.progress >= 1) {
                        tent.progress = 1;
                        tent.phase = 'lash';
                        tent.phaseTimer = 0;
                    }
                } else if (tent.phase === 'lash') {
                    tent.phaseTimer = (tent.phaseTimer || 0) + 1;
                    if (tent.phaseTimer >= tent.holdFrames) tent.phase = 'retract';
                } else if (tent.phase === 'retract') {
                    tent.progress -= 1 / retractFrames;
                    if (tent.progress <= 0.02) {
                        state.tentacles.splice(i, 1);
                        continue;
                    }
                }
                const prog = Math.max(0, Math.min(1, tent.progress));
                const eased = prog * prog * (3 - 2 * prog);
                let reach = tent.maxReach * eased;
                if (tent.phase === 'lash') {
                    const oscill = 1 + 0.12 * Math.sin((tent.phaseTimer || 0) * 0.35);
                    reach *= oscill;
                }
                reach = Math.min(tent.maxReachBase * 1.12, reach);
                const segCount = Math.max(4, tent.segmentCount || 6);
                const perpX = -dirY;
                const perpY = dirX;
                const segments = tent.segments;
                const waveAmp = tent.waveAmp || 22;
                for (let s = 0; s < segCount; s++) {
                    const frac = segCount === 1 ? 1 : s / (segCount - 1);
                    const segReach = reach * frac;
                    let sx = tent.anchor.x + dirX * segReach;
                    let sy = tent.anchor.y + dirY * segReach;
                    const wave = Math.sin((tent.age || 0) * 0.22 + frac * 3.4) * waveAmp * (1 - frac * 0.55) * prog;
                    sx += perpX * wave;
                    sy += perpY * wave;
                    const radius = Math.max(8, 18 - frac * 8);
                    segments[s] = segments[s] || {};
                    segments[s].x = sx;
                    segments[s].y = sy;
                    segments[s].radius = radius;
                    segments[s].weight = 0.55 + frac * 0.55;
                }
                tent.tip = segments[segments.length - 1];
                if (!tent._hitMap) tent._hitMap = new Map();
                const slowDuration = tent.slowDuration || 180;
                const hitCooldown = tent.hitCooldown || 14;
                for (let eIndex = 0; eIndex < enemies.length; eIndex++) {
                    const enemy = enemies[eIndex];
                    if (!enemy || enemy.health <= 0) continue;
                    let closestSeg = null;
                    let closestDistSq = Infinity;
                    for (let s = 0; s < segments.length; s++) {
                        const seg = segments[s];
                        const dx = enemy.x - seg.x;
                        const dy = enemy.y - seg.y;
                        const distSq = dx * dx + dy * dy;
                        const hitRadius = seg.radius + (enemy.size || 20) * 0.5;
                        if (distSq <= hitRadius * hitRadius && distSq < closestDistSq) {
                            closestDistSq = distSq;
                            closestSeg = seg;
                        }
                    }
                    if (!closestSeg) continue;
                    const lastHitFrame = tent._hitMap.get(enemy) || -Infinity;
                    if (frame < lastHitFrame) continue;
                    const segWeight = closestSeg.weight || 1;
                    const damage = Math.max(1, Math.floor(tent.baseDamage * tent.damageScale * segWeight));
                    const projStub = {
                        x: enemy.x,
                        y: enemy.y,
                        vx: 0,
                        vy: 0,
                        damage,
                        baseDamage: damage,
                        damageType: 'void',
                        knockback: true,
                        knockbackDistance: tent.knockbackDistance || 32,
                        ignoresArmor: true,
                        quackenTentacle: true
                    };
                    applyProjectileHit(enemy, projStub);
                    enemy.slowed = true;
                    enemy.slowTime = Math.max(enemy.slowTime || 0, slowDuration);
                    if (!lowFx) addParticle(enemy.x + (Math.random() - 0.5) * 14, enemy.y + (Math.random() - 0.5) * 14, '#8E6CFF', 'spark');
                    if (!(g.fxFlags && g.fxFlags.reduceRings)) addParticle(enemy.x, enemy.y, '#50307A', 'ring');
                    tent._hitMap.set(enemy, frame + hitCooldown);
                }
            }
        }

        function renderReleaseQuackenTentacles(ctx) {
            const state = game && game._releaseQuacken;
            if (!state || !state.tentacles || state.tentacles.length === 0) return;
            const img = window._bulletImages && window._bulletImages.quackenTentacle;
            const spriteReady = img && img.complete && !img._broken && (img.naturalWidth || img.width);
            state.tentacles.forEach(tent => {
                if (!tent || !tent.segments || tent.segments.length < 2) return;
                const segs = tent.segments;
                for (let s = 0; s < segs.length - 1; s++) {
                    const a = segs[s];
                    const b = segs[s + 1];
                    const midX = (a.x + b.x) * 0.5;
                    const midY = (a.y + b.y) * 0.5;
                    const dx = b.x - a.x;
                    const dy = b.y - a.y;
                    const angle = Math.atan2(dy, dx);
                    const segLen = Math.hypot(dx, dy) || 1;
                    const thickness = Math.max(6, (a.radius + b.radius) * 0.95);
                    if (spriteReady) {
                        const spriteH = (img.naturalHeight || img.height || 64);
                        const scale = thickness / spriteH;
                        const drawW = segLen * 1.08;
                        const drawH = spriteH * scale;
                        ctx.save();
                        ctx.translate(midX, midY);
                        ctx.rotate(angle);
                        ctx.globalAlpha = 0.92;
                        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
                        ctx.restore();
                    } else {
                        ctx.save();
                        ctx.strokeStyle = 'rgba(110, 70, 160, 0.88)';
                        ctx.lineWidth = thickness;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
                const tip = tent.tip;
                if (tip) {
                    const tipRadius = Math.max(4, (tip.radius || 14) * 0.55);
                    ctx.fillStyle = 'rgba(100, 70, 160, 0.9)';
                    ctx.beginPath();
                    ctx.arc(tip.x, tip.y, tipRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // SIGMA stage 3 spinner spawner and update hooks
        function spawnReleaseTheQuackenBurst(game, opts) {
            if (!game || typeof game.spawnProjectile !== 'function') return;
            const player = game.player;
            if (!player) return;
            if (window._bulletImages && typeof window._bulletImages.loadQuackenTentacle === 'function') {
                try { window._bulletImages.loadQuackenTentacle(); } catch(_) {}
            }
            const originX = (opts && typeof opts.originX === 'number') ? opts.originX : player.x;
            const originY = (opts && typeof opts.originY === 'number') ? opts.originY : player.y;
            const baseDamage = Math.max(1, Math.floor((opts && typeof opts.baseDamage === 'number') ? opts.baseDamage : (typeof calculateDamage === 'function' ? calculateDamage() : 10)));
            const patternCount = Math.max(1, (opts && typeof opts.patternCount === 'number') ? opts.patternCount : 1);
            let tentacleCount = 3;
            if (patternCount >= 10) tentacleCount++;
            if (patternCount >= 18) tentacleCount++;
            if (player.abilities && player.abilities.includes('Omni Shot')) tentacleCount++;
            if (player.abilities && player.abilities.includes('Temporal Drift')) tentacleCount++;
            tentacleCount = Math.min(5, tentacleCount);
            if (tentacleCount <= 0) tentacleCount = 1;
            const firstTarget = (opts && opts.primaryTarget && !opts.primaryTarget.dead && opts.primaryTarget.health > 0) ? opts.primaryTarget : null;
            const candidateSet = new Set();
            const candidates = [];
            if (firstTarget) {
                candidateSet.add(firstTarget);
                candidates.push(firstTarget);
            }
            const pool = [];
            if (Array.isArray(game.enemies)) {
                for (let i = 0; i < game.enemies.length; i++) {
                    const enemy = game.enemies[i];
                    if (!enemy || enemy === firstTarget || enemy.health <= 0 || enemy.dead) continue;
                    const dx = enemy.x - originX;
                    const dy = enemy.y - originY;
                    pool.push({ enemy, dist2: dx * dx + dy * dy });
                }
            }
            pool.sort((a, b) => a.dist2 - b.dist2);
            for (let i = 0; i < pool.length; i++) {
                const enemy = pool[i].enemy;
                if (!candidateSet.has(enemy)) {
                    candidateSet.add(enemy);
                    candidates.push(enemy);
                }
            }
            let baseAngle = opts && typeof opts.angle === 'number' && isFinite(opts.angle) ? opts.angle : NaN;
            if (!isFinite(baseAngle)) {
                if (firstTarget) {
                    baseAngle = Math.atan2(firstTarget.y - originY, firstTarget.x - originX);
                } else if (candidates.length) {
                    const e0 = candidates[0];
                    baseAngle = Math.atan2(e0.y - originY, e0.x - originX);
                } else {
                    const ld = (player.lastDirection && isFinite(player.lastDirection.x) && isFinite(player.lastDirection.y)) ? player.lastDirection : { x: 1, y: 0 };
                    baseAngle = Math.atan2(ld.y || 0, ld.x || 1);
                }
            }
            const frameSeed = (opts && typeof opts.frame === 'number') ? opts.frame : (game.frame || 0);
            for (let n = 0; n < tentacleCount; n++) {
                const target = candidates.length ? candidates[n % candidates.length] : null;
                const offset = tentacleCount === 1 ? 0 : (n - (tentacleCount - 1) / 2) * 0.28;
                const ang = baseAngle + offset;
                spawnQuackenTentacleProjectile(game, {
                    x: originX,
                    y: originY,
                    angle: ang,
                    baseDamage,
                    target,
                    owner: player,
                    patternCount,
                    seed: frameSeed * 0.13 + n * 1.77
                });
            }
        }

        function spawnQuackenTentacleProjectile(game, cfg) {
            if (!game || typeof game.spawnProjectile !== 'function') return -1;
            const angle = (cfg && typeof cfg.angle === 'number' && isFinite(cfg.angle)) ? cfg.angle : 0;
            const base = (cfg && typeof cfg.baseDamage === 'number') ? cfg.baseDamage : (typeof calculateDamage === 'function' ? calculateDamage() : 10);
            const damageOut = Math.max(1, Math.floor(base * 1.1));
            const speed = (cfg && typeof cfg.speed === 'number') ? cfg.speed : 6.4;
            const life = (cfg && typeof cfg.life === 'number') ? cfg.life : 120;
            const radius = (cfg && typeof cfg.radius === 'number') ? cfg.radius : 16;
            const spawnX = (cfg && typeof cfg.x === 'number') ? cfg.x : (game.player ? game.player.x : 0);
            const spawnY = (cfg && typeof cfg.y === 'number') ? cfg.y : (game.player ? game.player.y : 0);
            const idx = game.spawnProjectile({
                x: spawnX,
                y: spawnY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life,
                r: radius,
                damage: damageOut,
                damageType: 'void'
            });
            if (idx < 0) return idx;
            if (!game._projMeta) game._projMeta = new Map();
            const meta = {
                quackenTentacle: true,
                baseDamage: damageOut,
                damageType: 'void',
                piercing: true,
                pierceCount: (cfg && typeof cfg.pierceCount === 'number') ? cfg.pierceCount : 6,
                pierceHits: 0,
                phasing: true,
                knockback: true,
                knockbackDistance: (cfg && typeof cfg.knockbackDistance === 'number') ? cfg.knockbackDistance : 36,
                slowOnHit: true,
                quackenSlowFrames: (cfg && typeof cfg.quackenSlowFrames === 'number') ? cfg.quackenSlowFrames : 210,
                quackenSnareFrames: (cfg && typeof cfg.quackenSnareFrames === 'number') ? cfg.quackenSnareFrames : 220,
                quackenDotScale: (cfg && typeof cfg.quackenDotScale === 'number') ? cfg.quackenDotScale : 0.24,
                hitMultipleTimes: true,
                spriteKey: 'quackenTentacle',
                _tentacleStage: 'extend',
                _tentacleAge: 0,
                _tentacleSeed: (cfg && typeof cfg.seed === 'number') ? cfg.seed : Math.random() * Math.PI * 2,
                _tentacleBaseSpeed: speed,
                _tentacleExtendFrames: (cfg && typeof cfg.extendFrames === 'number') ? cfg.extendFrames : 46,
                _tentacleRetractFrames: (cfg && typeof cfg.retractFrames === 'number') ? cfg.retractFrames : 28,
                _tentacleRange: (cfg && typeof cfg.range === 'number') ? cfg.range : 420,
                _tentacleTrailCap: (cfg && typeof cfg.trailCap === 'number') ? cfg.trailCap : 18,
                _tentacleFlipSign: 1
            };
            const owner = cfg && cfg.owner ? cfg.owner : (game.player || null);
            if (owner) {
                meta._tentacleAnchorPlayer = owner;
                meta._tentacleAnchorX = owner.x;
                meta._tentacleAnchorY = owner.y;
            } else {
                meta._tentacleAnchorX = spawnX;
                meta._tentacleAnchorY = spawnY;
            }
            const target = cfg && cfg.target;
            if (target && typeof target === 'object' && target.health > 0 && !target.dead) {
                meta._tentacleTarget = target;
                meta._tentacleTargetId = Array.isArray(game.enemies) ? game.enemies.indexOf(target) : -1;
            } else {
                meta._tentacleTarget = null;
                meta._tentacleTargetId = -1;
            }
            game._projMeta.set(idx, meta);
            if (game.projectilesSoA) {
                const so = game.projectilesSoA;
                if (so.radius && so.radius[idx] != null) so.radius[idx] = Math.max(12, radius);
                if (so.colorIdx) so.colorIdx[idx] = 5;
            }
            return idx;
        }

        function spawnSigma3(x, y, power) {
            if (!game._sigma) game._sigma = {};
            const idx = game.spawnProjectile({ x, y, vx: 0, vy: 0, life: 120, r: 60, damage: power, damageType: null });
            if (idx >= 0) {
                if (!game._projMeta) game._projMeta = new Map();
                game._projMeta.set(idx, {
                    sigma3: true,
                    baseDamage: power,
                    _spin: 0,
                    _spinRate: 0.28,
                    _age: 0,
                    phasing: true,
                    // Unlimited piercing so sigma3 never disappears on enemy contact
                    piercing: true,
                    pierceCount: 999999,
                    // Tag damage type so contact hits show with a consistent tint
                    damageType: 'void'
                });
                // cue
                if (!(game.perf && game.perf.lowFx)) addParticle(x, y, '#BBD7FF','ring');
            }
        }

        function applyStatusEffects(enemy) {
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageType) {
                    switch (abilityData.effect.damageType) {
                        case 'poison':
                            enemy.poisoned = true;
                            let poisonDur = 240;
                            // Poison + Void synergy extends duration
                            if (game.player.abilities.includes('Void Shot') || game.player.abilities.includes('Black Hole')) {
                                poisonDur += 90; // extend 1.5s
                            }
                            enemy.poisonTime = Math.max(enemy.poisonTime || 0, poisonDur);
                            break;
                        case 'ice':
                            enemy.slowed = true;
                            let slowDur = 180;
                            // Ice + Wind (Blizzard synergy) increases slow duration
                            if (game.player.abilities.includes('Wind Blade') || game.player.abilities.includes('Blizzard')) {
                                slowDur += 60;
                            }
                            enemy.slowTime = Math.max(enemy.slowTime || 0, slowDur);
                            break;
                        case 'fire':
                            enemy.burning = true;
                            let burnDur = 200;
                            if (game.player.abilities.includes('Wind Blade')) burnDur += 40; // fire + wind extends burn
                            if (game.player.abilities.includes('Poison Shot') || game.player.abilities.includes('Toxic Cloud') || game.player.abilities.includes('Inferno') || game.player.abilities.includes('Magma Shot')) {
                                burnDur += 30; // fire + poison style synergy (magma) extends further
                            }
                            enemy.burnTime = Math.max(enemy.burnTime || 0, burnDur);
                            break;
                        case 'lightning':
                            // Chain lightning
                            let chained = 0;
                            const maxChains = 3;
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && chained < maxChains) {
                                    const dx = otherEnemy.x - enemy.x;
                                    const dy = otherEnemy.y - enemy.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < 100) {
                                        const zapDmg = Math.floor(calculateDamage() * 0.6);
                                        otherEnemy.health -= zapDmg;
                                        addDamageNumber(zapDmg, otherEnemy.x, otherEnemy.y - otherEnemy.size/2, { type: 'lightning' });
                                        addParticle(otherEnemy.x, otherEnemy.y, '#FFFF44', 'lightning');
                                        // Visual lightning arc from enemy -> otherEnemy
                                        if (typeof createLightningArc === 'function') createLightningArc(enemy.x, enemy.y, otherEnemy.x, otherEnemy.y, 5 + Math.random()*3);
                                        chained++;
                                    }
                                }
                            });
                            break;
                        case 'stun':
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, 60);
                            break;
                        case 'frost':
                            // freezing: short stun + slow
                            enemy.stunned = true;
                            enemy.stunTime = Math.max(enemy.stunTime || 0, 36);
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 160);
                            break;
                        case 'plasma':
                            // plasma applies burning over time
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 200);
                            break;
                        case 'acid':
                            // acid: applies corrosion (armor shred) and DoT bypassing armor
                            enemy.corroded = true;
                            enemy.corrodeTime = Math.max(enemy.corrodeTime || 0, 200);
                            enemy.armorShredded = (enemy.armorShredded || 0) + 1; // track stacks
                            // Unique: spawn a small lingering acid pool on first application per recent window
                            if (game && game._acidPoolsEnabled !== false) {
                                const nowA = Date.now();
                                const key = enemy._lastAcidPoolAt || 0;
                                const cd = 800; // ms cooldown per enemy to avoid spam
                                if (!key || nowA - key >= cd) {
                                    enemy._lastAcidPoolAt = nowA;
                                    spawnAcidPool(enemy.x, enemy.y, Math.max(42, Math.floor(56 + Math.random()*18)), 4000);
                                }
                            }
                            break;
                        case 'void':
                            // void: applies a weakening field (extra damage taken) and a small true damage tick over time
                            enemy.voidTouched = true;
                            enemy.voidTime = Math.max(enemy.voidTime || 0, 180);
                            enemy.weakness = true;
                            enemy.weaknessTime = Math.max(enemy.weaknessTime || 0, 180);
                            break;
                        case 'earth':
                            // earth: minor stun/slow due to impact shock
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 50);
                            if (Math.random() < 0.18) { // slightly lower chance
                                enemy.stunned = true;
                                // Cap cumulative stun chain length
                                const newDur = Math.max(enemy.stunTime || 0, 18);
                                enemy.stunTime = Math.min(newDur, 50); // hard cap
                            }
                            break;
                        case 'solar':
                            // solar blinds (reduces detection range)
                            if (abilityData.effect && abilityData.effect.blinds) {
                                enemy.blinded = true;
                                enemy.blindTime = Math.max(enemy.blindTime || 0, 120);
                                // Flash particles
                                for (let f=0; f<6; f++) addParticle(enemy.x + (Math.random()-0.5)*28, enemy.y + (Math.random()-0.5)*28, '#FFEFA5','explosion');
                                // Small radial spark ring
                                for (let s=0; s<10; s++) addParticle(enemy.x + Math.cos((s/10)*Math.PI*2)*18, enemy.y + Math.sin((s/10)*Math.PI*2)*12, '#FFF7D1','spark');
                                // Optional mini AoE blind pulse (shorter duration) around primary target
                                const aoeR = 80;
                                game.enemies.forEach(o=>{ if(o===enemy) return; const dx=o.x-enemy.x; const dy=o.y-enemy.y; const d=Math.sqrt(dx*dx+dy*dy); if(d<aoeR){ o.blinded=true; o.blindTime=Math.max(o.blindTime||0,60); if(Math.random()<0.25) addParticle(o.x,o.y,'#FFEFA5','spark'); } });
                            }
                            break;
                        case 'shadow':
                            // shadow drains life slightly on hit
                            const heal = Math.max(1, Math.floor(calculateDamage() * 0.06));
                            game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                            addParticle(game.player.x, game.player.y - 18, '#AA00AA', 'heal');
                            break;
                        case 'wind':
                            // gust: small knockback
                            const kdx = enemy.x - game.player.x;
                            const kdy = enemy.y - game.player.y;
                            const kdist = Math.sqrt(kdx*kdx + kdy*kdy) || 0.0001;
                            applyKnockback(enemy, 12, kdx, kdy);
                            break;
                        case 'steam':
                            // steam = hot + cold: burn and slow a little
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 120);
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 120);
                            break;
                        case 'magma':
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, 260);
                            // heavy shove
                            const mdx = enemy.x - game.player.x;
                            const mdy = enemy.y - game.player.y;
                            const mdist = Math.sqrt(mdx*mdx + mdy*mdy) || 0.0001;
                            applyKnockback(enemy, Math.max(6, Math.floor((mdist) * 0.06)), mdx, mdy);
                            break;
                        case 'storm':
                            // storm: small chain lightning + slow
                            enemy.slowed = true;
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 140);
                            // mini chain
                            let chainedLocal = 0; const maxChainsLocal = 2;
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && chainedLocal < maxChainsLocal) {
                                    const dx = otherEnemy.x - enemy.x; const dy = otherEnemy.y - enemy.y;
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist < 90) {
                                        otherEnemy.health -= Math.floor(calculateDamage() * 0.35);
                                        addParticle(otherEnemy.x, otherEnemy.y, '#FFFF88', 'lightning');
                                        chainedLocal++;
                                    }
                                }
                            });
                            break;
                        case 'crystal':
                            // Crystal Shot: reliable shatter on hit spawning prismatic shards
                            // Nerf: fewer shards on direct hit (2-3 instead of 3-4)
                            const shardBase = 2 + Math.floor(Math.random()*2); // 2-3
                            for (let s = 0; s < shardBase; s++) {
                                const ang = Math.random()*Math.PI*2;
                                const sp = 3.2 + Math.random()*3.2;
                                const dmgFrac = 0.16 + Math.random()*0.08; // 16-24% of base damage (slight total nerf)
                                game.spawnProjectile({
                                    x: enemy.x + Math.cos(ang)*6,
                                    y: enemy.y + Math.sin(ang)*6,
                                    vx: Math.cos(ang)*sp,
                                    vy: Math.sin(ang)*sp,
                                    life: 46 + Math.floor(Math.random()*12),
                                    size: 4,
                                    enemy: false,
                                    damage: Math.max(1, Math.floor(calculateDamage()*dmgFrac)),
                                    damageType: 'crystal',
                                    refract: true // flag for future synergy (e.g., bonus vs armored)
                                });
                            }
                            // Visual sparkle burst
                            for (let p=0;p<6;p++) addParticle(enemy.x + (Math.random()-0.5)*20, enemy.y + (Math.random()-0.5)*20, '#88EEFF', 'spark');
                            break;
                        case 'fear':
                            enemy.fleeing = true;
                            enemy.fleeTime = Math.max(enemy.fleeTime || 0, 120);
                            break;
                        case 'blind':
                            enemy.blinded = true;
                            enemy.blindTime = Math.max(enemy.blindTime || 0, 100);
                            break;
                        case 'charm':
                            enemy.charmed = true;
                            enemy.charmTime = Math.max(enemy.charmTime || 0, 120);
                            break;
                        case 'silence':
                            enemy.silenced = true;
                            enemy.silenceTime = Math.max(enemy.silenceTime || 0, 120);
                            break;
                        case 'curse':
                            // reduce enemy damage output for a period
                            enemy.cursed = true;
                            enemy.curseTime = Math.max(enemy.curseTime || 0, 240);
                            break;
                        case 'weakness':
                            // increase damage taken
                            enemy.weakness = true;
                            enemy.weaknessTime = Math.max(enemy.weaknessTime || 0, 240);
                            break;
                        case 'doom':
                            // mark for death: small periodic damage
                            enemy.doomed = true;
                            enemy.doomTime = Math.max(enemy.doomTime || 0, 300);
                            break;
                        case 'knockback':
                            // shove enemy away from player
                            const kx = enemy.x - game.player.x;
                            const ky = enemy.y - game.player.y;
                            const kdist2 = Math.sqrt(kx*kx + ky*ky) || 0.0001;
                            applyKnockback(enemy, 30, kx, ky);
                            break;
                    }
                }
            });
            // Post-processing: lifeSteal from abilities (apply on next hit resolution)
            // lifeSteal is handled when enemies die in updateEnemies; ensure flag exists
        }

        // --- Acid Pools (lingering) ---
        function spawnAcidPool(x, y, radius, durationMs) {
            if (!Array.isArray(game.acidPools)) game.acidPools = [];
            // Performance cap
            if (game.acidPools.length > 24) game.acidPools.shift();
            const pool = { x, y, r: radius, created: Date.now(), duration: durationMs, tickCd: 0 };
            game.acidPools.push(pool);
        }
        function updateAcidPools() {
            if (!Array.isArray(game.acidPools) || !game.acidPools.length) return;
            const now = Date.now();
            for (let i = game.acidPools.length - 1; i >= 0; i--) {
                const p = game.acidPools[i]; if (!p) { game.acidPools.splice(i,1); continue; }
                const age = now - p.created;
                if (age >= p.duration) { game.acidPools.splice(i,1); continue; }
                // Damage tick cadence ~200ms
                p.tickCd = (p.tickCd||0) - 16;
                if (p.tickCd <= 0) {
                    p.tickCd = 200;
                    const r2 = p.r * p.r;
                    game.enemies.forEach(e => {
                        if (!e || e.health<=0) return;
                        const dx = e.x - p.x; const dy = e.y - p.y;
                        if (dx*dx + dy*dy <= r2) {
                            const dps = Math.max(1, Math.floor(calculateDamage() * 0.10)); // true-like damage
                            e.health -= dps;
                            // apply corrosion stack and timer refresh
                            e.corroded = true; e.corrodeTime = Math.max(e.corrodeTime||0, 120);
                            e.armorShredded = Math.min(10, (e.armorShredded||0) + 1);
                            addDamageNumber(dps, e.x, e.y - e.size/2, { type: 'acid' });
                            if (Math.random()<0.12) addParticle(e.x, e.y, '#66FF44', 'impact');
                        }
                    });
                }
            }
        }
        function updateGoldDustPools() {
            if (!Array.isArray(game.goldDustPools) || !game.goldDustPools.length) return;
            const now = Date.now();
            for (let i = game.goldDustPools.length - 1; i >= 0; i--) {
                const p = game.goldDustPools[i]; if (!p) { game.goldDustPools.splice(i,1); continue; }
                const age = now - p.created;
                if (age >= p.duration) { game.goldDustPools.splice(i,1); continue; }
                // tick cadence ~300ms
                p.tickCd = (p.tickCd||0) - 16;
                if (p.tickCd <= 0) {
                    p.tickCd = 300;
                    const r2 = p.r * p.r;
                    // Apply splash damage to enemies within pool
                    game.enemies.forEach(e => {
                        if (!e || e.health <= 0) return;
                        const dx = e.x - p.x; const dy = e.y - p.y;
                        if (dx*dx + dy*dy <= r2) {
                            const dps = Math.max(1, Math.floor((p.tickDamage||3)));
                            e.health -= dps;
                            // small gold sparkle on hit
                            addParticle(e.x, e.y, '#FFD780', 'impact');
                            addDamageNumber(dps, e.x, e.y - (e.size||24)/2, { type: 'gold' });
                            if (Math.random()<0.22) addParticle(e.x, e.y, '#FFF3BF', 'spark');
                        }
                    });
                }
            }
        }

        function explodeProjectile(proj, damage) {
            // Create explosion particles (amplified for Time Bomb)
            const isTB = !!proj.timeBomb;
            const lowFx = !!(game.perf && game.perf.lowFx);
            const pCount = isTB ? (lowFx ? 12 : 28) : 8;
            // Choose explosion tint based on element when available
            const explHex = getProjElementColor(proj) || (isTB ? '#FF8844' : '#FF6600');
            for (let i = 0; i < pCount; i++) {
                const col = isTB
                    ? (Math.random() < 0.2 ? '#FFFFFF' : (Math.random() < 0.5 ? lightenHex(explHex, 0.35) : explHex))
                    : explHex;
                const spread = isTB ? 26 : 0;
                addParticle(
                    proj.x + (Math.random()-0.5)*spread,
                    proj.y + (Math.random()-0.5)*spread,
                    col,
                    'explosion'
                );
            }
            if (isTB && !lowFx) {
                // Central hot ring burst
                addParticle(proj.x, proj.y, lightenHex(explHex, 0.25), 'ring');
                addParticle(proj.x, proj.y, lightenHex(explHex, 0.45), 'ring');
            }
            
            // Damage nearby enemies (use proj.baseDamage when available so effects remain consistent)
            const baseRadius = proj.antimatter ? 120 : (isTB ? 90 : 60);
            // Allow callers (e.g., SIGMA3) to override the explosion radius to match visuals
            let radius = baseRadius * (proj.antimatter ? 1.4 : (isTB ? 1.35 : 1));
            if (typeof proj.explosionRadius === 'number' && isFinite(proj.explosionRadius)) {
                radius = proj.explosionRadius;
            }
            // Optional: separate radius for knockback-only area (can exceed damage radius)
            const kbRadius = (typeof proj.knockbackRadius === 'number' && isFinite(proj.knockbackRadius)) ? proj.knockbackRadius : radius;
            const sourceDmg = proj.baseDamage || damage;
            game.enemies.forEach(enemy => {
                const dx = enemy.x - proj.x;
                const dy = enemy.y - proj.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    // chainExplosion: cause secondary smaller explosions on nearby enemies
                    // If enemy is weakened, take extra damage
                    const mult = enemy.weakness ? 1.45 : 1.0;
                    // Allow explosion to bypass armor if flagged
                    let applied = Math.floor(sourceDmg * (proj.antimatter ? 1.0 : 0.7) * mult);
                    if (proj.ignoresEverything) applied = Math.floor(applied * 1.3);
                    // ignoresArmor would skip any armor calculation; since we don't have an armor
                    // scalar in this build, keeping applied as-is but honoring the flag for future hooks
                    enemy.health -= applied;
                    const dmgTypeOut = proj.damageType || (proj.antimatter ? 'void' : null);
                    addParticle(enemy.x, enemy.y, getDamageTypeColor(dmgTypeOut) || '#FF4444', 'impact');
                    addDamageNumber(applied, enemy.x, enemy.y - enemy.size/2, { type: dmgTypeOut });
                    if (proj.chainExplosion) {
                        // small secondary blast
                        setTimeout(() => {
                            explodeProjectile({ x: enemy.x, y: enemy.y, chainExplosion: false }, Math.floor(sourceDmg * 0.5));
                        }, 80);
                    }
                    // lifeSteal: heal player slightly based on damage dealt
                    if (proj.lifeSteal && proj.lifeSteal > 0) {
                        const heal = Math.min(10, Math.floor(sourceDmg * 0.06));
                        game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                        addParticle(game.player.x, game.player.y - 18, '#00FF00', 'heal');
                    }
                }
                // Apply knockback in a possibly larger area (outside damage radius) when flagged
                if (proj.knockback && dist < kbRadius) {
                    const falloff = Math.max(0, kbRadius - dist);
                    const scale = (typeof proj.knockbackScale === 'number' && isFinite(proj.knockbackScale)) ? proj.knockbackScale : 0.30;
                    const push = Math.max(10, Math.floor(falloff * scale));
                    const ndx = dx / Math.max(dist,1);
                    const ndy = dy / Math.max(dist,1);
                    applyKnockback(enemy, push, ndx, ndy);
                }
            });
            
            addScreenShake(proj.antimatter ? 12 : (isTB ? 10 : 6));

            // Trigger area effects if the projectile carried those abilities
            if (proj.shockwave) {
                createShockwave(proj.x, proj.y);
            }
            if (proj.timeWarp) {
                createTimeWarp(proj.x, proj.y);
            }
            if (proj.blackHole) {
                createBlackHole(proj.x, proj.y);
            }
            if (proj.vortex) {
                createVortex(proj.x, proj.y);
            }

            // Spawn outward shards similar to an omni blast when Time Bomb detonates
            if (isTB) {
                let shardCount = lowFx ? 10 : 16;
                // If many projectiles already active, tone it down a bit
                try { if (game.projectilePool && game.projectilePool.active && game.projectilePool.active() > 1200) shardCount = Math.max(8, Math.floor(shardCount * 0.7)); } catch (e) {}
                const spd = 4.2;
                const life = 55;
                const base = sourceDmg || calculateDamage();
                const shardDmg = Math.max(1, Math.floor(base * 0.5));
                const rSmall = 6;
                for (let s = 0; s < shardCount; s++) {
                    const ang = (s / shardCount) * Math.PI * 2;
                    const jitter = (Math.random() - 0.5) * 0.15; // tiny variance
                    const a = ang + jitter;
                    const idx = game.spawnProjectile({
                        x: proj.x,
                        y: proj.y,
                        vx: Math.cos(a) * spd,
                        vy: Math.sin(a) * spd,
                        life: life,
                        r: rSmall,
                        damage: shardDmg,
                        damageType: 'fire',
                        enemy: false
                    });
                    // Sanitize shard metadata: ensure plain bullet with no bomb/explosive chaining flags
                    if (idx >= 0) {
                        if (!game._projMeta) game._projMeta = new Map();
                        game._projMeta.set(idx, {
                            baseDamage: shardDmg,
                            damageType: 'fire',
                            // Explicitly disable all explosive/bomb style flags
                            timeBomb: false,
                            smartExplosive: false,
                            chainExplosion: false,
                            novaBlast: false,
                            explosive: false,
                            meteorAbility: false,
                            meteor: false,
                            // Keep them simple projectiles; allow piercing as false by default
                            piercing: false,
                            pierceCount: 0
                        });
                    }
                }
            }

            // Gold dust pool: special lingering sparkling area that deals periodic splash damage
            if (proj.goldDust) {
                try {
                    // initial sparkle burst
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const colors = ['#FFD700','#FFE48A','#FFD76A'];
                    // Larger initial sparkle burst for gold teeth
                    const burstCount = lowFx ? 18 : 44;
                    for (let i=0;i<burstCount;i++) {
                        const col = colors[i % colors.length];
                        // Increase spread so the burst looks larger and more dramatic
                        const spread = Math.max(20, (proj.goldDustRadius||60) * 0.60);
                        addParticle(proj.x + (Math.random()-0.5)*spread, proj.y + (Math.random()-0.5)*spread, col, 'spark');
                        // occasional larger explosion shards for visibility
                        if (!lowFx && Math.random() < 0.08) addParticle(proj.x + (Math.random()-0.5)*spread*0.7, proj.y + (Math.random()-0.5)*spread*0.7, '#FFF3D0', 'explosion');
                    }
                    // Add a couple of soft golden rings to emphasize the impact
                    addParticle(proj.x, proj.y, '#FFD780', 'ring');
                    if (!lowFx) addParticle(proj.x, proj.y, '#FFF3BF', 'ring');
                    // Create a lingering pool that ticks damage periodically (similar to acidPools)
                    const duration = (typeof proj.goldDustDuration === 'number') ? proj.goldDustDuration : 5200;
                    // Make lingering pool visually larger and a bit more damaging per tick
                    const radius = ((typeof proj.goldDustRadius === 'number') ? proj.goldDustRadius : Math.max(48, (proj.size||6)*6)) * 1.25;
                    const tickDamage = Math.max(1, Math.floor((proj.baseDamage || damage || 8) * 0.16));
                    // Ensure container exists
                    try { if (!Array.isArray(game.goldDustPools)) game.goldDustPools = []; } catch(_) { game.goldDustPools = []; }
                    // Limit active pools to avoid excessive load
                    try { if (game.goldDustPools.length > 12) game.goldDustPools.shift(); } catch(_) {}
                    const pool = { x: proj.x, y: proj.y, r: radius, created: Date.now(), duration: duration, tickCd: 0, tickDamage: tickDamage };
                    game.goldDustPools.push(pool);
                } catch(_){}
            }

            // Elemental area effects
            if (proj.areaEffect || proj.damageType === 'toxic') {
                // Toxic cloud: poisons enemies in area
                for (let i = 0; i < 6; i++) addParticle(proj.x + (Math.random()-0.5)*40, proj.y + (Math.random()-0.5)*40, '#44AA44', 'poison');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 90) {
                        enemy.poisoned = true;
                        enemy.poisonTime = Math.max(enemy.poisonTime || 0, 240);
                    }
                });
            }
            if (proj.damageType === 'blizzard' || proj.energyType === 'pulse') {
                // Blizzard: slows in area, small ice particles, and a light frostbite tick for feedback
                for (let i = 0; i < 10; i++) addParticle(proj.x + (Math.random()-0.5)*70, proj.y + (Math.random()-0.5)*70, '#88EEFF', 'fire');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 110) {
                        enemy.slowed = true;
                        enemy.slowTime = Math.max(enemy.slowTime || 0, 200);
                        // light frost tick (safe value) and number
                        const frost = Math.max(1, Math.floor((proj.baseDamage||calculateDamage()) * 0.10));
                        enemy.health -= frost;
                        addDamageNumber(frost, enemy.x, enemy.y - enemy.size/2, { type:'blizzard' });
                        if (Math.random() < 0.35) addParticle(enemy.x, enemy.y, '#C0F8FF', 'impact');
                    }
                });
            }
            if (proj.spreading || proj.damageType === 'inferno' || proj.energyType === 'laser') {
                // Inferno / spreading fire: ignite nearby area and apply burning
                const hex = getDamageTypeColor('fire') || '#FF3333';
                for (let i = 0; i < 10; i++) addParticle(proj.x + (Math.random()-0.5)*80, proj.y + (Math.random()-0.5)*80, hex, 'fire');
                game.enemies.forEach(enemy => {
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 130) {
                        enemy.burning = true;
                        enemy.burnTime = Math.max(enemy.burnTime || 0, 220);
                    }
                });
            }

            // Dimensional Rift: tears space, pulls enemies, damages and occasionally teleports them
            if (proj.dimensional) {
                createDimensionalRift(proj.x, proj.y, Math.max(80, Math.floor(damage * 0.8)));
            }
            // Reality Break: unpredictable physics distortions, small periodic damage and enemy jitter
            if (proj.realityBreak) {
                // slightly stronger base than dimensional by default
                createRealityBreak(proj.x, proj.y, Math.max(120, Math.floor(damage * 1.0)));
            }
        }

        // Small helper: lighten a hex color by fraction [0..1]
        function lightenHex(hex, amt) {
            if (!hex || !/^#([0-9a-fA-F]{6})$/.test(hex)) return hex || '#FFFFFF';
            const v = parseInt(hex.slice(1), 16);
            let r = (v >> 16) & 255, g = (v >> 8) & 255, b = v & 255;
            r = Math.min(255, Math.floor(r + (255 - r) * amt));
            g = Math.min(255, Math.floor(g + (255 - g) * amt));
            b = Math.min(255, Math.floor(b + (255 - b) * amt));
            return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1).toUpperCase();
        }

        // Area effect: shockwave knocks back and damages
        function createShockwave(x, y) {
                    // Expanding shockwave: short-lived ring that applies damage ticks as it expands
                    const maxRadius = 160;
                    const steps = 8;
                    const intervalMs = 28; // ~28ms per step for a quick expansion
                    let step = 0;
                    addParticle(x, y, '#AAAAFF', 'explosion');
                    const swInterval = setInterval(() => {
                        const r = (step / steps) * maxRadius;
                        // visual ring particles
                        for (let i = 0; i < 12; i++) {
                            const ang = Math.random() * Math.PI * 2;
                            const px = x + Math.cos(ang) * (r + (Math.random() - 0.5) * 12);
                            const py = y + Math.sin(ang) * (r + (Math.random() - 0.5) * 12);
                            addParticle(px, py, '#AAAAFF', 'spark');
                        }
                        // damage enemies near the ring edge
                        game.enemies.forEach(enemy => {
                            const dx = enemy.x - x;
                            const dy = enemy.y - y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > Math.max(0, r - 18) && dist < r + 18) {
                                enemy.health -= Math.floor(12 * (1 - step / steps));
                                // small shove away from ring center
                                enemy.x += (dx / Math.max(dist, 1)) * 10;
                                enemy.y += (dy / Math.max(dist, 1)) * 10;
                                addParticle(enemy.x, enemy.y, '#AAAAFF', 'impact');
                            }
                        });
                        step++;
                        if (step > steps) {
                            clearInterval(swInterval);
                            addScreenShake(3);
                        }
                    }, intervalMs);
        }

        // --- Dimensional Rift (fallback implementation) ---
        // Creates a transient singularity that gently pulls nearby enemies and deals minor ticking damage.
        // Called by explodeProjectile when proj.dimensional is true. Ensures game won't crash if ability acquired.
        function createDimensionalRift(x, y, power) {
            // power ~ base damage reference; scale effects lightly
            const radius = Math.min(220, 80 + Math.sqrt(power)*4);
            const life = 60; // frames
            const tickDamage = Math.max(6, Math.floor(power * 0.12));
            const rift = { x, y, r: radius, life, maxLife: life, tickDamage, t:0 };
            if (!game._dimRifts) game._dimRifts = [];
            game._dimRifts.push(rift);
            // Spawn cue: faint ring and a couple of sparks (perf-gated)
            const lowFx = !!(game.perf && game.perf.lowFx);
            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
            if (!reduceRings) addParticle(x, y, '#E6CCFF', 'ring');
            if (!lowFx && !hideSparks) {
                for (let p=0;p<3;p++) addParticle(x + (Math.random()-0.5)*radius*0.4, y + (Math.random()-0.5)*radius*0.4, '#CFA6FF', 'spark');
            }
        }

        // Update Dimensional Rifts (pull + damage + visuals)
        function updateDimensionalRifts() {
            if (!game._dimRifts || !game._dimRifts.length) return;
            for (let i = game._dimRifts.length - 1; i >= 0; i--) {
                const r = game._dimRifts[i];
                r.life--;
                const lowFx = !!(game.perf && game.perf.lowFx);
                const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                // Visual particles: violet sparks (perf-gated)
                if (!lowFx && !hideSparks && r.life % 5 === 0) {
                    const count = 2; // reduced baseline
                    for (let p=0; p<count; p++) {
                        addParticle(r.x + (Math.random()-0.5)*r.r*1.4, r.y + (Math.random()-0.5)*r.r*1.4, '#AA44FF', 'spark');
                    }
                }
                // Apply pull + tick damage every 10 frames
                if (r.life % 10 === 0) {
                    game.enemies.forEach(enemy => {
                        if (enemy.health <= 0) {
                            try { if (enemy && /golden/i.test(String(enemy.type||''))) { try { safeUnlockActII('timeWarp'); } catch(_){} } } catch(_) {}
                            return;
                        }
                        const dx = r.x - enemy.x;
                        const dy = r.y - enemy.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        if (dist < r.r) {
                            // Pull strength decays with distance
                            const pull = Math.max(0.4, 1 - dist / r.r) * 14;
                            enemy.x += (dx / dist) * pull;
                            enemy.y += (dy / dist) * pull;
                            // Damage (ignores armor per ability description context)
                            enemy.health -= r.tickDamage;
                            addDamageNumber(r.tickDamage, enemy.x, enemy.y - enemy.size/2, { type:'void' });
                            addParticle(enemy.x, enemy.y, '#AA44FF', 'impact');
                        }
                    });
                }
                if (r.life <= 0) {
                    // Collapse effect
                    if (!lowFx && !hideSparks) {
                        for (let c=0;c<10;c++) addParticle(r.x, r.y, '#DD99FF', 'spark');
                    }
                    // Collapse ring telegraph (perf-gated)
                    if (!lowFx && !reduceRings) {
                        addParticle(r.x, r.y, '#E6CCFF', 'ring');
                    }
                    game._dimRifts.splice(i,1);
                }
            }
        }

        // --- Traveling Shockwave (linear ground wave) ---
        function spawnShockwave(x, y, angle) {
            if (!game.shockwaves) game.shockwaves = [];
            game.shockwaves.push({
                x, y,
                angle,
                distance: 0,
                speed: 15,
                length: 70,
                width: 80,
                life: 36,
                maxLife: 36,
                hit: []
            });
        }

        function updateShockwaves() {
            if (!game.shockwaves || !game.shockwaves.length) return;
            for (let i = game.shockwaves.length - 1; i >= 0; i--) {
                const w = game.shockwaves[i];
                w.life--;
                w.distance += w.speed;
                const ax = Math.cos(w.angle), ay = Math.sin(w.angle);
                const frontStart = Math.max(0, w.distance - w.length);
                const frontEnd = w.distance;
                game.enemies.forEach(enemy => {
                    if (enemy.health <= 0) {
                        try { if (enemy && /golden/i.test(String(enemy.type||''))) { try { safeUnlockActII('shockwave'); } catch(_){} } } catch(_) {}
                        return;
                    }
                    if (w.hit.includes(enemy)) return;
                    const dx = enemy.x - w.x;
                    const dy = enemy.y - w.y;
                    const along = dx * ax + dy * ay;
                    if (along < frontStart || along > frontEnd) return;
                    const perp = Math.abs(-ay * dx + ax * dy);
                    if (perp > w.width * 0.5) return;
                    // Apply damage & push
                    const pct = 1 - (along / (frontEnd + 0.0001));
                    const base = calculateDamage();
                    const dmg = Math.max(5, Math.floor(base * 0.5 * (0.65 + 0.35 * pct)));
                    enemy.health -= dmg;
                    addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type: 'earth' });
                    applyKnockback(enemy, 34, ax, ay);
                    addParticle(enemy.x, enemy.y, '#AAAACC', 'impact');
                    w.hit.push(enemy);
                });
                // Auto remove when expired or out of bounds
                const endX = w.x + ax * w.distance;
                const endY = w.y + ay * w.distance;
                if (w.life <= 0 || endX < -100 || endX > canvas.width + 100 || endY < -100 || endY > canvas.height + 100) {
                    game.shockwaves.splice(i,1);
                }
            }
        }

        // Transient lightning arc segment (visual only)
        function createLightningArc(x1, y1, x2, y2, life = 8) {
            if (!game.lightningArcs) game.lightningArcs = [];
            const segs = 6 + Math.floor(Math.random()*4); // number of jitter points
            const points = [];
            for (let i=0;i<=segs;i++) {
                const t = i / segs;
                const bx = x1 + (x2 - x1) * t;
                const by = y1 + (y2 - y1) * t;
                const jitterScale = Math.sin(Math.PI * t); // 0 at ends, 1 mid
                const jx = (Math.random()-0.5) * 22 * jitterScale;
                const jy = (Math.random()-0.5) * 22 * jitterScale;
                points.push({ x: bx + jx, y: by + jy });
            }
            game.lightningArcs.push({ points, life, maxLife: life });
        }

        // Time warp: slows enemies in area briefly
        function createTimeWarp(x, y) {
            // Persistent temporal distortion field
            if (!game.timeWarpFields) game.timeWarpFields = [];
            const field = {
                x, y,
                radius: 170,
                createdAt: Date.now(),
                duration: 3000, // ms lifetime
                pulseInterval: 400, // ms between slow pulses
                lastPulse: 0,
                wave: 0 // internal animation phase
            };
            game.timeWarpFields.push(field);
            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                for (let i = 0; i < 10; i++) addParticle(x + (Math.random()-0.5)*field.radius*0.4, y + (Math.random()-0.5)*field.radius*0.4, '#44FFFF', 'spark');
            }
            addScreenShake(2);
        }

        function updateTimeWarpFields() {
            if (!game.timeWarpFields || !game.timeWarpFields.length) return;
            const now = Date.now();
            for (let i = game.timeWarpFields.length - 1; i >= 0; i--) {
                const f = game.timeWarpFields[i];
                const age = now - f.createdAt;
                if (age > f.duration) {
                    // collapse burst
                    if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                        for (let p=0;p<8;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.3, f.y + (Math.random()-0.5)*f.radius*0.3, '#2277FF', 'spark');
                    }
                    game.timeWarpFields.splice(i,1);
                    continue;
                }
                f.wave += 0.06;
                if (now - f.lastPulse >= f.pulseInterval) {
                    f.lastPulse = now;
                    // Apply slow to enemies inside radius
                    game.enemies.forEach(enemy => {
                        if (enemy.health <= 0) {
                            try { if (enemy && /golden/i.test(String(enemy.type||''))) { try { safeUnlockActII('timeWarp-pulse'); } catch(_){} } } catch(_) {}
                            return;
                        }
                        const dx = enemy.x - f.x;
                        const dy = enemy.y - f.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < f.radius) {
                            enemy.slowed = true;
                            // refresh / extend but cap to avoid infinite stacking
                            enemy.slowTime = Math.max(enemy.slowTime || 0, 150);
                            // Optional: add tiny temporal jitter particle
                            if (!(game.perf && game.perf.lowFx) && !(game.fxFlags && game.fxFlags.hideSparks)) {
                                if (Math.random() < 0.25) addParticle(enemy.x, enemy.y - enemy.size/2, '#66AAFF', 'spark');
                                // Subtle flash indicator on pulse
                                addParticle(enemy.x, enemy.y, '#88DDFF', 'impact');
                            }

        // === Bloom Ring System (Hybrid Mode C) ===
        // Player periodically spawns large expanding damage rings. Projectiles emit occasional sub-petal bursts (handled inline earlier).
        // Each enemy is damaged at most once per ring (edge pass). Ring has telegraph (pre-detonation) then expansion phase.
        function spawnBloomRing(x, y, opts) {
            if (!game.bloomRings) game.bloomRings = [];
            const maxActive = 6;
            if (game.bloomRings.length >= maxActive) game.bloomRings.shift();
            // Vortex proximity synergy: if spawning within any vortex innerRadius*1.1, boost damage and growth slightly
            let vortexBoost = 1;
            if (Array.isArray(game.vortexFields) && game.vortexFields.length) {
                for (const vf of game.vortexFields) {
                    const dx = x - vf.x, dy = y - vf.y; const d = Math.hypot(dx, dy);
                    if (d < vf.innerRadius * 1.1) { vortexBoost = 1.18; break; }
                }
            }
            const ring = {
                x, y,
                radius: 0,
                width: opts && opts.width || 28, // slightly thicker for readability
                growth: (opts && opts.growth || 7.2) * (vortexBoost>1?1.06:1),
                maxRadius: (opts && opts.maxRadius || 440) * (vortexBoost>1?1.04:1),
                damage: (opts && opts.damage || Math.max(2, Math.floor(calculateDamage() * 0.55))) * vortexBoost,
                createdAt: Date.now(),
                maxLife: (opts && opts.maxLife) || 6000,
                hits: new Set(),
                detonated: true,
                seed: Math.random()*Math.PI*2,
                telegraphUntil: performance.now() + 180, // first 180ms gets brighter core pulse
                firstDamage: false // flag for one-time stronger feedback on first enemy hit
            };
            game.bloomRings.push(ring);
            // Petal emission (stronger, fewer) at ring birth
            const petals = 8;
            for (let i=0;i<petals;i++) {
                const ang = (i/petals)*Math.PI*2;
                const spd = 4.2 + Math.random()*0.8;
                game.spawnProjectile({
                    x, y,
                    vx: Math.cos(ang)*spd,
                    vy: Math.sin(ang)*spd,
                    life: 46,
                    size: 4,
                    enemy:false,
                    damage: Math.max(1, Math.floor(ring.damage * 0.42 * (vortexBoost>1?1.1:1))),
                    baseDamage: Math.max(1, Math.floor(ring.damage * 0.42 * (vortexBoost>1?1.1:1))),
                    bloomChild:true,
                    _petal:true
                });
            }
            if (typeof addScreenShake === 'function') addScreenShake(4, 180);
            addParticle(x, y, '#FFE4CC','explosion');
        }

        function updateBloomRings() {
            if (!game.player || !game.player.abilities || !game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect && ABILITIES[a].effect.bloomRing)) return;
            if (!game._bloomRingCharge) game._bloomRingCharge = 0;
            const chargeTime = 58; // frames between main rings (approx 1s at 60fps)
            game._bloomRingCharge++;
            // Pre-fire telegraph: a brief ringFlash at the intended spawn spot shortly before spawning (perf-aware)
            if (game._bloomRingCharge === chargeTime - 6) {
                let sx = game.player.x, sy = game.player.y;
                if (game.player && game.player.vx && game.player.vy) { sx += game.player.vx * 4; sy += game.player.vy * 4; }
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                if (!lowFx && !reduceRings) addTransientEffect({ type:'ringFlash', x:sx, y:sy, color:'#FFE4CC', radius: 26, life: 160 });
            }
            if (game._bloomRingCharge >= chargeTime) {
                game._bloomRingCharge = 0;
                // Spawn ring at player location (slightly ahead if moving for dynamism)
                let sx = game.player.x;
                let sy = game.player.y;
                if (game.player && game.player.vx && game.player.vy) {
                    sx += game.player.vx * 4;
                    sy += game.player.vy * 4;
                }
                // Optional synergy: if Echo Bloom field active, increase radius a bit
                const activeEcho = game.echoBloomFields && game.echoBloomFields.length;
                spawnBloomRing(sx, sy, activeEcho ? { maxRadius: 470, growth: 7.8 } : null);
            }
            // Ring progression & damage application
            if (!game.bloomRings || !game.bloomRings.length) return;
            for (let i = game.bloomRings.length - 1; i >= 0; i--) {
                const rg = game.bloomRings[i];
                rg.radius += rg.growth;
                // Soft acceleration near early phase to feel more explosive
                if (rg.radius < rg.maxRadius*0.25) rg.radius += rg.growth*0.15;
                // Vortex intersection synergy: when ring edge passes through vortex radius for first time, spawn bonus petals & temp damage buff
                if (!rg._vortexProc && Array.isArray(game.vortexFields) && game.vortexFields.length) {
                    for (const vf of game.vortexFields) {
                        const dxv = rg.x - vf.x, dyv = rg.y - vf.y; const dv = Math.hypot(dxv, dyv);
                        // Check if ring edge intersects vortex outer radius band this frame
                        if (Math.abs(dv - rg.radius) < rg.growth + 8 && dv < vf.radius + rg.width) {
                            rg._vortexProc = true;
                            // Damage boost for remaining expansion
                            rg.damage *= 1.15;
                            rg.growth *= 1.08;
                            // Spawn bonus petals focused tangentially (12 smaller petals)
                            const bonus = 12;
                            for (let b=0;b<bonus;b++) {
                                const ang = (b/bonus)*Math.PI*2;
                                const spd = 4.6 + Math.random()*0.9;
                                game.spawnProjectile({
                                    x: rg.x + Math.cos(ang)*rg.radius,
                                    y: rg.y + Math.sin(ang)*rg.radius,
                                    vx: Math.cos(ang + Math.PI/2)*spd*0.55,
                                    vy: Math.sin(ang + Math.PI/2)*spd*0.55,
                                    life: 34,
                                    size: 3,
                                    enemy:false,
                                    damage: Math.max(1, Math.floor(rg.damage * 0.24)),
                                    baseDamage: Math.max(1, Math.floor(rg.damage * 0.24)),
                                    bloomChild:true,
                                    _petal:true,
                                    _vortexPetal:true
                                });
                            }
                            addParticle(rg.x, rg.y, '#FFEEDD','explosion');
                            if (typeof addScreenShake === 'function') addScreenShake(3, 160);
                            break;
                        }
                    }
                }
                // Lifespan fail-safe (ms)
                if (Date.now() - rg.createdAt > rg.maxLife || rg.radius > rg.maxRadius + rg.width*1.2) {
                    game.bloomRings.splice(i,1);
                    continue;
                }
                // Damage band: treat ring edge as annulus
                if (game.enemies && game.enemies.length) {
                    for (const enemy of game.enemies) {
                        if (!enemy || enemy.health <= 0) continue;
                        const id = enemy._id || enemy.__rid || enemy; // fallback: object ref
                        if (rg.hits.has(id)) continue;
                        const dx = enemy.x - rg.x;
                        const dy = enemy.y - rg.y;
                        const dist = Math.hypot(dx, dy);
                        const edgeDelta = Math.abs(dist - rg.radius);
                        if (edgeDelta <= rg.width * 0.55 && dist <= rg.radius + rg.width) {
                            rg.hits.add(id);
                            const dmg = Math.max(1, Math.floor(rg.damage * (0.85 + Math.random()*0.3)));
                            applyPlayerDamage(enemy, dmg);
                            addDamageNumber(dmg, enemy.x, enemy.y - (enemy.size||18)/2, { color:'#FFC8AA' });
                            // Hit shimmer particles (consistent, a couple per hit for clarity)
                            addParticle(enemy.x, enemy.y, '#FFE0CC','spark');
                            if (Math.random()<0.35) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y + (Math.random()-0.5)*10, '#FFD0B0','spark');
                            // Slight outline flash effect via a temporary marker
                            enemy._bloomFlash = 4; // frames of flash handled in enemy render (if implemented)
                            // One-time stronger feedback on first damage event of this ring
                            if (!rg.firstDamage) {
                                rg.firstDamage = true;
                                if (typeof addScreenShake === 'function') addScreenShake(5);
                                // Central flash particle cluster
                                for (let f=0;f<6;f++) addParticle(rg.x + (Math.random()-0.5)*rg.width*2, rg.y + (Math.random()-0.5)*rg.width*2, '#FFE8D8','explosion');
                            }
                        }
                    }
                }
            }
        }
                        }
                    });
                }
            }
        }

        // Black hole: persistent field handled in update loop for deterministic pulling
        function createBlackHole(x, y) {
            if (!game.blackHoles) game.blackHoles = [];
            const hole = {
                x, y,
                radius: 200,
                createdAt: performance.now(),
                lifeMs: 1900, // total duration
                pulseTimer: 0,
                pulseInterval: 140, // add a damage pulse every 140ms
                spin: 0,
                strength: 5.5, // base pull (effective strength now ramps over life)
                damagePerSecond: 32, // slight tweak (pull stronger so balanced DPS)
                id: Math.random().toString(36).slice(2)
            };
            // Initial particles
            for (let i = 0; i < 18; i++) addParticle(x + (Math.random()-0.5)*40, y + (Math.random()-0.5)*40, '#331133', 'explosion');
            game.blackHoles.push(hole);
            addScreenShake(6);
        }

        function updateBlackHoles() {
            if (!game.blackHoles || !game.blackHoles.length) return;
            const now = performance.now();
            for (let i = game.blackHoles.length - 1; i >= 0; i--) {
                const h = game.blackHoles[i];
                const age = now - h.createdAt;
                const lifeT = age / h.lifeMs; // 0..1
                if (lifeT >= 1) {
                    // collapse burst
                    for (let p=0;p<14;p++) addParticle(h.x + (Math.random()-0.5)*h.radius*0.3, h.y + (Math.random()-0.5)*h.radius*0.3, '#662244','spark');
                    for (let r=0;r<10;r++) addParticle(h.x + Math.cos((r/10)*Math.PI*2)*30, h.y + Math.sin((r/10)*Math.PI*2)*30, '#AA77CC','spark');
                    game.blackHoles.splice(i,1);
                    continue;
                }
                // Spin for visual modulation; spawn subtle inward drifting sparks
                h.spin += 0.04 + lifeT*0.06;
                if (Math.random() < 0.45) addParticle(h.x + Math.cos(h.spin)* (40 + Math.random()*50), h.y + Math.sin(h.spin)*(40 + Math.random()*50), '#442244','spark');
                // Pull + damage
                const radius = h.radius * (1 - lifeT*0.05); // shrink a little less over life
                const pullFalloff = 0.75;
                const frameDamage = (h.damagePerSecond / 60);
                h.pulseTimer += (1000/60);
                const doPulse = h.pulseTimer >= h.pulseInterval;
                if (doPulse) h.pulseTimer = 0;
                game.enemies.forEach(enemy => {
                    if (enemy.health <= 0) {
                        try { if (enemy && /golden/i.test(String(enemy.type||''))) { try { safeUnlockActII('blackHole'); } catch(_){} } } catch(_) {}
                        return;
                    }
                    const dx = h.x - enemy.x;
                    const dy = h.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < radius) {
                        const norm = dist || 0.0001;
                        // Raw falloff 0..1 (1 = center)
                        const fallRaw = (radius - dist) / radius;
                        // Lifetime scaling: suction ramps up toward collapse (0.6..1.5x)
                        const lifeBoost = 0.6 + lifeT * 0.9;
                        // Blend so outer ring still moves meaningfully (min motion) while inner accelerates strongly
                        const blended = 0.25 + Math.max(0, fallRaw) * 0.75; // 0.25..1.0
                        const base = h.strength * lifeBoost;
                        const pull = Math.max(0.35, base * blended * pullFalloff); // ensure minimum noticeable pull
                        enemy.x += (dx / norm) * pull;
                        enemy.y += (dy / norm) * pull;
                        // Frame damage scaled a bit less by distance now (outer ring still hurts some)
                        enemy.health -= frameDamage * (0.5 + blended * 0.5);
                        if (doPulse) {
                            const burst = Math.max(2, Math.floor(frameDamage * 12 * blended));
                            enemy.health -= burst;
                            addDamageNumber(burst, enemy.x, enemy.y - enemy.size/2, { type:'void'});
                            addParticle(enemy.x, enemy.y, '#8844AA','impact');
                        }
                    }
                });
            }
        }

        // Vortex: spinning damage field that applies burning
        function createVortex(x, y) {
            // Spawn a persistent field entry. Fields update in updateVortexFields.
            if (!Array.isArray(game.vortexFields)) game.vortexFields = [];
            const field = {
                x, y,
                radius: 260,
                innerRadius: 80,
                createdAt: Date.now(),
                duration: 4200, // ms lifetime (longer)
                tickEvery: 200, // ms between damage ticks (faster)
                lastTick: 0,
                spin: Math.random() * Math.PI * 2,
                spinSpeed: 0.10 + Math.random()*0.05,
                pullStrength: 7.5, // px per frame at center falloff (much stronger)
                damagePerTick: 12, // higher base damage
                burnTime: 200
            };
            game.vortexFields.push(field);
            for (let i = 0; i < 18; i++) addParticle(x + (Math.random()-0.5)*field.radius*0.65, y + (Math.random()-0.5)*field.radius*0.65, '#FF33FF', 'explosion');
            addScreenShake(4);
        }

        // Update active vortex fields (called from update())
        function updateVortexFields() {
            if (!Array.isArray(game.vortexFields) || game.vortexFields.length === 0) return;
            const now = Date.now();
            for (let i = game.vortexFields.length - 1; i >= 0; i--) {
                const f = game.vortexFields[i];
                if (!f) { game.vortexFields.splice(i,1); continue; }
                // Lifetime expiry
                if (now - f.createdAt > f.duration) {
                    // small dissipate effect
                    for (let p=0;p<8;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.5, f.y + (Math.random()-0.5)*f.radius*0.5, '#AA44AA', 'spark');
                    game.vortexFields.splice(i,1);
                    continue;
                }
                f.spin += f.spinSpeed;
                // Pull + damage ticks
                game.enemies.forEach(enemy => {
                    if (!enemy || enemy.health <= 0) {
                        try { if (enemy && /golden/i.test(String(enemy.type||''))) { try { safeUnlockActII('vortex'); } catch(_){} } } catch(_) {}
                        return;
                    }
                    const dx = f.x - enemy.x;
                    const dy = f.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < f.radius) {
                        // Normalized inward vector
                        const nx = dx / Math.max(dist, 1);
                        const ny = dy / Math.max(dist, 1);
                        // Falloff ramps sharply near center so pull overcomes movement
                        const proximity = (f.radius - dist) / f.radius; // 0..1
                        const falloff = Math.max(0, Math.min(1, proximity * proximity));
                        // Direct positional pull (guaranteed effect independent of enemy movement model)
                        const pull = f.pullStrength * falloff;
                        enemy.x += nx * pull;
                        enemy.y += ny * pull;
                        // If enemy uses velocity fields, damp and add a small inward accel so the pull "wins"
                        if (typeof enemy.vx === 'number' && typeof enemy.vy === 'number') {
                            const damp = 0.88; // light damping while inside the field
                            enemy.vx *= damp;
                            enemy.vy *= damp;
                            let ax = nx * f.pullStrength * 0.35 * falloff;
                            let ay = ny * f.pullStrength * 0.35 * falloff;
                            const maxAccel = 2.8;
                            const aMag = Math.hypot(ax, ay);
                            if (aMag > maxAccel && aMag > 0) { ax *= maxAccel / aMag; ay *= maxAccel / aMag; }
                            enemy.vx += ax;
                            enemy.vy += ay;
                        }
                        // Apply stronger slow while inside vortex
                        enemy.slowed = true;
                        enemy.slowTime = Math.max(enemy.slowTime||0, 60);
                        if (now - f.lastTick >= f.tickEvery) {
                            // Apply damage + burn once per tick interval
                            let dmg = f.damagePerTick;
                            if (enemy.weakness) dmg = Math.floor(dmg * 1.3);
                            enemy.health -= dmg;
                            enemy.burning = true;
                            enemy.burnTime = Math.max(enemy.burnTime || 0, f.burnTime);
                            addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type: 'void' });
                            if (Math.random() < 0.25) addParticle(enemy.x, enemy.y, '#FF66FF', 'impact');
                        }
                    }
                });
                if (now - f.lastTick >= f.tickEvery) {
                    f.lastTick = now;
                    // Pulse visual: tighter ring contraction, slightly more frequent flicker
                    for (let p=0;p<10;p++) addParticle(f.x + (Math.random()-0.5)*f.radius*0.8, f.y + (Math.random()-0.5)*f.radius*0.8, '#AA44AA','spark');
                    // Mark a short flash for renderer
                    f._flash = 6;
                }
            }
        }

        // Echo Bloom lingering resonance fields
        function updateEchoBloomFields() {
            if (!Array.isArray(game.echoBloomFields) || !game.echoBloomFields.length) return;
            const now = Date.now();
            for (let i = game.echoBloomFields.length - 1; i >= 0; i--) {
                const f = game.echoBloomFields[i];
                if (now - f.createdAt > f.duration) { game.echoBloomFields.splice(i,1); continue; }
                if (now - f.lastTick >= f.tickEvery) {
                    f.lastTick = now;
                    // Track stacked hits: if ticks land close together (due to many enemies inside), boost a short-lived visual intensity
                    f._stackCount = (f._stackCount||0) + 1;
                    f._stackVisUntil = performance.now() + Math.min(260, 120 + f._stackCount * 40);
                    game.enemies.forEach(en => {
                        if (en.health<=0) return;
                        const dx = en.x - f.x; const dy = en.y - f.y; const d = Math.hypot(dx,dy);
                        if (d < f.radius) {
                            const fall = 0.45 + 0.55*(1 - d / f.radius);
                            const dmg = Math.max(1, Math.floor(f.baseDamage * fall));
                            en.health -= dmg;
                            addDamageNumber(dmg, en.x, en.y - en.size/2, { type:'void' });
                            if (Math.random()<0.25) addParticle(en.x, en.y, '#FFC8FF','impact');
                        }

                        // Blizzard Frost Aura: persistent slow/tick around player when they have Blizzard
                        function updateFrostAura() {
                            if (!game.player || !Array.isArray(game.player.abilities)) return;
                            const hasBlizzard = game.player.abilities.some(a => /Blizzard/i.test(a));
                            if (!hasBlizzard) { game._frostAura = null; return; }
                            const now = performance.now();
                            if (!game._frostAura) game._frostAura = { r: 140, lastTick: 0, tickMs: 420 };
                            const aura = game._frostAura;
                            // Apply slow and intermittent frost tick to nearby enemies
                            if (game.enemies && game.enemies.length) {
                                game.enemies.forEach(enemy => {
                                    const dx = enemy.x - game.player.x; const dy = enemy.y - game.player.y; const d = Math.hypot(dx, dy);
                                    if (d <= aura.r + (enemy.size||16)) {
                                        enemy.slowed = true; enemy.slowTime = Math.max(enemy.slowTime||0, 120);
                                        if (now - aura.lastTick >= aura.tickMs) {
                                            const frost = Math.max(1, Math.floor(calculateDamage() * 0.08));
                                            enemy.health -= frost; addDamageNumber(frost, enemy.x, enemy.y - (enemy.size||18)/2, { type:'blizzard' });
                                        }
                                        if (!game.disableCosmeticParticles && Math.random() < 0.25) addParticle(enemy.x + (Math.random()-0.5)*10, enemy.y - (enemy.size||12), '#C8F4FF', 'spark');
                                    }
                                });
                            }
                            if (now - (aura.lastTick||0) >= aura.tickMs) aura.lastTick = now;
                            // Ambient snowflakes around player (cosmetic)
                            if (!game.disableCosmeticParticles) {
                                for (let i=0;i<2;i++) {
                                    const ang = Math.random()*Math.PI*2; const rad = 20 + Math.random()*aura.r;
                                    addParticle(game.player.x + Math.cos(ang)*rad, game.player.y + Math.sin(ang)*rad, '#E0FAFF', 'spark');
                                }
                            }
                        }
                    });
                }
            }
        }

        // Reality Break: short, chaotic distortion that jitters enemies, applies small damage ticks,
        // and occasionally warps an enemy's position to a random nearby location. Conservative safe defaults.
        function createRealityBreak(x, y, baseDamage) {
            const lowFx = !!(game.perf && game.perf.lowFx);
            const hideSparks = !!(game.fxFlags && game.fxFlags.hideSparks);
            const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
            if (!lowFx && !hideSparks) {
                for (let i = 0; i < 10; i++) addParticle(x + (Math.random()-0.5)*100, y + (Math.random()-0.5)*100, '#66FFFF', 'explosion');
            }
            if (!reduceRings) {
                addParticle(x, y, '#CCFFFF', 'ring');
                if (typeof addTransientEffect === 'function') addTransientEffect({ type:'ringFlash', x, y, color:'#AEEFFF', radius: 36, life: 140 });
            }
            const duration = 100; // frames (~1.6s)
            const radius = 220;
            const start = Date.now();
            // register active reality field for projectile refraction
            const field = { x, y, radius, expiresAt: start + duration * 16 };
            game.activeRealityFields.push(field);
            // Boost global distortion effect (cumulative but clamped)
            if (!game.realityBreakDistort) game.realityBreakDistort = { time:0, intensity:0 };
            game.realityBreakDistort.time = Math.min(game.realityBreakDistort.time + 40, 160);
            game.realityBreakDistort.intensity = Math.min(0.75, game.realityBreakDistort.intensity + 0.12);
            const interval = setInterval(() => {
                // chaotic visual sparks
                if (Math.random() < 0.6) addParticle(x + (Math.random()-0.5)*160, y + (Math.random()-0.5)*160, '#99FFFF', 'spark');

                game.enemies.forEach(enemy => {
                    const dx = enemy.x - x;
                    const dy = enemy.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 220) {
                        // small random jitter to simulate physics break
                        enemy.x += (Math.random() - 0.5) * Math.min(18, (220 - dist) / 8);
                        enemy.y += (Math.random() - 0.5) * Math.min(18, (220 - dist) / 8);

                        // periodic small damage ticks scaled down for safety
                        const dmg = Math.max(1, Math.floor(baseDamage * 0.035));
                        enemy.health -= dmg;
                        addDamageNumber(dmg, enemy.x, enemy.y - enemy.size/2, { type:'void' });
                        if (Math.random() < 0.12) addParticle(enemy.x, enemy.y, '#66FFFF', 'impact');

                        // small chance to randomly teleport the enemy a short distance (disorienting)
                        if (Math.random() < 0.035) {
                            const tx = enemy.x + (Math.random()-0.5) * 120;
                            const ty = enemy.y + (Math.random()-0.5) * 120;
                            enemy.x = Math.max(40, Math.min(tx, canvas.width - 40));
                            enemy.y = Math.max(40, Math.min(ty, canvas.height - 40));
                            addParticle(enemy.x, enemy.y, '#FFFFFF', 'spark');
                        }
                    }
                });

                // subtle camera feedback
                if (Math.random() < 0.08) addScreenShake(3);

                if (Date.now() - start > duration * 16) {
                    clearInterval(interval);
                    // final destabilizing burst
                    if (!lowFx && !hideSparks) {
                        for (let i = 0; i < 10; i++) addParticle(x + (Math.random()-0.5)*140, y + (Math.random()-0.5)*140, '#66FFFF', 'explosion');
                    }
                    if (!reduceRings) addParticle(x, y, '#B8F8FF', 'ring');
                    addScreenShake(8);
                    // remove field from active list
                    const idx = game.activeRealityFields.indexOf(field);
                    if (idx >= 0) game.activeRealityFields.splice(idx, 1);
                }
            }, 16);
        }

        // splitProjectile removed (Split Shot ability deprecated)

        // Crystal Shot helper: spawn prismatic shards on shatter
        function createCrystalShatter(x, y, baseDamage, sourceProj) {
            const abil = game.player.abilities || [];
            // Nerf: baseline 2-3 shards on death instead of 4-5
            let shardCount = 2 + Math.floor(Math.random()*2); // 2-3 baseline
            // Synergy: ice increases control -> +1 shard
            if (abil.some(a=>/Ice Shot|Frost|Blizzard/i.test(a))) shardCount++;
            // Synergy: lightning energizes fracture -> +1 shard (chance)
            if (abil.some(a=>/Lightning Shot|Storm Shot/i.test(a)) && Math.random()<0.6) shardCount++;
            // Cap to avoid spam
            shardCount = Math.min(6, shardCount);
            for (let i=0;i<shardCount;i++) {
                const ang = Math.random()*Math.PI*2;
                const sp = 3.4 + Math.random()*2.4;
                const dmgFrac = 0.18 + Math.random()*0.06; // 18-24%
                const vx = Math.cos(ang)*sp;
                const vy = Math.sin(ang)*sp;
                game.spawnProjectile({
                    x: x + Math.cos(ang)*4,
                    y: y + Math.sin(ang)*4,
                    vx, vy,
                    life: 55 + Math.floor(Math.random()*18),
                    size: 5,
                    enemy:false,
                    damage: Math.max(1, Math.floor((baseDamage||calculateDamage()) * dmgFrac)),
                    baseDamage: Math.max(1, Math.floor((baseDamage||calculateDamage()) * dmgFrac)),
                    damageType: 'crystal',
                    piercing: false,
                    crystalShard: true,
                    refract: true,
                    homing: false,
                    // (removed splitting flag)
                });
            }
            // Visual sparkle field
            for (let s=0;s<10;s++) addParticle(x + (Math.random()-0.5)*28, y + (Math.random()-0.5)*28, '#AAEEFF', 'spark');
            addScreenShake(4);
            if (sourceProj) sourceProj._crystalShattered = true;
        }

        function takeDamage(amount) {
            let finalDamage = amount;
            
            // Damage reduction
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.damageReduction) {
                    finalDamage -= abilityData.effect.damageReduction;
                }
            });
            
            // Block chance
            let blockChance = 0;
            game.player.abilities.forEach(ability => {
                const abilityData = ABILITIES[ability];
                if (abilityData && abilityData.effect.blockChance) {
                    blockChance = Math.max(blockChance, abilityData.effect.blockChance);
                }
            });
            
            if (Math.random() < blockChance) {
                finalDamage = 0;
                addParticle(game.player.x, game.player.y - 15, '#0088FF', 'shield');
            }
            
            finalDamage = Math.max(0, finalDamage);
            
            if (finalDamage > 0) {
                game.player.health -= finalDamage;
                game.player.invulnerable = true;
                game.player.invulnTime = 80;
                addScreenShake(4);
                addParticle(game.player.x, game.player.y, '#FF4444', 'damage');
            }
            
            if (game.player.health <= 0 && !game.gameOver && !game._bigQuackDefeated) {
                // Prevent game over overlapping with victory/ending flow
                triggerGameOver();
            }
            
            updateUI();
        }

        function triggerGameOver() {
            game.gameOver = true;
            // Pause gameplay music
            try { if (game.bgMusic) game.bgMusic.pause(); } catch(e) {}
            // One-shot game over audio (respect SFX preference)
            try {
                if (game._gameOverSound) { try { game._gameOverSound.pause(); } catch(e) {} }
                game._gameOverSound = new Audio('assets/audio/gameover.mp3');
                game._gameOverSound.loop = false;
                if (game.sfxEnabled) {
                    game._gameOverSound.play().catch(()=>{});
                }
            } catch(e) {}
            // Enforce a 1 second delay before restart allowed and guard against held input
            game._gameOverAt = performance.now();
            game._restartArm = false; // becomes true if fire is held during delay; requires release first
            game._restartGpPrev = false;
            // Keyboard handlers (Space = fire)
            const onKeyDown = (e) => {
                if (e.code !== 'Space' && e.key !== ' ') return;
                const dt = performance.now() - game._gameOverAt;
                if (dt < 1000) { game._restartArm = true; return; }
                if (game._restartArm) return; // wait for release
                finishRestart();
            };
            const onKeyUp = (e) => {
                if (e.code !== 'Space' && e.key !== ' ') return;
                // Clear arm after delay has elapsed so next press is accepted
                if (performance.now() - game._gameOverAt >= 1000) game._restartArm = false;
            };
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            // Gamepad polling (A button default) with rising-edge
            const pollGpRestart = () => {
                if (!game.gameOver) return; // stop polling when we leave screen
                const fireNow = !!(game.input && game.input.gpFire);
                const dt = performance.now() - game._gameOverAt;
                if (dt < 1000) {
                    if (fireNow) game._restartArm = true;
                } else {
                    if (fireNow && !game._restartGpPrev) {
                        if (!game._restartArm) return finishRestart();
                        // if armed, require release first
                    }
                    if (!fireNow && game._restartGpPrev) {
                        // released; clear arm if past delay
                        game._restartArm = false;
                    }
                }
                game._restartGpPrev = fireNow;
                requestAnimationFrame(pollGpRestart);
            };
            requestAnimationFrame(pollGpRestart);
            function finishRestart(){
                try { window.removeEventListener('keydown', onKeyDown); } catch(_) {}
                try { window.removeEventListener('keyup', onKeyUp); } catch(_) {}
                // Prevent any residual room-cleared flow from advancing
                game.roomCleared = false;
                game.gameOver = false;
                // Defensive: clear any residual duck dynasty flock visuals before reset (prevents one-frame ghost row)
                if (Array.isArray(game.duckFlocks)) game.duckFlocks.length = 0;
                game.nextDuckFlockFrame = 0;
                // Reset progression to the same street (do NOT advance) – keep current dungeon & room unless they were out of range
                if (game.room < 1 || game.room > 5) game.room = 1;
                if (game.dungeon < 1 || game.dungeon > 10) game.dungeon = 1;
                // Clear any transient flags that could trigger nextRoom()
                game._pendingAdvance = false;
                resetGame();
                if (typeof rebuildPlayerSprite === 'function') rebuildPlayerSprite();
            }
        }

        function openChest(chest) {
            // Helper: determine if an ability may be offered in chests. Secret abilities must be discovered first.
            function isAbilityOfferable(name) {
                try {
                    if (!name) return false;
                    // Already owned in this run should be considered not offerable
                    if (Array.isArray(game.player.abilities) && game.player.abilities.includes(name)) return false;
                    const secretList = ['Gooster Teeth','Wunder Doodle','Release the Quacken!'];
                    if (secretList.indexOf(name) >= 0) {
                        return !!(game && game.player && game.player._seenAbilities && game.player._seenAbilities[name]);
                    }
                    return true;
                } catch(_) { return true; }
            }
            chest.opened = true;
            game.chestsOpened++;
            // Opening effect (color keyed to variant)
            if (chest.variant === 'rainbow' || chest.rainbow) {
                const hues = [0,60,120,180,240,300];
                for (let i = 0; i < 10; i++) {
                    const h = hues[i % hues.length];
                    addParticle(chest.x, chest.y, `hsl(${h}, 85%, 65%)`, 'treasure');
                }
            } else {
                const baseColor = chest.variant === 'platinum' ? '#FFFFFF' : chest.variant === 'irradiated' ? '#b4ff5c' : '#FFD700';
                for (let i = 0; i < 8; i++) addParticle(chest.x, chest.y, baseColor, 'treasure');
            }

            // Rainbow chest: let the player choose any ability (preferably new)
            if (chest.variant === 'rainbow' || chest.rainbow) {
                showRainbowAbilityPicker((picked) => {
                    if (!picked || !ABILITIES[picked]) return;
                    if (!game.player.abilities.includes(picked)) {
                        game.player.abilities.push(picked);
                        try { if (typeof window._onAbilityAdded === 'function') window._onAbilityAdded(picked); } catch(_){}
                        try { game.player._newAbilities = game.player._newAbilities || {}; game.player._seenAbilities = game.player._seenAbilities || {}; if (!game.player._seenAbilities[picked]) game.player._newAbilities[picked] = true; } catch(_) {}
                        /* don't persist here; we'll mark as seen when the tooltip displays */
                    }
                    try { if (window.achv_onAbilityAcquired) achv_onAbilityAcquired(picked); } catch(_) {}
                    // Play pickup power-up sound on ability acquisition
                    try { playPowerupSfx(); } catch(_) {}
                    showAbilityTooltip(picked);
                    const abilityData = ABILITIES[picked];
                    if (abilityData && abilityData.effect && abilityData.effect.maxHealthBonus) {
                        game.player.maxHealth += abilityData.effect.maxHealthBonus;
                        game.player.health += abilityData.effect.maxHealthBonus;
                    }
                    updateUI();
                    addScreenShake(3);
                });
                return;
            }

            // Default chest behavior (preselected/random ability)
            let newAbility = chest.ability || null;
            if (newAbility) {
                // Respect secret/unseen abilities: if this chest's preset ability is secret and not yet discovered, ignore it
                if (!isAbilityOfferable(newAbility)) newAbility = null;
                else if (game.player.abilities.includes(newAbility)) {
                    const tier = ABILITIES[newAbility] ? (ABILITIES[newAbility].tier || 1) : 1;
                    const sameTierPool = Object.keys(ABILITIES).filter(a => isAbilityOfferable(a) && (ABILITIES[a].tier || 1) === tier);
                    if (sameTierPool.length > 0) newAbility = sameTierPool[Math.floor(Math.random()*sameTierPool.length)]; else newAbility = null;
                }
            }
            if (!newAbility) {
                const pool = Object.keys(ABILITIES).filter(a => isAbilityOfferable(a));
                if (pool.length > 0) newAbility = pool[Math.floor(Math.random()*pool.length)];
            }
                if (newAbility) {
                game.player.abilities.push(newAbility);
                try { if (typeof window._onAbilityAdded === 'function') window._onAbilityAdded(newAbility); } catch(_){}
                try { game.player._newAbilities = game.player._newAbilities || {}; game.player._seenAbilities = game.player._seenAbilities || {}; if (!game.player._seenAbilities[newAbility]) game.player._newAbilities[newAbility] = true; } catch(_) {}
                try { if (window.achv_onAbilityAcquired) achv_onAbilityAcquired(newAbility); } catch(_) {}
                // Play pickup power-up sound on ability acquisition
                try { playPowerupSfx(); } catch(_) {}
                showAbilityTooltip(newAbility);
                const abilityData = ABILITIES[newAbility];
                if (abilityData && abilityData.effect && abilityData.effect.maxHealthBonus) {
                    game.player.maxHealth += abilityData.effect.maxHealthBonus;
                    game.player.health += abilityData.effect.maxHealthBonus;
                }
                updateUI();
                addScreenShake(3);
            }
        }

        function checkRoomComplete() {
            // Grace guard: ignore empty enemy list for a few frames right after a restart to prevent false 'Street Cleared'.
            if (game._restartGraceFrames && game._restartGraceFrames > 0) {
                game._restartGraceFrames--;
                return;
            }
            if (!game.roomCleared && game.enemies.length === 0 && (game._roomSpawnedEnemies||0) > 0) {
                game.roomCleared = true;
                game._roomClearedAt = performance.now();
                game._roomAdvancePrev = false;
                game._roomAdvanceArm = false;
                game.roomsCleared++;
                game.score += 50 * game.dungeon;
                
                // Room clear effect
                for (let i = 0; i < 10; i++) {
                    addParticle(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        '#00FF00',
                        'spark'
                    );
                }
                
                updateUI();
            }
        }

        function nextRoom() {
            game.room++;
            
            if (game.room > 5) {
                game.dungeon++;
                game.room = 1;
                // New district: reset chest counter
                game.chestsThisCycle = 0;
                
                if (game.dungeon > 10) {
                    completeGame();
                    return;
                }
            }
            
            // Defensive: clear any transient Duck Dynasty visuals when moving rooms
            if (Array.isArray(game.duckFlocks)) game.duckFlocks.length = 0;
            game.nextDuckFlockFrame = 0;
            // Clear active SoA projectiles to avoid carry-over between rooms
            if (typeof game.resetProjectilePool === 'function') game.resetProjectilePool();
            generateRoom();
            updateUI();
        }

        function completeGame() {
            // Victory screen
            // Prevent multiple invocations (some pathways may call completeGame or offerPermanentAbilityChoice twice)
            if (game._victorySequenceShown) return; // hard guard
            game._victorySequenceShown = true;
            const overlay = document.createElement('div');
            overlay.id = 'endingOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(circle, rgba(0,255,0,0.2), rgba(0,0,0,0.9));
                display: flex; flex-direction: column; justify-content: center; align-items: center;
                color: white; font-family: 'Courier New', monospace; z-index: 1000;
                animation: fadeIn 1s ease-in;
            `;
            
            overlay.innerHTML = `
                <h1 style="color: #00FF00; font-size: 48px; text-shadow: 0 0 20px #00FF0088; margin-bottom: 20px;">
                    VICTORY!
                </h1>
                <h2 style="color: #FFFF00; margin-bottom: 30px;">
                    All Districts Cleared!
                </h2>
                <div style="background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center;">
                    <p><strong>Final Score:</strong> ${game.score.toLocaleString()}</p>
                    <p><strong>Total Kills:</strong> ${game.totalKills}</p>
                    <p><strong>Streets Cleared:</strong> ${game.roomsCleared}</p>
                    <p><strong>Chests Opened:</strong> ${game.chestsOpened}</p>
                    <button onclick="this.parentElement.parentElement.remove(); (window.game&&Array.isArray(window.game.duckFlocks))&&(window.game.duckFlocks.length=0); if (window.game) window.game.nextDuckFlockFrame=0; resetGame();" 
                            style="margin-top: 20px; padding: 10px 20px; font-size: 16px; 
                                   background: #333; color: white; border: 2px solid #666; 
                                   border-radius: 5px; cursor: pointer;">
                        Play Again
                    </button>
                </div>
`;
            // Only offer permanent ability if not already done (flagged elsewhere via Space key path)
            if (!game._finalAbilityOffered) {
                offerPermanentAbilityChoice();
                game._finalAbilityOffered = true;
            }
            
            
            // Add fadeIn animation
            const style = document.createElement('style');
            style.textContent = '@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }';
            document.head.appendChild(style);
            
            document.body.appendChild(overlay);
        }

        function resetGame(opts) {
            const options = opts || {};
            const suppressMusic = !!options.suppressMusic;
            const skipRoomInit = !!options.skipRoomInit;
                    // Preserve existing sprite sheet/meta before wiping player object so we don't lose load state
                    const prevSheet = game.player && game.player.spriteSheet;
                    const prevMeta = game.player && game.player.spriteMeta;
                    const prevFrames = game.player && game.player.directionalFrames;
                    const prevScale = game.player && game.player.spriteScale;
                    const prevLoaded = game.player && game.player.spriteLoaded;
                    const prevWalkFrames = game.player && game.player.walkFrames;
                    const prevWalkSheet = game.player && game.player.walkSheet;
                    const prevIdleImage = game.player && game.player.idleImage;
                    // Restore appropriate gameplay music if coming from boss/ending sequences
                    try {
                        if (game.bgMusic) { try { game.bgMusic.pause(); } catch(e) {} }
                        if (!suppressMusic) {
                            // Choose music based on selected act (persisted via saveSelectedAct/loadSelectedAct)
                            try {
                                if (game && game._selectedAct && String(game._selectedAct) === 'III') {
                                    // Preserve Act III music when restarting from Act III
                                    game.bgMusic = new Audio('assets/audio/MetalHeartsCollide.mp3');
                                    try { game._actMusicSet = true; } catch(_){ }
                                } else if (game && game._selectedAct && String(game._selectedAct) === 'II') {
                                    game.bgMusic = new Audio('assets/audio/GooseGhetto.mp3');
                                    try { game._actMusicSet = true; } catch(_){ }
                                } else {
                                    game.bgMusic = new Audio('assets/audio/QuackshotChronicles.mp3');
                                    try { game._actMusicSet = false; } catch(_){ }
                                }
                            } catch(_) {
                                game.bgMusic = new Audio('assets/audio/QuackshotChronicles.mp3');
                                try { game._actMusicSet = false; } catch(_){ }
                            }
                            if (game.bgMusic) {
                                game.bgMusic.loop = true;
                                applyMusicPreference();
                                try { if (game.musicEnabled) game.bgMusic.play().catch(()=>{}); } catch(_){ }
                            }
                        } else {
                            try { if (game.bgMusic) { game.bgMusic.currentTime = 0; } } catch(_){ }
                            try { game._actMusicSet = false; } catch(_){ }
                        }
                        game._bossMusicPlaying = false;
                    } catch(e) {}
                        game._bigQuackDefeated = false;
                    game._quackenToastShownRun = false;
                    game._finalAbilityOffered = false;
                    game._victorySequenceShown = false; // reset victory guard
                    // Do NOT clear unlocked Acts here — resetting progress should only occur via the explicit
                    // user-facing Reset Progress option which already removes the persistent keys.
                    // (Preserve `game._actIIUnlocked` / `game._actIIIUnlocked` on Play Again.)
            game.player = {
                x: 320, y: 240, health: 100, maxHealth: 100,
                abilities: [], permanentAbilities: [],
                facing: 'down',
                lastDirection: { x: 0, y: 1 },
                invulnerable: false, invulnTime: 0,
                speed: 2.5,
                // Terrifying Aura tracking
                killCount: 0,
                auraActive: false,
                // Removed level-based fields: auraActivatedLevel, auraExpireLevel
                auraExpireRoom: 0,
                auraKillCounter: 0, // explicit counter separate from totalKills if used for 25 threshold UI
                // Rendering / visibility control fields reset
                blinkTimer: 0,
                wasHitTimer: 0,
                directionalFrames: prevFrames || null,
                spriteScale: prevScale || null,
                spriteSheet: prevSheet || prevWalkSheet || null,
                spriteMeta: prevMeta || { rows: 2, cols: 8, frameWidth: 256, frameHeight: 266, totalFrames: 9, order: ['right'] },
                spriteLoaded: prevLoaded || (prevSheet ? prevSheet.complete : false),
                walkFrames: prevWalkFrames || null,
                walkSheet: prevWalkSheet || prevSheet || null,
                idleImage: prevIdleImage || null
            };

            try { game._seenAbilitiesLoaded = false; } catch(_){ }

            // Load persisted seen-abilities map (merge into newly created player object)
            try { if (typeof loadSeenAbilities === 'function') loadSeenAbilities(); } catch(_) {}

            // If sprite sheet was lost (first ever reset before load code ran), reinitialize it similar to startup
            if (!game.player.walkSheet) {
                game.player.walkSheet = new Image();
                game.player.walkSheet.onload = () => {
                    applyWalkFrames(game.player.walkSheet);
                    rebuildPlayerSprite();
                };
                game.player.walkSheet.onerror = (err) => { console.warn('[Reset] player walk sheet load failed', err); };
                game.player.walkSheet.src = 'assets/playerwalk-sheet.png';
            }
            if (!game.player.idleImage) {
                game.player.idleImage = new Image();
                game.player.idleImage.onload = () => {
                    applyIdleFrame(game.player.idleImage);
                    rebuildPlayerSprite();
                };
                game.player.idleImage.onerror = (err) => { console.warn('[Reset] player idle sprite load failed', err); };
                game.player.idleImage.src = 'assets/player-side.png';
            }
            if (!game.player.spriteSheet && game.player.walkSheet) {
                game.player.spriteSheet = game.player.walkSheet;
            }
            if (game.player.walkSheet && game.player.walkSheet.complete) {
                applyWalkFrames(game.player.walkSheet);
            }
            if (game.player.idleImage && game.player.idleImage.complete) {
                applyIdleFrame(game.player.idleImage);
            }

            // --- Permanent Ability Integration ---
            loadPermanentAbilities();
            grantPermanentAbilities();

            game.dungeon = 1;
            game.room = 1;
            game.score = 0;
            game.shotCounter = 0;
            game.chestsThisCycle = 0;
            game.totalKills = 0;
            game.roomsCleared = 0;
            game.chestsOpened = 0;
            game.paused = false;

            // Clear any lingering Terrifying Aura UI text / prompts (defensive)
            const auraNotice = document.getElementById('auraNotice');
            if (auraNotice) auraNotice.remove();
            if (game.player) {
                game.player.auraActive = false;
                // auraExpireLevel removed
                game.player.auraExpireRoom = 0;
                game.player.auraKillCounter = 0;
            }

            // Hide pause menu if open (fix: check if element exists)
            var pauseOverlay = document.getElementById('pauseOverlay');
            if (pauseOverlay) {
                pauseOverlay.style.display = 'none';
            }

            // Hard purge of any lingering entities from previous run (defensive in case a reference was kept elsewhere)
            game.enemies = [];
            game.projectiles = [];
            game.particles = [];
            game.chests = [];
            game.pickups = [];
            game.traps = [];
            game.pits = [];
            game.nukes = [];
            game.poisonClouds = [];
            game.shockwaves = [];
            game.vortexFields = [];
            game.lightningArcs = [];
            game.acidPools = [];
            game.duckFlocks = []; // clear any lingering Duck Dynasty flock sprites stuck after victory
            game.nextDuckFlockFrame = 0; // reset scheduling so first flock re-times correctly
            // Restart grace: suppress premature room clear until enemies have visibly spawned
            game._restartGraceFrames = 30; // ~0.5s at 60fps
            game._roomSpawnedEnemies = 0;
            // Rebuild & force visibility (will also set spriteLoaded true)
            if (typeof rebuildPlayerSprite === 'function') {
                rebuildPlayerSprite();
            } else if (typeof window !== 'undefined' && typeof window.rebuildPlayerSprite === 'function') {
                window.rebuildPlayerSprite();
            } else {
                console.warn('[Reset] rebuildPlayerSprite unavailable at call time');
            }
            // If for any reason directionalFrames not established, mark for early retry
            if (!game.player.directionalFrames) {
                game.player._pendingSpriteRetry = 6; // attempt for first 6 frames
            }
            game.player.spriteLoaded = true; // hard assert loaded since sheet persisted
            game.player.forceVisibleFrames = 90; // extend a bit longer (1.5s) to visually confirm

            // Ensure no lingering pause or overlays hide player
            game.gameOver = false;
            game.paused = false;
            game._bigQuackDefeated = false; // already set above, reinforce

            // Ensure all projectiles and metadata are cleared before starting a new run
            if (typeof game.resetProjectilePool === 'function') game.resetProjectilePool();
            if (!skipRoomInit) {
                generateRoom();
                updateUI();
            } else {
                try { updateUI(); } catch(_){ }
            }
        }

        // (Removed floating Reset Progress button; now in Pause -> Options)

        function addParticle(x, y, color, type) {
            // Cosmetic gating: suppress low-priority particle categories if potato mode is on.
            const cosmeticTypes = { spark:1, ambient:1, lightning:1, heal:1, shield:1, damage:1, treasure:1, swirl:1, dust:1 };
            if ((game.potatoMode || game.disableCosmeticParticles) && cosmeticTypes[type]) return;
            // Probabilistic suppression in low FX mode (only for cosmetic types)
            if (game.perf && game.perf.lowFx && cosmeticTypes[type]) {
                if (Math.random() < 0.55) return;
            }
            if (!game.particles) game.particles = [];
            const cap = (game.potatoMode ? 600 : ((game.perf && game.perf.lowFx) ? 1200 : 2500));
            if (game.particles.length >= cap) return;
            const particle = {
                x: x + (Math.random() - 0.5) * 10,
                y: y + (Math.random() - 0.5) * 10,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: (game.perf && game.perf.lowFx ? 22 : 30) + Math.random() * (game.perf && game.perf.lowFx ? 14 : 20),
                maxLife: (game.perf && game.perf.lowFx) ? 38 : 50,
                color: color,
                type: type,
                alpha: 1
            };
            
            // Type-specific properties
            switch (type) {
                case 'explosion':
                    particle.vx *= 2;
                    particle.vy *= 2;
                    particle.life = 20;
                    break;
                case 'fire':
                    particle.vy -= 1;
                    break;
                case 'heal':
                    particle.vy -= 2;
                    particle.vx = 0;
                    break;
                case 'treasure':
                    particle.vy -= 1.5;
                    particle.life = 60;
                    break;
            }
            
            game.particles.push(particle);
        }

        // Feather poof helper (re-added / ensured). Creates an initial bright burst and spawns drifting feather particles.
        function spawnFeatherPoof(enemy) {
            if (!enemy || !game || !game.particles) return;
            const size = enemy.size || 20;
            const scaleFactor = size / 20;
            const burstCount = Math.min(40, Math.floor(18 * scaleFactor));
            // Bright radial flash (quick fade) using featherSingle for a few for variety
            for (let i=0;i<burstCount;i++) {
                const ang = Math.random()*Math.PI*2;
                const dist = Math.random()* (6 + size*0.15);
                const px = enemy.x + Math.cos(ang)*dist;
                const py = enemy.y + Math.sin(ang)*dist;
                if (i < burstCount * 0.25) {
                    addParticle(px, py, '#ffffff', 'featherSingle');
                } else {
                    addParticle(px, py, '#ffffff', 'spark');
                }
            }
            // Drifting long-lived feathers
            const featherCount = Math.min(80, Math.floor(22 * scaleFactor));
            for (let f=0; f<featherCount; f++) {
                const ang = Math.random()*Math.PI*2;
                const sp = (Math.random()*1.8 + 0.6) * (0.8 + scaleFactor*0.2);
                const vx = Math.cos(ang)*sp;
                const vy = Math.sin(ang)*sp - (Math.random()*1.1 + 0.3);
                const life = 60 + Math.random()*70;
                const feather = {
                    x: enemy.x + (Math.random()-0.5)*size*0.4,
                    y: enemy.y + (Math.random()-0.5)*size*0.4,
                    vx, vy,
                    gravity: 0.055 + Math.random()*0.045,
                    life,
                    maxLife: life,
                    color: '#ffffff',
                    type: 'feather',
                    alpha: 1,
                    spin: Math.random()*Math.PI*2,
                    spinSpeed: (Math.random()*0.22 - 0.11),
                    scale: 0.45 + Math.random()*0.85 * (0.85 + scaleFactor*0.25),
                    drift: (Math.random()*0.5 - 0.25)
                };
                game.particles.push(feather);
            }
        }

        function addAmbientParticles() {
            // Skip ambient emissions entirely if cosmetic FX disabled
            if (game.disableCosmeticParticles) return;
            // Add some ambient city particles
            if (Math.random() < 0.3) {
                addParticle(
                    Math.random() * canvas.width,
                    canvas.height + 10,
                    '#666666',
                    'ambient'
                );
            }
        }

        // --- Minimal Attack SFX (WebAudio) ---
        let _atkAudioCtx = null;
        let _atkCompressor = null;
        let _atkLast = 0;
        function _ensureAtkAudio() {
            if (_atkAudioCtx) return;
            try {
                _atkAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                _atkCompressor = _atkAudioCtx.createDynamicsCompressor();
                _atkCompressor.threshold.setValueAtTime(-28, _atkAudioCtx.currentTime);
                _atkCompressor.knee.setValueAtTime(18, _atkAudioCtx.currentTime);
                _atkCompressor.ratio.setValueAtTime(8, _atkAudioCtx.currentTime);
                _atkCompressor.attack.setValueAtTime(0.003, _atkAudioCtx.currentTime);
                _atkCompressor.release.setValueAtTime(0.08, _atkAudioCtx.currentTime);
                _atkCompressor.connect(_atkAudioCtx.destination);
            } catch(e) { /* audio blocked */ }
        }
        function playAttackSfx() {
            if (!game.sfxEnabled) return;
            const nowMs = performance.now();
            const MIN_INTERVAL = 45; // allow slightly faster cadence for automatic fire, still limited
            if (nowMs - _atkLast < MIN_INTERVAL) return;
            _atkLast = nowMs;
            _ensureAtkAudio(); if (!_atkAudioCtx) return;
            const t = _atkAudioCtx.currentTime;
            // Lower-pitched redesign:
            // Layer 1: Core body (sawtooth with short decay, mid-low frequency sweep)
            const bodyOsc = _atkAudioCtx.createOscillator();
            const bodyGain = _atkAudioCtx.createGain();
            const bodyStart = 620 + Math.random()*80; // previously ~1800, now much lower
            const bodyEnd = bodyStart * 0.55;
            bodyOsc.type = 'sawtooth';
            bodyOsc.frequency.setValueAtTime(bodyStart, t);
            bodyOsc.frequency.exponentialRampToValueAtTime(bodyEnd, t + 0.09);
            bodyGain.gain.setValueAtTime(0.0001, t);
            bodyGain.gain.linearRampToValueAtTime(0.34, t + 0.004);
            bodyGain.gain.exponentialRampToValueAtTime(0.0005, t + 0.16);

            // Layer 2: Wider noise burst (lower bandpass center)
            const noiseBuffer = _atkAudioCtx.createBuffer(1, 4410, 44100);
            const data = noiseBuffer.getChannelData(0);
            for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
            const noiseSrc = _atkAudioCtx.createBufferSource(); noiseSrc.buffer = noiseBuffer;
            const bp = _atkAudioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.setValueAtTime(900, t); bp.Q.value = 2.2;
            const noiseGain = _atkAudioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.42, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.0005, t + 0.18);

            // Layer 3: Deep thump (even lower fundamental)
            const thumpOsc = _atkAudioCtx.createOscillator(); thumpOsc.type='sine';
            const thumpGain = _atkAudioCtx.createGain();
            const thumpFreq = 90 + Math.random()*15; // was ~140
            thumpOsc.frequency.setValueAtTime(thumpFreq, t);
            thumpOsc.frequency.exponentialRampToValueAtTime(thumpFreq * 0.65, t + 0.12);
            thumpGain.gain.setValueAtTime(0.0001, t);
            thumpGain.gain.linearRampToValueAtTime(0.28, t + 0.006);
            thumpGain.gain.exponentialRampToValueAtTime(0.0004, t + 0.20);

            // Sub emphasis (short sine burst one octave below thump)
            const subOsc = _atkAudioCtx.createOscillator(); subOsc.type='sine';
            const subGain = _atkAudioCtx.createGain();
            subOsc.frequency.setValueAtTime(thumpFreq/2, t);
            subGain.gain.setValueAtTime(0.0001, t);
            subGain.gain.linearRampToValueAtTime(0.18, t + 0.008);
            subGain.gain.exponentialRampToValueAtTime(0.0003, t + 0.17);

            // Master filters shifted lower
            const hp = _atkAudioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(140, t);
            const lp = _atkAudioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.setValueAtTime(3800, t);

            bodyOsc.connect(bodyGain);
            noiseSrc.connect(bp); bp.connect(noiseGain);
            thumpOsc.connect(thumpGain);
            subOsc.connect(subGain);
            const merger = _atkAudioCtx.createGain();
            bodyGain.connect(merger); noiseGain.connect(merger); thumpGain.connect(merger); subGain.connect(merger);
            merger.connect(hp); hp.connect(lp); lp.connect(_atkCompressor || _atkAudioCtx.destination);

            bodyOsc.start(t); bodyOsc.stop(t + 0.18);
            thumpOsc.start(t); thumpOsc.stop(t + 0.22);
            subOsc.start(t); subOsc.stop(t + 0.20);
            noiseSrc.start(t); noiseSrc.stop(t + 0.20);
        }

        function addScreenShake(intensity) {
            game.screenShake = Math.max(game.screenShake, intensity);
            game.screenShakeIntensity = intensity;
        }

        // Helper: attempt to derive an alternate URL for wunderswan asset when resolution fails
        function tryAlternateWunderswanUrl(src) {
            try {
                if (!src) return src;
                // If the URL contains an incorrectly encoded '%', attempt to re-encode the components
                try {
                    const u = new URL(src, document.baseURI);
                    // If path includes '%', try decoding then re-encoding properly
                    if (u.pathname && u.pathname.includes('%')) {
                        const decoded = decodeURIComponent(u.pathname);
                        const reencoded = decoded.split('/').map(encodeURIComponent).join('/');
                        u.pathname = reencoded;
                        return u.href;
                    }
                } catch(_) {}
                // Fallback strategies: replace spaces with %20 or vice-versa
                if (src.includes('%20')) return src.replace(/%20/g, ' ');
                if (src.includes(' ')) return src.replace(/ /g, '%20');
                // Do not substitute unrelated assets as a last-resort (was mapping everything
                // to the Wunderswan asset). That caused unintended sprite swaps (e.g. golden
                // goose -> wunderswan). Safer behavior: return the original src unchanged.
                return src;
            } catch(_) { return src; }
        }

        // Transient effects: small, short-lived visuals like ring flashes or hit blips
        function addTransientEffect(eff) {
            // Hard skip non-essential transient FX in Potato Mode
            if (game && game.potatoMode) return;
            if (!game.transientEffects) game.transientEffects = [];
            const now = performance.now();
            const life = eff.life || 180; // ms
            game.transientEffects.push({
                type: eff.type || 'ringFlash',
                x: eff.x, y: eff.y,
                color: eff.color || '#FFFFFF',
                radius: eff.radius || 24,
                created: now,
                life,
                seed: Math.random()*Math.PI*2
            });
        }

        function render() {
            if (game && game._returningToTitle) {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                return;
            }
            // Handle screen shake
            let shakeX = 0, shakeY = 0;
            if (game.screenShake > 0) {
                shakeX = (Math.random() - 0.5) * game.screenShakeIntensity;
                shakeY = (Math.random() - 0.5) * game.screenShakeIntensity;
            }
            // Auto-enable reality break overlay briefly when flagged
            if (game.settings && game.settings._rbAutoOverlay) {
                game.settings.realityBreakOverlay = true;
                game.settings._rbAutoOverlay--;
            } else if (game.settings && !game.realityBreakDistort) {
                // If no effect pending, release forced overlay
                game.settings._rbAutoOverlay = 0;
            }
            
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // (debug HUD moved to top-most layer to avoid being overdrawn)
            
            // Background: prefer image from assets/streets; during fade-in, draw fallback underneath
            const W = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
            const H = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || canvas.height;
            let drewImage = false;
            let needFallback = true;
            let b = window._streetBackgrounds;
            if (b && b.ready && b.img) {
                const img = b.img;
                const iw = (img.naturalWidth != null ? img.naturalWidth : img.width) || 0;
                const ih = (img.naturalHeight != null ? img.naturalHeight : img.height) || 0;
                if (iw > 0 && ih > 0) {
                // Determine scale and destination rect based on fit mode
                let fitMode = 'fitWidth';
                if (b.fit === 'contain' || b.fit === 'cover' || b.fit === 'fitWidth') fitMode = b.fit;
                let scale;
                if (fitMode === 'contain') {
                    scale = Math.min(W / iw, H / ih);
                } else if (fitMode === 'cover') {
                    scale = Math.max(W / iw, H / ih);
                } else { // fitWidth
                    scale = W / iw; // always match canvas width
                }
                scale *= (typeof b.zoom === 'number' ? Math.max(0.1, b.zoom) : 1.0);
                const dw = iw * scale, dh = ih * scale;
                // Center horizontally by construction; vertically center-crop if taller than canvas
                const dx = (W - dw) * 0.5;
                let dy = (H - dh) * 0.5;
                if (typeof b.alpha !== 'number') b.alpha = 1.0; // default to immediate if not set
                // If still fading, we keep fallback visible underneath
                needFallback = b.alpha < 1.0;
                ctx.save();
                const prevA = ctx.globalAlpha;
                ctx.globalAlpha = prevA * Math.max(0, Math.min(1, b.alpha));
                ctx.imageSmoothingEnabled = true;
                // When in fitWidth, ensure left/right are flush; if height exceeds, cropping will naturally happen by canvas boundary.
                ctx.drawImage(img, dx, dy, dw, dh);
                ctx.globalAlpha = prevA;
                ctx.restore();
                drewImage = true;
                if (b.alpha < 1.0) b.alpha = Math.min(1.0, b.alpha + 0.06);
                }
            }
            if (!drewImage || needFallback) {
                // Fallback/base: theme gradient fill
                const theme = game.currentTheme;
                const gcols = (theme && theme.gradient) || ['#1a1a2e','#16213e'];
                const gradient = ctx.createLinearGradient(0, 0, 0, H);
                if (gcols.length === 1) { gradient.addColorStop(0, gcols[0]); gradient.addColorStop(1, gcols[0]); }
                else if (gcols.length === 2) { gradient.addColorStop(0, gcols[0]); gradient.addColorStop(1, gcols[1]); }
                else { for (let i=0;i<gcols.length;i++) gradient.addColorStop(i/(gcols.length-1), gcols[i]); }
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, W, H);
                // Center line only when no image or during fade
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 3;
                ctx.setLineDash([15, 15]);
                ctx.beginPath();
                ctx.moveTo(0, H / 2);
                ctx.lineTo(W, H / 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw walls (restored original manual drawing)
            game.walls.forEach(wall => {
                ctx.save();
                switch (wall.type) {
                    case 'building':
                        ctx.fillStyle = '#404040';
                        ctx.fillRect(wall.x, wall.y, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(wall.x + 2, wall.y + 2, TILE_SIZE - 4, 4);
                        ctx.fillStyle = '#ffff88';
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 2; j++) {
                                if (Math.random() < 0.7) {
                                    ctx.fillRect(wall.x + 4 + i * 8, wall.y + 8 + j * 8, 4, 4);
                                }
                            }
                        }
                        break;
                    case 'car': {
                        const imgH = window._carObstacleImages && window._carObstacleImages.h;
                        const imgV = window._carObstacleImages && window._carObstacleImages.v;
                        // Use multi-tile footprint if provided (added during generation)
                        const w = wall.width || TILE_SIZE;
                        const h = wall.height || TILE_SIZE;
                        const x = wall.x, y = wall.y;
                        const vertical = wall.orientation === 'vertical';
                        const img = vertical ? imgV : imgH;
                        // Placeholder if image not yet ready / broken
                        if (!img || img._broken || !img.complete || !img.naturalWidth) {
                            ctx.fillStyle = '#444';
                            ctx.fillRect(x, y, w, h);
                            ctx.fillStyle = '#777';
                            ctx.fillRect(x + w*0.08, y + h*0.08, w*0.84, h*0.84);
                            if (wall.flashTimer > 0) {
                                ctx.fillStyle = 'rgba(255,255,255,' + (0.5 * (wall.flashTimer/10)).toFixed(2) + ')';
                                ctx.fillRect(x, y, w, h);
                            }
                            break;
                        }
                        ctx.imageSmoothingEnabled = true;
                        // Ensure per-car brightness adjustment exists; defaults aim to increase readability
                        if (wall.brightness == null) wall.brightness = 1.20;
                        // Draw shadow first (simple soft ellipse under car footprint)
                        const shadowInset = Math.min(w,h) * 0.05;
                        const shadowCX = x + w/2;
                        const shadowCY = y + h*0.92;
                        const shadowRX = w/2 - shadowInset;
                        const shadowRY = Math.min(h*0.18, h/2 - shadowInset);
                        ctx.save();
                        ctx.fillStyle = 'rgba(0,0,0,0.28)';
                        ctx.beginPath();
                        ctx.ellipse(shadowCX, shadowCY, shadowRX, shadowRY, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                        // Draw car image with readability boosts via canvas filter
                        const effBright = 1.45; // fixed brightness matches generation
                        ctx.save();
                        try { ctx.filter = `brightness(${effBright})`; } catch(_) {}
                        ctx.drawImage(img, x, y, w, h);
                        ctx.restore();
                        // No color overlays or screen fills to avoid visible transparent backgrounds; rely on brightness filter only
                        // Flash overlay (e.g., future explosions, collisions)
                        if (wall.flashTimer > 0) {
                            ctx.fillStyle = 'rgba(255,255,255,' + (0.55 * (wall.flashTimer/10)).toFixed(2) + ')';
                            ctx.fillRect(x, y, w, h);
                        }
                        break;
                    }
                    case 'dumpster': {
                        const tileW = wall.width || TILE_SIZE;
                        const tileH = wall.height || TILE_SIZE;
                        const spr = window._dumpsterSprite;
                        const img = spr && spr.image;
                        const frames = spr && spr.frames;
                        if (!img || img._broken || !img.complete || !img.naturalWidth || !frames || frames.length === 0) {
                            // Fallback: simple colored box if sprite not ready
                            ctx.fillStyle = '#2f522f';
                            ctx.fillRect(wall.x, wall.y, tileW, tileH);
                            break;
                        }
                        // Compute destination rect via shared helper so collisions match visuals
                        const rect = window.getDumpsterSpriteRect(wall);
                        // Determine current frame to sample from
                        const fps = spr.fps || 6;
                        const step = Math.max(1, Math.round(60 / fps));
                        const frameIdx = Math.floor(((game.frame||0) / step)) % frames.length;
                        const f = frames[frameIdx];
                        ctx.drawImage(img, f.x, f.y, f.w, f.h, rect.x, rect.y, rect.w, rect.h);
                        break;
                    }
                    case 'streetlight': {
                        const x = wall.x, y = wall.y, w = TILE_SIZE, h = TILE_SIZE;
                        const poleX = x + w*0.45;
                        // Pole
                        ctx.fillStyle = '#7a7a7a';
                        ctx.fillRect(poleX, y - h*0.30, w*0.10, h*1.30);
                        // Base
                        ctx.fillStyle = '#575757';
                        ctx.fillRect(poleX - w*0.10, y + h*0.95, w*0.30, h*0.08);
                        // Arm
                        ctx.fillStyle = '#6c6c6c';
                        ctx.fillRect(poleX + w*0.05, y - h*0.18, w*0.40, h*0.06);
                        // Lamp head
                        const lampX = poleX + w*0.42;
                        const lampY = y - h*0.18 + h*0.03;
                        ctx.fillStyle = '#444';
                        ctx.fillRect(lampX, lampY, w*0.24, h*0.14);
                        // Bulb + glow cone
                        ctx.fillStyle = '#ffec66';
                        ctx.fillRect(lampX + w*0.04, lampY + h*0.02, w*0.16, h*0.10);
                        // Light cone (semi-transparent)
                        const coneGradient = ctx.createLinearGradient(lampX, lampY + h*0.14, lampX, lampY + h*0.80);
                        coneGradient.addColorStop(0, 'rgba(255,236,102,0.45)');
                        coneGradient.addColorStop(1, 'rgba(255,236,102,0)');
                        ctx.fillStyle = coneGradient;
                        ctx.beginPath();
                        ctx.moveTo(lampX - w*0.05, lampY + h*0.14);
                        ctx.lineTo(lampX + w*0.29, lampY + h*0.14);
                        ctx.lineTo(lampX + w*0.18, lampY + h*0.90);
                        ctx.lineTo(lampX + w*0.06, lampY + h*0.90);
                        ctx.closePath();
                        ctx.fill();
                        // Subtle radial glow around bulb
                        const rg = ctx.createRadialGradient(lampX + w*0.12, lampY + h*0.07, 2, lampX + w*0.12, lampY + h*0.07, 18);
                        rg.addColorStop(0, 'rgba(255,236,102,0.6)');
                        rg.addColorStop(1, 'rgba(255,236,102,0)');
                        ctx.fillStyle = rg;
                        ctx.beginPath();
                        ctx.arc(lampX + w*0.12, lampY + h*0.07, 18, 0, Math.PI*2);
                        ctx.fill();
                        // Outline pole
                        ctx.strokeStyle = '#444';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(poleX, y - h*0.30, w*0.10, h*1.30);
                        break;
                    }
                    case 'barrier': {
                        const x = wall.x, y = wall.y;
                        const w = wall.width || TILE_SIZE;
                        const h = wall.height || TILE_SIZE;
                        const img = window._barrierImage;
                        // When available, draw sprite scaled to the obstacle footprint
                        if (img && !img._broken && img.complete && img.naturalWidth) {
                            // Optional: subtle drop shadow
                            ctx.save();
                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = '#000';
                            ctx.fillRect(x + 2, y + h - Math.max(4, Math.round(h*0.08)), w - 4, Math.max(3, Math.round(h*0.06)));
                            ctx.restore();
                            ctx.drawImage(img, x, y, w, h);
                        } else {
                            // Fallback: original procedural barrier if image missing
                            const W = TILE_SIZE, H = TILE_SIZE;
                            const bx = wall.x, by = wall.y;
                            // Support posts
                            ctx.fillStyle = '#5e5e5e';
                            ctx.fillRect(bx + W*0.08, by + H*0.10, W*0.12, H*0.70);
                            ctx.fillRect(bx + W*0.80, by + H*0.10, W*0.12, H*0.70);
                            // Feet
                            ctx.fillStyle = '#444';
                            ctx.fillRect(bx + W*0.02, by + H*0.78, W*0.24, H*0.10);
                            ctx.fillRect(bx + W*0.74, by + H*0.78, W*0.24, H*0.10);
                            // Panel background
                            const panelY = by + H*0.18;
                            const panelH = H*0.42;
                            ctx.fillStyle = '#d8d8d8';
                            ctx.fillRect(bx + W*0.12, panelY, W*0.76, panelH);
                            // Diagonal stripes
                            const stripeW = W*0.10;
                            for (let sx = bx + W*0.10; sx < bx + W*0.90 + stripeW; sx += stripeW*1.3) {
                                ctx.fillStyle = '#ff3b30';
                                ctx.beginPath();
                                ctx.moveTo(sx, panelY);
                                ctx.lineTo(sx + stripeW, panelY);
                                ctx.lineTo(sx + stripeW - panelH, panelY + panelH);
                                ctx.lineTo(sx - panelH, panelY + panelH);
                                ctx.closePath();
                                ctx.fill();
                            }
                            // Reflectors (top row small circles)
                            ctx.fillStyle = '#fffb9a';
                            for (let i=0;i<3;i++) {
                                ctx.beginPath();
                                ctx.arc(bx + W*0.24 + i*W*0.20, panelY + panelH*0.18, W*0.04, 0, Math.PI*2);
                                ctx.fill();
                            }
                            // Shadow at base
                            ctx.fillStyle = 'rgba(0,0,0,0.25)';
                            ctx.fillRect(bx + W*0.08, by + H*0.88, W*0.84, H*0.06);
                            // Outline panel
                            ctx.strokeStyle = '#6a6a6a';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(bx + W*0.12 + 0.5, panelY + 0.5, W*0.76 - 1, panelH - 1);
                        }
                        break;
                    }
                }
                ctx.restore();
            });

            // Render projectiles via SoA optimized renderer
            // Draw any one-frame beam overlays first so a beam spawns visible immediately
            try {
                if (game._oneFrameBeamOverlays && game._oneFrameBeamOverlays.length) {
                    const nowf = performance.now();
                    game._oneFrameBeamOverlays.forEach(b => {
                        try {
                            // draw a short beam using same visuals as beam renderer but based on simple params
                            const px = b.x || 0, py = b.y || 0; const vx = b.vx || 0, vy = b.vy || 1;
                            const sp = Math.hypot(vx, vy) || 0.0001; const fx = vx / sp, fy = vy / sp;
                            const len = 56; const core = Math.max(4, 8);
                            ctx.save(); ctx.translate(px, py); ctx.rotate(Math.atan2(fy, fx));
                            ctx.fillStyle = '#FF2A2A'; ctx.fillRect(0, -core*0.5, len, core);
                            ctx.restore();
                        } catch(_){}
                    });
                }
            } catch(_) {}
            // Clear overlays (one-frame only)
            try { if (game._oneFrameBeamOverlays) game._oneFrameBeamOverlays.length = 0; } catch(_) {}
            if (game.renderProjectilesSoA) game.renderProjectilesSoA(ctx);

            // Tanks Alot: lingering fire fields (beneath enemies/projectiles overlays for readability)
            if (Array.isArray(game.truckFires) && game.truckFires.length) {
                const nowTA = Date.now();
                game.truckFires.forEach(f => {
                    const age = nowTA - f.created;
                    const life = Math.max(0, 1 - age / f.duration);
                    const r = f.radius * (0.95 + Math.sin(nowTA/300 + f.x*0.02)*0.05);
                    // Soft orange-red glow under sprite
                    const g = ctx.createRadialGradient(f.x, f.y, r*0.2, f.x, f.y, r);
                    g.addColorStop(0, `rgba(255,220,120,${(0.30*life).toFixed(3)})`);
                    g.addColorStop(0.6, `rgba(255,120,40,${(0.22*life).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(255,60,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(f.x, f.y, r, 0, Math.PI*2); ctx.fill();
                    // Draw looping truck2.png sprite frames above the glow
                    const spr = window._truckSprite || {};
                    const fireImg = spr.fire;
                    const fireFrames = spr.frames && spr.frames.fire;
                    if (fireImg && fireImg.complete && !fireImg._broken && fireFrames && fireFrames.length) {
                        const fps = 6; // loop speed
                        const step = Math.max(1, Math.round(60 / fps));
                        const frameIdx = Math.floor(((game.frame||0) / step)) % fireFrames.length;
                        const src = fireFrames[frameIdx];
                        const scale = 1.0 * (r * 0.012 + 0.9); // scale loosely tied to radius; tweakable
                        const drawW = src.w * (64 / src.h) * scale * 2.2; // derive width from target height ratio
                        const drawH = 64 * scale * 2.2;
                        const yOffset = -12; // nudge upward for better alignment with truck
                        ctx.drawImage(fireImg, src.x, src.y, src.w, src.h, f.x - drawW/2, f.y - drawH/2 + yOffset, drawW, drawH);
                    }
                });
            }

            // Acid pools rendering (beneath enemies/projectiles)
            if (Array.isArray(game.acidPools) && game.acidPools.length) {
                const nowA = Date.now();
                game.acidPools.forEach(p => {
                    const age = nowA - p.created; const life = 1 - Math.min(1, age / p.duration);
                    const r = p.r * (0.98 + Math.sin(nowA/320 + p.x*0.01 + p.y*0.01)*0.02);
                    // Base toxic green pool
                    const g = ctx.createRadialGradient(p.x, p.y, r*0.15, p.x, p.y, r);
                    g.addColorStop(0, `rgba(140,255,100,${(0.28*life).toFixed(3)})`);
                    g.addColorStop(0.55, `rgba(90,220,80,${(0.20*life).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(40,100,30,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
                    // Bubbles
                    if (!(game.perf && game.perf.lowFx)) {
                        ctx.save();
                        ctx.globalAlpha = 0.5 * life;
                        for (let b=0;b<3;b++) {
                            const ang = (b/3)*Math.PI*2 + (nowA/800);
                            const rr = r*0.5 + Math.sin(nowA/500 + b)*r*0.08;
                            const bx = p.x + Math.cos(ang)*rr*0.4;
                            const by = p.y + Math.sin(ang)*rr*0.4 - Math.sin(nowA/300 + b)*3;
                            ctx.fillStyle = 'rgba(200,255,200,0.35)';
                            ctx.beginPath(); ctx.arc(bx, by, Math.max(2, r*0.05), 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                    }
                });
            }

            // Gold dust pools rendering (beneath enemies/projectiles) — sparkling golden lingering pools
            if (Array.isArray(game.goldDustPools) && game.goldDustPools.length) {
                const nowG = Date.now();
                game.goldDustPools.forEach(p => {
                    const age = nowG - p.created; const life = 1 - Math.min(1, age / p.duration);
                    const r = p.r * (0.98 + Math.sin(nowG/320 + p.x*0.01 + p.y*0.01)*0.02);
                    // Base golden radial gradient
                    const g = ctx.createRadialGradient(p.x, p.y, r*0.12, p.x, p.y, r);
                    g.addColorStop(0, `rgba(255,230,140,${(0.36*life).toFixed(3)})`);
                    g.addColorStop(0.55, `rgba(255,200,90,${(0.22*life).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(180,120,40,0)');
                    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
                    // Sparkles
                    if (!(game.perf && game.perf.lowFx)) {
                        ctx.save();
                        ctx.globalAlpha = 0.9 * life;
                        const sparkleCount = Math.max(6, Math.floor(12 * life));
                        for (let s=0;s<sparkleCount;s++) {
                            const ang = Math.random()*Math.PI*2;
                            const dist = Math.random()*r*0.9;
                            const px = p.x + Math.cos(ang)*dist;
                            const py = p.y + Math.sin(ang)*dist;
                            const size = 3 + Math.random()*4;
                            ctx.fillStyle = (Math.random() < 0.5) ? '#FFF8D8' : '#FFE090';
                            ctx.beginPath(); ctx.arc(px, py, size * (0.8 + 0.6*Math.random()) * life, 0, Math.PI*2); ctx.fill();
                            // occasional brighter flare
                            if (Math.random() < 0.08) {
                                ctx.fillStyle = '#FFFFFF'; ctx.beginPath(); ctx.arc(px, py, Math.max(1, size*0.5) * life, 0, Math.PI*2); ctx.fill();
                            }
                        }
                        ctx.restore();
                    }
                });
            }

            // Poison cloud trail rendering (Silent But Deadly) - beneath enemies/projectiles for readability
            if (Array.isArray(game.poisonClouds) && game.poisonClouds.length) {
                game.poisonClouds.forEach(c => {
                    const p = c.life / c.maxLife; // 1 -> 0
                    const r = c.radius * (1 + (1-p)*0.15);
                    const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r);
                    g.addColorStop(0, `rgba(120,255,150,${0.18 + 0.12*p})`);
                    g.addColorStop(0.5, `rgba(90,220,120,${0.12 + 0.10*p})`);
                    g.addColorStop(1, 'rgba(40,80,50,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, r, 0, Math.PI*2);
                    ctx.fill();
                    // Subtle swirling outline pulses
                    if (p > 0.25) {
                        ctx.save();
                        ctx.strokeStyle = `rgba(160,255,180,${0.08*p})`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6,12]);
                        ctx.lineDashOffset = (Date.now()/90 + c.x*0.2) % 18;
                        ctx.beginPath();
                        ctx.arc(c.x, c.y, r*0.7 + Math.sin(Date.now()/300 + c.y*0.05)*3, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }

            // Fragment Wake sparks (above ground effects but beneath main projectiles)
            if (Array.isArray(game.fragmentSparks) && game.fragmentSparks.length) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const now = Date.now();
                game.fragmentSparks.forEach(s => {
                    const lifeRatio = s.ttl / s.maxTtl; // 1 -> 0
                    const pulse = 0.55 + Math.sin(s.pulse)*0.45;
                    const radius = s.r * (0.7 + 0.6*pulse) * (0.6 + 0.4*lifeRatio);
                    const grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, radius);
                    grd.addColorStop(0, `rgba(255,210,140,${0.55 * lifeRatio})`);
                    grd.addColorStop(0.4, `rgba(255,140,60,${0.30 * lifeRatio})`);
                    grd.addColorStop(1, 'rgba(255,80,0,0)');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, radius, 0, Math.PI*2);
                    ctx.fill();
                    // Core spark flick (slightly brighter)
                    ctx.fillStyle = `rgba(255,245,210,${0.42 * lifeRatio})`;
                    ctx.beginPath();
                    ctx.arc(s.x + Math.sin(now/50 + s.x*0.1)*1.2, s.y + Math.cos(now/60 + s.y*0.1)*1.2, radius*0.25, 0, Math.PI*2);
                    ctx.fill();
                });
                ctx.restore();
            }

            // Vortex field rendering (beneath enemies for clarity, above ground effects)
            if (Array.isArray(game.vortexFields) && game.vortexFields.length) {
                const t = Date.now();
                game.vortexFields.forEach(f => {
                    const age = t - f.createdAt;
                    const lifeRatio = 1 - Math.min(1, age / f.duration);
                    const baseR = f.radius * (0.95 + Math.sin(t/260 + f.x*0.01 + f.spin)*0.05);
                    // Outer swirling gradient
                    const grad = ctx.createRadialGradient(f.x, f.y, f.innerRadius*0.3, f.x, f.y, baseR);
                    grad.addColorStop(0, `rgba(255,120,255,${0.30 * lifeRatio})`);
                    grad.addColorStop(0.55, `rgba(140,20,150,${0.22 * lifeRatio})`);
                    grad.addColorStop(1, 'rgba(60,0,70,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, baseR, 0, Math.PI*2);
                    ctx.fill();
                    // Rotating arc spokes
                    ctx.save();
                    ctx.translate(f.x, f.y);
                    ctx.rotate(f.spin);
                    const spokes = 6;
                    for (let s=0;s<spokes;s++) {
                        const a = (s/spokes)*Math.PI*2;
                        const len = baseR * 0.82;
                        const w = 5 + Math.sin(t/180 + s)*2;
                        ctx.strokeStyle = `rgba(255,180,255,${0.18 * lifeRatio})`;
                        ctx.lineWidth = w;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(a)*f.innerRadius*0.6, Math.sin(a)*f.innerRadius*0.6);
                        ctx.lineTo(Math.cos(a)*len, Math.sin(a)*len);
                        ctx.stroke();
                    }
                    ctx.restore();
                    // Inward wisps (skip if hideSpokes)
                    if (!(game.fxFlags && game.fxFlags.hideSpokes)) {
                        const wCount = 5;
                        for (let w=0; w<wCount; w++) {
                            const ang = (t/300 + w) % (Math.PI*2);
                            const r1 = baseR * (0.6 + (w/wCount)*0.35);
                            const r2 = r1 - 14 - (w*2);
                            ctx.strokeStyle = `rgba(255,180,255,${0.08 * lifeRatio})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(f.x + Math.cos(ang)*r1, f.y + Math.sin(ang)*r1);
                            ctx.lineTo(f.x + Math.cos(ang)*r2, f.y + Math.sin(ang)*r2);
                            ctx.stroke();
                        }
                    }
                    // Inner core pulse
                    const coreR = f.innerRadius * (1 + Math.sin(t/140 + f.y*0.02)*0.25);
                    const cgrad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, coreR);
                    cgrad.addColorStop(0, `rgba(255,200,255,${0.55 * lifeRatio})`);
                    cgrad.addColorStop(1, 'rgba(255,200,255,0)');
                    ctx.fillStyle = cgrad;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, coreR, 0, Math.PI*2);
                    ctx.fill();
                    // Brief flash ring when field ticks
                    if (f._flash && f._flash > 0) {
                        const alpha = Math.min(1, f._flash/6) * 0.9 * lifeRatio;
                        ctx.save();
                        ctx.strokeStyle = `rgba(255,200,255,${alpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(f.x, f.y, baseR*0.8, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                        f._flash--;
                    }
                });
            }

            // Black Hole rendering (beneath enemies, after vortex/echo for clarity)
            if (Array.isArray(game.blackHoles) && game.blackHoles.length) {
                const nowBH = performance.now();
                game.blackHoles.forEach(h => {
                    const age = nowBH - h.createdAt;
                    const k = Math.max(0, 1 - age / h.lifeMs);
                    const r = h.radius * (0.9 + 0.1*k);
                    // Outer lensing glow
                    const lg = ctx.createRadialGradient(h.x, h.y, r*0.65, h.x, h.y, r*1.05);
                    lg.addColorStop(0, `rgba(80,10,90,${0.22*k})`);
                    lg.addColorStop(0.9, 'rgba(40,0,50,0.05)');
                    lg.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = lg;
                    ctx.beginPath(); ctx.arc(h.x, h.y, r*1.05, 0, Math.PI*2); ctx.fill();
                    // Horizon rim
                    ctx.save();
                    ctx.strokeStyle = `rgba(180,80,220,${0.35*k})`;
                    ctx.lineWidth = 2.5;
                    ctx.beginPath(); ctx.arc(h.x, h.y, r*0.82, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();
                });
            }

            // Echo Bloom resonance field rendering (beneath enemies, above vortex for contrast)
            if (Array.isArray(game.echoBloomFields) && game.echoBloomFields.length) {
                const nowT = Date.now();
                game.echoBloomFields.forEach(f => {
                    const age = nowT - f.createdAt;
                    const life = 1 - Math.min(1, age / f.duration);
                    const pulse = 0.5 + Math.sin(nowT/170 + f.x*0.05 + f.y*0.03)*0.5;
                    const radius = f.radius * (0.92 + pulse*0.08);
                    const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, radius);
                    // Stacked-hit resonance highlight: temporarily brighten core when multiple ticks stack
                    const stacked = f._stackVisUntil && performance.now() < f._stackVisUntil;
                    const coreBoost = stacked ? 1.35 : 1.0;
                    const midBoost = stacked ? 1.18 : 1.0;
                    g.addColorStop(0, `rgba(255,230,255,${(0.40 * life * coreBoost).toFixed(3)})`);
                    g.addColorStop(0.45, `rgba(230,140,255,${(0.18 * life * midBoost).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(160,60,200,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(f.x, f.y, radius, 0, Math.PI*2); ctx.fill();
                    // Subtle rotating petal spokes
                    if (!(game.fxFlags && game.fxFlags.hideSpokes)) {
                        ctx.save();
                        ctx.translate(f.x, f.y);
                        ctx.rotate(age/600);
                        const petals = 8;
                        for (let p=0;p<petals;p++) {
                            const a = (p/petals)*Math.PI*2;
                            const ir = radius*0.15; const or = radius*0.75;
                            // Brighten spokes briefly on stacked-hit window
                            const spokeAlpha = (0.10 * life) * (stacked ? 1.6 : 1.0);
                            ctx.strokeStyle = `rgba(255,200,255,${spokeAlpha.toFixed(3)})`;
                            ctx.lineWidth = stacked ? 3.8 : 3;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(a)*ir, Math.sin(a)*ir);
                            ctx.lineTo(Math.cos(a)*or, Math.sin(a)*or);
                            ctx.stroke();
                        }
                        ctx.restore();
                    }
                    // Optional: faint outer halo when stacked highlight is active
                    if (stacked) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = `rgba(255,230,255,${(0.18 * life).toFixed(3)})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(f.x, f.y, radius*0.92, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }

            // Bloom Rings rendering (after Echo Bloom resonance so rings sit above fields but below lightning)
            if (Array.isArray(game.bloomRings) && game.bloomRings.length) {
                const nowBR = Date.now();
                game.bloomRings.forEach(rg => {
                    const age = nowBR - rg.createdAt;
                    const lifeRatio = 1 - Math.min(1, age / rg.maxLife);
                    const growthPhase = Math.min(1, rg.radius / rg.maxRadius);
                    const alpha = 0.65 * lifeRatio;
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const hideSpokes = !!(game.fxFlags && game.fxFlags.hideSpokes);
                    // Telegraph intensity (first ~180ms) – boosts inner glow & edge pulse
                    const teleActive = performance.now() < (rg.telegraphUntil || 0);
                    let telePulse = teleActive ? (0.55 + Math.sin(performance.now()/70 + rg.seed)*0.45) : 0;
                    if (lowFx) telePulse *= 0.6;
                    // Outer glow donut (warmer & brighter)
                    const grad = ctx.createRadialGradient(rg.x, rg.y, Math.max(0, rg.radius - rg.width*0.9), rg.x, rg.y, rg.radius + rg.width*0.85);
                    grad.addColorStop(0, `rgba(255,240,230,${teleActive?0.25+telePulse*0.25:0.10})`);
                    grad.addColorStop(0.55, `rgba(255,210,180,${alpha * (0.22 + telePulse*0.2)})`);
                    grad.addColorStop(0.80, `rgba(255,140,90,${alpha * 0.65})`);
                    grad.addColorStop(1, 'rgba(255,100,40,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.radius + rg.width*0.85, 0, Math.PI*2);
                    ctx.fill();
                    // Central flash (short lived after first damage)
                    if (rg.firstDamage && age < 220) {
                        const flashA = Math.max(0, 1 - (age/220)) * (lowFx ? 0.8 : 1);
                        const cg = ctx.createRadialGradient(rg.x, rg.y, 0, rg.x, rg.y, Math.min(rg.radius*0.55, 180));
                        cg.addColorStop(0, `rgba(255,250,240,${0.55*flashA})`);
                        cg.addColorStop(0.6, `rgba(255,200,150,${0.25*flashA})`);
                        cg.addColorStop(1, 'rgba(255,150,90,0)');
                        ctx.fillStyle = cg;
                        ctx.beginPath();
                        ctx.arc(rg.x, rg.y, Math.min(rg.radius*0.55, 180), 0, Math.PI*2);
                        ctx.fill();
                    }
                    // Core thin inner ring (charging telegraph fade out early)
                    if (!rg.detonated && !reduceRings) {
                        const teleA = 0.35 + Math.sin(nowBR/140 + rg.x*0.02)*0.25;
                        ctx.strokeStyle = `rgba(255,240,240,${teleA})`;
                        ctx.lineWidth = (lowFx ? 1.5 : 2) + Math.sin(nowBR/90)*1.2;
                        ctx.beginPath();
                        ctx.arc(rg.x, rg.y, 12 + Math.sin(nowBR/120)*3, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    // Ring edge (main visible band) brighter & pulsing
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const pulse = (0.55 + Math.sin(performance.now()/140 + rg.seed)*0.45) * (lowFx ? 0.75 : 1);
                    ctx.strokeStyle = `rgba(255,210,170,${alpha * (0.90 + pulse*0.10)})`;
                    ctx.lineWidth = rg.width * (0.60 + pulse*0.18 * (reduceRings?0.6:1));
                    ctx.beginPath();
                    ctx.arc(rg.x, rg.y, rg.radius, 0, Math.PI*2);
                    ctx.stroke();
                    // Rotating spokes for motion cue
                    if (!hideSpokes && !lowFx) {
                        ctx.translate(rg.x, rg.y);
                        ctx.rotate(age/600 + rg.seed);
                        const spokes = 4;
                        for (let s=0;s<spokes;s++) {
                            const ang = (s/spokes)*Math.PI*2;
                            ctx.strokeStyle = `rgba(255,200,180,${alpha*0.30})`;
                            ctx.lineWidth = 3.3;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(ang)*(rg.radius-rg.width*0.5), Math.sin(ang)*(rg.radius-rg.width*0.5));
                            ctx.lineTo(Math.cos(ang)*(rg.radius+rg.width*0.5), Math.sin(ang)*(rg.radius+rg.width*0.5));
                            ctx.stroke();
                        }
                    }
                    ctx.restore();
                });
            }

            // Transient effects (ring flashes, blips)
            if (Array.isArray(game.transientEffects) && game.transientEffects.length) {
                const nowTE = performance.now();
                for (let i = game.transientEffects.length - 1; i >= 0; i--) {
                    const t = game.transientEffects[i];
                    const age = nowTE - t.created;
                    const k = Math.min(1, age / t.life);
                    const a = Math.max(0, 1 - k);
                    if (t.type === 'ringFlash') {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = t.color.replace(')', `,${(0.65*a).toFixed(3)})`).replace('#', 'rgba(') || `rgba(255,255,255,${0.65*a})`;
                        // Fallback for hex colors: draw glow + core ring
                        ctx.beginPath();
                        ctx.lineWidth = 6 * (1 - k);
                        ctx.arc(t.x, t.y, t.radius * (0.8 + 0.6*k), 0, Math.PI*2);
                        ctx.stroke();
                        ctx.strokeStyle = `rgba(255,255,255,${0.35*a})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, t.radius * (0.9 + 0.4*k), 0, Math.PI*2);
                        ctx.stroke();
                        ctx.restore();
                    } else {
                        // blip: small expanding dot
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.fillStyle = `rgba(255,255,255,${0.6*a})`;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, 2 + 6*k, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }
                    if (age >= t.life) game.transientEffects.splice(i,1);
                }
            }

            // Lightning arcs rendering (after vortex so arcs sit on top of fields but beneath enemies for clarity)
            if (Array.isArray(game.lightningArcs) && game.lightningArcs.length) {
                for (let i = game.lightningArcs.length - 1; i >= 0; i--) {
                    const a = game.lightningArcs[i];
                    a.life--;
                    if (!a.points || a.points.length < 2) { game.lightningArcs.splice(i,1); continue; }
                    const fade = Math.max(0, a.life / a.maxLife);
                    // Glow pass
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = `rgba(255,255,180,${0.12 * fade})`;
                    ctx.lineWidth = 10;
                    ctx.beginPath();
                    ctx.moveTo(a.points[0].x, a.points[0].y);
                    for (let p=1;p<a.points.length;p++) ctx.lineTo(a.points[p].x, a.points[p].y);
                    ctx.stroke();
                    ctx.restore();
                    // Core stroke (slightly jagged each frame)
                    ctx.save();
                    ctx.strokeStyle = `rgba(255,255,120,${0.85 * fade})`;
                    ctx.lineWidth = 2 + 1*Math.random();
                    ctx.beginPath();
                    ctx.moveTo(a.points[0].x, a.points[0].y);
                    for (let p=1;p<a.points.length;p++) {
                        const pt = a.points[p];
                        // slight per-frame jitter for liveliness
                        const jx = (Math.random()-0.5) * 2;
                        const jy = (Math.random()-0.5) * 2;
                        ctx.lineTo(pt.x + jx, pt.y + jy);
                    }
                    ctx.stroke();
                    ctx.restore();
                    if (a.life <= 0) game.lightningArcs.splice(i,1);
                }
            }

            // Potato Mode HUD badge (lightweight) — render at top-right to avoid FPS panel overlap
            if (game.potatoMode) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                const label = 'Potato Mode';
                ctx.font = 'bold 12px Courier New, monospace';
                const textW = Math.ceil(ctx.measureText(label).width);
                const padX = 10; // horizontal padding inside badge
                const padY = 4;  // vertical padding inside badge
                const h = 22;    // fixed height for consistent look
                const w = Math.max(118, textW + padX * 2); // keep minimum width, expand if needed
                const margin = 10;
                // Place at top-right of the logical canvas
                const x = (typeof logicalW === 'number' ? logicalW : ctx.canvas.width) - w - margin;
                const y = margin;
                // Backing rounded rect
                ctx.fillStyle = 'rgba(0,0,0,0.45)';
                ctx.beginPath();
                const r = 6;
                ctx.moveTo(x + r, y);
                ctx.arcTo(x + w, y, x + w, y + h, r);
                ctx.arcTo(x + w, y + h, x, y + h, r);
                ctx.arcTo(x, y + h, x, y, r);
                ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
                ctx.fill();
                // Text
                ctx.fillStyle = '#d2ff7c';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, x + padX, y + h/2);
                ctx.restore();
            }

            // Draw punji pits
            if (game.pits && game.pits.length) {
                game.pits.forEach(pit => {
                    const age = Date.now() - pit.created;
                    const fade = Math.max(0.15, 1 - age / pit.duration);
                    ctx.save();
                    ctx.translate(pit.x, pit.y);
                    const r = pit.radius;
                    // Ground base (dirt ring)
                    const baseGrad = ctx.createRadialGradient(0,0,r*0.2,0,0,r);
                    baseGrad.addColorStop(0,'rgba(90,60,30,'+(0.35*fade)+')');
                    baseGrad.addColorStop(1,'rgba(50,30,15,'+(0.55*fade)+')');
                    ctx.fillStyle = baseGrad;
                    ctx.beginPath();
                    ctx.arc(0,0,r,0,Math.PI*2);
                    ctx.fill();
                    // Inner trench shadow
                    ctx.fillStyle = 'rgba(0,0,0,'+(0.25*fade)+')';
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.55,0,Math.PI*2);
                    ctx.fill();
                    // Poison aura subtle (kept but softer to not clash with spikes)
                    const aura = ctx.createRadialGradient(0,0,r*0.15,0,0,r*0.85);
                    aura.addColorStop(0,'rgba(120,255,140,'+(0.18*fade)+')');
                    aura.addColorStop(1,'rgba(40,120,50,0)');
                    ctx.fillStyle = aura;
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.9,0,Math.PI*2);
                    ctx.fill();
                    // Spikes: vertical wooden stakes with darker tips
                    const spikesArr = pit.spikes || [];
                    spikesArr.forEach(sp => {
                        const sx = sp.x * r; // local space
                        const sy = sp.y * r;
                        const h = sp.h; // height in pixels
                        const baseW = 4 + (h*0.08); // width scales lightly with height
                        // Slight lean offset
                        const topOffsetX = sp.lean * h;
                        // Shaft
                        ctx.strokeStyle = '#6B4A2B';
                        ctx.lineWidth = baseW * 0.55;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(sx + topOffsetX, sy - h);
                        ctx.stroke();
                        // Wood fill (behind stroke for thickness): draw a narrow polygon
                        ctx.fillStyle = '#8B5E34';
                        ctx.beginPath();
                        ctx.moveTo(sx - baseW*0.35, sy);
                        ctx.lineTo(sx + baseW*0.35, sy);
                        ctx.lineTo(sx + topOffsetX + baseW*0.15, sy - h*0.94);
                        ctx.lineTo(sx + topOffsetX - baseW*0.15, sy - h*0.94);
                        ctx.closePath();
                        ctx.fill();
                        // Tip (darker, sharpened)
                        ctx.fillStyle = '#3A2412';
                        ctx.beginPath();
                        ctx.moveTo(sx + topOffsetX, sy - h);
                        ctx.lineTo(sx + topOffsetX + baseW*0.25, sy - h*0.88);
                        ctx.lineTo(sx + topOffsetX - baseW*0.25, sy - h*0.88);
                        ctx.closePath();
                        ctx.fill();
                        // Highlight edge (simple light stroke on one side)
                        ctx.strokeStyle = 'rgba(255,230,180,'+(0.35*fade)+')';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(sx + topOffsetX - baseW*0.1, sy - h*0.94);
                        ctx.lineTo(sx - baseW*0.25, sy);
                        ctx.stroke();
                    });
                    // Ambient poison motes (light, low density)
                    if (Math.random() < 0.15 * fade) {
                        addParticle(pit.x + (Math.random()-0.5)*r*1.2, pit.y + (Math.random()-0.5)*r*1.2, '#66FF66','poison');
                    }
                    ctx.restore();
                });
            }

            // Draw beartraps
            if (game.traps && game.traps.length) {
                game.traps.forEach(trap => {
                    const armed = !trap.triggered;
                    ctx.save();
                    ctx.translate(trap.x, trap.y);
                    // base circle
                    ctx.beginPath();
                    ctx.arc(0,0, armed ? 14 : 16, 0, Math.PI*2);
                    ctx.fillStyle = armed ? '#444' : '#772222';
                    ctx.fill();
                    // teeth
                    const teeth = 10;
                    ctx.strokeStyle = armed ? '#bbbbbb' : '#ffdddd';
                    ctx.lineWidth = 2;
                    for (let t=0;t<teeth;t++) {
                        const ang = (t/teeth)*Math.PI*2;
                        const r1 = armed ? 10 : 8;
                        const r2 = armed ? 14 : 16;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
                        ctx.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
                        ctx.stroke();
                    }
                    if (!armed) {
                        ctx.fillStyle = '#ff4444aa';
                        ctx.beginPath();
                        ctx.arc(0,0,8,0,Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                });
            }
            
            // Shared chest variant specs (used by chests and irradiated cans)
            const CHEST_VARIANT_SPECS = {
                gold: { top:'#ffe680', mid:'#f7c846', bot:'#cfa02d', rib:'rgba(255,255,255,0.35)', glow:'rgba(255,223,90,', handle:'#cfa02d' },
                platinum: { top:'#f2f2f2', mid:'#d9d9d9', bot:'#b0b0b0', rib:'rgba(255,255,255,0.55)', glow:'rgba(200,200,255,', handle:'#e0e0e0' },
                rusty: { top:'#e8b270', mid:'#b96a33', bot:'#7a3f1c', rib:'rgba(255,220,180,0.25)', glow:'rgba(255,170,60,', handle:'#a85622' },
                irradiated: { top:'#d2ff7a', mid:'#9bdf31', bot:'#5e8f18', rib:'rgba(255,255,255,0.30)', glow:'rgba(170,255,90,', handle:'#9bdf31' },
                rainbow: { top:'#ffd1dc', mid:'#c5e1ff', bot:'#d5ffd5', rib:'rgba(255,255,255,0.45)', glow:'rgba(255,255,255,', handle:'#ffffff' }
            };

            // Draw chests
            const now = performance.now();
            game.chests.forEach(chest => {
                if (!chest.opened) {
                    const cx = chest.x;
                    const cy = chest.y;
                    const r = 18;
                    const variant = chest.variant || 'gold';
                    // Proximity jiggle will modify lid vertical offset later; precompute distance to player
                    const dx = game.player.x - cx;
                    const dy = game.player.y - cy;
                    const dist = Math.hypot(dx, dy);
                    // Update jiggle phase
                    const near = dist < 130;
                    chest.jigglePhase = (chest.jigglePhase || 0) + (near ? 0.12 : 0.02);
                    const lidLift = (near ? Math.sin(chest.jigglePhase)*2.4 : Math.sin(chest.jigglePhase)*0.8);

                    // Variant colors (reuse shared specs)
                    const spec = CHEST_VARIANT_SPECS[variant] || CHEST_VARIANT_SPECS.gold;
                    let grad = ctx.createLinearGradient(cx, cy - r, cx, cy + r);
                // Frost Aura (Blizzard) soft field around player
                if (game._frostAura && game.player) {
                    const a = game._frostAura;
                    const r = a.r;
                    const cg = ctx.createRadialGradient(game.player.x, game.player.y, 0, game.player.x, game.player.y, r*1.15);
                    const pulse = 0.5 + Math.sin(performance.now()/300)*0.5;
                    cg.addColorStop(0, `rgba(200,245,255,${0.10 + 0.12*pulse})`);
                    cg.addColorStop(0.55, `rgba(180,235,255,${0.08 + 0.10*pulse})`);
                    cg.addColorStop(1, 'rgba(160,220,255,0)');
                    ctx.fillStyle = cg;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, r*1.15, 0, Math.PI*2);
                    ctx.fill();
                    // Subtle ice ring
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = `rgba(180,230,255,${0.25 + 0.25*pulse})`;
                    ctx.lineWidth = 2 + 1.5*pulse;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, r, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                }

                    if (variant === 'rainbow') {
                        const t = (now * 0.001) % 1;
                        // 6-color rainbow gradient that subtly shifts over time
                        const colors = [0, 60, 120, 180, 240, 300].map(h => `hsl(${(h + t*360)|0}, 85%, 65%)`);
                        grad.addColorStop(0.00, colors[0]);
                        grad.addColorStop(0.20, colors[1]);
                        grad.addColorStop(0.40, colors[2]);
                        grad.addColorStop(0.60, colors[3]);
                        grad.addColorStop(0.80, colors[4]);
                        grad.addColorStop(1.00, colors[5]);
                    } else {
                        grad.addColorStop(0, spec.top);
                        grad.addColorStop(0.4, spec.mid);
                        grad.addColorStop(1, spec.bot);
                    }
                    ctx.fillStyle = grad;
                    // Top ellipse (body top) hidden mostly under lid
                    ctx.beginPath();
                    ctx.ellipse(cx, cy - r*0.25, r*0.90, r*0.35, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Side wall
                    ctx.fillRect(cx - r*0.90, cy - r*0.25, r*1.80, r*1.10);
                    // Bottom ellipse
                    ctx.fillStyle = spec.bot;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + r*0.85, r*0.88, r*0.30, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Vertical ribs
                    ctx.strokeStyle = spec.rib;
                    ctx.lineWidth = 2;
                    for (let i=0;i<6;i++) {
                        const t = -r*0.70 + i*(r*1.40/5);
                        ctx.beginPath();
                        ctx.moveTo(cx + t*0.6, cy - r*0.20);
                        ctx.lineTo(cx + t*0.75, cy + r*0.78);
                        ctx.stroke();
                    }
                    // Lid (raised + jiggle)
                    const lidY = cy - r*0.40 - lidLift*0.4;
                    ctx.fillStyle = spec.top;
                    ctx.beginPath();
                    ctx.ellipse(cx, lidY, r*0.95, r*0.38, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = spec.bot;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(cx, lidY, r*0.95, r*0.38, 0, 0, Math.PI*2);
                    ctx.stroke();
                    // Handle arc
                    ctx.strokeStyle = spec.handle;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(cx, lidY - r*0.08, r*0.25, Math.PI*0.90, Math.PI*0.10, false);
                    ctx.stroke();
                    // Side handles
                    ctx.strokeStyle = spec.handle;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(cx - r*1.00, cy + r*0.10);
                    ctx.lineTo(cx - r*1.15, cy + r*0.00);
                    ctx.moveTo(cx + r*1.00, cy + r*0.10);
                    ctx.lineTo(cx + r*1.15, cy + r*0.00);
                    ctx.stroke();
                    // Orbiting sparkles (not for rusty; more for premium variants)
                    if (variant !== 'rusty') {
                        const sparkleCount = 6;
                        for (let i=0;i<sparkleCount;i++) {
                            const ang = (now*0.002 + i*(Math.PI*2/sparkleCount));
                            const sr = r*1.15;
                            const sx = cx + Math.cos(ang)*sr;
                            const sy = cy + Math.sin(ang)*sr*0.65; // ellipse orbit
                            const pulse = 0.5 + 0.5*Math.sin(now*0.005 + i);
                            ctx.globalAlpha = 0.6 * pulse;
                            if (variant === 'rainbow') {
                                const hue = ((i*60) + (now*0.08)) % 360;
                                ctx.fillStyle = `hsl(${hue}, 90%, 70%)`;
                            } else {
                                ctx.fillStyle = variant === 'platinum' ? '#ffffff' : (variant === 'irradiated' ? '#d6ff88' : '#ffec8a');
                            }
                            ctx.beginPath();
                            ctx.moveTo(sx, sy - 3);
                            ctx.lineTo(sx + 3, sy);
                            ctx.lineTo(sx, sy + 3);
                            ctx.lineTo(sx - 3, sy);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    }
                    // Special glow / flicker
                    let alphaBase = 0.45;
                    if (variant === 'platinum') alphaBase = 0.55;
                    if (variant === 'rusty') alphaBase = 0.25;
                    if (variant === 'irradiated') alphaBase = 0.60 + Math.sin(now*0.008)*0.15;
                    if (variant === 'rainbow') alphaBase = 0.62 + Math.sin(now*0.012)*0.10;
                    const chestGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, r*1.6);
                    chestGlow.addColorStop(0, spec.glow + alphaBase + ')');
                    chestGlow.addColorStop(1, spec.glow + '0)');
                    ctx.fillStyle = chestGlow;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r*1.6, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            // Draw pickups (bread slices + cans)
            if (game.pickups && game.pickups.length) {
                game.pickups.forEach(p => {
                    if (p.type === 'bread') {
                        const t = (performance.now() - p.spawnTime) / 1000;
                        const bob = Math.sin(t * 4) * 4;
                        const x = p.x;
                        const y = p.y + bob;
                        const w = 20, h = 20;
                        // Shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.25)';
                        ctx.beginPath(); ctx.ellipse(x, y + h*0.55, w*0.55, h*0.28, 0, 0, Math.PI*2); ctx.fill();
                        // Crust
                        ctx.fillStyle = '#b57533';
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(x - w/2, y - h/2, w, h, 4) : ctx.rect(x - w/2, y - h/2, w, h);
                        ctx.fill();
                        // Crumb interior slightly inset
                        ctx.fillStyle = '#f4e2b6';
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(x - w/2 + 2, y - h/2 + 2, w - 4, h - 6, 3) : ctx.rect(x - w/2 + 2, y - h/2 + 2, w - 4, h - 6);
                        ctx.fill();
                        // Random seed specks (deterministic-ish per spawn)
                        const seedCount = 4;
                        for (let i=0;i<seedCount;i++) {
                            const sx = x - w/2 + 4 + (i * (w-8)/(seedCount-1));
                            const sy = y - 2 + ((i*31)%5) - 2;
                            ctx.fillStyle = '#d9c190';
                            ctx.fillRect(sx, sy, 2, 2);
                        }
                        // Light highlight
                        ctx.strokeStyle = '#ffffff66';
                        ctx.beginPath();
                        ctx.moveTo(x - w/2 + 4, y - h/2 + 4);
                        ctx.lineTo(x + w/2 - 4, y - h/2 + 4);
                        ctx.stroke();
                    }
                    else if (p.type === 'irradiatedCan') {
                        try {
                            const t = (performance.now() - p.spawnTime) / 1000;
                            const bob = Math.sin(t * 3.2) * 6;
                            const x = p.x;
                            const y = p.y + bob;
                            // Shadow
                            ctx.save();
                            ctx.globalAlpha = 0.75;
                            ctx.fillStyle = 'rgba(0,0,0,0.28)';
                            ctx.beginPath(); ctx.ellipse(x, y + 10, 18, 8, 0, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                            // Can body
                            ctx.save();
                            ctx.translate(x, y);
                            const tilt = Math.sin(t * 1.35) * 0.06;
                            ctx.rotate(tilt);
                            // Use shared chest variant spec for consistent irradiated visuals.
                            // For irradiated cans we force the irradiated spec to avoid mismatches from mutated variant fields.
                            let chestSpec = null;
                            if (typeof CHEST_VARIANT_SPECS !== 'undefined' && CHEST_VARIANT_SPECS) {
                                if (p && p.type === 'irradiatedCan') {
                                    chestSpec = CHEST_VARIANT_SPECS['irradiated'];
                                } else {
                                    chestSpec = CHEST_VARIANT_SPECS[p && p.variant] || CHEST_VARIANT_SPECS['irradiated'];
                                }
                            }
                            try { console.debug('[Draw][irradiatedCan] pickup=', p, 'variant=', p.variant || '(none)', 'chestSpec=', !!chestSpec); } catch(_) {}
                            const g = ctx.createLinearGradient(-12, -10, 12, 12);
                            if (chestSpec) {
                                g.addColorStop(0, chestSpec.top);
                                g.addColorStop(0.5, chestSpec.mid);
                                g.addColorStop(1, chestSpec.bot);
                                ctx.fillStyle = g;
                            } else {
                                // Fallback hard-coded irradiated palette
                                g.addColorStop(0, '#d6ff88');
                                g.addColorStop(0.5, '#9bdf31');
                                g.addColorStop(1, '#5e8f18');
                                ctx.fillStyle = g;
                            }
                            ctx.beginPath(); ctx.roundRect ? ctx.roundRect(-12, -18, 24, 26, 3) : ctx.rect(-12, -18, 24, 26); ctx.fill();
                            // Lid
                            ctx.fillStyle = '#6b7f2f';
                            ctx.beginPath(); ctx.roundRect ? ctx.roundRect(-14, -22, 28, 6, 2) : ctx.rect(-14, -22, 28, 6); ctx.fill();
                            // Hazard stripe
                            ctx.fillStyle = 'rgba(255,255,0,0.95)';
                            ctx.fillRect(-8, -2, 16, 4);
                            ctx.fillStyle = 'rgba(0,0,0,0.75)';
                            ctx.fillRect(-8, -2, 8, 4);
                            // Small dents / rust speckles
                            for (let s=0; s<4; s++) {
                                ctx.fillStyle = 'rgba(120,60,20,' + (0.18 + Math.random()*0.18).toFixed(2) + ')';
                                const rx = -6 + Math.random()*12; const ry = -6 + Math.random()*16; const rw = 2 + Math.random()*2; const rh = 2 + Math.random()*2;
                                ctx.beginPath(); ctx.ellipse(rx, ry, rw, rh, Math.random()*Math.PI, 0, Math.PI*2); ctx.fill();
                            }
                            ctx.restore();
                            // Irradiated glow + subtle icon (production visual) — use chest glow color if available
                            ctx.save();
                            ctx.translate(x, y);
                            const glow = ctx.createRadialGradient(0, 0, 2, 0, 0, 40);
                            if (chestSpec && chestSpec.glow) {
                                // chestSpec.glow is like 'rgba(R,G,B,' prefix — we append alpha for stops
                                try {
                                    glow.addColorStop(0, chestSpec.glow + '0.85)');
                                    glow.addColorStop(0.5, chestSpec.glow + '0.35)');
                                    glow.addColorStop(1, chestSpec.glow + '0)');
                                } catch(_) {
                                    glow.addColorStop(0, 'rgba(214,255,136,0.85)');
                                    glow.addColorStop(0.5, 'rgba(155,223,49,0.35)');
                                    glow.addColorStop(1, 'rgba(94,143,24,0)');
                                }
                            } else {
                                // Map chest.spec.glow (a 'rgba(...,' prefix) to usable color stops
                                glow.addColorStop(0, 'rgba(214,255,136,0.85)');
                                glow.addColorStop(0.5, 'rgba(155,223,49,0.35)');
                                glow.addColorStop(1, 'rgba(94,143,24,0)');
                            }
                            ctx.fillStyle = glow;
                            ctx.beginPath(); ctx.arc(0, 0, 36, 0, Math.PI * 2); ctx.fill();
                            // Small radioactive three-dot icon (subtle)
                            ctx.fillStyle = '#2d4b06';
                            ctx.beginPath(); ctx.arc(-6, -6, 3.2, 0, Math.PI*2); ctx.fill();
                            ctx.beginPath(); ctx.arc(6, -6, 3.2, 0, Math.PI*2); ctx.fill();
                            ctx.beginPath(); ctx.arc(0, 6, 3.2, 0, Math.PI*2); ctx.fill();
                            ctx.restore();
                        } catch(_) {}
                    }
                });
            }
            
            // Draw particles
            game.particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                
                switch (particle.type) {
                    case 'explosion':
                    case 'fire':
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'feather': {
                        // Draw a slim rotated feather (white) with subtle tip fade
                        const s = (particle.scale || 1) * 4.0; // base length
                        const w = s * 0.35;
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.spin || 0);
                        const grad = ctx.createLinearGradient(0, -s/2, 0, s/2);
                        grad.addColorStop(0, 'rgba(255,255,255,' + (particle.alpha*0.2).toFixed(3) + ')');
                        grad.addColorStop(0.3, 'rgba(255,255,255,' + (particle.alpha*0.85).toFixed(3) + ')');
                        grad.addColorStop(1, 'rgba(255,255,255,' + (particle.alpha*0.05).toFixed(3) + ')');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.ellipse(0,0, w, s, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Center spine
                        ctx.strokeStyle = 'rgba(255,255,255,' + (particle.alpha*0.55).toFixed(3) + ')';
                        ctx.lineWidth = Math.max(0.6, w*0.22);
                        ctx.beginPath();
                        ctx.moveTo(0, -s*0.48);
                        ctx.lineTo(0, s*0.48);
                        ctx.stroke();
                        // Small barb hints
                        ctx.lineWidth = Math.max(0.4, w*0.12);
                        ctx.beginPath();
                        ctx.moveTo(0, -s*0.20); ctx.lineTo(w*0.8, -s*0.05);
                        ctx.moveTo(0, s*0.05); ctx.lineTo(-w*0.8, s*0.20);
                        ctx.stroke();
                        break;
                    }
                    case 'spark':
                    case 'lightning':
                        ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                        break;
                    case 'heal':
                        ctx.font = '12px Arial';
                        ctx.fillText('+', particle.x, particle.y);
                        break;
                    case 'treasure':
                        ctx.font = '8px Arial';
                        ctx.fillText('★', particle.x, particle.y);
                        break;
                    case 'shield':
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'damage':
                        ctx.font = '10px Arial';
                        ctx.fillText('!', particle.x, particle.y);
                        break;
                    case 'victory':
                        ctx.font = '14px Arial';
                        ctx.fillText('✓', particle.x, particle.y);
                        break;
                    default:
                        ctx.fillRect(particle.x - 1, particle.y - 1, 2, 2);
                }
                ctx.restore();
            });
            
            // Rizz telegraph: cooldown sweep ring + active halo
            if (game.player && game.player.abilities && game.player.abilities.includes('Rizz')) {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const px = game.player.x, py = game.player.y;
                const last = game._lastRizz || 0;
                const nowR = performance.now();
                const cd = Math.min(1, Math.max(0, (nowR - last) / RIZZ_INTERVAL_MS)); // 0->1 toward ready
                const r = RIZZ_RING_RADIUS * (1 + (lowFx?0.02:0.08)*Math.sin(nowR/320));
                // Draw cooldown arc (fills clockwise as cooldown progresses)
                if (!reduceRings) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.lineWidth = lowFx ? 2 : 3.5;
                    ctx.strokeStyle = `rgba(200,150,255,${lowFx?0.35:0.55})`;
                    ctx.beginPath();
                    ctx.arc(px, py, r, -Math.PI/2, -Math.PI/2 + cd * Math.PI*2);
                    ctx.stroke();
                    // Faint outer glow ring to hint radius
                    ctx.strokeStyle = `rgba(160,120,230,${lowFx?0.10:0.20})`;
                    ctx.lineWidth = lowFx ? 1.5 : 2;
                    ctx.beginPath();
                    ctx.arc(px, py, r*1.03, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.restore();
                }
                // Brief halo when pull just started (first 180ms)
                if (nowR - last < 220) {
                    const k = 1 - ((nowR - last) / 220);
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const g = ctx.createRadialGradient(px, py, 0, px, py, r*1.15);
                    g.addColorStop(0, `rgba(225,200,255,${(0.35*k).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(225,200,255,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(px, py, r*1.15, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Duck Dynasty flock rendering (beneath projectile layer, above ground telegraphs)
            if (Array.isArray(game.duckFlocks) && game.duckFlocks.length) {
                game.duckFlocks.forEach(d => {
                    if (d.x == null || d.y == null) return;
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    // Orientation based on instantaneous motion (approx using last two positions if cached)
                    if (!d._lx) { d._lx = d.x; d._ly = d.y; }
                    const mvx = d.x - d._lx; const mvy = d.y - d._ly;
                    d._lx = d.x; d._ly = d.y;
                    const ang = Math.atan2(mvy, mvx);
                    ctx.rotate(ang);
                    const bodyR = d.size * 0.5;
                    // Body ellipse
                    const g = ctx.createLinearGradient(-bodyR,0,bodyR,0);
                    g.addColorStop(0,(d.color||'#FFE8AA')+'AA');
                    g.addColorStop(1,(d.color||'#FFE8AA'));
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.ellipse(0,0, bodyR, bodyR*0.55, 0,0,Math.PI*2); ctx.fill();
                    // Head
                    ctx.fillStyle = d.color||'#FFE8AA';
                    ctx.beginPath(); ctx.ellipse(bodyR*0.95, -bodyR*0.15, bodyR*0.38, bodyR*0.34, 0,0,Math.PI*2); ctx.fill();
                    // Beak
                    ctx.fillStyle = '#FFB243';
                    ctx.beginPath(); ctx.moveTo(bodyR*1.25,-bodyR*0.12); ctx.lineTo(bodyR*1.55,0); ctx.lineTo(bodyR*1.25, bodyR*0.12); ctx.closePath(); ctx.fill();
                    // Wings out (static spread + slight undulation)
                    const flap = Math.sin((d.wingPhase||0)*0.8) * 0.25;
                    const wingSpan = bodyR * 1.9;
                    ctx.fillStyle = (d.color||'#FFE8AA')+'BB';
                    // Left wing
                    ctx.save(); ctx.rotate(-0.25 + flap);
                    ctx.beginPath(); ctx.ellipse(-bodyR*0.2,0, wingSpan*0.55, wingSpan*0.22, 0,0,Math.PI*2); ctx.fill(); ctx.restore();
                    // Right wing
                    ctx.save(); ctx.rotate(0.25 - flap);
                    ctx.beginPath(); ctx.ellipse(-bodyR*0.2,0, wingSpan*0.55, wingSpan*0.22, 0,0,Math.PI*2); ctx.fill(); ctx.restore();
                    // Tail accent
                    ctx.fillStyle = (d.color||'#FFE8AA')+'AA';
                    ctx.beginPath(); ctx.moveTo(-bodyR*0.9, -bodyR*0.15); ctx.lineTo(-bodyR*0.9, bodyR*0.15); ctx.lineTo(-bodyR*0.55, 0); ctx.closePath(); ctx.fill();
                    ctx.restore();
                });
            }
            
            // Nuke pre-impact telegraphs (draw beneath enemies & player for clarity)
            if (Array.isArray(game.nukes) && game.nukes.length) {
                const now = Date.now();
                game.nukes.forEach(n => {
                    if (!n || n.exploded) return; // only telegraph pending strikes
                    const totalWarn = n.impactAt - n.spawnAt;
                    const remaining = Math.max(0, n.impactAt - now);
                    const t = remaining / totalWarn; // 1 -> 0
                    const pulse = 1 + Math.sin(now/120 + n.x*0.05) * 0.05;
                    const radius = n.radius * pulse;
                    // Soft fill glow
                    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, radius);
                    g.addColorStop(0, 'rgba(255,180,40,0.10)');
                    g.addColorStop(0.65, 'rgba(255,120,0,0.08)');
                    g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, radius, 0, Math.PI*2);
                    ctx.fill();
                    // Outer warning ring (animated dash)
                    ctx.save();
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10,8]);
                    const dashOffset = (now/40) % 18;
                    ctx.lineDashOffset = -dashOffset;
                    ctx.strokeStyle = `rgba(${Math.round(255*(1-t))}, ${Math.round(200*t)}, 40, 0.85)`; // shifts to red
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.radius, 0, Math.PI*2);
                    ctx.stroke();
                    // Countdown shrinking inner ring
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, Math.max(6, n.radius * t), 0, Math.PI*2);
                    ctx.stroke();
                    // Crosshair lines
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = 'rgba(255,220,120,0.5)';
                    ctx.beginPath();
                    ctx.moveTo(n.x - n.radius, n.y);
                    ctx.lineTo(n.x + n.radius, n.y);
                    ctx.moveTo(n.x, n.y - n.radius);
                    ctx.lineTo(n.x, n.y + n.radius);
                    ctx.stroke();
                    ctx.restore();
                    // Time text
                    const secs = (remaining/1000).toFixed(2);
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.fillText(secs, n.x, n.y + 6);
                });
            }

            // Meteor impact telegraph markers (appear where meteor will land)
            if (Array.isArray(game.meteorMarkers) && game.meteorMarkers.length) {
                for (let i = game.meteorMarkers.length - 1; i >= 0; i--) {
                    const m = game.meteorMarkers[i];
                    // Convert legacy ms life to frame-based if needed
                    if (!m._initFrameLife) {
                        // If marker provided 'life' as ms ( > 300 ), translate to frames (~60fps)
                        if (m.life && m.life > 300) {
                            m.maxLife = Math.floor((m.life / 1000) * 60);
                        } else {
                            m.maxLife = m.life || 220;
                        }
                        m.life = m.maxLife;
                        m._initFrameLife = true;
                    }
                    // If created timestamp exists and exceeds original requested lifespan (1600ms default), flag dead
                    if (m.created && Date.now() - m.created > 1800) {
                        m.dead = true;
                    }
                    m.life = (typeof m.life === 'number') ? m.life - 1 : (m.maxLife||220) - 1;
                    m.pulse = (m.pulse || 0) + 1;
                    if (m.dead || m.life <= 0) { game.meteorMarkers.splice(i,1); continue; }
                    const t = 1 - (m.life / m.maxLife); // 0 -> 1
                    const baseAlpha = 0.55 * (1 - t);
                    const pulseA = 0.35 + 0.25*Math.sin(m.pulse/6);
                    const alpha = Math.max(0, Math.min(1, baseAlpha + pulseA*(1-t)));
                    const r = 26 + 24 * t; // ring expands slightly
                    const lineW = 3 + 2*Math.sin(m.pulse/5);
                    ctx.save();
                    ctx.translate(m.x, m.y);
                    // shadow / scorch oval (beneath ring)
                    ctx.globalAlpha = 0.35 * (1 - t);
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(0,0,r*1.15,r*0.55,0,0,Math.PI*2);
                    ctx.fill();
                    // main warning ring
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = (m.enemyTarget) ? '#ff8240' : '#ffcf40';
                    ctx.lineWidth = lineW;
                    ctx.beginPath();
                    ctx.ellipse(0,0,r,r*0.65,0,0,Math.PI*2);
                    ctx.stroke();
                    // inner hot core
                    const innerR = r*0.35 + 4*Math.sin(m.pulse/7);
                    ctx.globalAlpha = 0.35 + 0.25*Math.sin(m.pulse/4);
                    ctx.fillStyle = '#ffef9c';
                    ctx.beginPath();
                    ctx.ellipse(0,0,innerR,innerR*0.65,0,0,Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Photon strike beams (rendered after telegraphs, before enemies/projectiles overlays)
            if (Array.isArray(game.photonStrikes) && game.photonStrikes.length) {
                for (let i = game.photonStrikes.length - 1; i >= 0; i--) {
                    const s = game.photonStrikes[i];
                    s.life--;
                    if (s.life <= 0) { game.photonStrikes.splice(i,1); continue; }
                    const reduceBeams = !!(game.fxFlags && game.fxFlags.reduceBeams);
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const baseLife = s.life;
                    const maxLife = 24;
                    const alpha = baseLife / maxLife;
                    const grad = ctx.createLinearGradient(s.x1, s.y1, s.x2, s.y2);
                    const edgeA = alpha * (reduceBeams ? 0.25 : 0.35);
                    const midA = alpha * (reduceBeams ? 0.7 : 0.9);
                    grad.addColorStop(0, 'rgba(120,200,255,'+edgeA+')');
                    grad.addColorStop(0.5, 'rgba(255,255,255,'+midA+')');
                    grad.addColorStop(1, 'rgba(120,200,255,'+edgeA+')');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const width = (reduceBeams ? 3 : 4) + (reduceBeams ? 2 : 3) * alpha;
                    ctx.lineWidth = width;
                    ctx.strokeStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(s.x1, s.y1);
                    ctx.lineTo(s.x2, s.y2);
                    ctx.stroke();
                    // Impact flash orb (skip heavy second core on lowFx)
                    ctx.globalAlpha = alpha * (lowFx ? 0.6 : 0.85);
                    ctx.fillStyle = 'rgba(255,255,255,'+(alpha*(lowFx?0.45:0.6))+')';
                    ctx.beginPath();
                    ctx.arc(s.x2, s.y2, (s.impactSize||30) * (0.6 + 0.4*alpha) * (lowFx?0.85:1), 0, Math.PI*2);
                    ctx.fill();
                    if (!lowFx) {
                        // Subtle core
                        ctx.fillStyle = 'rgba(200,255,255,'+(alpha*0.8)+')';
                        ctx.beginPath();
                        ctx.arc(s.x2, s.y2, Math.max(6, (s.impactSize||30)*0.3*alpha), 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
                if (game.photonStrikes.length > 40) game.photonStrikes.length = 40; // defensive cap
            }

            // Traveling Shockwaves (Shockwave ability) - draw BEFORE enemies/projectiles so they appear on ground
            if (Array.isArray(game.shockwaves) && game.shockwaves.length) {
                game.shockwaves.forEach(w => {
                    const lifePct = w.life / w.maxLife; // 1 -> 0
                    const ax = Math.cos(w.angle), ay = Math.sin(w.angle);
                    const startDist = Math.max(0, w.distance - w.length);
                    const endDist = w.distance;
                    const startX = w.x + ax * startDist;
                    const startY = w.y + ay * startDist;
                    const endX = w.x + ax * endDist;
                    const endY = w.y + ay * endDist;
                    const width = w.width * (0.85 + 0.25*Math.sin((w.maxLife - w.life)/3));
                    const halfW = width * 0.5;
                    // Perp vector
                    const px = -ay, py = ax;
                    const fade = 0.55 * lifePct + 0.15*Math.sin(Date.now()/160 + w.x*0.03);
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, fade);
                    const grad = ctx.createLinearGradient(startX, startY, endX, endY);
                    grad.addColorStop(0, 'rgba(180,200,255,0)');
                    grad.addColorStop(0.15, 'rgba(160,190,255,0.25)');
                    grad.addColorStop(0.55, 'rgba(140,170,255,0.35)');
                    grad.addColorStop(1, 'rgba(110,140,220,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(startX + px*halfW, startY + py*halfW);
                    ctx.lineTo(endX + px*halfW, endY + py*halfW);
                    ctx.lineTo(endX - px*halfW, endY - py*halfW);
                    ctx.lineTo(startX - px*halfW, startY - py*halfW);
                    ctx.closePath();
                    ctx.fill();
                    // Edge highlights
                    ctx.globalAlpha = fade * 0.9;
                    ctx.strokeStyle = 'rgba(200,220,255,0.55)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(startX + px*halfW, startY + py*halfW);
                    ctx.lineTo(endX + px*halfW, endY + py*halfW);
                    ctx.moveTo(startX - px*halfW, startY - py*halfW);
                    ctx.lineTo(endX - px*halfW, endY - py*halfW);
                    ctx.stroke();
                    // Front impact arc (slightly rounded tip)
                    ctx.globalAlpha = fade * 0.75;
                    const tipR = Math.min(40, halfW * 0.8);
                    const tipGrad = ctx.createRadialGradient(endX, endY, tipR*0.15, endX, endY, tipR);
                    tipGrad.addColorStop(0,'rgba(255,255,255,0.55)');
                    tipGrad.addColorStop(1,'rgba(150,180,255,0)');
                    ctx.fillStyle = tipGrad;
                    ctx.beginPath();
                    ctx.arc(endX, endY, tipR, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                });
            }
            
            // Draw enemies (restored original logic)
            game.enemies.forEach(enemy => {
                // Elite aura pass (before sprite/procedural body). Skip for final boss or lowFX to reduce cost.
                if (enemy.elite && !enemy.finalBoss && !game.lowFX) {
                    const pulse = 0.6 + 0.4 * Math.sin(performance.now()/320 + enemy.x*0.015);
                    const baseR = (enemy.size || 12) * 1.45;
                    const grad = ctx.createRadialGradient(enemy.x, enemy.y, baseR*0.1, enemy.x, enemy.y, baseR);
                    grad.addColorStop(0, 'rgba(255,220,120,' + (0.55 * pulse).toFixed(3) + ')');
                    grad.addColorStop(1, 'rgba(255,150,40,0)');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, baseR, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
                let baseColor = enemy.color;
                if (enemy.wunderScribble) {
                    if (enemy.burning) {
                        baseColor = '#FF1F4D';
                    } else if (enemy.poisoned) {
                        baseColor = '#D6447B';
                    } else if (enemy.slowed) {
                        baseColor = '#B743FF';
                    } else {
                        baseColor = '#FF1A55';
                    }
                } else if (enemy.poisoned && enemy.burning) {
                    baseColor = '#8B4B00';
                } else if (enemy.poisoned && enemy.slowed) {
                    baseColor = '#4B6040';
                } else if (enemy.burning && enemy.slowed) {
                    baseColor = '#8B0080';
                } else if (enemy.poisoned) {
                    baseColor = '#4B8040';
                } else if (enemy.burning) {
                    baseColor = '#FF4040';
                } else if (enemy.slowed) {
                    baseColor = '#4040BB';
                }
                // Duck-style enemy drawing helper (lightweight, with fallback or sprite override)
                const drawDuckEnemy = (ctx, enemy, tintColor) => {
                    try {
                    // Robust golden-goose detection: match any type string containing 'goose' (case-insensitive)
                    const isGoldenGoose = (enemy && enemy.type && typeof enemy.type === 'string') ? enemy.type.toLowerCase().includes('goose') : false;
                    // Normalized lowercase type string for robust matching of variants (e.g. "Swandroid18" vs "Swandroid 18")
                    const typeStr = (enemy && (enemy.type || enemy.name || '')).toString().toLowerCase();
                    // Emergency quick-draw for Swandroid variants: try to render immediately from any
                    // available source (preflipped canvases, forced bitmap, or the image crop). This
                    // covers timing races where the sprite container exists but the later specialized
                    // branch isn't reached due to ordering or state. It also sets _noFallback so the
                    // magenta debug marker won't be drawn while the sprite is pending.
                    try {
                        if (typeStr.indexOf('swandroid') !== -1) {
                            const sa = game && game.enemySprites && game.enemySprites.swandroid18;
                            if (sa) {
                                const frameSet = sa.frames || {};
                                let facing = enemy.facing || 'down';
                                let box = frameSet[facing];
                                const img = sa.image;
                                const leftCanvas = sa._leftCanvas;
                                const rightCanvas = sa._rightCanvas;
                                const scale = sa.baseScaleForSize ? sa.baseScaleForSize(enemy.size || 52) : 1;
                                if (!box) { if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up; }
                                const srcW = (box && box.w) ? box.w : (sa._forcedBitmap ? sa._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || (enemy.size||52)*2);
                                const srcH = (box && box.h) ? box.h : (sa._forcedBitmap ? sa._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || (enemy.size||52)*2);
                                const drawW = srcW * scale;
                                const drawH = srcH * scale;
                                const dstW = Math.max(1, Math.round(drawW));
                                const dstH = Math.max(1, Math.round(drawH));
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                try { if (enemy) enemy._noFallback = true; } catch(_){ }
                                if (facing === 'left') {
                                    if (leftCanvas) { try { ctx.drawImage(leftCanvas, 0,0,leftCanvas.width,leftCanvas.height, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (sa._forcedBitmap) { try { ctx.scale(-1,1); ctx.drawImage(sa._forcedBitmap, (box?box.x:0),(box?box.y:0),(box?box.w:sa._forcedBitmap.width),(box?box.h:sa._forcedBitmap.height), -Math.round(dstW/2), -Math.round(dstH/2), dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (frameSet.right && img) { try { ctx.scale(-1,1); ctx.drawImage(img, frameSet.right.x, frameSet.right.y, frameSet.right.w, frameSet.right.h, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (img && box) { try { ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                } else if (facing === 'right') {
                                    if (rightCanvas) { try { ctx.drawImage(rightCanvas, 0,0,rightCanvas.width,rightCanvas.height, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (sa._forcedBitmap) { try { ctx.drawImage(sa._forcedBitmap, (box?box.x:0),(box?box.y:0),(box?box.w:sa._forcedBitmap.width),(box?box.h:sa._forcedBitmap.height), -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (img && frameSet.right) { try { ctx.drawImage(img, frameSet.right.x, frameSet.right.y, frameSet.right.w, frameSet.right.h, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (img && box) { try { ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                } else {
                                    const fbox = frameSet.front || frameSet.down || box;
                                    const rbox = frameSet.rear || frameSet.up || box;
                                    const useBox = (facing === 'down') ? fbox : (facing === 'up' ? rbox : box);
                                    if (sa._forcedBitmap && useBox) { try { ctx.drawImage(sa._forcedBitmap, useBox.x, useBox.y, useBox.w, useBox.h, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (img && useBox) { try { ctx.drawImage(img, useBox.x, useBox.y, useBox.w, useBox.h, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                    if (sa._forcedBitmap) { try { ctx.drawImage(sa._forcedBitmap, 0,0,sa._forcedBitmap.width,sa._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH); ctx.restore(); return; } catch(_){} }
                                }
                                ctx.restore();
                            }
                        }
                    } catch(_){}
                    // Tiny instrumentation: record when the renderer begins processing a Golden Goose
                    try {
                        if (isGoldenGoose) {
                            try { window._gg_drawEvents = window._gg_drawEvents || []; } catch(_){}
                            try {
                                const gg = (game && game.enemySprites && game.enemySprites.goldengoose) || null;
                                window._gg_drawEvents.push({ type: 'enter', time: Date.now(), enemy: { x: enemy.x, y: enemy.y, size: enemy.size, facing: enemy.facing }, gg: gg ? { loaded: !!gg.loaded, frames: !!gg.frames } : null });
                            } catch(_){}
                        }
                    } catch(_){}
                    // Strong early-guard: never perform the Wunderswan fallback draw here.
                    // The Wunderswan boss is rendered by the forced top-layer overlay later in the frame.
                    try {
                        if (enemy && enemy.type === 'Wunderswan') {
                            // Skip all procedural/fallback drawing for Wunderswan to avoid magenta debug markers
                            return;
                        }
                        // Thug sprite override
                        if (enemy.type === 'Thug' && game.enemySprites && game.enemySprites.thug && game.enemySprites.thug.loaded) {
                            const ts = game.enemySprites.thug;
                            const animations = ts.animations;
                            // Determine facing based on player's position relative to enemy's center
                            const playerX = (game && game.player) ? game.player.x : 0;
                            let facing = playerX < enemy.x ? 'left' : 'right';
                            const img = ts.image;
                            const size = enemy.size;
                            const scale = ts.baseScaleForSize ? ts.baseScaleForSize(size) : ((size*2)/256);
                            // Get sequence
                            let sequenceEntry = null;
                            if (animations && animations[facing]) {
                                sequenceEntry = animations[facing];
                            } else if (facing === 'left' && animations && animations.right) {
                                sequenceEntry = animations.right;
                            } else {
                                sequenceEntry = ts.defaultAnimation || (ts.anim && ts.anim.sequence ? { frames: ts.anim.sequence, frameStep: ts.anim.frameStep || 5 } : null);
                            }
                            if (sequenceEntry && sequenceEntry.frames && sequenceEntry.frames.length) {
                                const framesForSequence = sequenceEntry.frames;
                                const mirrorSequence = sequenceEntry.mirrorX === true;
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const frameStep = Math.max(1, sequenceEntry.frameStep || ts.animFrameStep || 5);
                                const sequenceLength = framesForSequence.length;
                                const frameIndex = Math.floor(nowFrame / frameStep) % sequenceLength;
                                const box = framesForSequence[frameIndex];
                                if (box && img) {
                                    const drawW = box.w * scale;
                                    const drawH = box.h * scale;
                                    ctx.save();
                                    ctx.translate(enemy.x, enemy.y);
                                    if (mirrorSequence && facing === 'left') {
                                        ctx.scale(-1, 1);
                                    }
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,255,0,0.6)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                    ctx.restore();
                                    return;
                                }
                            }
                        }
                        // Street Dog sprite override
                        if (enemy.type === 'Street Dog' && game.enemySprites && game.enemySprites.streetDog && game.enemySprites.streetDog.loaded) {
                            const ds = game.enemySprites.streetDog;
                            const animations = ds.animations;
                            // Determine facing based on player's position relative to enemy's center
                            const playerX = (game && game.player) ? game.player.x : 0;
                            let facing = playerX < enemy.x ? 'left' : 'right';
                            const img = ds.image;
                            const size = enemy.size;
                            const scale = ds.baseScaleForSize ? ds.baseScaleForSize(size) : ((size*2)/256);
                            // Get sequence
                            let sequenceEntry = null;
                            if (animations && animations[facing]) {
                                sequenceEntry = animations[facing];
                            } else if (facing === 'left' && animations.right) {
                                sequenceEntry = animations.right;
                            } else {
                                sequenceEntry = ds.defaultAnimation || (ds.anim && ds.anim.sequence ? { frames: ds.anim.sequence, frameStep: ds.anim.frameStep || 5 } : null);
                            }
                            if (sequenceEntry && sequenceEntry.frames && sequenceEntry.frames.length) {
                                const framesForSequence = sequenceEntry.frames;
                                const mirrorSequence = sequenceEntry.mirrorX === true;
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const frameStep = Math.max(1, sequenceEntry.frameStep || ds.animFrameStep || 5);
                                const sequenceLength = framesForSequence.length;
                                const frameIndex = Math.floor(nowFrame / frameStep) % sequenceLength;
                                const box = framesForSequence[frameIndex];
                                if (box && img) {
                                    const drawW = box.w * scale;
                                    const drawH = box.h * scale;
                                    ctx.save(); ctx.translate(enemy.x, enemy.y);
                                    if (mirrorSequence) ctx.scale(-1, 1);
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,200,255,0.6)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                    ctx.restore();
                                    return;
                                }
                            }
                        }
                        // The Quacken rare melee enemy uses a four-row spritesheet; mirror row 0 at draw time.
                        if (enemy.type === 'The Quacken' && game.enemySprites && game.enemySprites.quacken) {
                            const qs = game.enemySprites.quacken;
                            const seq = (qs.frames && qs.frames.seq) || (qs.anim && qs.anim.frames);
                            const columns = (qs.frames && qs.frames.columns) || (qs.anim && qs.anim.columns) || 8;
                            const rows = (qs.frames && qs.frames.rows) || (qs.anim && qs.anim.rows) || Math.max(1, Math.ceil((seq ? seq.length : 0) / Math.max(1, columns)));
                            const src = qs._forcedBitmap || qs.image;
                            if (src && seq && seq.length) {
                                const frameStep = Math.max(1, (qs.anim && qs.anim.frameStep) || 6);
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                if (typeof enemy._quackenAnimSeed !== 'number') enemy._quackenAnimSeed = nowFrame;
                                const animTicks = Math.max(0, nowFrame - enemy._quackenAnimSeed);
                                let facing = (enemy.facing && typeof enemy.facing === 'string') ? enemy.facing.toLowerCase() : '';
                                if (!facing || facing === 'idle') {
                                    const vx = (typeof enemy.vx === 'number') ? enemy.vx : ((typeof enemy.velX === 'number') ? enemy.velX : (typeof enemy.velocityX === 'number' ? enemy.velocityX : 0));
                                    const vy = (typeof enemy.vy === 'number') ? enemy.vy : ((typeof enemy.velY === 'number') ? enemy.velY : (typeof enemy.velocityY === 'number' ? enemy.velocityY : 0));
                                    if (Math.abs(vx) >= Math.abs(vy)) {
                                        if (vx < -0.05) facing = 'left';
                                        else if (vx > 0.05) facing = 'right';
                                    }
                                    if (!facing) {
                                        if (vy < -0.05) facing = 'up';
                                        else if (vy > 0.05) facing = 'down';
                                    }
                                }
                                if (!facing) {
                                    const playerX = (game && game.player) ? game.player.x : null;
                                    facing = (playerX != null && playerX < enemy.x) ? 'left' : 'right';
                                }
                                enemy.facing = facing;
                                let mirror = false;
                                let rowIndex = 0;
                                if (facing === 'left') { mirror = true; rowIndex = 0; }
                                else if (facing === 'right') { rowIndex = 0; }
                                else if (facing === 'down') { rowIndex = Math.min(rows - 1, 1); }
                                else if (facing === 'up') { rowIndex = Math.min(rows - 1, 2); }
                                const attacking = !!(enemy._attackTimer > 0 || enemy._meleeActive || enemy._isMeleeAttacking);
                                if (attacking && rows > 3) rowIndex = Math.min(rows - 1, 3);
                                const framesPerRow = Math.max(1, columns);
                                const frameOffset = Math.floor(animTicks / frameStep) % framesPerRow;
                                let frameIdx = rowIndex * framesPerRow + frameOffset;
                                if (frameIdx >= seq.length) frameIdx = seq.length - 1;
                                const box = seq[frameIdx] || seq[0];
                                if (box) {
                                    const enemySize = enemy.size || 42;
                                    const scale = qs.baseScaleForSize ? qs.baseScaleForSize(enemySize) : ((enemySize * 2) / Math.max(1, box.h));
                                    const drawW = box.w * scale;
                                    const drawH = box.h * scale;
                                    const offsetY = qs.drawOffsetY || 0;
                                    ctx.save();
                                    ctx.translate(enemy.x, enemy.y + offsetY);
                                    if (mirror) {
                                        ctx.scale(-1, 1);
                                        ctx.drawImage(src, box.x, box.y, box.w, box.h, -drawW / 2, -drawH / 2, drawW, drawH);
                                    } else {
                                        ctx.drawImage(src, box.x, box.y, box.w, box.h, -drawW / 2, -drawH / 2, drawW, drawH);
                                    }
                                    if (game._debugSpriteBounds) {
                                        ctx.strokeStyle = 'rgba(255,230,120,0.55)';
                                        ctx.strokeRect(-drawW / 2, -drawH / 2, drawW, drawH);
                                    }
                                    ctx.restore();
                                    if (typeof qs.computeHitbox === 'function') {
                                        const hb = qs.computeHitbox(enemy);
                                        if (hb && typeof hb.w === 'number' && typeof hb.h === 'number' && typeof hb.x === 'number' && typeof hb.y === 'number') {
                                            enemy.hitbox = { x: Math.round(hb.x), y: Math.round(hb.y), w: Math.round(hb.w), h: Math.round(hb.h) };
                                        }
                                    }
                                    enemy._noFallback = true;
                                    return;
                                }
                            }
                        }
                        // Swandroid 18 sprite override (Act III melee, non-ranged)
                        // Accept minor naming variants by matching any type that contains 'swandroid'
                        if (typeStr.indexOf('swandroid') !== -1 && game.enemySprites && game.enemySprites.swandroid18 && (game.enemySprites.swandroid18.loaded || game.enemySprites.swandroid18._forcedBitmap)) {
                            const sa = game.enemySprites.swandroid18;
                            const { seq } = sa.frames || {};
                            const { frameStep } = sa.anim || {};
                            const playerX = game.player ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            const animTicks = Math.floor(game.frame / (frameStep || 8));
                            const box = seq ? seq[animTicks % seq.length] : null;
                            const img = sa.image;
                            const size = enemy.size;
                            const scale = sa.baseScaleForSize ? sa.baseScaleForSize(size) : ((size*2)/256);
                            const srcW = (box && box.w) ? box.w : (sa._forcedBitmap ? sa._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || size*2);
                            const srcH = (box && box.h) ? box.h : (sa._forcedBitmap ? sa._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                ctx.scale(-1, 1);
                            }

                            if (sa._forcedBitmap && box) {
                                ctx.drawImage(sa._forcedBitmap, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (img && box) {
                                ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (sa._forcedBitmap) {
                                ctx.drawImage(sa._forcedBitmap, 0, 0, sa._forcedBitmap.width, sa._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH);
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(180,200,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Punk sprite override
                        if (enemy.type === 'Punk' && game.enemySprites && game.enemySprites.punk && game.enemySprites.punk.loaded) {
                            const ps = game.enemySprites.punk;
                            const animations = ps.animations;
                            // Determine facing based on player's position relative to enemy's center
                            const playerX = (game && game.player) ? game.player.x : 0;
                            let facing = playerX < enemy.x ? 'left' : 'right';
                            const img = ps.image;
                            const size = enemy.size;
                            const scale = ps.baseScaleForSize ? ps.baseScaleForSize(size) : ((size*2)/256);
                            // Get sequence
                            let sequenceEntry = null;
                            if (animations && animations[facing]) {
                                sequenceEntry = animations[facing];
                            } else if (facing === 'left' && animations && animations.right) {
                                sequenceEntry = animations.right;
                            } else {
                                sequenceEntry = ps.defaultAnimation || (ps.anim && ps.anim.sequence ? { frames: ps.anim.sequence, frameStep: ps.anim.frameStep || 5 } : null);
                            }
                            if (sequenceEntry && sequenceEntry.frames && sequenceEntry.frames.length) {
                                const framesForSequence = sequenceEntry.frames;
                                const mirrorSequence = sequenceEntry.mirrorX === true;
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const frameStep = Math.max(1, sequenceEntry.frameStep || ps.animFrameStep || 5);
                                const sequenceLength = framesForSequence.length;
                                const frameIndex = Math.floor(nowFrame / frameStep) % sequenceLength;
                                const box = framesForSequence[frameIndex];
                                if (box && img) {
                                    const drawW = box.w * scale;
                                    const drawH = box.h * scale;
                                    ctx.save();
                                    ctx.translate(enemy.x, enemy.y);
                                    if (mirrorSequence && facing === 'left') {
                                        ctx.scale(-1, 1);
                                    }
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,0,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                    ctx.restore();
                                    return;
                                }
                            }
                        }
                        // Eggscobar sprite override (Act II only)
                        if (enemy.type === 'Eggscobar' && game.enemySprites && game.enemySprites.eggscobar && game.enemySprites.eggscobar.loaded) {
                            const es = game.enemySprites.eggscobar;
                            const frameSet = es.frames;
                            let facing = (game && game.player && game.player.x >= enemy.x) ? 'right' : 'left';
                            let box = null;
                            const img = es.image;
                            const size = enemy.size;
                            const scale = es.baseScaleForSize ? es.baseScaleForSize(size) : ((size*2)/256);
                            if (Array.isArray(frameSet)) {
                                // Animated frames
                                const frameStep = 5;
                                const nowFrame = game.frame || Math.floor(Date.now() / 16);
                                const idx = Math.floor(nowFrame / frameStep) % frameSet.length;
                                box = frameSet[idx];
                            } else {
                                // Fallback to static
                                box = frameSet[facing];
                                if (!box) {
                                    if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                                }
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,215,100,0.65)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Dealer sprite override
                        if (enemy.type === 'Dealer' && game.enemySprites && game.enemySprites.dealer && game.enemySprites.dealer.loaded) {
                            const ds = game.enemySprites.dealer;
                            const animations = ds.animations;
                            // Determine facing based on player's position relative to enemy's center
                            const playerX = (game && game.player) ? game.player.x : 0;
                            let facing = playerX < enemy.x ? 'left' : 'right';
                            const img = ds.image;
                            const size = enemy.size;
                            const scale = ds.baseScaleForSize ? ds.baseScaleForSize(size) : ((size*2)/256);
                            // Get sequence
                            let sequenceEntry = null;
                            if (animations && animations[facing]) {
                                sequenceEntry = animations[facing];
                            } else if (facing === 'left' && animations && animations.right) {
                                sequenceEntry = animations.right;
                            } else {
                                sequenceEntry = ds.defaultAnimation || (ds.anim && ds.anim.sequence ? { frames: ds.anim.sequence, frameStep: ds.anim.frameStep || 5 } : null);
                            }
                            if (sequenceEntry && sequenceEntry.frames && sequenceEntry.frames.length) {
                                const framesForSequence = sequenceEntry.frames;
                                const mirrorSequence = sequenceEntry.mirrorX === true;
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const frameStep = Math.max(1, sequenceEntry.frameStep || ds.animFrameStep || 5);
                                const sequenceLength = framesForSequence.length;
                                const frameIndex = Math.floor(nowFrame / frameStep) % sequenceLength;
                                const box = framesForSequence[frameIndex];
                                if (box && img) {
                                    const drawW = box.w * scale;
                                    const drawH = box.h * scale;
                                    ctx.save();
                                    ctx.translate(enemy.x, enemy.y);
                                    if (mirrorSequence && facing === 'left') {
                                        ctx.scale(-1, 1);
                                    }
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,255,0,0.6)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                    ctx.restore();
                                    return;
                                }
                            }
                        }
                        // Gangster sprite override
                        if (enemy.type === 'Gangster' && game.enemySprites && game.enemySprites.gangster && game.enemySprites.gangster.loaded) {
                            const gs = game.enemySprites.gangster;
                            const size = enemy.size;
                            const vx = (typeof enemy.vx === 'number') ? enemy.vx : ((typeof enemy.velX === 'number') ? enemy.velX : (typeof enemy.velocityX === 'number' ? enemy.velocityX : 0));
                            const vy = (typeof enemy.vy === 'number') ? enemy.vy : ((typeof enemy.velY === 'number') ? enemy.velY : (typeof enemy.velocityY === 'number' ? enemy.velocityY : 0));
                            const rawFacing = (enemy.facing && typeof enemy.facing === 'string') ? enemy.facing.toLowerCase() : '';
                            let facing = rawFacing;
                            // Determine facing based on player position (for horizontal) and velocity (for vertical)
                            let playerX = (game && game.player && typeof game.player.x === 'number') ? game.player.x : null;
                            let horizontalFacing = null;
                            if (playerX !== null) {
                                horizontalFacing = playerX < enemy.x ? 'left' : 'right';
                            }
                            if (!facing || facing === 'idle') {
                                if (horizontalFacing) {
                                    facing = horizontalFacing;
                                } else if (Math.abs(vx) >= Math.abs(vy) && Math.abs(vx) > 0.05) {
                                    facing = vx < 0 ? 'left' : 'right';
                                } else if (vy < -0.05) {
                                    facing = 'up';
                                } else if (vy > 0.05) {
                                    facing = 'down';
                                }
                            }
                            if (facing === 'down' || facing === 'up') {
                                if (horizontalFacing) {
                                    facing = horizontalFacing;
                                } else if (Math.abs(vx) > 0.05) {
                                    facing = vx < 0 ? 'left' : 'right';
                                } else if (typeof enemy._gangsterLastHorizontalFacing === 'string') {
                                    facing = enemy._gangsterLastHorizontalFacing;
                                }
                            }
                            if (facing !== 'left' && facing !== 'right') {
                                if (horizontalFacing) {
                                    facing = horizontalFacing;
                                } else if (Math.abs(vx) > 0.05) {
                                    facing = vx < 0 ? 'left' : 'right';
                                } else {
                                    facing = (typeof enemy._gangsterLastHorizontalFacing === 'string') ? enemy._gangsterLastHorizontalFacing : 'right';
                                }
                            }
                            if (facing === 'left' || facing === 'right') {
                                enemy._gangsterLastHorizontalFacing = facing;
                            }
                            try { enemy.facing = facing; } catch(_) {}
                            const animations = gs.animations;
                            const resolveSequence = (key)=> {
                                if (!animations || typeof animations !== 'object') return null;
                                const candidate = animations[key];
                                if (!candidate) return null;
                                const seqFrames = candidate.frames;
                                if (!Array.isArray(seqFrames) || !seqFrames.length) return null;
                                return candidate;
                            };
                            let sequenceEntry = resolveSequence(facing);
                            if (!sequenceEntry && facing === 'left') {
                                sequenceEntry = resolveSequence('left') || resolveSequence('right');
                            }
                            if (!sequenceEntry && (facing === 'down' || facing === 'up')) {
                                sequenceEntry = resolveSequence('down') || resolveSequence('up') || resolveSequence('right');
                            }
                            if (!sequenceEntry) {
                                sequenceEntry = resolveSequence('idle');
                            }
                            if (!sequenceEntry) {
                                const fallbackSeq = gs.defaultAnimation || (gs.anim && Array.isArray(gs.anim.sequence) ? { frames: gs.anim.sequence, frameStep: gs.anim.frameStep || 5, id: 'gangster-generic', mirrorX: false } : null);
                                if (fallbackSeq && Array.isArray(fallbackSeq.frames) && fallbackSeq.frames.length) {
                                    sequenceEntry = fallbackSeq;
                                }
                            }
                            if (sequenceEntry && Array.isArray(sequenceEntry.frames) && sequenceEntry.frames.length) {
                                const framesForSequence = sequenceEntry.frames;
                                const mirrorSequence = sequenceEntry.mirrorX === true;
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const frameStep = Math.max(1, sequenceEntry.frameStep || gs.animFrameStep || 5);
                                const sequenceId = (sequenceEntry.id || sequenceEntry.source || facing || 'gangster') + (mirrorSequence ? '_M' : '_N');
                                if (enemy._gangsterAnimFacing !== sequenceId) {
                                    enemy._gangsterAnimFacing = sequenceId;
                                    enemy._gangsterAnimStart = nowFrame;
                                }
                                if (typeof enemy._gangsterAnimStart !== 'number') {
                                    enemy._gangsterAnimStart = nowFrame;
                                }
                                const elapsed = Math.max(0, nowFrame - enemy._gangsterAnimStart);
                                const idx = Math.floor(elapsed / frameStep) % framesForSequence.length;
                                const frame = framesForSequence[idx] || framesForSequence[0];
                                enemy._gangsterAnimFrame = idx;
                                let applyFlip = false;
                                let preparedSource = null;
                                if (mirrorSequence) {
                                    if (frame.mirroredCanvas) {
                                        preparedSource = frame.mirroredCanvas;
                                    } else if (frame.canvas) {
                                        preparedSource = frame.canvas;
                                        applyFlip = true;
                                    } else if (frame.bitmap) {
                                        preparedSource = frame.bitmap;
                                        applyFlip = true;
                                    }
                                }
                                if (!preparedSource) {
                                    preparedSource = frame.canvas || frame.bitmap || null;
                                }
                                const preparedWidth = preparedSource ? (preparedSource.width || frame.preparedWidth || frame.w || 1) : (gs.preparedWidth || frame.w || 1);
                                const preparedHeight = preparedSource ? (preparedSource.height || frame.preparedHeight || frame.h || 1) : (gs.preparedHeight || frame.h || 1);
                                const referenceHeight = gs.referenceHeight || frame.visibleHeight || frame.h || preparedHeight || 1;
                                const baseScale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/Math.max(1, referenceHeight));
                                const drawW = preparedWidth * baseScale;
                                const drawH = preparedHeight * baseScale;
                                const anchorBaseX = (typeof frame.anchorRatioX === 'number') ? frame.anchorRatioX : (typeof gs.anchorRatioX === 'number' ? gs.anchorRatioX : 0.5);
                                const baselineRefY = (typeof frame.baselineRatio === 'number') ? frame.baselineRatio : (typeof gs.baselineRatio === 'number' ? gs.baselineRatio : 1);
                                let destX = -drawW * anchorBaseX;
                                const destY = -drawH * baselineRefY;
                                ctx.save();
                                ctx.translate(enemy.x, enemy.y);
                                if (applyFlip) {
                                    ctx.scale(-1, 1);
                                    destX = drawW * anchorBaseX;
                                }
                                const sourceImage = preparedSource || gs.image;
                                const srcX = preparedSource ? 0 : frame.sourceX;
                                const srcY = preparedSource ? 0 : frame.sourceY;
                                const srcW = preparedSource ? preparedWidth : frame.w;
                                const srcH = preparedSource ? preparedHeight : frame.h;
                                ctx.drawImage(sourceImage, srcX, srcY, srcW, srcH, destX, destY, drawW, drawH);
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,255,255,0.55)'; ctx.strokeRect(destX, destY, drawW, drawH); }
                                ctx.restore();
                                try { enemy._noFallback = true; } catch(_) {}
                                return;
                            }
                            const frameSet = gs.frames || {};
                            let fallbackFrame = frameSet[facing];
                            let flipForFallback = false;
                            if (!fallbackFrame) {
                                if (facing === 'left' && frameSet.right) {
                                    fallbackFrame = frameSet.right;
                                    flipForFallback = true;
                                } else {
                                    fallbackFrame = frameSet.right || frameSet.down || frameSet.up || null;
                                }
                            }
                            if (fallbackFrame) {
                                const preparedSource = fallbackFrame.canvas || null;
                                const preparedWidth = preparedSource ? (preparedSource.width || fallbackFrame.preparedWidth || fallbackFrame.w || 1) : (gs.preparedWidth || fallbackFrame.w || 1);
                                const preparedHeight = preparedSource ? (preparedSource.height || fallbackFrame.preparedHeight || fallbackFrame.h || 1) : (gs.preparedHeight || fallbackFrame.h || 1);
                                const referenceHeight = gs.referenceHeight || fallbackFrame.visibleHeight || fallbackFrame.h || preparedHeight || 1;
                                const baseScale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/Math.max(1, referenceHeight));
                                const drawW = preparedWidth * baseScale;
                                const drawH = preparedHeight * baseScale;
                                const anchorBaseX = (typeof fallbackFrame.anchorRatioX === 'number') ? fallbackFrame.anchorRatioX : (typeof gs.anchorRatioX === 'number' ? gs.anchorRatioX : 0.5);
                                const anchorRefX = (flipForFallback && typeof fallbackFrame.mirrorAnchorRatioX === 'number') ? fallbackFrame.mirrorAnchorRatioX : anchorBaseX;
                                const baselineRefY = (typeof fallbackFrame.baselineRatio === 'number') ? fallbackFrame.baselineRatio : (typeof gs.baselineRatio === 'number' ? gs.baselineRatio : 1);
                                const destX = -drawW * anchorRefX;
                                const destY = -drawH * baselineRefY;
                                ctx.save();
                                ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left' || flipForFallback) {
                                    if (fallbackFrame.mirroredCanvas) {
                                        ctx.drawImage(fallbackFrame.mirroredCanvas, 0, 0, fallbackFrame.mirroredCanvas.width, fallbackFrame.mirroredCanvas.height, destX, destY, drawW, drawH);
                                    } else if (preparedSource) {
                                        ctx.scale(-1, 1);
                                        ctx.drawImage(preparedSource, 0, 0, preparedWidth, preparedHeight, -(destX + drawW), destY, drawW, drawH);
                                    } else {
                                        ctx.scale(-1, 1);
                                        ctx.drawImage(gs.image, fallbackFrame.sourceX, fallbackFrame.sourceY, fallbackFrame.w, fallbackFrame.h, -(destX + drawW), destY, drawW, drawH);
                                    }
                                } else {
                                    ctx.drawImage(preparedSource || gs.image, preparedSource ? 0 : fallbackFrame.sourceX, preparedSource ? 0 : fallbackFrame.sourceY, preparedSource ? preparedWidth : fallbackFrame.w, preparedSource ? preparedHeight : fallbackFrame.h, destX, destY, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(0,255,255,0.55)'; ctx.strokeRect(destX, destY, drawW, drawH); }
                                ctx.restore();
                                try { enemy._noFallback = true; } catch(_) {}
                                return;
                            }
                        }
                        // Goose Willis sprite override (Act II ranged grunt)
                        if (enemy.type === 'Goose Willis' && game.enemySprites && game.enemySprites.gooseWillis && game.enemySprites.gooseWillis.loaded) {
                            const ws = game.enemySprites.gooseWillis;
                            const frameSet = ws.frames;
                            let facing = (game && game.player && game.player.x >= enemy.x) ? 'right' : 'left';
                            let box = null;
                            const img = ws.image;
                            const size = enemy.size;
                            const scale = ws.baseScaleForSize ? ws.baseScaleForSize(size) : ((size*2)/256);
                            if (Array.isArray(frameSet)) {
                                // Animated frames
                                const frameStep = 5;
                                const nowFrame = game.frame || Math.floor(Date.now() / 16);
                                const idx = Math.floor(nowFrame / frameStep) % frameSet.length;
                                box = frameSet[idx];
                            } else {
                                // Fallback to static
                                box = frameSet[facing];
                                if (!box) {
                                    if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                                }
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(180,200,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Lil Goosey sprite override (Act II small ranged grunt)
                        if (enemy.type === 'Lil Goosey' && game.enemySprites && game.enemySprites.lilGoosey && game.enemySprites.lilGoosey.loaded) {
                            const lg = game.enemySprites.lilGoosey;
                            const frameSet = lg.frames;
                            let facing = (game && game.player && game.player.x >= enemy.x) ? 'right' : 'left';
                            let box = null;
                            const img = lg.image;
                            const size = enemy.size;
                            const scale = lg.baseScaleForSize ? lg.baseScaleForSize(size) : ((size*2)/256);
                            if (Array.isArray(frameSet)) {
                                // Animated frames
                                const frameStep = 5;
                                const nowFrame = game.frame || Math.floor(Date.now() / 16);
                                const idx = Math.floor(nowFrame / frameStep) % frameSet.length;
                                box = frameSet[idx];
                            } else {
                                // Fallback to static
                                box = frameSet[facing];
                                if (!box) {
                                    if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                                }
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(180,220,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Goosey Smalls sprite override (Act II melee grunt)
                        if (enemy.type === 'Goosey Smalls' && game.enemySprites && game.enemySprites.gooseySmalls && game.enemySprites.gooseySmalls.loaded) {
                            const gs = game.enemySprites.gooseySmalls;
                            const frameSet = gs.frames;
                            let facing = (game && game.player && game.player.x >= enemy.x) ? 'right' : 'left';
                            let box = null;
                            const img = gs.image;
                            const size = enemy.size;
                            const scale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/256);
                            if (Array.isArray(frameSet)) {
                                // Animated frames
                                const frameStep = 5;
                                const nowFrame = game.frame || Math.floor(Date.now() / 16);
                                const idx = Math.floor(nowFrame / frameStep) % frameSet.length;
                                box = frameSet[idx];
                            } else {
                                // Fallback to static
                                box = frameSet[facing];
                                if (!box) {
                                    if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                                }
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(180,255,180,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Goosey Elliot sprite override (Act II melee grunt)
                        if (enemy.type === 'Goosey Elliot' && game.enemySprites && game.enemySprites.gooseyElliot && game.enemySprites.gooseyElliot.loaded) {
                            const ge = game.enemySprites.gooseyElliot;
                            const frameSet = ge.frames;
                            let facing = (game && game.player && game.player.x >= enemy.x) ? 'right' : 'left';
                            let box = null;
                            const img = ge.image;
                            const size = enemy.size;
                            const scale = ge.baseScaleForSize ? ge.baseScaleForSize(size) : ((size*2)/256);
                            if (Array.isArray(frameSet)) {
                                // Animated frames
                                const frameStep = 5;
                                const nowFrame = game.frame || Math.floor(Date.now() / 16);
                                const idx = Math.floor(nowFrame / frameStep) % frameSet.length;
                                box = frameSet[idx];
                            } else {
                                // Fallback to static
                                box = frameSet[facing];
                                if (!box) {
                                    if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                                }
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,220,200,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Fowl Pacino sprite override (Act II melee grunt)
                        if (enemy.type === 'Fowl Pacino' && game.enemySprites && game.enemySprites.fowlPacino && game.enemySprites.fowlPacino.loaded) {
                            const fp = game.enemySprites.fowlPacino;
                            const frameSet = fp.frames;
                            let facing = (game && game.player && game.player.x >= enemy.x) ? 'right' : 'left';
                            let box = null;
                            const img = fp.image;
                            const size = enemy.size;
                            const scale = fp.baseScaleForSize ? fp.baseScaleForSize(size) : ((size*2)/256);
                            if (Array.isArray(frameSet)) {
                                // Animated frames
                                const frameStep = 5;
                                const nowFrame = game.frame || Math.floor(Date.now() / 16);
                                const idx = Math.floor(nowFrame / frameStep) % frameSet.length;
                                box = frameSet[idx];
                            } else {
                                // Fallback to static
                                box = frameSet[facing];
                                if (!box) {
                                    if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                                }
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,200,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Geese Robbins sprite override (Act II ranged grunt)
                        if (enemy.type === 'Geese Robbins' && game.enemySprites && game.enemySprites.geeseRobbins && game.enemySprites.geeseRobbins.loaded) {
                            const gr = game.enemySprites.geeseRobbins;
                            const frameSet = gr.frames;
                            let facing = (game && game.player && game.player.x >= enemy.x) ? 'right' : 'left';
                            let box = null;
                            const img = gr.image;
                            const size = enemy.size;
                            const scale = gr.baseScaleForSize ? gr.baseScaleForSize(size) : ((size*2)/256);
                            if (Array.isArray(frameSet)) {
                                // Animated frames
                                const frameStep = 5;
                                const nowFrame = game.frame || Math.floor(Date.now() / 16);
                                const idx = Math.floor(nowFrame / frameStep) % frameSet.length;
                                box = frameSet[idx];
                            } else {
                                // Fallback to static
                                box = frameSet[facing];
                                if (!box) {
                                    if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                                }
                            }
                            if (box && img) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(180,200,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Cardi Beak sprite override (Act III ranged)
                        if (enemy.type === 'Cardi Beak' && game.enemySprites && game.enemySprites.cardiBeak && (game.enemySprites.cardiBeak.loaded || game.enemySprites.cardiBeak._forcedBitmap)) {
                            const cb = game.enemySprites.cardiBeak;
                            const { seq } = cb.frames || {};
                            const { frameStep } = cb.anim || {};
                            const playerX = game.player ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            const animTicks = Math.floor(game.frame / (frameStep || 8));
                            const box = seq ? seq[animTicks % seq.length] : null;
                            const img = cb.image;
                            const size = enemy.size;
                            const scale = cb.baseScaleForSize ? cb.baseScaleForSize(size) : ((size*2)/256);
                            const srcW = (box && box.w) ? box.w : (cb._forcedBitmap ? cb._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || size*2);
                            const srcH = (box && box.h) ? box.h : (cb._forcedBitmap ? cb._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                ctx.scale(-1, 1);
                            }

                            if (cb._forcedBitmap && box) {
                                ctx.drawImage(cb._forcedBitmap, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (img && box) {
                                ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (cb._forcedBitmap) {
                                ctx.drawImage(cb._forcedBitmap, 0, 0, cb._forcedBitmap.width, cb._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH);
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,180,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // The Honkinator sprite override (Act III ranged)
                        if (enemy.type === 'The Honkinator' && game.enemySprites && game.enemySprites.honkinator && (game.enemySprites.honkinator.loaded || game.enemySprites.honkinator._forcedBitmap)) {
                            const hk = game.enemySprites.honkinator;
                            const { seq } = hk.frames || {};
                            const { frameStep } = hk.anim || {};
                            const playerX = game.player ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            const animTicks = Math.floor(game.frame / (frameStep || 8));
                            const box = seq ? seq[animTicks % seq.length] : null;
                            const img = hk.image;
                            const size = enemy.size;
                            const scale = hk.baseScaleForSize ? hk.baseScaleForSize(size) : ((size*2)/256);
                            const srcW = (box && box.w) ? box.w : (hk._forcedBitmap ? hk._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || size*2);
                            const srcH = (box && box.h) ? box.h : (hk._forcedBitmap ? hk._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                ctx.scale(-1, 1);
                            }

                            if (hk._forcedBitmap && box) {
                                ctx.drawImage(hk._forcedBitmap, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (img && box) {
                                ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (hk._forcedBitmap) {
                                ctx.drawImage(hk._forcedBitmap, 0, 0, hk._forcedBitmap.width, hk._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH);
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,200,255,0.45)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Cygnus Prime sprite override (Act III boss)
                        if (enemy.type === 'Cygnus Prime' && game.enemySprites && game.enemySprites.cygnusPrime && (game.enemySprites.cygnusPrime.loaded || game.enemySprites.cygnusPrime._forcedBitmap)) {
                            const cp = game.enemySprites.cygnusPrime;
                            const { seq } = cp.frames || {};
                            const { frameStep } = cp.anim || {};
                            const playerX = game.player ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            const animTicks = Math.floor(game.frame / (frameStep || 8));
                            const box = seq ? seq[animTicks % seq.length] : null;
                            const img = cp.image;
                            const size = enemy.size;
                            const scale = cp.baseScaleForSize ? cp.baseScaleForSize(size) : ((size*2)/256);
                            const srcW = (box && box.w) ? box.w : (cp._forcedBitmap ? cp._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || size*2);
                            const srcH = (box && box.h) ? box.h : (cp._forcedBitmap ? cp._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                ctx.scale(-1, 1);
                            }

                            if (cp._forcedBitmap && box) {
                                ctx.drawImage(cp._forcedBitmap, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (img && box) {
                                ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (cp._forcedBitmap) {
                                ctx.drawImage(cp._forcedBitmap, 0, 0, cp._forcedBitmap.width, cp._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH);
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,200,255,0.45)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Swan Wick sprite override (Act III ranged)
                        if (enemy.type === 'Swan Wick' && game.enemySprites && game.enemySprites.swanwick && (game.enemySprites.swanwick.loaded || game.enemySprites.swanwick._forcedBitmap || game.enemySprites.swanwick._leftCanvas)) {
                            const sw = game.enemySprites.swanwick;
                            const frameSet = sw.frames || {};
                            const seq = frameSet.seq || [];
                            const img = sw.image;
                            const leftCanvas = sw._leftCanvas;
                            const rightCanvas = sw._rightCanvas;
                            const size = enemy.size;
                            // Determine facing based on player position for centering
                            const playerX = (game && game.player) ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            // Calculate current animation frame
                            let box = frameSet.right; // default
                            if (seq.length > 0) {
                                const frameStep = Math.max(1, (sw.anim && sw.anim.frameStep) || 8);
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                if (typeof enemy._swAnimSeed !== 'number') enemy._swAnimSeed = nowFrame;
                                const animTicks = Math.max(0, nowFrame - enemy._swAnimSeed);
                                let frameIdx = Math.floor(animTicks / frameStep) % seq.length;
                                box = seq[frameIdx];
                            }
                            const scale = sw.baseScaleForSize ? sw.baseScaleForSize(size) : ((size*2)/(box?box.h:256));
                            const srcW = (box && box.w) ? box.w : 256;
                            const srcH = (box && box.h) ? box.h : 256;
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));
                            if (facing === 'left') {
                                // Mirror horizontally
                                ctx.scale(-1, 1);
                                if (img && box) {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                                }
                            } else {
                                // Right: use normal
                                if (img && box) {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                                }
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,200,255,0.45)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Swanomaly sprite override (Act III melee)
                        if (enemy.type === 'Swanomaly' && game.enemySprites && game.enemySprites.swanomaly && (game.enemySprites.swanomaly.loaded || game.enemySprites.swanomaly._forcedBitmap)) {
                            const sa = game.enemySprites.swanomaly;
                            const { seq } = sa.frames || {};
                            const { frameStep } = sa.anim || {};
                            const playerX = game.player ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            const animTicks = Math.floor(game.frame / (frameStep || 8));
                            const box = seq ? seq[animTicks % seq.length] : null;
                            const img = sa.image;
                            const size = enemy.size;
                            const scale = sa.baseScaleForSize ? sa.baseScaleForSize(size) : ((size*2)/256);
                            const srcW = (box && box.w) ? box.w : (sa._forcedBitmap ? sa._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || size*2);
                            const srcH = (box && box.h) ? box.h : (sa._forcedBitmap ? sa._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                ctx.scale(-1, 1);
                            }

                            if (sa._forcedBitmap && box) {
                                ctx.drawImage(sa._forcedBitmap, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (img && box) {
                                ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (sa._forcedBitmap) {
                                ctx.drawImage(sa._forcedBitmap, 0, 0, sa._forcedBitmap.width, sa._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH);
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,200,255,0.45)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Mr Gosling sprite override (Act III ranged)
                        if (enemy.type === 'Mr Gosling' && game.enemySprites && game.enemySprites.mrGosling && (game.enemySprites.mrGosling.loaded || game.enemySprites.mrGosling._forcedBitmap)) {
                            const mg = game.enemySprites.mrGosling;
                            const { seq } = mg.frames || {};
                            const { frameStep } = mg.anim || {};
                            const playerX = game.player ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            const animTicks = Math.floor(game.frame / (frameStep || 8));
                            const box = seq ? seq[animTicks % seq.length] : null;
                            const img = mg.image;
                            const size = enemy.size;
                            const scale = mg.baseScaleForSize ? mg.baseScaleForSize(size) : ((size*2)/256);
                            const srcW = (box && box.w) ? box.w : (mg._forcedBitmap ? mg._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || size*2);
                            const srcH = (box && box.h) ? box.h : (mg._forcedBitmap ? mg._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                ctx.scale(-1, 1);
                            }

                            if (mg._forcedBitmap && box) {
                                ctx.drawImage(mg._forcedBitmap, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (img && box) {
                                ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (mg._forcedBitmap) {
                                ctx.drawImage(mg._forcedBitmap, 0, 0, mg._forcedBitmap.width, mg._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH);
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(220,200,220,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Swan Wick sprite override (Act III ranged)
                        if (enemy.type === 'Swan Wick' && game.enemySprites && game.enemySprites.swanwick && (game.enemySprites.swanwick.loaded || game.enemySprites.swanwick._forcedBitmap || game.enemySprites.swanwick._leftCanvas)) {
                            const sw = game.enemySprites.swanwick;
                            const frameSet = sw.frames || {};
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            const img = sw.image;
                            const leftCanvas = sw._leftCanvas;
                            const rightCanvas = sw._rightCanvas;
                            const size = enemy.size;
                            const scale = sw.baseScaleForSize ? sw.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            if (!box) { if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up; }
                            const srcW = (box && box.w) ? box.w : (sw._forcedBitmap ? sw._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || enemy.size*2);
                            const srcH = (box && box.h) ? box.h : (sw._forcedBitmap ? sw._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || enemy.size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                if (leftCanvas) {
                                    try { ctx.drawImage(leftCanvas, 0, 0, leftCanvas.width, leftCanvas.height, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                } else if (sw._forcedBitmap) {
                                    try { ctx.scale(-1,1); ctx.drawImage(sw._forcedBitmap, (box?box.x:0), (box?box.y:0), (box?box.w:sw._forcedBitmap.width), (box?box.h:sw._forcedBitmap.height), -Math.round(dstW/2), -Math.round(dstH/2), dstW, dstH); } catch(_){ }
                                } else if (frameSet.right && img) {
                                    try { ctx.scale(-1,1); ctx.drawImage(img, frameSet.right.x, frameSet.right.y, frameSet.right.w, frameSet.right.h, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                } else if (img && box) {
                                    try { ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                }
                            } else if (facing === 'right') {
                                if (rightCanvas) {
                                    try { ctx.drawImage(rightCanvas, 0, 0, rightCanvas.width, rightCanvas.height, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                } else if (sw._forcedBitmap) {
                                    try { ctx.drawImage(sw._forcedBitmap, (box?box.x:0), (box?box.y:0), (box?box.w:sw._forcedBitmap.width), (box?box.h:sw._forcedBitmap.height), -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                } else if (img && frameSet.right) {
                                    try { ctx.drawImage(img, frameSet.right.x, frameSet.right.y, frameSet.right.w, frameSet.right.h, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                } else if (img && box) {
                                    try { ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                }
                            } else {
                                const fbox = frameSet.front || frameSet.down || box;
                                const rbox = frameSet.rear || frameSet.up || box;
                                const useBox = (facing === 'down') ? fbox : (facing === 'up' ? rbox : box);
                                if (sw._forcedBitmap && useBox) {
                                    try { ctx.drawImage(sw._forcedBitmap, useBox.x, useBox.y, useBox.w, useBox.h, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                } else if (img && useBox) {
                                    try { ctx.drawImage(img, useBox.x, useBox.y, useBox.w, useBox.h, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                } else if (sw._forcedBitmap) {
                                    try { ctx.drawImage(sw._forcedBitmap, 0, 0, sw._forcedBitmap.width, sw._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH); } catch(_){ }
                                }
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(220,200,220,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Feather Krueger sprite override (Act III ranged)
                        if (enemy.type === 'Feather Krueger' && game.enemySprites && game.enemySprites.featherKrueger && (game.enemySprites.featherKrueger.loaded || game.enemySprites.featherKrueger._forcedBitmap || game.enemySprites.featherKrueger._leftCanvas)) {
                            const fk = game.enemySprites.featherKrueger;
                            const frameSet = fk.frames || {};
                            const seq = frameSet.seq || [];
                            const img = fk.image;
                            const leftCanvas = fk._leftCanvas;
                            const rightCanvas = fk._rightCanvas;
                            const size = enemy.size;
                            // Determine facing based on player position for centering
                            const playerX = (game && game.player) ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            // Calculate current animation frame
                            let box = frameSet.right; // default
                            if (seq.length > 0) {
                                const frameStep = Math.max(1, (fk.anim && fk.anim.frameStep) || 8);
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                if (typeof enemy._fkAnimSeed !== 'number') enemy._fkAnimSeed = nowFrame;
                                const animTicks = Math.max(0, nowFrame - enemy._fkAnimSeed);
                                let frameIdx = Math.floor(animTicks / frameStep) % seq.length;
                                box = seq[frameIdx];
                            }
                            const scale = fk.baseScaleForSize ? fk.baseScaleForSize(size) : ((size*2)/(box?box.h:256));
                            const srcW = (box && box.w) ? box.w : 256;
                            const srcH = (box && box.h) ? box.h : 256;
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));
                            if (facing === 'left') {
                                // Mirror horizontally
                                ctx.scale(-1, 1);
                                if (img && box) {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                                }
                            } else {
                                // Right: use normal
                                if (img && box) {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                                }
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,180,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // Honkutus of Cygnus sprite override (Act III ranged)
                        if (enemy.type === 'Honkutus of Cygnus' && game.enemySprites && game.enemySprites.honkutusOfCygnus && (game.enemySprites.honkutusOfCygnus.loaded || game.enemySprites.honkutusOfCygnus._forcedBitmap)) {
                            const hk = game.enemySprites.honkutusOfCygnus;
                            const { seq } = hk.frames || {};
                            const { frameStep } = hk.anim || {};
                            const playerX = game.player ? game.player.x : 0;
                            const facing = (playerX < enemy.x) ? 'left' : 'right';
                            const animTicks = Math.floor(game.frame / (frameStep || 8));
                            const box = seq ? seq[animTicks % seq.length] : null;
                            const img = hk.image;
                            const size = enemy.size;
                            const scale = hk.baseScaleForSize ? hk.baseScaleForSize(size) : ((size*2)/256);
                            const srcW = (box && box.w) ? box.w : (hk._forcedBitmap ? hk._forcedBitmap.width : (img && (img.naturalWidth || img.width)) || size*2);
                            const srcH = (box && box.h) ? box.h : (hk._forcedBitmap ? hk._forcedBitmap.height : (img && (img.naturalHeight || img.height)) || size*2);
                            const drawW = srcW * scale;
                            const drawH = srcH * scale;

                            ctx.save(); ctx.translate(enemy.x, enemy.y);
                            if (typeof ctx.imageSmoothingEnabled !== 'undefined') try{ ctx.imageSmoothingEnabled = true; } catch(_){ }
                            try { if (enemy) enemy._noFallback = true; } catch(_){ }
                            const dstW = Math.max(1, Math.round(drawW));
                            const dstH = Math.max(1, Math.round(drawH));

                            if (facing === 'left') {
                                ctx.scale(-1, 1);
                            }

                            if (hk._forcedBitmap && box) {
                                ctx.drawImage(hk._forcedBitmap, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (img && box) {
                                ctx.drawImage(img, box.x, box.y, box.w, box.h, -dstW/2, -dstH/2, dstW, dstH);
                            } else if (hk._forcedBitmap) {
                                ctx.drawImage(hk._forcedBitmap, 0, 0, hk._forcedBitmap.width, hk._forcedBitmap.height, -dstW/2, -dstH/2, dstW, dstH);
                            }
                            if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,200,200,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                            ctx.restore();
                            return;
                        }
                        // 2Honk Shakur sprite override (Act II special ranged)
                        if (enemy.type === '2Honk Shakur' && game.enemySprites && game.enemySprites['2honkShakur'] && game.enemySprites['2honkShakur'].loaded) {
                            const hs = game.enemySprites['2honkShakur'];
                            const frames = hs.frames;
                            const img = hs.image;
                            const size = enemy.size;
                            const scale = hs.baseScaleForSize ? hs.baseScaleForSize(size) : ((size*2)/256);
                            const facing = (game.player.x >= enemy.x) ? 'right' : 'left';
                            const nowFrame = game.frame || Date.now();
                            const idx = Math.floor(nowFrame / 5) % frames.length;
                            const frame = frames[idx];
                            if (frame && img) {
                                const drawW = frame.w * scale;
                                const drawH = frame.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1, 1);
                                }
                                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, -drawW/2, -drawH/2, drawW, drawH);
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(230,200,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Enforcer sprite override
                        if (enemy.type === 'Enforcer' && game.enemySprites && game.enemySprites.enforcer && game.enemySprites.enforcer.loaded) {
                            const es = game.enemySprites.enforcer;
                            const animations = es.animations;
                            // Determine facing based on player's position relative to enemy's center
                            const playerX = (game && game.player) ? game.player.x : 0;
                            let facing = playerX < enemy.x ? 'left' : 'right';
                            const img = es.image;
                            const size = enemy.size;
                            const scale = es.baseScaleForSize ? es.baseScaleForSize(size) : ((size*2)/256);
                            // Get sequence
                            let sequenceEntry = null;
                            if (animations && animations[facing]) {
                                sequenceEntry = animations[facing];
                            } else if (facing === 'left' && animations && animations.right) {
                                sequenceEntry = animations.right;
                            } else {
                                sequenceEntry = es.defaultAnimation || (es.anim && es.anim.sequence ? { frames: es.anim.sequence, frameStep: es.anim.frameStep || 5 } : null);
                            }
                            if (sequenceEntry && sequenceEntry.frames && sequenceEntry.frames.length) {
                                const framesForSequence = sequenceEntry.frames;
                                const mirrorSequence = sequenceEntry.mirrorX === true;
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const frameStep = Math.max(1, sequenceEntry.frameStep || es.animFrameStep || 5);
                                const sequenceLength = framesForSequence.length;
                                const frameIndex = Math.floor(nowFrame / frameStep) % sequenceLength;
                                const box = framesForSequence[frameIndex];
                                if (box && img) {
                                    const drawW = box.w * scale;
                                    const drawH = box.h * scale;
                                    ctx.save();
                                    ctx.translate(enemy.x, enemy.y);
                                    if (mirrorSequence && facing === 'left') {
                                        ctx.scale(-1, 1);
                                    }
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,165,0,0.6)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                    ctx.restore();
                                    return;
                                }
                            }
                        }
                        // Enforcer sprite fallback (unused - now using atlas-based rendering above)

                        // Boss Thug sprite override
                        if (enemy.type === 'Boss Thug' && game.enemySprites && game.enemySprites.bossThug && game.enemySprites.bossThug.loaded) {
                            const ts = game.enemySprites.bossThug;
                            const animations = ts.animations;
                            // Determine facing based on player's position relative to enemy's center
                            const playerX = (game && game.player) ? game.player.x : 0;
                            let facing = playerX < enemy.x ? 'left' : 'right';
                            const img = ts.image;
                            const size = enemy.size;
                            const scale = ts.baseScaleForSize ? ts.baseScaleForSize(size) : ((size*2)/256);
                            // Get sequence
                            let sequenceEntry = null;
                            if (animations && animations[facing]) {
                                sequenceEntry = animations[facing];
                            } else if (facing === 'left' && animations && animations.right) {
                                sequenceEntry = animations.right;
                            } else {
                                sequenceEntry = ts.defaultAnimation || (ts.anim && ts.anim.sequence ? { frames: ts.anim.sequence, frameStep: ts.anim.frameStep || 5 } : null);
                            }
                            if (sequenceEntry && sequenceEntry.frames && sequenceEntry.frames.length) {
                                const framesForSequence = sequenceEntry.frames;
                                const mirrorSequence = sequenceEntry.mirrorX === true;
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                const frameStep = Math.max(1, sequenceEntry.frameStep || ts.animFrameStep || 5);
                                const sequenceLength = framesForSequence.length;
                                const frameIndex = Math.floor(nowFrame / frameStep) % sequenceLength;
                                const box = framesForSequence[frameIndex];
                                if (box && img) {
                                    const drawW = box.w * scale;
                                    const drawH = box.h * scale;
                                    ctx.save();
                                    ctx.translate(enemy.x, enemy.y);
                                    if (mirrorSequence && facing === 'left') {
                                        ctx.scale(-1, 1);
                                    }
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                    if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(170,90,255,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                    ctx.restore();
                                    return;
                                }
                            }
                        }

                        // Big Bill (Act II boss) sprite override
                        if (enemy.type === 'Big Bill' && game.enemySprites && game.enemySprites.bigBill && game.enemySprites.bigBill.loaded) {
                            const bb = game.enemySprites.bigBill;
                            const frames = bb.frames;
                            const img = bb.image;
                            const size = enemy.size;
                            const scale = bb.baseScaleForSize ? bb.baseScaleForSize(size) : ((size*2)/256);
                            const facing = (game.player.x >= enemy.x) ? 'right' : 'left';
                            const nowFrame = game.frame || Date.now();
                            const idx = Math.floor(nowFrame / 5) % frames.length;
                            const frame = frames[idx];
                            if (frame && img) {
                                const drawW = frame.w * scale;
                                const drawH = frame.h * scale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    ctx.scale(-1, 1);
                                }
                                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, -drawW/2, -drawH/2, drawW, drawH);
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(200,140,60,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        
                        // Boss Gangster sprite override
                        if (enemy.type === 'Boss Gangster' && game.enemySprites && game.enemySprites.bossGangster && game.enemySprites.bossGangster.loaded) {
                            const gs = game.enemySprites.bossGangster;
                            const animSeq = gs.anim && Array.isArray(gs.anim.sequence) ? gs.anim.sequence : null;
                            const img = gs.image;
                            const size = enemy.size;
                            let frame = null;
                            if (animSeq && animSeq.length) {
                                const frameStep = Math.max(1, gs.anim.frameStep || 5);
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                if (typeof enemy._bossGangsterAnimStart !== 'number') enemy._bossGangsterAnimStart = nowFrame;
                                const elapsed = Math.max(0, nowFrame - enemy._bossGangsterAnimStart);
                                const idx = animSeq.length ? (Math.floor(elapsed / frameStep) % animSeq.length) : 0;
                                frame = animSeq[idx] || animSeq[0] || null;
                                enemy._bossGangsterAnimFrame = idx;
                            }
                            if (!frame) {
                                const frameSet = gs.frames || {};
                                frame = frameSet.down || frameSet.right || frameSet.up || null;
                            }
                            if (frame && img) {
                                const preparedSource = frame.bitmap || frame.canvas || null;
                                const preparedWidth = preparedSource ? (preparedSource.width || (frame.canvas && frame.canvas.width) || frame.w || 1) : (gs.preparedWidth || frame.w || 1);
                                const preparedHeight = preparedSource ? (preparedSource.height || (frame.canvas && frame.canvas.height) || frame.h || 1) : (gs.preparedHeight || frame.h || 1);
                                const referenceHeight = gs.referenceHeight || frame.h || preparedHeight || 1;
                                const baseScale = gs.baseScaleForSize ? gs.baseScaleForSize(size) : ((size*2)/Math.max(1, referenceHeight));
                                const drawW = preparedWidth * baseScale;
                                const drawH = preparedHeight * baseScale;
                                const anchorRefX = (typeof frame.anchorRatioX === 'number') ? frame.anchorRatioX : (typeof gs.anchorRatioX === 'number' ? gs.anchorRatioX : 0.5);
                                const anchorRefY = (typeof frame.anchorRatioY === 'number') ? frame.anchorRatioY : (typeof gs.anchorRatioY === 'number' ? gs.anchorRatioY : 0.5);
                                const destX = -drawW * anchorRefX;
                                const destY = -drawH * anchorRefY;
                                const playerX = (game && game.player && typeof game.player.x === 'number') ? game.player.x : enemy.x;
                                const spriteCenterX = enemy.x + drawW * (0.5 - anchorRefX);
                                const flipLeft = playerX < spriteCenterX;
                                try { enemy.facing = flipLeft ? 'left' : 'right'; enemy._noFallback = true; } catch(_) {}
                                ctx.save();
                                ctx.translate(enemy.x, enemy.y);
                                if (flipLeft) {
                                    ctx.scale(-1, 1);
                                }
                                const drawX = flipLeft ? (-(destX + drawW)) : destX;
                                const sourceImage = preparedSource || img;
                                const srcX = preparedSource ? 0 : frame.x;
                                const srcY = preparedSource ? 0 : frame.y;
                                const srcW = preparedSource ? preparedWidth : frame.w;
                                const srcH = preparedSource ? preparedHeight : frame.h;
                                ctx.drawImage(sourceImage, srcX, srcY, srcW, srcH, drawX, destY, drawW, drawH);
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(90,170,255,0.55)'; ctx.strokeRect(drawX, destY, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // The Big Quack final boss sprite override
                        if (enemy.type === 'The Big Quack' && game.enemySprites && game.enemySprites.bigQuack && game.enemySprites.bigQuack.loaded) {
                            const bq = game.enemySprites.bigQuack;
                            const frameSet = bq.frames || {};
                            const anim = bq.anim;
                            let facing = enemy.facing || 'down';
                            let box = frameSet[facing];
                            if (anim && anim.frames && anim.frames.length) {
                                const frames = anim.frames;
                                const frameStep = Math.max(1, anim.frameStep || 6);
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                let frameIndex;
                                if (enemy) {
                                    if (typeof enemy._bigQuackAnimOrigin !== 'number') enemy._bigQuackAnimOrigin = nowFrame;
                                    if (typeof enemy._bigQuackAnimPhase !== 'number') enemy._bigQuackAnimPhase = Math.floor(Math.random() * frames.length) | 0;
                                    const elapsed = Math.max(0, nowFrame - enemy._bigQuackAnimOrigin);
                                    frameIndex = (enemy._bigQuackAnimPhase + Math.floor(elapsed / frameStep)) % frames.length;
                                    enemy._bigQuackAnimFrame = frameIndex;
                                } else {
                                    frameIndex = Math.floor(nowFrame / frameStep) % frames.length;
                                }
                                box = frames[frameIndex] || frames[0];
                            }
                            const img = bq.image;
                            const size = enemy.size;
                            if (!box) {
                                if (facing === 'left' && frameSet.right) box = frameSet.right; else box = frameSet.down || frameSet.right || frameSet.up;
                            }
                            if (box && img) {
                                const referenceHeight = bq.referenceHeight || box.h || 1;
                                const baseScale = bq.baseScaleForSize ? bq.baseScaleForSize(size) : ((size*2)/Math.max(1, referenceHeight));
                                const effectiveScale = baseScale * (box.renderScale || 1);
                                const drawW = box.w * effectiveScale;
                                const drawH = box.h * effectiveScale;
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                if (facing === 'left') {
                                    if (frameSet.right) { ctx.scale(-1,1); ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                    else { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); }
                                } else {
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH);
                                }
                                if (game._debugSpriteBounds) { ctx.strokeStyle = 'rgba(255,80,80,0.55)'; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH); }
                                ctx.restore();
                                return;
                            }
                        }
                        // Golden Goose secret boss sprite override
                        // Run this branch for any enemy whose type indicates a goose so we don't fall
                        // back to the procedural yellow duck drawing below. Make gg/img/frameSet
                        // null-safe in case the sprite container hasn't been registered yet.
                        if (isGoldenGoose) {
                            // Always force rendering, robust fallback chain
                            // Mark this enemy so other generic fallback code won't draw magenta/yellow for it.
                            try { if (enemy) enemy._noFallback = true; } catch(_) {}
                            const gg = (game.enemySprites && (game.enemySprites['Golden Goose'] || game.enemySprites.goldengoose)) || null;
                            let img = gg ? (gg._gg_img_ref || gg.image) : null;
                            let frameSet = gg ? gg.frames : null;
                            if ((!frameSet || typeof frameSet !== 'object') && img && ((img.naturalWidth || img.width) > 0)) {
                                frameSet = { down: { x:0, y:0, w: img.naturalWidth || img.width, h: img.naturalHeight || img.height } };
                                gg.frames = frameSet;
                            }
                            const animFrames = (gg && gg.anim && Array.isArray(gg.anim.frames) && gg.anim.frames.length) ? gg.anim.frames : null;
                            let box = null;
                            if (animFrames) {
                                const frameStep = Math.max(1, gg.anim.frameStep || 5);
                                const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                                if (enemy) {
                                    if (typeof enemy._goldenAnimStartFrame !== 'number') enemy._goldenAnimStartFrame = nowFrame;
                                    if (typeof enemy._goldenAnimPhase !== 'number') enemy._goldenAnimPhase = Math.floor(Math.random() * animFrames.length) | 0;
                                    const elapsed = Math.max(0, nowFrame - enemy._goldenAnimStartFrame);
                                    const progress = Math.floor(elapsed / frameStep);
                                    const frameIndex = (enemy._goldenAnimPhase + progress) % animFrames.length;
                                    box = animFrames[frameIndex] || animFrames[0];
                                    try { enemy._goldenAnimFrame = frameIndex; } catch(_){ }
                                } else {
                                    const fallbackIndex = Math.floor(nowFrame / frameStep) % animFrames.length;
                                    box = animFrames[fallbackIndex] || animFrames[0];
                                }
                            }
                            if (!box) {
                                box = (frameSet && (frameSet.down || frameSet.right || frameSet.up)) || null;
                            }
                            if (!box && img && ((img.naturalWidth || img.width) > 0) && ((img.naturalHeight || img.height) > 0)) {
                                box = { x: 0, y: 0, w: img.naturalWidth || img.width, h: img.naturalHeight || img.height };
                            }
                            const size = enemy.size;
                            const scale = gg.baseScaleForSize ? gg.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            let drawn = false;
                            // Compute optional alignment offsets from the sprite's computeHitbox (preferred)
                            // or common per-enemy hitbox fields so the Golden Goose sprite lines up with
                            // the enemy's collision/hitbox and facing math uses the sprite center.
                            let _hitOffsetX = 0;
                            let _hitOffsetY = 0;
                            const markDrawSuccess = () => {
                                try {
                                    if (enemy) {
                                        const frameId = (game && game.frame) || 0;
                                        enemy._overlayDrawnFrame = frameId;
                                        enemy._goldenSpriteDrawnFrame = frameId;
                                        enemy._noFallback = true;
                                        enemy._goldenSpriteNeedsOverlay = false;
                                    }
                                } catch(_) {}
                            };
                                try {
                                // Prefer the sprite-provided computeHitbox if available (keeps draw & collision in sync)
                                if (gg && typeof gg.computeHitbox === 'function') {
                                    const hb = gg.computeHitbox(enemy) || null;
                                    if (hb) {
                                        if ('ox' in hb || 'oy' in hb) {
                                            // convert top-left-style ox/oy into a center offset so the
                                            // sprite translation uses the same center as the AABB
                                            const halfW = (hb.w || 0) / 2;
                                            const halfH = (hb.h || 0) / 2;
                                            _hitOffsetX = (hb.ox || 0) + halfW; _hitOffsetY = (hb.oy || 0) + halfH;
                                        } else if ('x' in hb && 'y' in hb) {
                                            // If computeHitbox returned absolute world coords, convert to offset
                                            _hitOffsetX = (hb.x + (hb.w||0)/2) - (enemy && enemy.x || 0);
                                            _hitOffsetY = (hb.y + (hb.h||0)/2) - (enemy && enemy.y || 0);
                                        }
                                    }
                                }
                                // Fallback: if sprite didn't provide computeHitbox, use any per-enemy hitbox fields
                                if ((_hitOffsetX === 0 && _hitOffsetY === 0) && enemy) {
                                    const hb = enemy && (enemy.hitbox || enemy.hb || enemy.hit || enemy.collisionBox || enemy.box || null);
                                    if (hb && typeof hb.w === 'number' && typeof hb.h === 'number') {
                                        const hbCenterX = (typeof hb.x === 'number') ? (hb.x + (hb.w||0)/2) : ((hb.x || 0) + (hb.w||0)/2);
                                        const hbCenterY = (typeof hb.y === 'number') ? (hb.y + (hb.h||0)/2) : ((hb.y || 0) + (hb.h||0)/2);
                                        if (!isNaN(hbCenterX) && !isNaN(hbCenterY)) {
                                            // If hb looks like world coords, compute offset from enemy.x/y
                                            if (Math.abs(hbCenterX - (enemy && enemy.x || 0)) > 1e-6) {
                                                _hitOffsetX = hbCenterX - (enemy && enemy.x || 0);
                                            } else if (typeof hb.x === 'number') {
                                                _hitOffsetX = (hb.x || 0) + (hb.w||0)/2;
                                            }
                                            if (Math.abs(hbCenterY - (enemy && enemy.y || 0)) > 1e-6) {
                                                _hitOffsetY = hbCenterY - (enemy && enemy.y || 0);
                                            } else if (typeof hb.y === 'number') {
                                                _hitOffsetY = (hb.y || 0) + (hb.h||0)/2;
                                            }
                                        }
                                    }
                                }
                            } catch(_) {}

                            // Determine horizontal facing relative to the sprite's world center so the sprite faces the player
                            const _centerX = enemy.x + _hitOffsetX;
                            const _playerOnRight = (game && game.player) ? (game.player.x >= _centerX) : ((enemy.facing || 'left') === 'right');
                            const _facingDir = _playerOnRight ? 'right' : 'left';
                            try { enemy.facing = _facingDir; } catch(_) {}

                            // Try to draw the image if possible
                            if (box && img && ((img.naturalWidth || img.width) > 0) && ((img.naturalHeight || img.height) > 0)) {
                                const drawW = box.w * scale;
                                const drawH = box.h * scale;
                                // anchor handling: allow frame boxes to specify anchorX/Y in source pixels
                                const anchorX = (box && typeof box.anchorX === 'number') ? box.anchorX : (box ? box.w/2 : ((img.naturalWidth||img.width)/2));
                                const anchorY = (box && typeof box.anchorY === 'number') ? box.anchorY : (box ? box.h/2 : ((img.naturalHeight||img.height)/2));
                                const anchorOffsetX = (anchorX - (box ? box.w/2 : ((img.naturalWidth||img.width)/2))) * scale;
                                const anchorOffsetY = (anchorY - (box ? box.h/2 : ((img.naturalHeight||img.height)/2))) * scale;
                                const destX = -drawW/2 + anchorOffsetX;
                                const destY = -drawH/2 + anchorOffsetY;
                                ctx.save(); ctx.translate(enemy.x + _hitOffsetX, enemy.y + _hitOffsetY);
                                // Mirror such that the sprite faces the player (flip when the player stands to the right)
                                const _mirrored = !_playerOnRight;
                                const _drawX = _mirrored ? (-(destX + drawW)) : destX;
                                // Sync enemy.hitbox to sprite draw rect so collisions match the visible sprite.
                                try {
                                    const worldRectX = (enemy && (enemy.x || 0)) + _hitOffsetX + destX;
                                    const worldRectY = (enemy && (enemy.y || 0)) + _hitOffsetY + destY;
                                    if (enemy) {
                                        enemy.hitbox = { x: worldRectX, y: worldRectY, w: drawW, h: drawH };
                                    }
                                } catch(_) {}
                                try {
                                    if (_mirrored) ctx.scale(-1,1);
                                    ctx.drawImage(img, box.x, box.y, box.w, box.h, _drawX, destY, drawW, drawH);
                                    drawn = true;
                                    markDrawSuccess();
                                    try { game._debug = game._debug || {}; const now = performance.now(); if (!game._debug._lastGoldenLog || now - game._debug._lastGoldenLog > 1000) { game._debug._lastGoldenLog = now; console.info('[GoldenGooseSprite][FORCED-DRAW]', { enemyType: enemy && enemy.type, enemyX: enemy && enemy.x, playerX: (game && game.player) ? game.player.x : null, facing: _facingDir, mirrored: _mirrored, used: 'image', imgSrc: img && img.src }); } } catch(_){ }
                                } catch(e) {
                                    console.warn('[GoldenGooseSprite][FORCED-DRAW][ERROR]', e);
                                }
                                // debug sprite outline suppressed for Golden Goose to avoid visible yellow fallback
                                ctx.restore();
                            }
                            // If not drawn, try an ImageBitmap forced-draw (async fetch initiated once),
                            // otherwise fall back to the visible magenta marker immediately so you can see the enemy.
                            if (!drawn) {
                                try {
                                    if (enemy) {
                                        enemy._goldenSpriteNeedsOverlay = true;
                                    }
                                } catch(_) {}
                                try {
                                    // If we've previously created an ImageBitmap for this sprite, draw it now.
                                    if (gg && gg._forcedBitmap) {
                                        try {
                                            const bm = gg._forcedBitmap;
                                            // If frame box missing, assume full-bitmap
                                            const bmBox = box || { x: 0, y: 0, w: bm.width || (img && (img.naturalWidth || img.width)) || enemy.size*2, h: bm.height || (img && (img.naturalHeight || img.height)) || enemy.size*2 };
                                            const drawW = bmBox.w * scale;
                                            const drawH = bmBox.h * scale;
                                            const anchorX = (bmBox && typeof bmBox.anchorX === 'number') ? bmBox.anchorX : (bmBox ? bmBox.w/2 : (bm.width/2 || enemy.size));
                                            const anchorY = (bmBox && typeof bmBox.anchorY === 'number') ? bmBox.anchorY : (bmBox ? bmBox.h/2 : (bm.height/2 || enemy.size));
                                            const anchorOffsetX = (anchorX - (bmBox ? bmBox.w/2 : (bm.width/2 || enemy.size))) * scale;
                                            const anchorOffsetY = (anchorY - (bmBox ? bmBox.h/2 : (bm.height/2 || enemy.size))) * scale;
                                            const destX = -drawW/2 + anchorOffsetX;
                                            const destY = -drawH/2 + anchorOffsetY;
                                            ctx.save(); ctx.translate(enemy.x + _hitOffsetX, enemy.y + _hitOffsetY);
                                            const _mirroredBM = !_playerOnRight;
                                            const _drawXBM = _mirroredBM ? (-(destX + drawW)) : destX;
                                            // Sync enemy.hitbox to sprite draw rect for ImageBitmap draw
                                            try {
                                                const worldRectX = (enemy && (enemy.x || 0)) + _hitOffsetX + destX;
                                                const worldRectY = (enemy && (enemy.y || 0)) + _hitOffsetY + destY;
                                                if (enemy) {
                                                    enemy.hitbox = { x: worldRectX, y: worldRectY, w: drawW, h: drawH };
                                                }
                                            } catch(_) {}
                                            try { if (_mirroredBM) ctx.scale(-1,1); ctx.drawImage(bm, bmBox.x, bmBox.y, bmBox.w, bmBox.h, _drawXBM, destY, drawW, drawH); drawn = true; console.info('[GoldenGooseSprite][FORCED-BITMAP-DRAW]', { src: (gg && gg.image && gg.image.src) || '(bitmap)', w: bm.width, h: bm.height }); } catch(e) { console.warn('[GoldenGooseSprite][FORCED-BITMAP-ERROR]', e); }
                                            if (drawn) markDrawSuccess();
                                            ctx.restore();
                                        } catch(e) {
                                            console.warn('[GoldenGooseSprite][FORCED-BITMAP-ERROR]', e);
                                        }
                                    }
                                } catch(_) {}

                                // If still not drawn, start a one-time background fetch -> createImageBitmap to populate _forcedBitmap
                                if (!drawn && gg && !gg._golden_force_fetch_started) {
                                    gg._golden_force_fetch_started = true;
                                    try {
                                        const forcedUrl = (gg && gg.image && gg.image.src) || (function(){ try { return new URL('assets/geese/goldengoose-sheet.png', document.baseURI).href; } catch(_) { return 'assets/geese/goldengoose-sheet.png'; } })();
                                        // If the Image object is already present and appears loaded, try creating an ImageBitmap from it
                                        const existingImg = gg && (gg._gg_img_ref || gg.image) ? (gg._gg_img_ref || gg.image) : null;
                                        try { console.info('[GoldenGooseSprite][FORCE-FETCH] entry: forcedUrl=', forcedUrl, ' existingImg=', existingImg && existingImg.src, 'complete=', existingImg && existingImg.complete, 'nw=', existingImg && (existingImg.naturalWidth || existingImg.width), 'nh=', existingImg && (existingImg.naturalHeight || existingImg.height)); } catch(_){}

                                        if (existingImg && existingImg.complete && ((existingImg.naturalWidth || existingImg.width) > 0) && ((existingImg.naturalHeight || existingImg.height) > 0)) {
                                            // Prefer createImageBitmap from the loaded Image element (works without network fetch and avoids file:// fetch issues)
                                            try {
                                                createImageBitmap(existingImg).then(bitmap => {
                                                    try {
                                                        if (game && game.enemySprites && game.enemySprites.goldengoose) {
                                                            game.enemySprites.goldengoose._forcedBitmap = bitmap;
                                                            console.info('[GoldenGooseSprite][FORCE-FETCH] created ImageBitmap from existing Image', { w: bitmap.width, h: bitmap.height, src: existingImg.src });
                                                        }
                                                    } catch(e) { console.warn('[GoldenGooseSprite][FORCE-FETCH][STORE-ERR]', e); }
                                                }).catch(err => {
                                                    console.warn('[GoldenGooseSprite][FORCE-FETCH][BITMAP-FROM-IMG-ERR]', err, ' — falling back to fetch(', forcedUrl, ')');
                                                    // Fall back to fetch-based bitmap creation
                                                    try {
                                                        fetch(forcedUrl).then(r => r.blob()).then(b => createImageBitmap(b)).then(bitmap => {
                                                            try {
                                                                if (game && game.enemySprites && game.enemySprites.goldengoose) {
                                                                    game.enemySprites.goldengoose._forcedBitmap = bitmap;
                                                                    console.info('[GoldenGooseSprite][FORCE-FETCH] bitmap ready (from fetch)', { w: bitmap.width, h: bitmap.height });
                                                                }
                                                            } catch(e) { console.warn('[GoldenGooseSprite][FORCE-FETCH][STORE-ERR]', e); }
                                                        }).catch(e => { console.warn('[GoldenGooseSprite][FORCE-FETCH][ERROR]', e); });
                                                    } catch(e2) { console.warn('[GoldenGooseSprite][FORCE-FETCH][ERROR-INIT]', e2); }
                                                });
                                            } catch(e) {
                                                console.warn('[GoldenGooseSprite][FORCE-FETCH][CREATE-IMG-BITMAP-THROWN]', e, ' — will attempt fetch(', forcedUrl, ')');
                                                // If createImageBitmap throws synchronously, fall back to fetch
                                                try {
                                                    fetch(forcedUrl).then(r => r.blob()).then(b => createImageBitmap(b)).then(bitmap => {
                                                        try {
                                                            if (game && game.enemySprites && game.enemySprites.goldengoose) {
                                                                game.enemySprites.goldengoose._forcedBitmap = bitmap;
                                                                console.info('[GoldenGooseSprite][FORCE-FETCH] bitmap ready (from fetch after createImageBitmap throw)', { w: bitmap.width, h: bitmap.height });
                                                            }
                                                        } catch(e) { console.warn('[GoldenGooseSprite][FORCE-FETCH][STORE-ERR]', e); }
                                                    }).catch(e => { console.warn('[GoldenGooseSprite][FORCE-FETCH][ERROR]', e); });
                                                } catch(e2) { console.warn('[GoldenGooseSprite][FORCE-FETCH][ERROR-INIT]', e2); }
                                            }
                                        } else {
                                            // No usable Image element yet — perform the network fetch as a fallback
                                            try {
                                                console.info('[GoldenGooseSprite][FORCE-FETCH] no loaded Image available, fetching', forcedUrl);
                                                fetch(forcedUrl).then(r => r.blob()).then(b => createImageBitmap(b)).then(bitmap => {
                                                    try {
                                                        if (game && game.enemySprites && game.enemySprites.goldengoose) {
                                                            game.enemySprites.goldengoose._forcedBitmap = bitmap;
                                                            console.info('[GoldenGooseSprite][FORCE-FETCH] bitmap ready', { w: bitmap.width, h: bitmap.height });
                                                        }
                                                    } catch(e) { console.warn('[GoldenGooseSprite][FORCE-FETCH][STORE-ERR]', e); }
                                                }).catch(e => { console.warn('[GoldenGooseSprite][FORCE-FETCH][ERROR]', e); });
                                            } catch(e) { console.warn('[GoldenGooseSprite][FORCE-FETCH][ERROR-INIT]', e); }
                                        }
                                    } catch(e) { console.warn('[GoldenGooseSprite][FORCE-FETCH][ERROR-INIT-OUTER]', e); }
                                }

                                // Immediate attempt: if the original Image element is present and loaded, draw it once more
                                try {
                                    if (!drawn && img && img.complete && ((img.naturalWidth || img.width) > 0) && ((img.naturalHeight || img.height) > 0)) {
                                        const srcW = (box ? box.w : (img.naturalWidth||img.width));
                                        const srcH = (box ? box.h : (img.naturalHeight||img.height));
                                        const drawW = srcW * scale;
                                        const drawH = srcH * scale;
                                        const anchorX = (box && typeof box.anchorX === 'number') ? box.anchorX : (srcW/2);
                                        const anchorY = (box && typeof box.anchorY === 'number') ? box.anchorY : (srcH/2);
                                        const anchorOffsetX = (anchorX - (srcW/2)) * scale;
                                        const anchorOffsetY = (anchorY - (srcH/2)) * scale;
                                        const destX = -drawW/2 + anchorOffsetX;
                                        const destY = -drawH/2 + anchorOffsetY;
                                        ctx.save(); ctx.translate(enemy.x + _hitOffsetX, enemy.y + _hitOffsetY);
                                        const _mirroredFinal = !_playerOnRight;
                                        const _drawXFinal = _mirroredFinal ? (-(destX + drawW)) : destX;
                                            // Sync enemy.hitbox to this final-image draw rect so collisions match the visible sprite
                                            try {
                                                const worldRectX = (enemy && (enemy.x || 0)) + _hitOffsetX + destX;
                                                const worldRectY = (enemy && (enemy.y || 0)) + _hitOffsetY + destY;
                                                if (enemy) {
                                                    enemy.hitbox = { x: worldRectX, y: worldRectY, w: drawW, h: drawH };
                                                }
                                            } catch(_) {}
                                        try { if (_mirroredFinal) ctx.scale(-1,1); ctx.drawImage(img, (box?box.x:0), (box?box.y:0), srcW, srcH, _drawXFinal, destY, drawW, drawH); drawn = true; markDrawSuccess(); console.info('[GoldenGooseSprite][FORCED-DRAW-FINAL] drew existing Image fallback', { src: img.src, nw: img.naturalWidth, nh: img.naturalHeight }); } catch(e) { console.warn('[GoldenGooseSprite][FORCED-DRAW-FINAL][ERROR]', e); }
                                        ctx.restore();
                                    }
                                } catch(_) {}
                                    // NO FALLBACK: intentionally draw nothing while the Golden Goose sprite is pending.
                                    // This prevents both the magenta debug marker and the procedural yellow duck
                                    // from ever appearing for Golden Goose. We return early and wait for the
                                    // normal image/bitmap draw path to render the sprite when available.
                                    if (!drawn) {
                                        try { game._debug = game._debug || {}; const now = (typeof performance !== 'undefined') ? performance.now() : Date.now(); if (!game._debug._lastGoldenNoFallbackLog || now - game._debug._lastGoldenNoFallbackLog > 1000) { game._debug._lastGoldenNoFallbackLog = now; console.info('[GoldenGooseSprite] no fallback drawn (waiting for sprite)'); } } catch(_){}
                                        return;
                                    }
                            }
                            return;
                        }

                        // Wunderswan sprite override
                        if (enemy.type === 'Wunderswan' && game.enemySprites && game.enemySprites.wunderswan && game.enemySprites.wunderswan.loaded) {
                            const ws = game.enemySprites.wunderswan;
                            let frameSet = ws.frames;
                            const img = ws.image; // declare image early to avoid accidental reference-before-declaration errors
                            let facing = enemy.facing || 'down';
                            // If frameSet is missing (spawn-kick may have not populated frames yet), attempt to repair
                            try {
                                if ((!frameSet || typeof frameSet !== 'object') && img && ((img.naturalWidth || img.width) > 0)) {
                                    frameSet = { down: { x:0, y:0, w: img.naturalWidth || img.width, h: img.naturalHeight || img.height } };
                                    ws.frames = frameSet;
                                    try { console.info('[WunderswanSprite][DRAW] repaired missing frames from image natural size', { nw: img.naturalWidth, nh: img.naturalHeight, src: img && img.src }); } catch(_){ }
                                }
                            } catch(e) {
                                // Defensive: if any unexpected error occurs during frame repair, log once and continue to fallback
                                if (!game._debug) game._debug = {};
                                const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
                                if (!game._debug._lastWundRepairErr || now - game._debug._lastWundRepairErr > 1000) {
                                    game._debug._lastWundRepairErr = now;
                                    try { console.warn('[WunderswanSprite][DRAW] frame repair threw', e && e.message); } catch(_){}
                                }
                            }
                            let box = (frameSet && (frameSet.down || frameSet.right || frameSet.up)) || null;
                            const size = enemy.size;
                            const scale = ws.baseScaleForSize ? ws.baseScaleForSize(size) : ((size*2)/(box?box.h:1));
                            // Diagnostic: if image exists but has zero natural size, warn once per 500ms
                            try {
                                game._debug = game._debug || {};
                                const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
                                const nw = img && (img.naturalWidth || img.width) || 0;
                                const nh = img && (img.naturalHeight || img.height) || 0;
                                if ((nw === 0 || nh === 0) && (!game._debug._lastWundSizeWarn || now - game._debug._lastWundSizeWarn > 500)) {
                                    game._debug._lastWundSizeWarn = now;
                                    console.warn('[WunderswanSprite][DRAW] image zero-size or not loaded properly', { src: img && img.src, nw, nh, loaded: !!ws.loaded });
                                }
                            } catch(_) {}

                            // If the stored frame box has zero dimensions (spawn-kick may have set it early),
                            // use the actual loaded image natural size as a fallback so the sprite can draw.
                            if (box && img && ((img.naturalWidth || img.width) > 0 && (img.naturalHeight || img.height) > 0)) {
                                if (!box.w || !box.h) {
                                    // Repair the frame box from the image itself
                                    const nw = img.naturalWidth || img.width || 0;
                                    const nh = img.naturalHeight || img.height || 0;
                                    if (nw > 0 && nh > 0) {
                                        // Replace box with a direct full-image box for drawing
                                        box = { x: 0, y: 0, w: nw, h: nh };
                                        try { console.info('[WunderswanSprite][DRAW] repaired zero-size frame box using natural image size', { nw, nh, src: img.src }); } catch(_){}
                                    }
                                }
                            }
                            // However, if a forced overlay draw already rendered the Wunderswan this frame
                            // we should not draw the magenta fallback behind it. Clear the overlay flag and
                            // return early so the forced overlay remains visible.
                            try {
                                // If the forced overlay drew this frame, skip the magenta fallback so it won't appear underneath.
                                if (enemy && (enemy._overlayDrawnFrame === (game.frame || 0))) { return; }
                                // Additional strong guard: if this enemy is Wunderswan, never draw the magenta fallback
                                // (the forced overlay will always render the actual sprite on top). This avoids timing
                                // races where the fallback renders before the overlay draw occurs.
                                if (enemy && enemy.type === 'Wunderswan') { return; }
                            } catch(_) {}
                            try {
                                // Throttle a console message to avoid spam
                                const now2 = (typeof performance !== 'undefined') ? performance.now() : Date.now();
                                if (!game._debug._lastWundFallbackWarn || now2 - game._debug._lastWundFallbackWarn > 500) {
                                    game._debug._lastWundFallbackWarn = now2;
                                    console.info('[WunderswanSprite][DRAW] drawing fallback marker at enemy position', { x: enemy.x, y: enemy.y, facing: enemy.facing, imgSrc: img && img.src });
                                }
                            } catch(_) {}
                            // If the sprite image is available, skip the magenta fallback entirely —
                            // the forced top-layer overlay will draw the sprite later.
                            try {
                                // If the sprite container reports it's loaded (or image has size), skip the magenta fallback
                                // This is a stronger check to avoid the debug magenta appearing underneath the forced overlay
                                if (ws && (ws.loaded || (ws.image && ((ws.image.naturalWidth || ws.image.width) > 0)))) {
                                    return;
                                }
                            } catch(_){ }
                            // Visible magenta circle fallback (debug-only) so you can see the enemy even if sprite failed
                            try {
                                // Respect any per-enemy suppression marker (e.g., from Golden Goose handling)
                                if (enemy && enemy._noFallback) { return; }
                                ctx.save(); ctx.translate(enemy.x, enemy.y);
                                ctx.fillStyle = 'magenta'; ctx.beginPath(); ctx.arc(0, 0, Math.max(12, size/2), 0, Math.PI*2); ctx.fill();
                                ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0,0, Math.max(12, size/2)+4, 0, Math.PI*2); ctx.stroke();
                                ctx.restore();
                            } catch(_) {}
                            return;
                        }
                        // If a previous branch marked this enemy as no-fallback (eg. Golden Goose),
                        // skip the procedural drawing entirely so no yellow debug duck appears.
                        try { if (enemy && (enemy._noFallback || (typeof enemy.type === 'string' && /goose/i.test(enemy.type)))) { return; } } catch(_) {}
                        // Cache style palette per type on the function to avoid re-allocation
                        if (!drawDuckEnemy._styles) {
                            drawDuckEnemy._styles = {
                                'Thug': { body:'#6b4d2e', head:'#765633', beak:'#d08c00', wing:'#5a3f25' },
                                'Gangster': { body:'#2d2d2d', head:'#383838', beak:'#d08c00', wing:'#1f1f1f', hat:'#000000' },
                                'Street Dog': { body:'#704214', head:'#804c19', beak:'#c07000', wing:'#5a3410', ears:true },
                                'Punk': { body:'#91298f', head:'#a936a7', beak:'#ffb000', wing:'#762177', mohawk:true },
                                'Dealer': { body:'#2a6b2a', head:'#2f7a2f', beak:'#d08c00', wing:'#1e4d1e', stripe:'#ffff66' },
                                'Enforcer': { body:'#7c0a02', head:'#8f1208', beak:'#ff9c00', wing:'#5a0601', pads:true },
                                'Boss Thug': { body:'#4a2c85', head:'#533296', beak:'#ffb000', wing:'#392063', crown:true },
                                'Boss Gangster': { body:'#1c1c1c', head:'#262626', beak:'#d08c00', wing:'#131313', hat:'#000000', pinstripe:true },
                                'The Big Quack': { body:'#050505', head:'#0a0a0a', beak:'#e0a800', wing:'#050505', hat:'#000000', pinstripe:true, overfedora:true }
                            };
                        }
                        const style = drawDuckEnemy._styles[enemy.type] || {};
                        const bodyColor = tintColor || style.body || enemy.color || '#888888';
                        const headColor = style.head || bodyColor;
                        const beakColor = style.beak || '#d08c00';
                        const wingColor = style.wing || bodyColor;

                        // Left/right facing only: determine horizontal facing
                        const faceLeft = game.player.x < enemy.x;
                        const s = enemy.size; // base scale reference

                        ctx.save();
                        ctx.translate(enemy.x, enemy.y);
                        // Visual cue if blinded: golden halo + slight dim of body
                        if (enemy.blinded) {
                            const pulse = 0.6 + 0.4*Math.sin(performance.now()/180 + enemy.x*0.02);
                            ctx.globalAlpha = 0.55 * pulse;
                            ctx.fillStyle = '#FFEFA5';
                            ctx.beginPath();
                            ctx.ellipse(0, enemy.size*0.15, enemy.size*0.9, enemy.size*0.45, 0, 0, Math.PI*2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        if (enemy.blinded) {
                            ctx.filter = 'brightness(0.85)';
                        }
                        if (faceLeft) {
                            ctx.scale(-1, 1); // mirror horizontally
                        }

                        // Body (ellipse)
                        ctx.fillStyle = bodyColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.05, 0, s*0.55, s*0.38, 0, 0, Math.PI*2);
                        ctx.fill();

                        // Trenchcoat (wrapped) — sculpted shape hugging body with flare and collar
                        const coatColor = '#3f2c1b';
                        const coatShadow = '#281a10';
                        const coatHighlight = '#705030';
                        // Adjusted for full body coverage
                        const coatTopY = -s*0.28; // raised under beak
                        const coatBottomY = s*0.62; // lowered to cover lower ellipse
                        const coatHalf = s*0.60; // wider wrap to exceed body ellipse width
                        ctx.fillStyle = coatColor;
                        ctx.beginPath();
                        // Top curve (collar base)
                        ctx.moveTo(-coatHalf*0.90, coatTopY + s*0.05);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatTopY - s*0.10, 0, coatTopY - s*0.08);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatTopY - s*0.10, coatHalf*0.90, coatTopY + s*0.05);
                        // Side down (left)
                        ctx.lineTo(coatHalf*0.68, coatBottomY - s*0.06);
                        // Bottom flare waves (extended)
                        ctx.quadraticCurveTo(coatHalf*0.25, coatBottomY + s*0.14, 0, coatBottomY + s*0.06);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatBottomY + s*0.14, -coatHalf*0.68, coatBottomY - s*0.06);
                        // Close along left side
                        ctx.closePath();
                        ctx.fill();
                        // Collar & lapels overlay
                        ctx.fillStyle = coatHighlight;
                        ctx.beginPath();
                        ctx.moveTo(-coatHalf*0.55, coatTopY + s*0.04);
                        ctx.lineTo(-coatHalf*0.20, coatTopY + s*0.36);
                        ctx.lineTo(-coatHalf*0.06, coatTopY + s*0.04);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(coatHalf*0.55, coatTopY + s*0.04);
                        ctx.lineTo(coatHalf*0.20, coatTopY + s*0.36);
                        ctx.lineTo(coatHalf*0.06, coatTopY + s*0.04);
                        ctx.closePath();
                        ctx.fill();
                        // Inner shadow (gradient simulation via semi-transparent stroke)
                        ctx.strokeStyle = coatShadow + 'aa';
                        ctx.lineWidth = Math.max(1, s*0.06);
                        ctx.beginPath();
                        ctx.moveTo(0, coatTopY - s*0.06);
                        ctx.lineTo(0, coatBottomY);
                        ctx.stroke();
                        // Buttons (shifted slightly right for wrap illusion)
                        ctx.fillStyle = '#cfae72';
                        for (let i=0;i<4;i++) {
                            ctx.beginPath();
                            ctx.arc(s*0.07, coatTopY + s*(0.18 + i*0.20), s*0.038, 0, Math.PI*2);
                            ctx.fill();
                        }
                        // Belt suggestion (two small horizontal strokes)
                        ctx.strokeStyle = coatShadow;
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.beginPath();
                        ctx.moveTo(-s*0.32, coatTopY + s*0.54);
                        ctx.lineTo(s*0.32, coatTopY + s*0.54);
                        ctx.moveTo(-s*0.32, coatTopY + s*0.57);
                        ctx.lineTo(s*0.20, coatTopY + s*0.57);
                        ctx.stroke();
                        // Wing aperture (eroded area) + sleeve cap
                        ctx.save();
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.beginPath();
                        ctx.ellipse(-s*0.20, 0, s*0.24, s*0.20, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                        ctx.fillStyle = coatColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.20, -s*0.02, s*0.22, s*0.18, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Subtle outline
                        ctx.strokeStyle = '#00000044';
                        ctx.lineWidth = Math.max(1, s*0.025);
                        ctx.beginPath();
                        ctx.moveTo(-coatHalf*0.90, coatTopY + s*0.05);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatTopY - s*0.10, 0, coatTopY - s*0.08);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatTopY - s*0.10, coatHalf*0.90, coatTopY + s*0.05);
                        ctx.lineTo(coatHalf*0.68, coatBottomY - s*0.06);
                        ctx.quadraticCurveTo(coatHalf*0.25, coatBottomY + s*0.14, 0, coatBottomY + s*0.06);
                        ctx.quadraticCurveTo(-coatHalf*0.25, coatBottomY + s*0.14, -coatHalf*0.68, coatBottomY - s*0.06);
                        ctx.closePath();
                        ctx.stroke();
                        // Wing (simple arc) drawn after coat so it appears on top/side
                        ctx.fillStyle = wingColor;
                        ctx.beginPath();
                        ctx.ellipse(-s*0.15, 0, s*0.30, s*0.22, Math.PI/6, Math.PI*0.15, Math.PI*1.15);
                        ctx.fill();

                        // Head
                        ctx.fillStyle = headColor;
                        ctx.beginPath();
                        ctx.arc(s*0.42, -s*0.15, s*0.28, 0, Math.PI*2);
                        ctx.fill();

                        // Beak
                        ctx.fillStyle = beakColor;
                        ctx.beginPath();
                        ctx.moveTo(s*0.62, -s*0.10);
                        ctx.lineTo(s*0.90, -s*0.05);
                        ctx.lineTo(s*0.62,  -s*0.00);
                        ctx.closePath();
                        ctx.fill();

                        // Eye
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(s*0.50, -s*0.22, s*0.07, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(s*0.515, -s*0.22, s*0.03, 0, Math.PI*2);
                        ctx.fill();

                        // Weapon (before hat so it sits below hat brim visually)
                        // Decide melee vs ranged using enemy.ranged flag
                        if (enemy.ranged) {
                            // Gun lowered to body line (emerges from wing/coat front)
                            const gunBaseX = s*0.42; // forward in facing direction
                            const gunBaseY = s*0.18; // lowered
                            ctx.save();
                            ctx.translate(gunBaseX, gunBaseY);
                            ctx.rotate(-0.08); // slight downward-forward angle
                            ctx.fillStyle = '#2b2b2b';
                            // Body
                            ctx.fillRect(0, -s*0.07, s*0.40, s*0.12);
                            // Barrel
                            ctx.fillRect(s*0.40, -s*0.045, s*0.30, s*0.055);
                            // Front sight
                            ctx.fillRect(s*0.68, -s*0.055, s*0.04, s*0.02);
                            // Grip
                            ctx.fillStyle = '#3d3d3d';
                            ctx.fillRect(s*0.08, s*0.02, s*0.14, s*0.20);
                            // Highlight line
                            ctx.strokeStyle = '#ffffff22';
                            ctx.lineWidth = Math.max(1, s*0.015);
                            ctx.beginPath();
                            ctx.moveTo(s*0.02, -s*0.035);
                            ctx.lineTo(s*0.36, -s*0.035);
                            ctx.stroke();
                            ctx.restore();
                        } else {
                            // Knife lowered to appear held at body level
                            const knifeBaseX = s*0.36;
                            const knifeBaseY = s*0.20;
                            ctx.save();
                            ctx.translate(knifeBaseX, knifeBaseY);
                            ctx.rotate(-0.12);
                            // Handle
                            ctx.fillStyle = '#3a2412';
                            ctx.fillRect(-s*0.05, -s*0.035, s*0.12, s*0.10);
                            // Guard
                            ctx.fillStyle = '#cfae72';
                            ctx.fillRect(s*0.02, -s*0.045, s*0.07, s*0.032);
                            // Blade
                            ctx.fillStyle = '#c8d0d5';
                            ctx.beginPath();
                            ctx.moveTo(s*0.06, -s*0.04);
                            ctx.lineTo(s*0.40, -s*0.012);
                            ctx.lineTo(s*0.06,  s*0.018);
                            ctx.closePath();
                            ctx.fill();
                            // Edge highlight
                            ctx.strokeStyle = '#ffffff55';
                            ctx.lineWidth = Math.max(1, s*0.015);
                            ctx.beginPath();
                            ctx.moveTo(s*0.08, -s*0.030);
                            ctx.lineTo(s*0.36, -s*0.010);
                            ctx.stroke();
                            ctx.restore();
                        }

                        // Type-specific accents
                        // Universal fedora (gangster look)
                        // Fedora: dynamic palette (black for gangster variants)
                        const isBossGang = enemy.type === 'Boss Gangster' || enemy.type === 'The Big Quack' || enemy.type === 'Gangster';
                        const hatBrimColor = isBossGang ? '#000000' : '#5a3b19';
                        const hatCrownColor = isBossGang ? '#111111' : '#6d4722';
                        const hatBandColor = isBossGang ? '#222222' : '#3a2613';
                        const highlightColor = '#ffffff18';
                        // Slightly larger brim
                        const brimWidth = s*0.50;
                        const brimHeight = s*0.085;
                        const brimX = s*0.18;
                        const brimY = -s*0.44;
                        ctx.fillStyle = hatBrimColor;
                        ctx.beginPath();
                        ctx.roundRect ? ctx.roundRect(brimX, brimY, brimWidth, brimHeight, brimHeight*0.4) : ctx.fillRect(brimX, brimY, brimWidth, brimHeight);
                        ctx.fill();
                        // Crown (tapered)
                        const crownBaseWidth = s*0.30;
                        const crownTopWidth = crownBaseWidth * 0.70; // taper
                        const crownHeight = s*0.26;
                        const crownBaseX = brimX + (brimWidth - crownBaseWidth)/2;
                        const crownTopX = crownBaseX + (crownBaseWidth - crownTopWidth)/2;
                        const crownBottomY = brimY - s*0.01;
                        const crownTopY = crownBottomY - crownHeight;
                        ctx.fillStyle = hatCrownColor;
                        ctx.beginPath();
                        ctx.moveTo(crownBaseX, crownBottomY);
                        ctx.lineTo(crownBaseX + crownBaseWidth, crownBottomY);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY);
                        ctx.lineTo(crownTopX, crownTopY);
                        ctx.closePath();
                        ctx.fill();
                        // Band wraps around lower third
                        const bandHeight = crownHeight * 0.22;
                        const bandY = crownBottomY - bandHeight - crownHeight*0.18;
                        ctx.fillStyle = hatBandColor;
                        ctx.fillRect(crownBaseX, bandY, crownBaseWidth, bandHeight);
                        // Highlight along top ridge
                        ctx.strokeStyle = highlightColor;
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.beginPath();
                        ctx.moveTo(crownTopX, crownTopY + s*0.01);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY + s*0.01);
                        ctx.stroke();
                        // Outline
                        ctx.strokeStyle = isBossGang ? '#00000088' : '#2b1b0d88';
                        ctx.lineWidth = Math.max(1, s*0.035);
                        ctx.beginPath();
                        ctx.moveTo(crownBaseX, crownBottomY);
                        ctx.lineTo(crownBaseX + crownBaseWidth, crownBottomY);
                        ctx.lineTo(crownTopX + crownTopWidth, crownTopY);
                        ctx.lineTo(crownTopX, crownTopY);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.strokeStyle = isBossGang ? '#00000066' : '#2b1b0d66';
                        ctx.lineWidth = Math.max(1, s*0.03);
                        ctx.strokeRect(brimX, brimY, brimWidth, brimHeight);
                        // Pinstripes for suit (body area) on boss gangster & big quack
                        if (style.pinstripe) {
                            ctx.save();
                            ctx.translate(0,0);
                            ctx.strokeStyle = enemy.type === 'The Big Quack' ? '#44444488' : '#555555AA';
                            ctx.lineWidth = Math.max(1, s*0.01);
                            for (let ps=-s*0.55; ps<=s*0.55; ps+= s*0.12) {
                                ctx.beginPath();
                                ctx.moveTo(ps, -s*0.30);
                                ctx.lineTo(ps, s*0.55);
                                ctx.stroke();
                            }
                            ctx.restore();
                        }
                        if (style.overfedora) {
                            // Add a subtle wider shadow under brim to emphasize scale
                            ctx.save();
                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = '#000000';
                            ctx.beginPath();
                            ctx.ellipse(brimX + brimWidth/2, brimY + brimHeight*0.65, brimWidth*0.65, brimHeight*0.9, 0, 0, Math.PI*2);
                            ctx.fill();
                            ctx.restore();
                        }
                        if (style.mohawk) {
                            ctx.fillStyle = '#ff00ff';
                            ctx.beginPath();
                            ctx.moveTo(s*0.38, -s*0.42);
                            ctx.lineTo(s*0.44, -s*0.60);
                            ctx.lineTo(s*0.50, -s*0.42);
                            ctx.closePath();
                            ctx.fill();
                        }
                        if (style.ears) {
                            ctx.fillStyle = headColor;
                            ctx.beginPath();
                            ctx.arc(s*0.30, -s*0.34, s*0.08, 0, Math.PI*2);
                            ctx.arc(s*0.54, -s*0.34, s*0.08, 0, Math.PI*2);
                            ctx.fill();
                        }
                        if (style.stripe) {
                            ctx.strokeStyle = style.stripe;
                            ctx.lineWidth = Math.max(2, s*0.08);
                            ctx.beginPath();
                            ctx.moveTo(-s*0.55, -s*0.10);
                            ctx.lineTo(s*0.10, s*0.12);
                            ctx.stroke();
                        }
                        if (style.pads) {
                            ctx.fillStyle = '#ffaa33';
                            ctx.fillRect(-s*0.30, s*0.14, s*0.18, s*0.10);
                            ctx.fillRect(-s*0.05, s*0.14, s*0.18, s*0.10);
                        }
                        // (Removed crown accent in favor of universal fedora)

                        // Subtle outline
                        ctx.strokeStyle = '#00000055';
                        ctx.lineWidth = Math.max(1, s*0.05);
                        ctx.beginPath();
                        ctx.ellipse(-s*0.05, 0, s*0.55, s*0.38, 0, 0, Math.PI*2);
                        ctx.stroke();

                        ctx.restore();
                    } catch (err) {
                        try { console.warn('[drawDuckEnemy] sprite override block failed', err); } catch(_){ }
                    }
                } catch (e) {
                        // Fallback to original rectangle if anything goes wrong
                        ctx.save();
                        ctx.fillStyle = tintColor || enemy.color || '#888';
                        ctx.fillRect(enemy.x - enemy.size/2, enemy.y - enemy.size/2, enemy.size, enemy.size);
                        ctx.restore();
                    }
                };

                // Apply fear/flee tint (purple) while under those effects
                const isPanic = enemy.feared || enemy.fleeing;
                const tintColor = isPanic ? '#AA44FF' : baseColor;
                drawDuckEnemy(ctx, enemy, tintColor);
                // Subtle pulsing glow to highlight panic state
                if (isPanic) {
                    const pulse = 0.45 + 0.25 * Math.sin(performance.now()/160 + enemy.x*0.04);
                    ctx.save();
                    ctx.globalAlpha = 0.35 * pulse;
                    ctx.fillStyle = '#AA44FF';
                    ctx.beginPath();
                    ctx.ellipse(enemy.x, enemy.y + enemy.size*0.10, enemy.size*0.95, enemy.size*0.55, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }

                if (enemy.wunderScribble) {
                    try {
                        if (window._bulletImages && typeof window._bulletImages.loadWunderScribble === 'function') {
                            const imgRef = window._bulletImages.wunderScribble;
                            if (imgRef && !imgRef.src) { window._bulletImages.loadWunderScribble(); }
                        }
                    } catch(_) {}
                    const imgStore = window._bulletImages || {};
                    const anim = imgStore.wunderScribbleAnim;
                    const img = imgStore.wunderScribble;
                    const overlayTime = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();
                    const bob = Math.sin((overlayTime + enemy.x * 9) / 280) * Math.max(4, enemy.size * 0.1);
                    const baseSize = Math.max(42, enemy.size * 2.05);
                    const imgW = img && (img.naturalWidth || img.width) || 0;
                    const imgH = img && (img.naturalHeight || img.height) || (imgW || 0);
                    const defaultDrawW = baseSize;
                    const defaultDrawH = imgH ? Math.max(12, baseSize * (imgH / Math.max(1, imgW))) : baseSize;
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y + bob);
                    ctx.globalAlpha = 0.9;
                    let rendered = false;
                    if (anim && anim.frames && anim.frames.length) {
                        const total = anim.totalDuration || 1;
                        let t = overlayTime % total;
                        let frameRef = anim.frames[0];
                        for (let fi = 0; fi < anim.frames.length; fi++) {
                            const f = anim.frames[fi];
                            if (t <= f.duration || fi === anim.frames.length - 1) {
                                frameRef = f;
                                break;
                            }
                            t -= f.duration;
                        }
                        if (frameRef) {
                            if (frameRef.canvas || frameRef.bitmap) {
                                const srcW = frameRef.width || (frameRef.canvas ? frameRef.canvas.width : frameRef.bitmap.width);
                                const srcH = frameRef.height || (frameRef.canvas ? frameRef.canvas.height : frameRef.bitmap.height);
                                const drawW = baseSize;
                                const drawH = srcH ? Math.max(12, baseSize * (srcH / srcW)) : baseSize;
                                const src = frameRef.canvas || frameRef.bitmap;
                                ctx.drawImage(src, 0, 0, srcW, srcH, -drawW/2, -drawH/2, drawW, drawH);
                                rendered = true;
                            } else if (frameRef.transform && img && imgW && imgH) {
                                const tf = frameRef.transform;
                                const srcW = imgW;
                                const srcH = imgH;
                                const scale = tf.scale != null ? tf.scale : 1;
                                const drawW = defaultDrawW * scale;
                                const drawH = defaultDrawH * scale;
                                ctx.save();
                                ctx.translate(tf.jitterX || 0, tf.jitterY || 0);
                                if (tf.rotation) ctx.rotate(tf.rotation);
                                ctx.drawImage(img, 0, 0, srcW, srcH, -drawW/2, -drawH/2, drawW, drawH);
                                ctx.restore();
                                rendered = true;
                            }
                        }
                    }
                    if (!rendered && img && img.complete && !img._broken && imgW && imgH) {
                        ctx.drawImage(img, 0, 0, imgW, imgH, -defaultDrawW/2, -defaultDrawH/2, defaultDrawW, defaultDrawH);
                        rendered = true;
                    }
                    if (!rendered) {
                        const t = overlayTime / 220;
                        ctx.strokeStyle = '#FF1A55';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, baseSize * 0.46, baseSize * 0.32, t, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.ellipse(0, 0, baseSize * 0.28, baseSize * 0.54, -t * 1.2, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
                // Health bar
                if (enemy.health < enemy.maxHealth && enemy.maxHealth > 0) {
                    const barWidth = enemy.size + 10;
                    const barHeight = 4;
                    // Gangster sprites need special positioning due to their visual bounds
                    let barY = enemy.y - enemy.size/2 - 8;
                    if (enemy.type === 'Gangster' && game.enemySprites && game.enemySprites.gangster) {
                        const gs = game.enemySprites.gangster;
                        const scale = gs.baseScaleForSize ? gs.baseScaleForSize(enemy.size) : 1;
                        const visibleH = (gs.maxVisibleHeight || gs.referenceHeight || gs.preparedHeight || 1);
                        const scaledH = visibleH * scale;
                        // Position bar well above the sprite's visual top (head level)
                        barY = enemy.y - scaledH/2 - 24;
                    }
                    // Clamp ratio to [0,1] to avoid flash expansion when health dips below 0 or state mutates on death
                    let ratio = enemy.health / enemy.maxHealth;
                    if (!isFinite(ratio)) ratio = 0; // safeguard
                    ratio = Math.min(1, Math.max(0, ratio));
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, barHeight);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x - barWidth/2, barY, barWidth, barHeight);
                    if (ratio > 0) {
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(enemy.x - barWidth/2, barY, barWidth * ratio, barHeight);
                    }
                }
                
                // Status effect indicators
                let indicatorY = enemy.y - enemy.size/2 - 15;
                if (enemy.wunderScribble) {
                    ctx.fillStyle = '#FF1A55';
                    ctx.fillRect(enemy.x - 8, indicatorY, 16, 3);
                    indicatorY -= 5;
                }
                if (enemy.poisoned) {
                    ctx.fillStyle = '#90EE90';
                    ctx.fillRect(enemy.x - 8, indicatorY, 16, 3);
                    indicatorY -= 5;
                }
                if (enemy.burning) {
                    ctx.fillStyle = '#FF6600';
                    ctx.fillRect(enemy.x - 8, indicatorY, 16, 3);
                    indicatorY -= 5;
                }
                if (enemy.slowed) {
                    ctx.fillStyle = '#4040ff';
                    ctx.fillRect(enemy.x - 6, indicatorY, 12, 2);
                }
            });

            // Tanks Alot: draw trucks on top of ground effects but beneath enemies/projectiles overlays
            if (Array.isArray(game.trucks) && game.trucks.length) {
                const spr = window._truckSprite || {};
                const img = spr.image;
                const driveFrames = spr.frames && spr.frames.drive || null;
                const targetH = window.TRUCK_TARGET_H || 110; // use shared target height for consistency
                game.trucks.forEach(t => {
                    if (!t) return;
                    ctx.save();
                    ctx.translate(t.x, t.y);
                    // Shadow
                    const shW = (t.width||targetH*2.2)*0.46;
                    const shH = (t.height||targetH)*0.24;
                    ctx.fillStyle = 'rgba(0,0,0,0.25)';
                    ctx.beginPath(); ctx.ellipse(0, (t.height||targetH)*0.28, shW, shH, 0, 0, Math.PI*2); ctx.fill();
                    // Body (use cropped bounds if available)
                    if (img && img.complete && !img._broken && img.naturalWidth) {
                        const sel = (driveFrames && driveFrames[Math.min(t.frame||0, driveFrames.length-1)]) || (driveFrames && driveFrames[0]);
                        const src = sel || { x:0, y:0, w: img.naturalWidth, h: img.naturalHeight };
                        const scale = targetH / src.h;
                        const drawW = src.w * scale;
                        const drawH = src.h * scale;
                        ctx.drawImage(img, src.x, src.y, src.w, src.h, -drawW/2, -drawH/2, drawW, drawH);
                    } else {
                        // Fallback rectangle
                        const wBox = (t.width||targetH*2.2); const hBox = (t.height||targetH);
                        ctx.fillStyle = '#555'; ctx.fillRect(-wBox/2, -hBox/2, wBox, hBox);
                        ctx.fillStyle = '#999'; ctx.fillRect(-wBox*0.45, -hBox*0.30, wBox*0.9, hBox*0.36);
                    }
                    ctx.restore();
                });
            }
            
            // Top-screen boss health bar (Wunderswan / Golden Goose)
            try {
                if (Array.isArray(game.enemies) && game.enemies.length) {
                    const candidates = game.enemies.filter(e => {
                        if (!e || e.health <= 0) return false;
                        const type = (e.type || '').toString().toLowerCase();
                        const name = (e.name || '').toString().toLowerCase();
                        return type.includes('wunderswan') || type.includes('golden goose') || type.includes('goldengoose') || name.includes('wunderswan') || name.includes('golden goose');
                    });
                    let boss = candidates.find(e => {
                        const type = (e.type || '').toString().toLowerCase();
                        const name = (e.name || '').toString().toLowerCase();
                        return type.includes('golden goose') || type.includes('goldengoose') || name.includes('golden goose');
                    });
                    if (!boss) boss = candidates.find(e => ((e.type || '').toString().toLowerCase().includes('wunderswan') || (e.name || '').toString().toLowerCase().includes('wunderswan')));
                    if (!boss) {
                        boss = game.enemies.find(e => e && e.health > 0 && (e.isBoss || e.bossSecret));
                    }
                    if (boss) {
                        const logicalW = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
                        const barW = Math.min(logicalW * 0.86, 820);
                        const barH = Math.max(12, Math.round(Math.min(48, logicalW * 0.024)));
                        const cx = logicalW / 2;
                        const x = cx - barW / 2;
                        const y = 12; // top margin
                        // Background panel
                        ctx.save();
                        ctx.globalAlpha = 0.92;
                        ctx.fillStyle = 'rgba(0,0,0,0.75)';
                        ctx.beginPath();
                        if (ctx.roundRect) ctx.roundRect(x - 6, y - 6, barW + 12, barH + 12, 8);
                        else ctx.rect(x - 6, y - 6, barW + 12, barH + 12);
                        ctx.fill();
                        // Base bar (red)
                        ctx.fillStyle = '#660000';
                        ctx.fillRect(x, y, barW, barH);
                        // Health fill (color depends on boss)
                        const maxHealthSource = boss.maxHealth || boss._maxHealth || boss.healthMax || boss.initialHealth || boss.baseHealth;
                        const maxHealth = Math.max(1, maxHealthSource || 1);
                        const ratio = Math.max(0, Math.min(1, (boss.health || 0) / maxHealth));
                        const typeLabel = (boss.type || '').toString().toLowerCase();
                        const nameLabel = (boss.name || '').toString().toLowerCase();
                        if (typeLabel.includes('golden goose') || typeLabel.includes('goldengoose') || nameLabel.includes('golden goose')) {
                            ctx.fillStyle = '#FFD24D'; // golden fill
                        } else {
                            ctx.fillStyle = '#00ff66'; // default green
                        }
                        ctx.fillRect(x, y, barW * ratio, barH);
                        // Label
                        ctx.fillStyle = '#ffffff';
                        ctx.font = Math.max(12, Math.floor(barH * 0.85)) + 'px Arial';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        const label = (boss.displayName || boss.name || boss.type || 'Boss').toString();
                        ctx.fillText(label, x + 8, y + barH / 2);
                        ctx.restore();
                    }
                }
            } catch(e){/* non-fatal */}

            // Draw projectiles with enhanced effects
            game.projectiles.forEach(proj => {
                if (proj.enemy) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(proj.x - 3, proj.y - 3, 6, 6);
                    return;
                }
                // Resonant Pulse overlay rings (object-mode) — expanding/fading ring at pulse; perf-gated
                if (proj._resActiveRings && proj._resActiveRings.length && !(game.perf && game.perf.lowFx)) {
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    for (let i=0;i<proj._resActiveRings.length;i++) {
                        const ring = proj._resActiveRings[i];
                        const rr = Math.max(4, ring.r || 0);
                        const lifeNorm = Math.max(0, Math.min(1, (ring.life != null ? ring.life : 0) / 38));
                        const alpha = 0.60 * lifeNorm;
                        ctx.strokeStyle = `rgba(199,164,255,${alpha.toFixed(3)})`;
                        ctx.lineWidth = 2 + 1.4 * lifeNorm;
                        if (!reduceRings && ctx.setLineDash) ctx.setLineDash([6, 6]);
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, rr, 0, Math.PI*2); ctx.stroke();
                        if (!reduceRings && ctx.setLineDash) ctx.setLineDash([]);
                    }
                    ctx.restore();
                }
                // Time Bomb fuse glow (object renderer path): intensifies as fuse nears zero
                if (proj.timeBomb && typeof proj._timeBombTimer === 'number') {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    if (!lowFx) {
                        const maxFuse = Math.max(1, proj._tbFuseMax || 54);
                        const t = Math.max(0, proj._timeBombTimer);
                        const frac = 1 - Math.min(1, t / maxFuse);
                        const intensity = Math.min(1, frac*frac * (proj._timeBombArmed ? 1.2 : 1));
                        const baseR = (proj.size || 6) + 6;
                        const glowR = baseR * (1.1 + 0.55 * intensity);
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        // Outer soft warm glow
                        const g = ctx.createRadialGradient(proj.x, proj.y, glowR*0.25, proj.x, proj.y, glowR);
                        const a0 = 0.12 + 0.28 * intensity;
                        g.addColorStop(0, `rgba(255, 210, 120, ${a0.toFixed(3)})`);
                        g.addColorStop(1, 'rgba(255, 210, 120, 0)');
                        ctx.fillStyle = g;
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, glowR, 0, Math.PI*2); ctx.fill();
                        // Inner hot ring pulse as armed approaches detonation
                        if (proj._timeBombArmed && intensity > 0.5) {
                            ctx.globalAlpha = 0.35 + 0.45 * (intensity - 0.5);
                            ctx.strokeStyle = '#FFB366';
                            ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 4 + intensity*4, 0, Math.PI*2); ctx.stroke();
                        }
                        ctx.restore();
                    }
                }
                // Visual Accent: Pattern Amplification halo (SHOOTING INTENSIFIES)
                if (proj._patternAmpFactor && proj._patternAmpFactor > 1.01) {
                    const pulse = 0.55 + Math.sin(performance.now()/140 + (proj.x+proj.y)*0.01)*0.25; // 0.3 amplitude
                    const radius = (proj.size||6) * (1.4 + pulse*0.6);
                    ctx.save();
                    const g = ctx.createRadialGradient(proj.x, proj.y, radius*0.15, proj.x, proj.y, radius);
                    g.addColorStop(0,'rgba(255,255,255,0.55)');
                    g.addColorStop(0.45,'rgba(120,255,200,0.35)');
                    g.addColorStop(1,'rgba(0,255,160,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, radius, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                }
                // Visual Accent: Cascade Burst core flicker prior to pulses
                if (proj.cascadeBurst) {
                    // Mild warm core sheen; intensity spikes right before emission when timer small
                    const tLeft = proj._cascTimer || 0;
                    const intensity = (tLeft <= 3) ? 0.85 : (tLeft <= 6 ? 0.55 : 0.25);
                    if (Math.random() < 0.6) {
                        addParticle(proj.x + (Math.random()-0.5)*4, proj.y + (Math.random()-0.5)*4, intensity>0.6?'#FFE5AA':'#FFC877', 'spark');
                    }
                }
                // Determine base elemental color (fallback cyan)
                let baseColor = '#00BFFF';
                if (proj.damageType === 'fire') baseColor = '#FF5522';
                else if (proj.damageType === 'poison') baseColor = '#33DD55';
                else if (proj.damageType === 'ice' || proj.damageType === 'frost') baseColor = '#44AAFF';
                else if (proj.damageType === 'lightning' || proj.damageType === 'storm') baseColor = '#FFFF55';
                else if (proj.damageType === 'acid') baseColor = '#66FF44';
                else if (proj.damageType === 'void') baseColor = '#AA00FF';
                else if (proj.damageType === 'shadow') baseColor = '#663399';
                else if (proj.damageType === 'crystal') baseColor = '#88EEFF';
                else if (proj.damageType === 'magma') baseColor = '#FF7722';
                else if (proj.damageType === 'plasma') baseColor = '#FF4455';
                else if (proj.damageType === 'inferno') baseColor = '#FF3311';
                else if (proj.damageType === 'blizzard') baseColor = '#C0F8FF';
                else if (proj.damageType === 'toxic') baseColor = '#55FFAA';
                // Energy type overrides
                if (proj.energyType) {
                    const energyColors = {
                        laser: '#99EEFF',
                        particle: '#66FFE4',
                        ion: '#FFE066',
                        pulse: '#FF88DD',
                        photon: '#FFFFFF'
                    };
                    if (energyColors[proj.energyType]) baseColor = energyColors[proj.energyType];
                }
                // Homing tint accent
                if (proj.homing) baseColor = '#FFFFFF';
                else if (proj.weakHoming) baseColor = shadeColor(baseColor, 30);
                // Wunderswan beam override: bright red laser look for projectiles marked as beam
                const isBeam = !!proj.beam;
                if (isBeam) {
                    // Draw long bright red laser beam oriented along velocity
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const ang = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(ang);
                    // Beam core
                    const beamLen = Math.max(40, Math.hypot(proj.vx, proj.vy) * 8);
                    const coreW = Math.max(6, proj.r || (proj.size || 6));
                    const g = ctx.createLinearGradient( -beamLen, 0, beamLen, 0 );
                    g.addColorStop(0, 'rgba(255,80,80,0)');
                    g.addColorStop(0.25, 'rgba(255,40,40,0.65)');
                    g.addColorStop(0.5, 'rgba(255,20,20,0.95)');
                    g.addColorStop(0.75, 'rgba(255,40,40,0.65)');
                    g.addColorStop(1, 'rgba(255,80,80,0)');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.rect(0, -coreW/2, -beamLen, coreW);
                    ctx.fill();
                    // Glow
                    ctx.globalAlpha = 0.55;
                    const glow = ctx.createLinearGradient(-beamLen, 0, beamLen, 0);
                    glow.addColorStop(0, 'rgba(255,120,120,0)');
                    glow.addColorStop(0.5, 'rgba(255,60,60,0.28)');
                    glow.addColorStop(1, 'rgba(255,120,120,0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath(); ctx.rect(0, -coreW*2, -beamLen, coreW*4); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.restore();
                    return; // skip default projectile rendering for beams
                }
                // Quantum flicker: random slight hue shift
                if (proj.quantum && Math.random() < 0.25) baseColor = '#66FFFF';
                // Spiral Bloom pre-bloom cue (brief inner ring)
                if (proj.spiralBloom && proj._sbTelegraph>0 && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.85, proj._sbTelegraph/12);
                    ctx.strokeStyle = '#FFE6AA';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) * 1.1, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();
                }
                // Harmonic Split pre-split cue (thin ring)
                if (proj.harmonicSplit && proj._harmonicTele>0 && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.8, proj._harmonicTele/6);
                    ctx.strokeStyle = '#FFE2BB';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 4, 0, Math.PI*2); ctx.stroke();
                    ctx.restore();
                }
                // Temporal Drift cues: stronger pre-beat and brighter surge shimmer; always show a minimal ring
                if (proj.temporalDrift) {
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const phase = proj._tdPhase || 0;
                    const timer = proj._tdTimer || 0;
                    // Updated thresholds to match stronger cadence
                    const th = phase === 0 ? 30 : (phase === 1 ? 10 : 18);
                    // Pre-beat telegraph: always show one thin ring; add a richer gated ring near swap
                    if (timer >= th - 4) {
                        // minimal always-on ring
                        ctx.save();
                        ctx.globalAlpha = 0.45; // brighter baseline
                        ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                        ctx.lineWidth = 2.2; // thicker
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 4, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                        // ramped richer ring when perf allows
                        if (!lowFx && !reduceRings) {
                            const tight = Math.max(0, Math.min(1, (timer - (th - 4)) / 4));
                            ctx.save();
                            ctx.globalAlpha = 0.30 + 0.65 * tight;
                            ctx.strokeStyle = phase === 2 ? '#A4F5FF' : '#7EDCFF';
                            ctx.lineWidth = 2.6;
                            ctx.beginPath(); ctx.arc(proj.x, proj.y, (proj.size||6) + 6, 0, Math.PI*2); ctx.stroke();
                            ctx.restore();
                        }
                    }
                    // Surge shimmer: brighter/denser inner core during phase 2 (skips on lowFx)
                    if (!lowFx && phase === 2) {
                        const t = (performance.now()/220) + (proj.x+proj.y)*0.002;
                        const pulse = 0.5 + 0.5*Math.sin(t*2*Math.PI);
                        const radius = (proj.size||6) * (1.35 + 0.35*pulse);
                        ctx.save();
                        const g = ctx.createRadialGradient(proj.x, proj.y, radius*0.10, proj.x, proj.y, radius);
                        g.addColorStop(0, 'rgba(170,250,255,' + (0.58 + 0.30*pulse).toFixed(3) + ')');
                        g.addColorStop(1, 'rgba(170,250,255,0)');
                        ctx.fillStyle = g;
                        ctx.beginPath(); ctx.arc(proj.x, proj.y, radius, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                    }
                    // Brief afterimage during surge: faint streaks trailing behind
                    if (!lowFx && phase === 2) {
                        proj._tdTrail = proj._tdTrail || [];
                        const buf = proj._tdTrail;
                        buf.push({ x: proj.x, y: proj.y, t: performance.now() });
                        while (buf.length > 8) buf.shift();
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        for (let k=1; k<buf.length; k++) {
                            const p0 = buf[k-1]; const p1 = buf[k];
                            const ageMs = performance.now() - p0.t;
                            const a = Math.max(0, 1 - ageMs / 140);
                            if (a <= 0) continue;
                            ctx.strokeStyle = `rgba(164,245,255,${(0.20*a).toFixed(3)})`;
                            ctx.lineWidth = Math.max(1.2, (proj.size||6) * 0.22 * a);
                            ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                        }
                        ctx.restore();
                    }
                }
                // Resonant Pulse Core HUD ring for recently buffed shots (perf-gated)
                if ((proj._resBuffSpeed>0 || proj._resBuffDamage>0 || proj._resBuffHoming>0) && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const t = (performance.now()/500) % (Math.PI*2);
                    ctx.rotate(t);
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#C7A4FF';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3,3]);
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+5,0,Math.PI*2); ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
                // Plasma trailing ion particles (add subtle heat haze dots)
                if (proj.damageType === 'plasma' && Math.random() < 0.5) {
                    addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FF7766', 'spark');
                    if (Math.random() < 0.25) addParticle(proj.x, proj.y, '#FFAA99', 'spark');
                }
                // Resonant Pulse Core HUD ring for recently buffed shots (perf-gated)
                if ((proj._resBuffSpeed>0 || proj._resBuffDamage>0 || proj._resBuffHoming>0) && !(game.perf && game.perf.lowFx)) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const t = (performance.now()/500) % (Math.PI*2);
                    ctx.rotate(t);
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#C7A4FF';
                    ctx.lineWidth = 1.5;
                    if (ctx.setLineDash) ctx.setLineDash([3,3]);
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+5,0,Math.PI*2); ctx.stroke();
                    if (ctx.setLineDash) ctx.setLineDash([]);
                    ctx.restore();
                }
                // Weapon-specific override accents
                const wt = proj.weaponType;
                const angle = Math.atan2(proj.vy, proj.vx);
                // Toenail Clibbins enhanced crescent rendering (half-moon keratin shard)
                if (proj.toenail) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    // Gentle forward pointing orientation plus spin
                    const spin = (proj._crescentPhase||0);
                    ctx.rotate(spin);
                    const baseR = (proj.size||10) * 0.95;
                    const thicknessRatio = proj._tnThickness || 0.5;
                    const innerR = baseR * (1 - thicknessRatio);
                    const arcSweep = proj._tnArcSweep || (Math.PI*1.0);
                    const innerOffset = (proj._tnInnerOffset||0.32) * baseR;
                    // Outer arc path
                    ctx.beginPath();
                    const startA = -arcSweep/2;
                    const endA = arcSweep/2;
                    ctx.arc(0,0,baseR,startA,endA,false);
                    // Inner reverse arc (offset center for crescent thickness)
                    const cutX = innerOffset;
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    // Keratin gradient (subtle off-yellow to pale ivory)
                    const grad = ctx.createLinearGradient(-baseR, -baseR, baseR, baseR);
                    grad.addColorStop(0,'#FFF8D7');
                    grad.addColorStop(0.45,'#FFE684');
                    grad.addColorStop(0.75,'#F3D266');
                    grad.addColorStop(1,'#D8B850');
                    ctx.fillStyle = grad;
                    ctx.fill();
                    // Rough edge speckles along outer rim
                    ctx.save();
                    ctx.clip();
                    for (let s=0;s<6;s++) {
                        const a = startA + Math.random()*arcSweep;
                        const rr = baseR - Math.random()*3;
                        ctx.fillStyle = 'rgba(255,255,255,'+(0.25+Math.random()*0.35)+')';
                        ctx.beginPath(); ctx.arc(Math.cos(a)*rr, Math.sin(a)*rr, 1 + Math.random()*1.4, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.restore();
                    // Outline & inner shine
                    ctx.lineWidth = 1.4; ctx.strokeStyle = '#B3943A';
                    ctx.beginPath();
                    ctx.arc(0,0,baseR,startA,endA,false);
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    ctx.stroke();
                    // Inner warm glow
                    const glowR = innerR * 0.85;
                    const g2 = ctx.createRadialGradient(cutX*0.55,0, glowR*0.1, cutX*0.55,0, glowR);
                    g2.addColorStop(0,'rgba(255,240,200,0.6)');
                    g2.addColorStop(1,'rgba(255,240,200,0)');
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = g2;
                    ctx.beginPath(); ctx.arc(cutX*0.55,0,glowR,0,Math.PI*2); ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                    // Occasional sparkle near tip
                    if (Math.random() < 0.10) addParticle(proj.x + Math.cos(spin+0.2)*baseR*0.6 + (Math.random()-0.5)*4, proj.y + Math.sin(spin+0.2)*baseR*0.6 + (Math.random()-0.5)*4, '#FFF6AA','spark');
                    return;
                }
                // Crystal shard unique rendering
                if (proj.crystalShard) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const ang = Math.atan2(proj.vy||0, proj.vx||1);
                    ctx.rotate(ang + (proj._crSpin||0));
                    // Faceted rhombus/triangle shard
                    const r = Math.max(4, (proj.size||5) * 1.2);
                    const hue = 190 + Math.sin((performance.now()/300) + proj.x*0.02 + proj.y*0.02)*5;
                    const body = `hsl(${hue}, 90%, 72%)`;
                    const edge = `hsl(${hue}, 95%, 55%)`;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.8, 0);
                    ctx.lineTo(-r*0.2, -r*0.55);
                    ctx.lineTo(r*0.9, 0);
                    ctx.lineTo(-r*0.2, r*0.55);
                    ctx.closePath();
                    const grad = ctx.createLinearGradient(-r*0.6, -r*0.6, r*0.9, r*0.6);
                    grad.addColorStop(0, 'rgba(255,255,255,0.85)');
                    grad.addColorStop(0.25, body);
                    grad.addColorStop(0.75, 'rgba(150,240,255,0.75)');
                    grad.addColorStop(1, 'rgba(140,230,255,0.0)');
                    ctx.fillStyle = grad;
                    ctx.fill();
                    ctx.strokeStyle = edge; ctx.lineWidth = 1.2;
                    ctx.stroke();
                    // glint
                    if (Math.random()<0.15 && !(game.perf && game.perf.lowFx)) addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#CFF6FF','spark');
                    // subtle spin
                    proj._crSpin = (proj._crSpin||0) + 0.10;
                    ctx.restore();
                    return;
                }
                // Popcorn kernel rendering
                if (proj.isPopcornKernel) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const wob = Math.sin((proj._kernelWobble||0))*0.25;
                    ctx.rotate(wob);
                    const r = (proj.size||6)*0.9;
                    // Outer golden shell
                    const grad = ctx.createRadialGradient(0,-r*0.3, r*0.2, 0,0,r);
                    grad.addColorStop(0,'#FFF7AA');
                    grad.addColorStop(1,'#E0B540');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
                    // Subtle seam
                    ctx.strokeStyle = '#C09030AA';
                    ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(0,0,r*0.65, Math.PI*0.15, Math.PI*1.15); ctx.stroke();
                    ctx.restore();
                    if (Math.random()<0.08) addParticle(proj.x + (Math.random()-0.5)*6, proj.y + (Math.random()-0.5)*6, '#FFEFA0','spark');
                    return;
                }
                // Popcorn puff rendering
                if (proj.popcornPuff) {
                    const img = window._bulletImages && window._bulletImages.popcorn;
                    if (img && img._ok && img.complete && img.naturalWidth) {
                        ctx.save();
                        ctx.translate(proj.x, proj.y);
                        ctx.rotate(proj._puffSpin||0);
                        const base = Math.max(14, (proj.size||10) * 2.0);
                        const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                        let w = base; let h = w / aspect;
                        ctx.imageSmoothingEnabled = true;
                        ctx.drawImage(img, -w/2, -h/2, w, h);
                        ctx.restore();
                        if (Math.random()<0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFEFA0','spark');
                        return;
                    } else {
                        ctx.save();
                        ctx.translate(proj.x, proj.y);
                        ctx.rotate(proj._puffSpin||0);
                        const r = (proj.size||10)*0.85;
                        // Draw clustered lobes
                        ctx.fillStyle = '#FFF9D6';
                        for (let l=0;l<5;l++) {
                            const ang = l/5 * Math.PI*2;
                            const lr = r * (0.55 + ((l%2)*0.15));
                            const lx = Math.cos(ang)*r*0.55;
                            const ly = Math.sin(ang)*r*0.55;
                            ctx.beginPath(); ctx.arc(lx, ly, lr, 0, Math.PI*2); ctx.fill();
                        }
                        // Toasted shading overlay
                        ctx.fillStyle = 'rgba(255,180,60,0.35)';
                        ctx.beginPath(); ctx.arc(-r*0.15, -r*0.1, r*0.65, 0, Math.PI*2); ctx.fill();
                        // Outline
                        ctx.strokeStyle = '#E8D490';
                        ctx.lineWidth = 1.2;
                        ctx.beginPath(); ctx.arc(0,0,r*0.95,0,Math.PI*2); ctx.stroke();
                        ctx.restore();
                        if (Math.random()<0.10) addParticle(proj.x + (Math.random()-0.5)*8, proj.y + (Math.random()-0.5)*8, '#FFEFA0','spark');
                        return;
                    }
                }
                // Umbrella arc rendering (semi-transparent canopy segment)
                if (proj.umbrellaArc) {
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    // Draw a curved segment implying part of an overhead umbrella path.
                    const r = (proj.size||6) * 1.55;
                    const sweep = Math.PI * 0.7; // segment width
                    const start = (Date.now()/520 + (proj._arcSide||1)*0.3) % (Math.PI*2);
                    ctx.lineWidth = 2.3;
                    // canopy gradient (brighter center to pop visually)
                    const grad = ctx.createRadialGradient(0,0,r*0.10,0,0,r);
                    grad.addColorStop(0,'#FFF9E8');
                    grad.addColorStop(0.55,'#FFE5B0AA');
                    grad.addColorStop(1,'#FFAF5030');
                    ctx.strokeStyle = '#FFEDBB';
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0,0,r,start,start+sweep, proj._arcSide===-1);
                    ctx.lineTo(0,0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // shimmering rim
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(255,230,180,0.45)';
                    ctx.lineWidth = 1.1;
                    ctx.beginPath();
                    ctx.arc(0,0,r*0.92,start,start+sweep, proj._arcSide===-1);
                    ctx.stroke();
                    ctx.restore();
                    // Core node (slightly larger)
                    ctx.fillStyle = '#FFEBCF';
                    ctx.beginPath(); ctx.arc(0,0,Math.max(3,(proj.size||6)*0.62),0,Math.PI*2); ctx.fill();
                    // motion shimmer dots
                    if (Math.random()<0.25) {
                        ctx.fillStyle = 'rgba(255,240,210,0.8)';
                        ctx.beginPath(); ctx.arc(Math.cos(start+sweep*0.5)*r*0.55, Math.sin(start+sweep*0.5)*r*0.55, r*0.07, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.restore();
                    if (Math.random()<0.14) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#FFE5B8','spark');
                    return;
                }
                // Diarrhea ability rear clone color override
                if (proj._diarrheaBrown) {
                    // Dedicated brown-only look using sprite if available; bypass other overlays
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    const ang = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(ang);
                    const img = window._bulletImages && window._bulletImages.diarrhea;
                    if (img && img._ok && img.complete && img.naturalWidth) {
                        const base = Math.max(14, (proj.size||6) * 2.0);
                        const iw = img.naturalWidth, ih = img.naturalHeight; const aspect = iw/ih;
                        let w = base * 1.15; let h = w / aspect;
                        ctx.imageSmoothingEnabled = true;
                        ctx.drawImage(img, -w*0.15, -h/2, w, h);
                    } else {
                        const brown = '#8B4513';
                        const w = (proj.size||6) * 1.9; // horizontal stretch for oval look
                        const h = (proj.size||6) * 1.05;
                        ctx.fillStyle = brown;
                        ctx.beginPath(); ctx.ellipse(0,0,w,h,0,0,Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#5A3410AA';
                        ctx.beginPath(); ctx.ellipse(-w*0.15,0,w*0.55,h*0.55,0,0,Math.PI*2); ctx.fill();
                        if (Math.random()<0.15) addParticle(proj.x + (Math.random()-0.5)*10, proj.y + (Math.random()-0.5)*10, '#6B3410', 'spark');
                    }
                    ctx.restore();
                    return; // skip rest of projectile rendering pipeline
                }
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(angle);
                // Motion trail: draw stretched translucent quad opposite velocity
                const speedMag = Math.max(1, Math.hypot(proj.vx, proj.vy));
                const trailLen = Math.min(60, speedMag * 4);
                ctx.save();
                ctx.rotate(0); // already aligned
                ctx.fillStyle = baseColor + '33';
                ctx.beginPath();
                ctx.moveTo(-trailLen, - (proj.size||6)*0.6);
                ctx.lineTo(0, - (proj.size||6)*0.25);
                ctx.lineTo(0,  (proj.size||6)*0.25);
                ctx.lineTo(-trailLen, (proj.size||6)*0.6);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                // Radial aura / special overlays
                const auraR = (proj.size||6) + 8;
                const aura = ctx.createRadialGradient(0,0,0,0,0,auraR);
                aura.addColorStop(0, baseColor + '55');
                aura.addColorStop(1, baseColor + '00');
                ctx.fillStyle = aura;
                ctx.beginPath();
                ctx.arc(0,0,auraR,0,Math.PI*2);
                ctx.fill();
                // Exotic overlays (skip antimatter visual override for diarrhea brown clones so they stay brown)
                if (proj.antimatter && !proj._diarrheaBrown) {
                    // dark core with bright rim
                    const ring = ctx.createRadialGradient(0,0,(proj.size||6)*0.2,0,0,(proj.size||6)+14);
                    ring.addColorStop(0,'#000000');
                    ring.addColorStop(0.5,'#5500AA88');
                    ring.addColorStop(1,'#FFEEFF11');
                    ctx.fillStyle = ring;
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+14,0,Math.PI*2); ctx.fill();
                }
                // Split child accent (golden halo & brighten core)
                if (proj._splitChild) {
                    const sr = (proj.size||6) + 6;
                    const sg = ctx.createRadialGradient(0,0,sr*0.25,0,0,sr);
                    sg.addColorStop(0,'#FFFAD2');
                    sg.addColorStop(0.45,'#FFDD66');
                    sg.addColorStop(1,'#FFDD6600');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = sg;
                    ctx.beginPath(); ctx.arc(0,0,sr,0,Math.PI*2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    // Inner bright core pulse
                    ctx.fillStyle = '#FFFFFF88';
                    ctx.beginPath(); ctx.arc(0,0,Math.max(2,(proj.size||6)*0.4),0,Math.PI*2); ctx.fill();
                }
                if (proj.dimensional) {
                    // swirling ring (animate via time)
                    const t = Date.now()/400;
                    ctx.strokeStyle = '#AA00FF';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4,4]);
                    ctx.beginPath();
                    ctx.arc(0,0,(proj.size||6)+6 + Math.sin(t)*2, t, t + Math.PI*1.2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                if (proj.realityBreak) {
                    // glitch squares
                    for (let g=0; g<3; g++) {
                        ctx.save();
                        ctx.rotate(Math.random()*Math.PI*2);
                        ctx.fillStyle = '#66FFFF' + (Math.random()<0.5?'AA':'55');
                        ctx.fillRect((proj.size||6)+4, -2, 4,4);
                        ctx.restore();
                    }
                }
                if (proj.quantum) {
                    // duplicate faint offset image
                    ctx.save();
                    ctx.globalAlpha = 0.35;
                    ctx.translate(3 * Math.sin(Date.now()/90), 3 * Math.cos(Date.now()/110));
                    ctx.scale(1.05,1.05);
                    ctx.fillStyle = '#66FFFF88';
                    ctx.beginPath(); ctx.arc(0,0,(proj.size||6)+2,0,Math.PI*2); ctx.fill();
                    ctx.restore();
                    // pulsing quantum ring (perf-aware: skip on lowFx)
                    if (!(game.perf && game.perf.lowFx)) {
                        const q = 0.5 + 0.5*Math.sin(performance.now()/180 + (proj.x+proj.y)*0.01);
                        ctx.save();
                        ctx.globalAlpha = 0.25 + 0.45*q;
                        ctx.strokeStyle = '#66FFFF';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.arc(0,0,(proj.size||6) + 4 + q*2, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                    }
                    // orbiting dots indicate remaining extra hits (if present)
                    if (typeof proj.remainingHits === 'number' && proj.remainingHits > 0) {
                        const count = Math.min(5, proj.remainingHits);
                        const rr = (proj.size||6) + 7;
                        const t = performance.now()/400;
                        ctx.save();
                        ctx.fillStyle = '#AAFFFF';
                        for (let i=0;i<count;i++) {
                            const a = t + i*(Math.PI*2/count);
                            ctx.beginPath(); ctx.arc(Math.cos(a)*rr, Math.sin(a)*rr, 1.8, 0, Math.PI*2); ctx.fill();
                        }
                        ctx.restore();
                    }
                }
                // Multi-Infusion visual: inner core gradient blended across active infusion elements
                if (proj.infusionElements && proj.infusionElements.length) {
                    const colorsMap = { fire:'#ff6a00', ice:'#55ccff', lightning:'#ffee55', poison:'#55ff55', void:'#aa55ff', wind:'#aaffdd' };
                    const coreR = (proj.size||6) * 0.9;
                    const g = ctx.createRadialGradient(0,0,0,0,0,coreR);
                    const els = proj.infusionElements.slice(0,4); // limit stops for perf
                    els.forEach((inf, idx) => {
                        const c = colorsMap[inf.type] || '#ffffff';
                        const stop = idx/(els.length);
                        g.addColorStop(Math.min(0.98, stop*0.9), c + 'AA');
                    });
                    g.addColorStop(1, baseColor + '00');
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0,0,coreR,0,Math.PI*2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                // Draw by weapon type
                if (wt === 'sword') {
                    // Blade
                    ctx.fillStyle = '#d0e4ff';
                    ctx.beginPath();
                    ctx.moveTo(-6, -2);
                    ctx.lineTo(18, -1.5);
                    ctx.lineTo(20, 0);
                    ctx.lineTo(18, 1.5);
                    ctx.lineTo(-6, 2);
                    ctx.closePath();
                    ctx.fill();
                    // Edge highlight
                    ctx.strokeStyle = '#ffffffaa';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-5, -1.2);
                    ctx.lineTo(18.5, -0.4);
                    ctx.stroke();
                    // Guard & hilt
                    ctx.fillStyle = '#c09030';
                    ctx.fillRect(-7, -3.5, 3, 7);
                    ctx.fillRect(-9, -1, 4, 2);
                } else if (wt === 'axe') {
                    // Handle
                    ctx.strokeStyle = '#8b5a2b';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-10,0);
                    ctx.lineTo(10,0);
                    ctx.stroke();
                    // Head
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.moveTo(4,-8);
                    ctx.lineTo(14,-4);
                    ctx.lineTo(14,4);
                    ctx.lineTo(4,8);
                    ctx.lineTo(6,0);
                    ctx.closePath();
                    ctx.fill();
                    // Edge
                    ctx.strokeStyle = '#ffffffdd';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(13.5,-4);
                    ctx.lineTo(13.5,4);
                    ctx.stroke();
                } else if (wt === 'spear') {
                    // Shaft
                    ctx.strokeStyle = '#b07a30';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-14,0);
                    ctx.lineTo(18,0);
                    ctx.stroke();
                    // Tip
                    ctx.fillStyle = '#e0e0e0';
                    ctx.beginPath();
                    ctx.moveTo(18,0);
                    ctx.lineTo(12,-4);
                    ctx.lineTo(12,4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffffffaa';
                    ctx.beginPath();
                    ctx.moveTo(18,0);
                    ctx.lineTo(12,-3);
                    ctx.stroke();
                } else if (wt === 'hammer') {
                    // Handle
                    ctx.strokeStyle = '#7b4a1a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-14,0);
                    ctx.lineTo(10,0);
                    ctx.stroke();
                    // Head (rectangular)
                    ctx.fillStyle = '#bbbbbb';
                    ctx.fillRect(4,-6,12,12);
                    // Face highlight
                    ctx.fillStyle = '#e6e6e6';
                    ctx.fillRect(4,-6,5,12);
                } else if (wt === 'dagger') {
                    // Represent a cluster of small daggers spinning
                    const t = (Date.now()/80)%Math.PI*2;
                    for (let i=0;i<3;i++) {
                        const a = t + i*(Math.PI*2/3);
                        ctx.save();
                        ctx.rotate(a);
                        ctx.fillStyle = '#d8eaff';
                        ctx.beginPath();
                        ctx.moveTo(0,-1.5);
                        ctx.lineTo(10,-0.8);
                        ctx.lineTo(10,0.8);
                        ctx.lineTo(0,1.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    // Central core
                    ctx.fillStyle = '#c09030';
                    ctx.beginPath();
                    ctx.arc(0,0,2.5,0,Math.PI*2);
                    ctx.fill();
                } else if (wt === 'toenail') {
                    // Main projectile as a yellow crescent shard (distinct from separate Toenail crescent spawns)
                    ctx.save();
                    ctx.translate(0,0);
                    const baseR = (proj.size||8) * 1.0;
                    const thicknessRatio = 0.45;
                    const innerR = baseR * (1 - thicknessRatio);
                    const arcSweep = Math.PI*1.05;
                    const cutX = baseR * 0.35;
                    // Outer arc path
                    ctx.beginPath();
                    const startA = -arcSweep/2;
                    const endA = arcSweep/2;
                    ctx.arc(0,0,baseR,startA,endA,false);
                    // Inner reverse arc
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    // Keratin yellow gradient
                    const grad = ctx.createLinearGradient(-baseR, -baseR, baseR, baseR);
                    grad.addColorStop(0,'#FFF8D7');
                    grad.addColorStop(0.45,'#FFE684');
                    grad.addColorStop(0.75,'#F3D266');
                    grad.addColorStop(1,'#D8B850');
                    ctx.fillStyle = grad; ctx.fill();
                    // Outline
                    ctx.lineWidth = 1.2; ctx.strokeStyle = '#B3943A';
                    ctx.beginPath();
                    ctx.arc(0,0,baseR,startA,endA,false);
                    ctx.arc(cutX,0, innerR, endA, startA, true);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                } else if (!proj.meteor) {
                    // Default (non-weapon) projectile (skip if meteor to keep it purely round)
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    const half = proj.size;
                    // Render as a rounded diamond-ish shape for slight polish vs basic square
                    ctx.moveTo(-half, 0);
                    ctx.lineTo(0, -half);
                    ctx.lineTo(half, 0);
                    ctx.lineTo(0, half);
                    ctx.closePath();
                    ctx.fill();
                    // Slalom visual cue: faint alternating chevrons showing gated turns
                    if (proj.slalomPattern) {
                        ctx.save();
                        ctx.globalAlpha = 0.45;
                        ctx.strokeStyle = baseColor + 'AA';
                        ctx.lineWidth = 1;
                        const step = 6;
                        for (let d=step; d<=24; d+=step) {
                            const s = (Math.floor(d/step)%2===0) ? 1 : -1;
                            ctx.beginPath();
                            ctx.moveTo(-d, s*half*0.4);
                            ctx.lineTo(-(d-3), s*half*0.15);
                            ctx.stroke();
                        }
                        ctx.restore();
                    }
                }
                // Meteor custom rendering (round fiery rock with craters & flame trail)
                if (proj.meteor) {
                    const mR = (proj.size || 16);
                    // Overdraw previous shape with meteor look
                    ctx.save();
                    // Core fiery gradient (center bright, edge dark rock)
                    const g = ctx.createRadialGradient(0,0,mR*0.2,0,0,mR);
                    g.addColorStop(0,'#FFE4BB');
                    g.addColorStop(0.35,'#FFAA44');
                    g.addColorStop(0.65,'#DD5511');
                    g.addColorStop(1,'#331104');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(0,0,mR,0,Math.PI*2);
                    ctx.fill();
                    // Rim glow (slight flicker)
                    ctx.strokeStyle = 'rgba(255,180,80,' + (0.35 + Math.random()*0.35).toFixed(2) + ')';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0,0,mR-1,0,Math.PI*2); ctx.stroke();
                    // Crater / scorch marks
                    for (let c=0;c<6;c++) {
                        const ca = Math.random()*Math.PI*2;
                        const cr = Math.random()*mR*0.55;
                        const r  = mR*0.12*(0.6+Math.random()*0.8);
                        ctx.fillStyle = 'rgba(0,0,0,' + (0.25+Math.random()*0.25).toFixed(2) + ')';
                        ctx.beginPath(); ctx.arc(Math.cos(ca)*cr, Math.sin(ca)*cr, r, 0, Math.PI*2); ctx.fill();
                    }
                    // Flame tongue trail (context rotated along velocity, so draw to -X)
                    for (let f=0; f<3; f++) {
                        const fx = -mR - f*mR*0.45;
                        const ry = mR*0.35*(0.9 - f*0.25);
                        ctx.fillStyle = 'rgba(255,' + (120+Math.floor(Math.random()*100)) + ',0,' + (0.25+Math.random()*0.25).toFixed(2) + ')';
                        ctx.beginPath();
                        ctx.ellipse(fx, (Math.random()-0.5)*mR*0.4, mR*0.55*(1-f*0.15), ry, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                    // Spark / ember particles (spawn behind meteor)
                    if (Math.random() < 0.5) {
                        addParticle(proj.x - proj.vx*0.2 + (Math.random()-0.5)*mR*0.6, proj.y - proj.vy*0.2 + (Math.random()-0.5)*mR*0.6, '#FFAA55', 'spark');
                    }
                }
                // Piercing arrowhead indicator
                if (proj.piercing && !wt) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.moveTo((proj.size||6)+4,0);
                    ctx.lineTo((proj.size||6)+0, -3);
                    ctx.lineTo((proj.size||6)+0, 3);
                    ctx.closePath();
                    ctx.fill();
                }
                // Homing indicator
                if (proj.homing) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-1,-1,2,2);
                }
                if (proj.weakHoming && !proj.homing) {
                    ctx.fillStyle = '#ffffffaa';
                    ctx.fillRect(-1,-1,2,2);
                }
                // Explosive ring indicator
                if (proj.explosive) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2,2]);
                    ctx.beginPath();
                    ctx.arc(0,0,(proj.size||6)+5,0,Math.PI*2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                // Remaining quantum hits (small dots)
                if (proj.hitMultipleTimes && proj.remainingHits > 0) {
                    ctx.fillStyle = '#66FFFF';
                    for (let h=0; h<proj.remainingHits; h++) {
                        ctx.beginPath(); ctx.arc(-6 - h*5, - (proj.size||6) - 4, 2, 0, Math.PI*2); ctx.fill();
                    }
                }
                ctx.restore();
            });

            // Ion Cannon charge telegraph (HUD ring near player while holding fire)
            if (game.player && game._ionChargeTime && game._ionChargeTime > 0) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const charge = Math.min(1.0, game._ionChargeTime / 80);
                const r = 18 + charge * 14;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = `rgba(150,240,255,${0.6 + 0.35*charge})`;
                ctx.lineWidth = 2 + charge * 3;
                ctx.beginPath();
                ctx.arc(px, py, r, 0, Math.PI*2);
                ctx.stroke();
                // inner glow
                const g = ctx.createRadialGradient(px, py, r*0.35, px, py, r);
                g.addColorStop(0, `rgba(120,220,255,${0.15 + 0.25*charge})`);
                g.addColorStop(1, 'rgba(120,220,255,0)');
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }

            // Render Dimensional Rift fields (soft pulsing gradient to show radius)
            if (game._dimRifts && game._dimRifts.length) {
                for (let i=0; i<game._dimRifts.length; i++) {
                    const r = game._dimRifts[i];
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                    const agePct = 1 - (r.life / (r.maxLife||r.life||1));
                    const pulse = 0.9 + 0.1 * Math.sin(performance.now()/260 + i*0.7);
                    const rad = r.r * pulse;
                    const alpha = 0.20 * (1 - agePct * 0.65);
                    const g = ctx.createRadialGradient(r.x, r.y, rad*0.15, r.x, r.y, rad);
                    g.addColorStop(0, `rgba(170,70,255,${(alpha*0.75).toFixed(3)})`);
                    g.addColorStop(1, 'rgba(170,70,255,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(r.x, r.y, rad, 0, Math.PI*2); ctx.fill();
                    // Faint perimeter ring
                    if (!reduceRings) {
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, alpha * 0.9);
                        ctx.strokeStyle = 'rgba(220,180,255,0.5)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5,5]);
                        ctx.beginPath(); ctx.arc(r.x, r.y, r.r*0.9, 0, Math.PI*2); ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                    // Subtle inner swirl hint (skip on lowFx)
                    if (!lowFx) {
                        ctx.save();
                        ctx.globalAlpha = alpha * 0.4;
                        ctx.translate(r.x, r.y);
                        const t = performance.now()/800 + i;
                        ctx.rotate(t);
                        ctx.strokeStyle = 'rgba(210,190,255,0.35)';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        for (let a=0; a<=Math.PI*2; a+=Math.PI/24) {
                            const rr = (r.r*0.35) + Math.sin(a*3 + t*4) * 6;
                            const px = Math.cos(a) * rr;
                            const py = Math.sin(a) * rr;
                            if (a===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
                        }
                        ctx.closePath(); ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            // Render Time Warp fields (under projectiles but above background)
            if (game.timeWarpFields && game.timeWarpFields.length) {
                game.timeWarpFields.forEach(f => {
                    const age = Date.now() - f.createdAt;
                    const pct = age / f.duration;
                    const baseAlpha = Math.max(0, 0.35 * (1 - pct));
                    const ringR = f.radius * (0.85 + 0.15*Math.sin(f.wave*3));
                    const lowFx = !!(game.perf && game.perf.lowFx);
                    // Outer soft glow
                    const grad = ctx.createRadialGradient(f.x, f.y, ringR*0.15, f.x, f.y, ringR);
                    grad.addColorStop(0, 'rgba(80,200,255,' + (baseAlpha*0.8).toFixed(3) + ')');
                    grad.addColorStop(1, 'rgba(80,200,255,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(f.x, f.y, ringR, 0, Math.PI*2); ctx.fill();
                    // Pulsing ring outline
                    ctx.strokeStyle = 'rgba(120,240,255,' + (baseAlpha*0.9).toFixed(3) + ')';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6,6]);
                    ctx.beginPath(); ctx.arc(f.x, f.y, ringR * (0.55 + 0.25*Math.sin(f.wave*4)), 0, Math.PI*2); ctx.stroke();
                    ctx.setLineDash([]);
                    // Brief flash at pulse beats (approximate using wave phase)
                    const beat = Math.sin(f.wave*Math.PI*2);
                    if (beat > 0.985) {
                        ctx.save();
                        ctx.globalAlpha = baseAlpha * 0.9;
                        ctx.strokeStyle = 'rgba(180,255,255,0.9)';
                        ctx.lineWidth = 3.5;
                        ctx.beginPath(); ctx.arc(f.x, f.y, ringR*0.75, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                    }
                    // Pre-pulse telegraph: a faint inner ring just before beat, skip on lowFx
                    if (!lowFx && beat > 0.9 && beat <= 0.985) {
                        ctx.save();
                        ctx.globalAlpha = baseAlpha * 0.5;
                        ctx.strokeStyle = 'rgba(160,230,255,0.6)';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.arc(f.x, f.y, ringR*0.62, 0, Math.PI*2); ctx.stroke();
                        ctx.restore();
                    }
                });
            }
            
            // Render Reality Break fields (layered shimmering halo + edge highlight)
            if (game.activeRealityFields && game.activeRealityFields.length) {
                const lowFx = !!(game.perf && game.perf.lowFx);
                const reduceRings = !!(game.fxFlags && game.fxFlags.reduceRings);
                const nowRB = Date.now();
                for (let i=0;i<game.activeRealityFields.length;i++) {
                    const f = game.activeRealityFields[i];
                    const tLeft = Math.max(0, f.expiresAt - nowRB);
                    const pct = 1 - (tLeft / (100)); // normalized within local span; safe default
                    const pulse = 0.9 + 0.1*Math.sin(performance.now()/280 + i*1.1);
                    const r = f.radius * pulse;
                    // Outer halo
                    const grad = ctx.createRadialGradient(f.x, f.y, r*0.2, f.x, f.y, r);
                    grad.addColorStop(0, 'rgba(120,255,255,0.24)');
                    grad.addColorStop(1, 'rgba(120,255,255,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(f.x, f.y, r, 0, Math.PI*2); ctx.fill();
                    // Edge highlight ring
                    if (!reduceRings) {
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.strokeStyle = 'rgba(180,255,255,0.6)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([3,3]);
                        ctx.beginPath(); ctx.arc(f.x, f.y, f.radius*0.96, 0, Math.PI*2); ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                    // Inner shimmer wobble (skip on lowFx)
                    if (!lowFx) {
                        ctx.save();
                        ctx.globalAlpha = 0.35;
                        ctx.strokeStyle = 'rgba(160,255,255,0.5)';
                        ctx.lineWidth = 1.25;
                        ctx.translate(f.x, f.y);
                        const t = performance.now()/700 + i*0.5;
                        ctx.rotate(Math.sin(t)*0.1);
                        ctx.beginPath();
                        for (let a=0; a<=Math.PI*2; a+=Math.PI/18) {
                            const rr = (f.radius*0.5) + Math.cos(a*5 + t*3) * 5;
                            const px = Math.cos(a) * rr;
                            const py = Math.sin(a) * rr;
                            if (a===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
                        }
                        ctx.closePath(); ctx.stroke();
                        ctx.restore();
                    }
                }
            }
            
            // Draw player with enhanced graphics (sprite sheet based)
            // Elemental Conduit visual halo (behind sprite): blend of active infusion colors
            if (game.player && game.player.infusions && game.player.infusions.length) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const baseR = 36;
                // Compute blended color once per frame using helper
                const blend = (typeof getInfusionColorBlend === 'function') ? getInfusionColorBlend() : '#ffffff';
                // Outer soft radial glow with slight pulsing
                const t = performance.now();
                const pulse = 1 + Math.sin(t/240 + (px+py)*0.01) * 0.08;
                const r = baseR * pulse;
                const g = ctx.createRadialGradient(px, py, 6, px, py, r);
                // Convert hex to rgba stops
                try {
                    const v = parseInt(blend.slice(1), 16);
                    const cr = (v>>16)&255, cg = (v>>8)&255, cb = v&255;
                    g.addColorStop(0, `rgba(${cr},${cg},${cb},0.35)`);
                    g.addColorStop(1, `rgba(${cr},${cg},${cb},0)`);
                } catch(e) {
                    g.addColorStop(0, 'rgba(255,255,255,0.25)');
                    g.addColorStop(1, 'rgba(255,255,255,0)');
                }
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
            // Terrifying Aura visual (behind player sprite)
            if (game.player && game.player.auraActive) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const t = performance.now() * 0.002;
                const baseR = 60; // matches aura contact radius
                const pulse = Math.sin(t*3) * 5;
                const rOuter = baseR + pulse;
                // Multi-layer glow for fuller circular look (less "D" shape)
                for (let layer=0; layer<3; layer++) {
                    const lr = rOuter - layer*6;
                    if (lr <= 0) continue;
                    const g = ctx.createRadialGradient(px, py, 12, px, py, lr);
                    const alphaBase = 0.22 - layer*0.06;
                    g.addColorStop(0, `rgba(185,90,255,${alphaBase})`);
                    g.addColorStop(0.5, `rgba(150,50,230,${alphaBase*0.55})`);
                    g.addColorStop(1, 'rgba(90,0,170,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(px, py, lr, 0, Math.PI*2);
                    ctx.fill();
                }
                // Soft perimeter ring
                ctx.save();
                ctx.beginPath();
                ctx.arc(px, py, rOuter-3, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(210,140,255,0.35)';
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = 14;
                ctx.shadowColor = 'rgba(200,120,255,0.6)';
                ctx.stroke();
                ctx.restore();
            }
            // Ensure player stays visible after final boss defeat (disable blink suppression)
            // forceVisibleFrames: countdown frames where player must be drawn (post-reset/death)
            if (game.player && game.player.forceVisibleFrames && game.player.forceVisibleFrames > 0) {
                game.player.forceVisibleFrames--;
            }
            const forceShowPlayer = (game._bigQuackDefeated && !game.gameOver) || (game.player && game.player.forceVisibleFrames>0);
            if (forceShowPlayer || (!game.player.invulnerable || Math.floor(Date.now() / 100) % 2)) {
                const px = Math.round(game.player.x);
                const py = Math.round(game.player.y);
                const meta = game.player.spriteMeta;
                const sheet = game.player.spriteSheet;
                const desiredHeight = (game.player && game.player.spriteTargetHeight) || 54;
                const df = game.player.directionalFrames;
                // If we are within initial forced visibility window but frames missing, retry rebuild
                if ((!df || !game.player.spriteLoaded) && game.player._pendingSpriteRetry) {
                    game.player._pendingSpriteRetry--;
                    if (typeof rebuildPlayerSprite === 'function') rebuildPlayerSprite();
                }
                const walkFrames = Array.isArray(game.player.walkFrames) && game.player.walkFrames.length ? game.player.walkFrames : null;
                const hasWalkAnim = !!walkFrames;
                const wantsStatic = !game.player.moving || !hasWalkAnim;
                let frameW, frameH, sx, sy, sourceW, sourceH;
                let visibleHeight = null;
                let useStatic = false;
                let useWalkAnim = false;
                let sourceImage = sheet;
                if (wantsStatic && df && game.player.spriteLoaded) {
                    let facing = game.player.facing || 'down';
                    if (facing === 'left' && !df.left) facing = 'left';
                    let box = df[facing];
                    if (!box) {
                        if (facing === 'left' && df.right) {
                            box = df.right;
                        } else {
                            box = df.down || (df.right || df.up) || Object.values(df)[0];
                        }
                    }
                    if (box) {
                        sx = box.x;
                        sy = box.y;
                        sourceW = box.w;
                        sourceH = box.h;
                        frameW = sourceW;
                        frameH = sourceH;
                        sourceImage = box.image || sheet;
                        useStatic = true;
                        visibleHeight = box.visibleHeight || frameH;
                    }
                }
                if (!useStatic && hasWalkAnim && game.player.spriteLoaded) {
                    const len = walkFrames.length;
                    if (len > 0) {
                        const idx = ((game.player.animFrame % len) + len) % len;
                        const frame = walkFrames[idx] || walkFrames[0];
                        if (frame) {
                            sx = frame.x;
                            sy = frame.y;
                            sourceW = frame.w;
                            sourceH = frame.h;
                            frameW = frame.w;
                            frameH = frame.h;
                            sourceImage = frame.image || sheet;
                            useWalkAnim = true;
                            visibleHeight = frame.visibleHeight || frameH;
                        }
                    }
                }
                if (!useStatic && !useWalkAnim) {
                    const frameWBase = meta ? meta.frameWidth : 48;
                    const frameHBase = meta ? meta.frameHeight : 48;
                    frameW = frameWBase;
                    frameH = frameHBase;
                    sourceImage = sheet;
                    visibleHeight = frameH;
                }
                const rawHeight = Math.max(1, frameH || desiredHeight);
                const effectiveVisibleHeight = Math.max(1, visibleHeight || rawHeight);
                let scale = desiredHeight / effectiveVisibleHeight;
                if (!isFinite(scale) || scale <= 0) scale = game.player.spriteScale && isFinite(game.player.spriteScale) ? game.player.spriteScale : 1;
                else if (!game.player.spriteScale || !isFinite(game.player.spriteScale) || game.player.spriteScale <= 0) game.player.spriteScale = scale;
                const drawW = frameW * scale;
                const drawH = frameH * scale;
                const yOffset = 6; // adjust to taste so feet contact ground line
                if (sourceImage && game.player.spriteLoaded) {
                    // Defensive: if directionalFrames lost (e.g. due to external mutation) rebuild minimal mapping once
                    if (!df && meta && !game.player._rebuildAttempted) {
                        game.player._rebuildAttempted = true;
                        // Reconstruct a single-frame fallback using first frame of sheet
                        game.player.directionalFrames = { down: { x:0, y:0, w: meta.frameWidth, h: meta.frameHeight } };
                    }
                    if (useStatic || useWalkAnim) {
                        const isLeft = (game.player.facing === 'left');
                        const allowMirror = (useStatic && df && df.right) || useWalkAnim;
                        if (isLeft && allowMirror) {
                            // Mirror draw
                            ctx.save();
                            ctx.translate(px, py + yOffset);
                            ctx.scale(-1, 1);
                            ctx.drawImage(sourceImage, sx, sy, sourceW, sourceH, -drawW/2, -drawH/2, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH);
                            }
                            ctx.restore();
                        } else {
                            ctx.drawImage(sourceImage, sx, sy, sourceW, sourceH, px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            }
                        }
                    } else if (meta) {
                        // Fallback to grid method if directionalFrames missing
                        if (!df && forceShowPlayer) {
                            // Draw a simple placeholder circle so player is never invisible
                            ctx.save();
                            ctx.fillStyle = 'rgba(255,255,255,0.85)';
                            ctx.beginPath();
                            ctx.arc(px, py, 12, 0, Math.PI*2);
                            ctx.fill();
                            ctx.restore();
                        }
                        let rowIndex = meta.order.indexOf(game.player.facing || 'down');
                        if (rowIndex < 0) rowIndex = 0;
                        if (rowIndex >= meta.rows) rowIndex = 0;
                        let colIndex = game.player.animFrame % (meta.cols || 1);
                        if (colIndex >= meta.cols) colIndex = 0;
                        const _sx = colIndex * frameW;
                        const _sy = rowIndex * frameH;
                        if (_sx + frameW <= sheet.width && _sy + frameH <= sheet.height) {
                            ctx.drawImage(sheet, _sx, _sy, frameW, frameH, px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            if (game._debugSpriteBounds) {
                                ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                                ctx.strokeRect(px - drawW/2, py - drawH/2 + yOffset, drawW, drawH);
                            }
                        } else {
                            ctx.fillStyle = '#990000';
                            ctx.fillRect(px - 12, py - 12, 24, 24);
                        }
                    }
                } else {
                    // More assertive placeholder if we're forcing visibility
                    if (forceShowPlayer) {
                        ctx.save();
                        ctx.translate(px, py);
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.55)'; // gold shimmer
                        ctx.beginPath();
                        ctx.arc(0, 0, 20, 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    } else if (!game._playerPlaceholderDrawn) {
                        // Single faint silhouette fallback (non-forced path)
                        ctx.fillStyle = 'rgba(0,0,0,0.08)';
                        ctx.beginPath();
                        ctx.arc(px, py, 18, 0, Math.PI*2);
                        ctx.fill();
                        game._playerPlaceholderDrawn = true;
                    }
                }
            }
            
            // Nuke explosion flash overlay (above scene, below damage numbers/UI)
            if (Array.isArray(game.nukes) && game.nukes.length) {
                game.nukes.forEach(n => {
                    if (!n || !n.exploded || n.flashTime <= 0 || !n._flashMax) return;
                    const p = n.flashTime / n._flashMax; // 0..1
                    const intensity = Math.pow(p, 0.6); // slower fade at start
                    const maxR = n.radius * 1.4; // expand slightly
                    const r = maxR * (1 + (1-p)*0.35);
                    const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, r);
                    g.addColorStop(0, `rgba(255,255,255,${0.85*intensity})`);
                    g.addColorStop(0.25, `rgba(255,220,120,${0.55*intensity})`);
                    g.addColorStop(0.55, `rgba(255,140,0,${0.35*intensity})`);
                    g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.9*intensity;
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, r, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                });
                ctx.globalAlpha = 1;
            }

            // Floating damage numbers (above everything except pause/menu overlays)
            if (game.damageNumbers && game.damageNumbers.length) {
                ctx.save();
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                game.damageNumbers.forEach(dn => {
                    const alpha = Math.max(0, Math.min(1, dn.life / 60));
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = dn.color;
                    ctx.save();
                    ctx.translate(dn.x, dn.y);
                    ctx.scale(dn.scale, dn.scale);
                    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                    ctx.lineWidth = 3;
                    ctx.strokeText(dn.value, 0, 0);
                    ctx.fillText(dn.value, 0, 0);
                    ctx.restore();
                });
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            // Enemy bullets: draw last so they are always visible on top
            if (game.renderEnemyProjectilesTop) game.renderEnemyProjectilesTop(ctx);

            // Forced Wunderswan overlay (defensive): if the asset image is loaded, draw it here
            // This ensures the Wunderswan sprite from `assets/wunderswan-sheet-1-30.png` renders above other
            // scene elements even if the normal override branch did not execute for timing reasons.
            try {
                const ws = game && game.enemySprites && game.enemySprites.wunderswan;
                if (ws && ws.image && (ws.image.complete || (ws.image.naturalWidth && ws.image.naturalWidth > 0))) {
                    const boss = Array.isArray(game.enemies) && game.enemies.find(e => e && e.type === 'Wunderswan' && e.health > 0);
                    if (boss) {
                        const img = ws.image;
                        const frameSet = ws.frames;
                        const seq = frameSet && frameSet.seq;
                        let f = null;
                        if (seq && seq.length) {
                            const frameStep = (ws.anim && ws.anim.frameStep) || 8;
                            const nowFrame = (game && typeof game.frame === 'number') ? game.frame : Math.floor(Date.now() / 16);
                            if (typeof boss._wunderswanAnimSeed !== 'number') boss._wunderswanAnimSeed = nowFrame;
                            const animTicks = Math.max(0, nowFrame - boss._wunderswanAnimSeed);
                            let frameIdx = Math.floor(animTicks / frameStep) % seq.length;
                            f = seq[frameIdx];
                        } else {
                            f = (frameSet && (frameSet.down || frameSet.right || frameSet.up)) || (img && ((img.naturalWidth || img.width) > 0) ? { x:0, y:0, w: img.naturalWidth || img.width, h: img.naturalHeight || img.height } : null);
                        }
                        if (f && img) {
                            const size = boss.size || 180;
                            const scale = (typeof ws.baseScaleForSize === 'function') ? ws.baseScaleForSize(size) : ((size*2)/(f.h || 256));
                            const drawW = f.w * scale;
                            const drawH = f.h * scale;
                            ctx.save();
                            ctx.globalCompositeOperation = 'source-over';
                            // center at boss.x/boss.y
                            // mark that we drew a forced overlay this frame so the normal enemy draw won't render
                            // its own magenta fallback on top of this; the draw-time fallback will clear this flag.
                            try { boss._overlayDrawnFrame = (game.frame || 0); } catch(_){ }
                            // Draw centered at boss.x/boss.y. Mirror horizontally when player is to the right of boss center.
                            const dx = Math.round(boss.x - drawW/2);
                            const dy = Math.round(boss.y - drawH/2);
                            try {
                                // Decide facing for drawing based on player position relative to boss center.
                                const drawFacing = (game && game.player && typeof game.player.x === 'number') ? (game.player.x > boss.x ? 'right' : 'left') : (boss.facing || 'left');
                                if (drawFacing === 'left') {
                                    ctx.save();
                                    // Translate to the right edge of destination rect, flip X, draw at (0,0)
                                    ctx.translate(dx + drawW, dy);
                                    ctx.scale(-1, 1);
                                    ctx.drawImage(img, f.x, f.y, f.w, f.h, 0, 0, drawW, drawH);
                                    ctx.restore();
                                } else {
                                    ctx.drawImage(img, f.x, f.y, f.w, f.h, dx, dy, drawW, drawH);
                                }
                            } catch(_) {
                                // Fallback: draw without mirroring if anything goes wrong
                                ctx.drawImage(img, f.x, f.y, f.w, f.h, dx, dy, drawW, drawH);
                            }
                            ctx.restore();
                            try { console.info('[WunderswanSprite][OVERLAY] forced top-layer draw', { src: img && img.src, x: boss.x, y: boss.y, drawW, drawH }); } catch(_){}
                        }
                    }
                }
            } catch (e) { try { console.warn('[WunderswanSprite][OVERLAY] draw failure', e && e.message); } catch(_){} }

            // Reality Break screen-space distortion: slice displacement & chromatic fringe (gated by settings)
            if (game.settings && game.settings.realityBreakOverlay && game.realityBreakDistort && game.realityBreakDistort.time > 0) {
                const d = game.realityBreakDistort;
                // Create / reuse offscreen buffer
                if (!game._distortCanvas || game._distortCanvas.width !== canvas.width || game._distortCanvas.height !== canvas.height) {
                    game._distortCanvas = document.createElement('canvas');
                    game._distortCanvas.width = canvas.width; game._distortCanvas.height = canvas.height;
                }
                const off = game._distortCanvas;
                const octx = off.getContext('2d');
                octx.clearRect(0,0,off.width,off.height);
                octx.drawImage(canvas, 0, 0);
                const slices = 12;
                // Replace the main canvas content with the displaced slices (avoid drawing slices on top of
                // the original scene which produced a doubled/ghosted image). Clear first, then draw slices.
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i=0;i<slices;i++) {
                    const sliceH = Math.ceil(canvas.height / slices);
                    const sy = i * sliceH;
                    const sh = Math.min(sliceH, canvas.height - sy);
                    const offset = Math.sin((Date.now()/140)+(i*0.9)) * 7 * d.intensity + (Math.random()-0.5)*4*d.intensity;
                    ctx.globalAlpha = 1.0;
                    ctx.drawImage(off, 0, sy, canvas.width, sh, offset, sy, canvas.width, sh);
                }
                ctx.restore();
                // Chromatic radial fringe removed to avoid additional ghosting/double-image effects.
                // Previous implementation applied a translucent radial color overlay here which
                // some players found disorienting when combined with the slice displacement.
                ctx.globalAlpha = 1;
                // Decay timers
                d.time--;
                d.intensity *= 0.97; if (d.time<=0) d.intensity = 0;
            }

            // Room cleared overlay
            if (game.roomCleared) {
                // NOTE: removed the heavy fullscreen dim so leftover chests and items remain visible.
                // If readability of the text becomes an issue, consider adding a small outline or
                // a faint translucent panel behind the text only instead of dimming the whole scene.
                // ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                // ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw a subtle stroked title so it remains legible on varied backgrounds
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                // Center using logical dimensions (avoid DPR inflated canvas.width causing mis-centering)
                const logicalMidX = (window.__LOGICAL_CANVAS__ ? window.__LOGICAL_CANVAS__.w : canvas.width) / 2;
                const logicalMidY = (window.__LOGICAL_CANVAS__ ? window.__LOGICAL_CANVAS__.h : canvas.height) / 2;
                ctx.strokeText('STREET CLEARED!', logicalMidX, logicalMidY - 30);
                ctx.fillText('STREET CLEARED!', logicalMidX, logicalMidY - 30);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '18px Arial';
                ctx.strokeText('Press FIRE for next street', logicalMidX, logicalMidY + 20);
                ctx.fillText('Press FIRE for next street', logicalMidX, logicalMidY + 20);

                ctx.fillStyle = '#ffff00';
                ctx.font = '14px Arial';
                ctx.strokeText(`Score: +${50 * game.dungeon}`, logicalMidX, logicalMidY + 50);
                ctx.fillText(`Score: +${50 * game.dungeon}`, logicalMidX, logicalMidY + 50);
                
                ctx.textAlign = 'left';
            }
            // Game Over overlay (draw after room cleared so it supersedes)
            if (game.gameOver) {
                const logicalW = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.w) || canvas.width;
                const logicalH = (window.__LOGICAL_CANVAS__ && window.__LOGICAL_CANVAS__.h) || canvas.height;
                const cx = logicalW / 2;
                const cy = logicalH / 2;
                const since = performance.now() - (game._gameOverAt || performance.now());
                const fade = Math.min(1, since / 650); // slower fade to full
                // Ease (quadratic out)
                const eased = fade * (2 - fade);
                ctx.save();
                ctx.globalAlpha = 0.85 + eased * 0.10;
                if (game.gameOverImage && game.gameOverImage.complete) {
                    const iw = game.gameOverImage.width;
                    const ih = game.gameOverImage.height;
                    // Target max fractions of logical dimensions
                    const maxW = logicalW * 0.70;
                    const maxH = logicalH * 0.70;
                    let scale = Math.min(maxW / iw, maxH / ih);
                    // Intro pop scale (slightly overshoot then settle)
                    const pop = 1 + (1 - eased) * 0.25; // starts 1.25 -> 1.0
                    scale *= pop;
                    const dw = iw * scale;
                    const dh = ih * scale;
                    const dx = cx - dw / 2;
                    const dy = cy - dh / 2;
                    ctx.drawImage(game.gameOverImage, dx, dy, dw, dh);
                } else {
                    // Fallback simple text if image not yet loaded
                    ctx.fillStyle = 'rgba(0,0,0,'+(0.7+0.2*eased)+')';
                    ctx.fillRect(0,0,logicalW,logicalH);
                    ctx.fillStyle = '#FF4444';
                    const baseFont = 56;
                    ctx.font = 'bold '+Math.round(baseFont)+'px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', cx, cy);
                }
                ctx.restore();
                // Restart hint bar (slide/fade in)
                ctx.save();
                const hintFade = Math.max(0, fade - 0.35) / 0.65;
                ctx.globalAlpha = hintFade;
                const barH = 54;
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.fillRect(0, logicalH - barH, logicalW, barH);
                ctx.fillStyle = '#FFFFFF';
                const hintFont = 18 + Math.floor(2 * (1-hintFade));
                ctx.font = hintFont+'px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Press FIRE to play again', cx, logicalH - 22);
                ctx.restore();
            }
            
            ctx.restore();

            // FPS / FX overlay (debug) -- drawn after primary scene & overlays
            if (game.showFps && game.perf && typeof game.perf.fps === 'number') {
                ctx.save();
                ctx.font = '14px Courier New';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                // Extended performance HUD (toggle with F2)
                const showHud = game.perfHud; // bool set via key handler
                const lines = [];
                lines.push('FPS '+game.perf.fps.toFixed(0));
                if (showHud) {
                    const act = game.projectilePool ? game.projectilePool.active() : (game.projectiles? game.projectiles.length : 0);
                    lines.push('Proj '+act + (game.projectileDegradeTier!=null? ' T'+game.projectileDegradeTier:''));
                    if (game.collisionStats) {
                        const c = game.collisionStats;
                        const eff = c.checks? ((c.hits/c.checks)*100).toFixed(1):'0.0';
                        lines.push('Coll '+c.hits+'/'+c.checks+' '+eff+'%');
                    }
                    if (game._spatial) {
                        lines.push('Buckets '+game._spatial.buckets.size);
                    }
                    if (game.perf && game.perf.avgFrameMs) {
                        lines.push('Frame '+game.perf.avgFrameMs.toFixed(2)+'ms');
                    }
                } else {
                    lines.push('FX '+(game.perf.lowFx?'LOW':'FULL'));
                }
                const panelW = 150;
                const panelH = 8 + lines.length*16;
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.fillRect(4,4,panelW,panelH);
                for (let i=0;i<lines.length;i++){
                    let col = '#0f0';
                    if (lines[i].startsWith('FX')) col = game.perf.lowFx ? '#ffb347' : '#93d3ff';
                    else if (lines[i].startsWith('Coll')) col = '#ffd27f';
                    else if (lines[i].startsWith('Proj')) col = '#6ad3ff';
                    else if (lines[i].startsWith('Buckets')) col = '#c6a0ff';
                    else if (lines[i].startsWith('Frame')) col = '#ffa0a0';
                    ctx.fillStyle = col;
                    ctx.fillText(lines[i], 10, 8 + i*16);
                }
                ctx.restore();
            }

            // Temporary on-screen debug HUD (top-most layer) disabled — no-op to avoid drawing debug overlays.
            try { /* HUD disabled by build */ } catch(_) {}
        }

        // DEBUG: always-draw pickups on top (diagnostic overlay) so missing pickups are obvious
        try {
            if (game.pickups && game.pickups.length) {
                game.pickups.forEach((p, idx) => {
                    try {
                        const x = Math.round(p.x || 0);
                        const y = Math.round(p.y || 0);
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.globalAlpha = 0.95;
                        // Big cyan box + label for visibility
                        ctx.fillStyle = 'rgba(0,200,255,0.12)'; ctx.fillRect(-22, -22, 44, 44);
                        ctx.strokeStyle = 'rgba(0,200,255,0.95)'; ctx.lineWidth = 2; ctx.strokeRect(-22, -22, 44, 44);
                        ctx.beginPath(); ctx.moveTo(-18,-18); ctx.lineTo(18,18); ctx.moveTo(-18,18); ctx.lineTo(18,-18); ctx.stroke();
                        ctx.fillStyle = '#ffffff'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText(p.type + ' #' + idx, 0, 28);
                        ctx.restore();
                    } catch(_){}
                });
            }
            // If too many active projectiles, log count once so we can see if projectile spam is hiding things
            try {
                const so = game.projectilesSoA;
                if (so && so.alive) {
                    let activeCount = 0; for (let i=0;i<so.MAX;i++) if (so.alive[i]) activeCount++;
                    if (activeCount > 1000) {
                        game._debug = game._debug || {};
                        const now = performance.now();
                        if (!game._debug._lastProjLog || now - game._debug._lastProjLog > 2000) {
                            game._debug._lastProjLog = now;
                            console.info('[Projectiles][DEBUG] activeCount=', activeCount, 'MAX=', so.MAX);
                        }
                    }
                }
            } catch(_){}
        } catch(_){}

        // DEBUG: Forced top-layer overlay for Wunderswan sprite (diagnostic only)
        try {
            // Watcher: detect when the stored image src changes so we can see accidental overwrites
            try {
                game._debug = game._debug || {};
                const wsC = game.enemySprites && game.enemySprites.wunderswan;
                const imgC = wsC && wsC.image;
                const srcNow = imgC && imgC.src ? imgC.src : null;
                if (!game._debug._lastWundSrc || game._debug._lastWundSrc !== srcNow) {
                    const old = game._debug._lastWundSrc || '(none)';
                    game._debug._lastWundSrc = srcNow;
                    try { console.info('[WunderswanSprite][WATCH2] image.src changed', { old: old, now: srcNow }); } catch(_){}
                }
            } catch(_){}
            if (game.enemies && Array.isArray(game.enemies)) {
                const boss = game.enemies.find(e => e && e.type === 'Wunderswan' && e.health > 0);
                if (boss) {
                    const ws = (game.enemySprites && game.enemySprites.wunderswan) ? game.enemySprites.wunderswan : null;
                    const img = ws && ws.image ? ws.image : null;
                    if (img && img.complete && (img.naturalWidth || img.width) > 0) {
                        // Build a box from frames if present, else fallback to natural size
                        let box = (ws && ws.frames && (ws.frames.down || ws.frames.right || ws.frames.up)) || null;
                        if (!box || !box.w || !box.h) {
                            box = { x:0, y:0, w: img.naturalWidth || img.width, h: img.naturalHeight || img.height };
                        }
                        const scale = (ws && ws.baseScaleForSize) ? ws.baseScaleForSize(boss.size) : ((boss.size*2)/(box.h||1));
                        const drawW = box.w * scale; const drawH = box.h * scale;
                        ctx.save();
                        ctx.globalAlpha = 0.95;
                        ctx.translate(boss.x, boss.y);
                        if ((boss.facing || 'left') === 'left') ctx.scale(-1,1);
                        try { ctx.drawImage(img, box.x, box.y, box.w, box.h, -drawW/2, -drawH/2, drawW, drawH); } catch(e) { /* ignore */ }
                        // stroke to make overlay obvious
                        ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = 2; ctx.strokeRect(-drawW/2, -drawH/2, drawW, drawH);
                        ctx.restore();
                        // Log once per 1s to confirm overlay drawing
                        try { game._debug = game._debug || {}; const now = performance.now(); if (!game._debug._lastWundOverlay || now - game._debug._lastWundOverlay > 1000) { game._debug._lastWundOverlay = now; console.info('[WunderswanSprite][OVERLAY] forced overlay drawn', { src: img.src, nw: img.naturalWidth, nh: img.naturalHeight, enemyX: boss.x, enemyY: boss.y }); } } catch(_){}
                    }
                }
            }
        } catch(_){}

        function updateStats() {
            if (!window.game || !game.player) {
                return;
            }
            const abilitiesList = Array.isArray(game.player.abilities) ? game.player.abilities : [];
            const abilityCatalog = (typeof ABILITIES !== 'undefined' && ABILITIES) ? ABILITIES : null;

            let damage = 25;
            let projectileCount = 1;
            // Attack speed display now mirrors additive stacking logic used in gameplay.
            let attackSpeedBaseMult = 1; // will become (1 + sum of bonuses)
            let attackSpeedBonusSum = 0;
            let pierceCount = 0;
            let critChance = 0;
            let blockChance = 0;
            let multiShotCount = 0;

            if (abilityCatalog) {
                abilitiesList.forEach(ability => {
                    const abilityData = abilityCatalog[ability];
                    if (abilityData && abilityData.effect) {
                        if (abilityData.effect.damageBonus) damage += abilityData.effect.damageBonus;
                        if (abilityData.effect.projectileCount) multiShotCount += abilityData.effect.projectileCount;
                        if (abilityData.effect.attackSpeedMultiplier) attackSpeedBonusSum += (abilityData.effect.attackSpeedMultiplier - 1);
                        if (abilityData.effect.pierceCount) pierceCount = Math.max(pierceCount, abilityData.effect.pierceCount);
                        if (abilityData.effect.critChance) critChance = Math.max(critChance, abilityData.effect.critChance);
                        if (abilityData.effect.blockChance) blockChance = Math.max(blockChance, abilityData.effect.blockChance);
                    }
                });
            }
            if (abilityCatalog && abilitiesList.some(a => abilityCatalog[a] && abilityCatalog[a].effect.shotgunBlast)) {
                projectileCount = multiShotCount + 5;
            } else if (multiShotCount > 0) {
                projectileCount = multiShotCount;
            }
            // Cross Shot baseline: if owned and computed total is less than 4, display 4 to match firing behavior
            if (abilityCatalog && abilitiesList.some(a => abilityCatalog[a] && abilityCatalog[a].effect.crossPattern)) {
                if (projectileCount < 4) projectileCount = 4;
            }
            if (abilitiesList.includes('Rage Mode')) {
                damage += (game.totalKills || 0) * 3;
            }
            // Berserker preview: show current and potential max (+50%) when active
            if (abilitiesList.includes('Berserker')) {
                const healthPercent = game.player.health / game.player.maxHealth;
                const currentMult = 1 + (1 - healthPercent) * 0.5;
                const currentDamage = Math.floor(damage * currentMult);
                const maxDamage = Math.floor(damage * 1.5);
                document.getElementById('statDamage').textContent = `${currentDamage} (max ${maxDamage})`;
            } else {
                document.getElementById('statDamage').textContent = damage;
            }
            document.getElementById('statProjectiles').textContent = projectileCount;
            const attackSpeed = attackSpeedBaseMult + attackSpeedBonusSum; // effective multiplier
            document.getElementById('statAttackSpeed').textContent = Math.round(attackSpeed * 100) + '%';
            document.getElementById('statPierce').textContent = pierceCount === 999 ? '∞' : pierceCount;
            document.getElementById('statCrit').textContent = Math.round(critChance * 100) + '%';
            document.getElementById('statBlock').textContent = Math.round(blockChance * 100) + '%';
            document.getElementById('statKills').textContent = game.totalKills || 0;
            document.getElementById('statRooms').textContent = game.roomsCleared || 0;
            document.getElementById('statChests').textContent = game.chestsOpened || 0;
        }

        // Throttled UI updater: reduce DOM churn by diffing + interval gating.
        (function(){
            let lastUIUpdate = 0;
            const UI_INTERVAL = 250; // ms (4Hz)
            // Cached element references (resolved lazily on first call)
            let elHealth, elMaxHealth, elDungeon, elRoom, elScore, elProj, elHealthBar, elAura;
            // Last displayed primitive values for diffing
            let lastHealth=-1, lastMaxHealth=-1, lastDungeon, lastRoom, lastScore, lastProjText, lastHealthBarWidth=-1, lastHealthBarColor='', lastAuraText='';
            function cache() {
                if (!elHealth) {
                    elHealth = document.getElementById('health');
                    elMaxHealth = document.getElementById('maxHealth');
                    elDungeon = document.getElementById('dungeon');
                    elRoom = document.getElementById('room');
                    elScore = document.getElementById('score');
                    elProj = document.getElementById('statProjectiles');
                    elHealthBar = document.getElementById('healthBar');
                    elAura = document.getElementById('auraStatus');
                }
            }
            window.updateUI = function updateUI(){
                cache();
                // Always update health bar width immediately (player feedback critical)
                const healthPercent = (game.player.health / game.player.maxHealth) * 100;
                const widthVal = Math.max(0, healthPercent).toFixed(2) + '%';
                if (elHealthBar && widthVal !== lastHealthBarWidth) {
                    elHealthBar.style.width = widthVal;
                    lastHealthBarWidth = widthVal;
                }
                // Color only changes on band transitions; compute band key
                let colorKey;
                if (healthPercent > 60) colorKey = 'g'; else if (healthPercent > 30) colorKey = 'y'; else colorKey = 'r';
                if (elHealthBar && colorKey !== lastHealthBarColor) {
                    if (colorKey==='g') elHealthBar.style.background = 'linear-gradient(90deg, #00ff88, #00aa66)';
                    else if (colorKey==='y') elHealthBar.style.background = 'linear-gradient(90deg, #ffaa00, #ff8800)';
                    else elHealthBar.style.background = 'linear-gradient(90deg, #ff4444, #aa0000)';
                    lastHealthBarColor = colorKey;
                }

                const now = performance.now();
                if (now - lastUIUpdate < UI_INTERVAL) {
                    return; // defer non-critical DOM writes
                }
                lastUIUpdate = now;

                // Health / max health numbers (integer health rounding)
                const hVal = Math.ceil(game.player.health);
                if (elHealth && hVal !== lastHealth) { elHealth.textContent = hVal; lastHealth = hVal; }
                if (elMaxHealth && game.player.maxHealth !== lastMaxHealth) { elMaxHealth.textContent = game.player.maxHealth; lastMaxHealth = game.player.maxHealth; }

                // Dungeon / room / score
                if (elDungeon && game.dungeon !== lastDungeon) { elDungeon.textContent = game.dungeon; lastDungeon = game.dungeon; }
                if (elRoom && game.room !== lastRoom) { elRoom.textContent = game.room; lastRoom = game.room; }
                const scoreStr = game.score.toLocaleString();
                if (elScore && scoreStr !== lastScore) { elScore.textContent = scoreStr; lastScore = scoreStr; }

                // Projectile instrumentation (SoA active)
                if (game.projectilePool && elProj) {
                    const active = game.projectilePool.active ? game.projectilePool.active() : (game.projectiles? game.projectiles.length : 0);
                    const tier = game.projectileDegradeTier != null ? ` T${game.projectileDegradeTier}` : '';
                    let extra = '';
                    if (game.collisionStats) {
                        const c = game.collisionStats;
                        const eff = c.checks ? Math.round((c.hits / c.checks) * 100) : 0;
                        extra = ` (${eff}% hit)`;
                    }
                    const projText = `${active}${tier}${extra}`;
                    if (projText !== lastProjText) { elProj.textContent = projText; lastProjText = projText; }
                }

                // Stats (runs several DOM writes) - run only on throttled cycle
                try { updateStats(); } catch(err) { console.warn('[HUD] updateStats failed', err); }

                // Terrifying Aura status indicator
                if (elAura && game.player.abilities.includes('Terrifying Aura')) {
                    const kills = game.player.killCount || 0;
                    const nextThreshold = 25 - (kills % 25);
                    let auraText;
                    if (game.player.auraActive) {
                        let remainingRooms = 0;
                        if (game.player.auraExpireRoom) {
                            remainingRooms = game.player.auraExpireRoom - (game.room || 0);
                            if (remainingRooms < 0) remainingRooms = 0;
                        }
                        if (remainingRooms === 0) {
                            game.player.auraActive = false;
                            auraText = 'Terrifying Aura: Expired';
                        } else {
                            auraText = `Terrifying Aura ACTIVE (${remainingRooms} room${remainingRooms===1?'':'s'} left)`;
                        }
                    } else {
                        auraText = `Terrifying Aura: ${nextThreshold === 25 ? 'Ready on next 25 kills' : (nextThreshold + ' kills to activate')}`;
                    }
                    if (auraText !== lastAuraText) { elAura.textContent = auraText; lastAuraText = auraText; }
                }
            }
        })();

        function updateMinimap() {
            const minimap = document.getElementById('minimap');
            if (!minimap) return;
            minimap.innerHTML = '<div style="position: absolute; top: 2px; left: 2px; font-size: 8px; color: #888;">District Map</div>';
            // Inject (idempotent) Potato Mode toggle button next to minimap if not present
            if (!document.getElementById('btnToggleCosmetic')) {
                const btn = document.createElement('button');
                btn.id = 'btnToggleCosmetic';
                btn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF');
                // Position the button directly to the right of the minimap (minimap is 100x75)
                // Placing inside the minimap keeps layout stable without affecting surrounding flow.
                btn.style.cssText = 'position:absolute; top:8px; left:108px; font-size:10px; padding:3px 6px; background:#222; color:#0f0; border:1px solid #444; border-radius:4px; cursor:pointer; white-space:nowrap;';
                btn.onclick = () => { game.potatoMode = !game.potatoMode; applyPotatoFxClamps(game.potatoMode); saveAudioPreferences(); btn.textContent = 'Potato Mode: ' + (game.potatoMode ? 'ON' : 'OFF'); };
                minimap.appendChild(btn);
                // After adding cosmetic FX button, append chest legend just below it to the right.
                // We'll create a container anchored relative to minimap for tight grouping.
                const legend = document.createElement('div');
                legend.id = 'minimapChestLegend';
                // Position the legend further right (offset 188px) so it clears audio buttons region.
                legend.style.cssText = 'position:absolute; top:8px; left:220px; display:flex; flex-direction:column; gap:4px; background:rgba(0,0,0,0.55); padding:6px 8px 6px 8px; border:1px solid #333; border-radius:6px; font-size:10px; font-family:Courier New, monospace; letter-spacing:0.5px; max-width:210px;';
                legend.innerHTML = `
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #666; background:linear-gradient(#ffffff,#d9d9d9); box-shadow:0 0 3px rgba(255,255,255,0.5);"></span>
                        <span style="color:#ccc;">Platinum <span style=\"color:#888;\">(Common)</span></span>
                    </div>
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #775f00; background:linear-gradient(#ffec8a,#d6a400); box-shadow:0 0 3px rgba(255,220,120,0.4);"></span>
                        <span style="color:#ffdc72;">Gold <span style=\"color:#bfa04a;\">(Rare)</span></span>
                    </div>
                    <div style="display:flex; align-items:center; gap:4px; line-height:12px;">
                        <span style="width:12px; height:12px; display:inline-block; border:1px solid #4a6f1e; background:linear-gradient(#d2ff7a,#5e8f18); box-shadow:0 0 4px #aaff66, 0 0 6px rgba(170,255,90,0.55);"></span>
                        <span style="color:#c9ff86;">Irradiated <span style=\"color:#86c44a;\">(Epic)</span></span>
                    </div>
                `;
                minimap.appendChild(legend);
            }
            

        // === Ability Activation Notifier ===
        // Displays a transient banner once per run when key abilities first become active.
        (function abilityNotifier(){
            const shown = {};
            function showBanner(text, color) {
                let wrap = document.getElementById('abilityNotifyWrap');
                if (!wrap) {
                    wrap = document.createElement('div');
                    wrap.id = 'abilityNotifyWrap';
                    wrap.style.cssText = 'position:fixed;top:14px;left:50%;transform:translateX(-50%);z-index:12000;display:flex;flex-direction:column;gap:6px;pointer-events:none;font-family:Courier New,monospace;';
                    document.body.appendChild(wrap);
                }
                const el = document.createElement('div');
                el.textContent = text;
                el.style.cssText = 'background:rgba(0,0,0,0.70);padding:6px 14px;border:2px solid '+color+';color:'+color+';font-size:14px;letter-spacing:1px;border-radius:6px;opacity:0;transition:opacity .35s, transform .35s;transform:translateY(-6px);text-shadow:0 0 6px '+color+'33;';
                wrap.appendChild(el);
                requestAnimationFrame(()=>{ el.style.opacity='1'; el.style.transform='translateY(0)'; });
                setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(-6px)'; }, 2600);
                setTimeout(()=>{ if (el.parentElement) el.parentElement.removeChild(el); }, 3200);
            }
            setInterval(()=>{
                if (!window.game || !game.player || !Array.isArray(game.player.abilities)) return;
                if (!shown.patternAmplify && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.patternAmplify)) {
                    shown.patternAmplify = true; showBanner('SHOOTING INTENSIFIES ONLINE','#66FFC8');
                }
                if (!shown.cascadeBurst && game.player.abilities.some(a=>ABILITIES[a] && ABILITIES[a].effect.cascadeBurst)) {
                    shown.cascadeBurst = true; showBanner('CASCADE BURST ARMED','#FFB866');
                }
            }, 1000);
        })();
            // Draw minimap grid
            for (let d = 1; d <= 10; d++) {
                const x = 10 + ((d - 1) % 5) * 16;
                const y = 20 + Math.floor((d - 1) / 5) * 20;
                
                const cell = document.createElement('div');
                cell.style.cssText = `
                    position: absolute; left: ${x}px; top: ${y}px;
                    width: 12px; height: 16px; border: 1px solid #333;
                    font-size: 8px; text-align: center; line-height: 16px;
                `;
                
                if (d < game.dungeon) {
                    cell.style.background = '#004400';
                    cell.style.color = '#00ff00';
                    cell.textContent = '✓';
                } else if (d === game.dungeon) {
                    cell.style.background = '#444400';
                    cell.style.color = '#ffff00';
                    cell.textContent = game.room + '/5';
                } else {
                    cell.style.background = '#222';
                    cell.style.color = '#666';
                    cell.textContent = d;
                }
                
                minimap.appendChild(cell);
            }
        }

        // Legacy showTitleScreen block fully removed (simplified version defined earlier in file)

        // ============ Orientation Enforcement (Mobile Landscape) ============
        (function(){
            function isTouch() { return ('ontouchstart' in window) || (navigator.maxTouchPoints>0); }
            function portraitActive() { return window.matchMedia('(orientation: portrait)').matches; }
            function ensureOverlayElement() {
                let ov = document.getElementById('orientationOverlay');
                if (!ov) {
                    ov = document.createElement('div');
                    ov.id = 'orientationOverlay';
                    ov.innerHTML = '<h1>Rotate Device</h1><p>This game is optimized for landscape. Please rotate your phone or tablet to continue playing.</p>';
                    document.body.appendChild(ov);
                }
                return ov;
            }
            function applyOrientationState(){
                const ov = ensureOverlayElement();
                if (isTouch() && portraitActive()) {
                    document.body.classList.add('enforce-landscape');
                    ov.style.display = 'flex';
                    // Soft pause while portrait
                    if (!game.paused) game._wasAutoPausedForOrientation = true;
                    game.paused = true;
                } else {
                    document.body.classList.remove('enforce-landscape');
                    ov.style.display = 'none';
                    if (game._wasAutoPausedForOrientation) {
                        game._wasAutoPausedForOrientation = false;
                        game.paused = false;
                    }
                }
            }
            window.addEventListener('orientationchange', ()=> setTimeout(applyOrientationState, 120));
            window.addEventListener('resize', ()=> applyOrientationState());
            document.addEventListener('DOMContentLoaded', ()=> setTimeout(applyOrientationState, 300));
            // Expose for manual forcing after init if needed
            window.forceOrientationCheck = applyOrientationState;
        })();
        // ====================================================================
        // THEME SYSTEM -----------------------------------------------------------
        // Each theme adjusts visuals (background gradient), obstacle weighting, enemy weighting, and elite spawn multiplier.
        const THEMES = [
            {
                key: 'neon',
                label: 'Neon District',
                gradient: ['#1a1a2e', '#301848', '#180a28'],
                obstacleWeights: { car: 1.1, dumpster: 0.8, streetlight: 1.2, barrier: 0.9 },
                enemyWeights: { GunDuck: 1.15, KnifeDuck: 0.95 },
                carTintRange: [0.95, 1.25],
                eliteMult: 1.15
            },
            {
                key: 'industrial',
                label: 'Industrial Docks',
                gradient: ['#18222c', '#2a3a42', '#0e181e'],
                obstacleWeights: { car: 0.9, dumpster: 1.3, streetlight: 0.7, barrier: 1.1 },
                enemyWeights: { KnifeDuck: 1.1 },
                carTintRange: [0.80, 1.05],
                eliteMult: 1.0
            },
            {
                key: 'financial',
                label: 'Financial Core',
                gradient: ['#1a2230', '#22384c', '#162a3e'],
                obstacleWeights: { car: 1.2, dumpster: 0.6, streetlight: 1.3, barrier: 0.8 },
                enemyWeights: { GunDuck: 1.2 },
                carTintRange: [0.9, 1.15],
                eliteMult: 1.25
            },
            {
                key: 'underpass',
                label: 'Shadow Underpass',
                gradient: ['#101014', '#181a20', '#08090c'],
                obstacleWeights: { car: 0.7, dumpster: 1.2, streetlight: 0.4, barrier: 1.3 },
                enemyWeights: { KnifeDuck: 1.15 },
                carTintRange: [0.7, 1.0],
                eliteMult: 1.3
            }
        ];

        function pickTheme(dungeon, room) {
            // Simple rotation: cycle by dungeon index with slight variation based on room
            const idx = (dungeon + Math.floor(room/3)) % THEMES.length;
            return THEMES[idx];
        }
        // NOTE: Themes influence:
        //  - Background gradient (applied each frame)
        //  - Obstacle frequency via duplication weighting (generateRoom)
        //  - Enemy spawn weighting (theme enemyWeights scaled & gated by legacy progression)
        //  - Car tint range (overrides random car tint variance)
        //  - Elite spawn multiplier (eliteMult)
        // Elite System:
        //  - Soft elites add health, speed, damage scaling without new behaviors (yet)
        //  - Visual differentiation: pre-body aura with additive glow & outline stroke
        //  - Low FX mode automatically suppresses aura composite for performance
        // Future hooks: elite ability modifiers, loot bonuses, synergy-based elite variants.

        window.addEventListener('load', () => {
            try {
                if (typeof updateUI === 'function') updateUI();
            } catch (err) {
                console.warn('[HUD] initial populate failed', err);
            }
        });
        </script>

        <!-- Golden Goose debug badge removed -->
            <!-- Temporary forced overlay for Golden Goose (auto-inserted) -->
            <script>
                (function(){
                    try{
                        if (document.getElementById('ggOverlayCanvas')) return;
                        const baseCanvas = document.getElementById('gameCanvas');
                        if (!baseCanvas) return; // game not present yet
                        const overlay = document.createElement('canvas');
                        overlay.id = 'ggOverlayCanvas';
                        // Keep the overlay above the game canvas but below UI overlays like pause (z-index 1000)
                        overlay.style.cssText = 'position:fixed;left:0;top:0;pointer-events:none;z-index:900;';
                        document.body.appendChild(overlay);
                        // Mark overlay presence so the main renderer can reliably skip the magenta fallback
                        try { window._ggOverlayInstalled = true; if (window.game && game.enemySprites && game.enemySprites.goldengoose) { game.enemySprites.goldengoose._overlayCanvasInstalled = true; } } catch(_) {}
                        const ctx = overlay.getContext('2d');

                        function syncSize(){
                            const rect = baseCanvas.getBoundingClientRect();
                            // match internal pixel size to game canvas pixel size
                            overlay.width = baseCanvas.width || rect.width || 800;
                            overlay.height = baseCanvas.height || rect.height || 600;
                            overlay.style.left = rect.left + 'px';
                            overlay.style.top = rect.top + 'px';
                            overlay.style.width = rect.width + 'px';
                            overlay.style.height = rect.height + 'px';
                            overlay._rect = rect;
                        }

                        window.addEventListener('resize', syncSize);
                        window.addEventListener('scroll', syncSize);
                        setTimeout(syncSize, 200);
                        setInterval(syncSize, 1500);

                        function drawForced(){
                            requestAnimationFrame(drawForced);
                            try{
                                const overlayEnabled = (window._forceGoldenOverlay === true) || (window.game && game._forceGoldenOverlay === true);
                                if (!overlayEnabled) {
                                    ctx.clearRect(0,0,overlay.width, overlay.height);
                                    return;
                                }
                                const gg = window.game && game.enemySprites ? game.enemySprites.goldengoose : null;
                                const boss = (window.game && Array.isArray(game.enemies)) ? game.enemies.find(e=>e && e.type === 'Golden Goose') : null;
                                if (!gg || !boss) { ctx.clearRect(0,0,overlay.width, overlay.height); return; }
                                const img = gg._forcedBitmap || gg.image;
                                if (!img) { ctx.clearRect(0,0,overlay.width, overlay.height); return; }
                                // compute frame box and anchor offsets
                                let box = (gg.frames && (gg.frames.down || gg.frames.right || gg.frames.up)) || null;
                                if (!box || !box.w || !box.h) box = { x:0, y:0, w: (gg.image && (gg.image.naturalWidth||gg.image.width))||0, h: (gg.image && (gg.image.naturalHeight||gg.image.height))||0 };
                                const scale = (gg.baseScaleForSize ? gg.baseScaleForSize(boss.size) : ((boss.size*2)/(box.h||1)));
                                const drawW = box.w * scale, drawH = box.h * scale;
                                const anchorX = (box && typeof box.anchorX === 'number') ? box.anchorX : (box ? box.w/2 : ((gg.image && (gg.image.naturalWidth||gg.image.width))/2));
                                const anchorY = (box && typeof box.anchorY === 'number') ? box.anchorY : (box ? box.h/2 : ((gg.image && (gg.image.naturalHeight||gg.image.height))/2));
                                const anchorOffsetX = (anchorX - (box ? box.w/2 : ((gg.image && (gg.image.naturalWidth||gg.image.width))/2))) * scale;
                                const anchorOffsetY = (anchorY - (box ? box.h/2 : ((gg.image && (gg.image.naturalHeight||gg.image.height))/2))) * scale;

                                // Clear previous
                                ctx.clearRect(0,0,overlay.width, overlay.height);
                                ctx.save();
                                // Draw at boss.x,boss.y (game uses canvas coordinates)
                                ctx.translate(boss.x, boss.y);
                                // Determine horizontal facing relative to player so sprite faces the player (consistent rule)
                                const _centerX = boss.x + anchorOffsetX;
                                const _playerOnRight = (game && game.player) ? (game.player.x >= _centerX) : ((boss.facing || 'left') === 'right');
                                const _facingDir = _playerOnRight ? 'right' : 'left';
                                try { boss.facing = _facingDir; } catch(_) {}
                                let _drew = false;
                                try{ 
                                    const isBitmap = !!gg._forcedBitmap;
                                    const isImgReady = !isBitmap && img && img.complete && ((img.naturalWidth || img.width) > 0) && ((img.naturalHeight || img.height) > 0);
                                    const _mirroredOv = !_playerOnRight;
                                    const _baseX = -drawW/2 + anchorOffsetX;
                                    const _baseY = -drawH/2 + anchorOffsetY;
                                    const _drawX = _mirroredOv ? -(_baseX + drawW) : _baseX;
                                    if (isBitmap) {
                                        if (_mirroredOv) ctx.scale(-1,1);
                                        ctx.drawImage(img, box.x, box.y, box.w, box.h, _drawX, _baseY, drawW, drawH);
                                        _drew = true;
                                    } else if (isImgReady) {
                                        if (_mirroredOv) ctx.scale(-1,1);
                                        ctx.drawImage(img, box.x, box.y, box.w, box.h, _drawX, _baseY, drawW, drawH);
                                        _drew = true;
                                    } else {
                                        // Image not ready; skip draw to avoid misalignment/false outline
                                    }
                                }catch(e){}
                                // Mark that overlay was drawn this frame so the main enemy draw can skip magenta fallback
                                try { if (_drew) boss._overlayDrawnFrame = (game.frame || 0); } catch(_) {}
                                // (outline removed to avoid visual flashes in normal gameplay)
                                ctx.restore();
                            }catch(e){ /* ignore frame errors */ }
                        }

                        drawForced();
                    }catch(e){ console.warn('gg overlay install failed', e); }
                })();
            </script>